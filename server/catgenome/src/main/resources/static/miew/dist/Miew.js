/** Miew - 3D Molecular Viewer v0.9.0+20230822.103925.6b542ed Copyright (c) 2015-2023 EPAM Systems, Inc. */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('lodash'), require('three')) :
  typeof define === 'function' && define.amd ? define(['lodash', 'three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Miew = factory(global._, global.THREE));
}(this, (function (_, THREE) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n['default'] = e;
    return Object.freeze(n);
  }

  var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
  var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var arrayLikeToArray = _arrayLikeToArray;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  var unsupportedIterableToArray = _unsupportedIterableToArray;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  var __assign = (undefined && undefined.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var defaults = {
      lines: 12,
      length: 7,
      width: 5,
      radius: 10,
      scale: 1.0,
      corners: 1,
      color: '#000',
      fadeColor: 'transparent',
      animation: 'spinner-line-fade-default',
      rotate: 0,
      direction: 1,
      speed: 1,
      zIndex: 2e9,
      className: 'spinner',
      top: '50%',
      left: '50%',
      shadow: '0 0 1px transparent',
      position: 'absolute',
  };
  var Spinner = /** @class */ (function () {
      function Spinner(opts) {
          if (opts === void 0) { opts = {}; }
          this.opts = __assign(__assign({}, defaults), opts);
      }
      /**
       * Adds the spinner to the given target element. If this instance is already
       * spinning, it is automatically removed from its previous target by calling
       * stop() internally.
       */
      Spinner.prototype.spin = function (target) {
          this.stop();
          this.el = document.createElement('div');
          this.el.className = this.opts.className;
          this.el.setAttribute('role', 'progressbar');
          css(this.el, {
              position: this.opts.position,
              width: 0,
              zIndex: this.opts.zIndex,
              left: this.opts.left,
              top: this.opts.top,
              transform: "scale(" + this.opts.scale + ")",
          });
          if (target) {
              target.insertBefore(this.el, target.firstChild || null);
          }
          drawLines(this.el, this.opts);
          return this;
      };
      /**
       * Stops and removes the Spinner.
       * Stopped spinners may be reused by calling spin() again.
       */
      Spinner.prototype.stop = function () {
          if (this.el) {
              if (typeof requestAnimationFrame !== 'undefined') {
                  cancelAnimationFrame(this.animateId);
              }
              else {
                  clearTimeout(this.animateId);
              }
              if (this.el.parentNode) {
                  this.el.parentNode.removeChild(this.el);
              }
              this.el = undefined;
          }
          return this;
      };
      return Spinner;
  }());
  /**
   * Sets multiple style properties at once.
   */
  function css(el, props) {
      for (var prop in props) {
          el.style[prop] = props[prop];
      }
      return el;
  }
  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
      return typeof color == 'string' ? color : color[idx % color.length];
  }
  /**
   * Internal method that draws the individual lines.
   */
  function drawLines(el, opts) {
      var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
      var shadow = 'none';
      if (opts.shadow === true) {
          shadow = '0 2px 4px #000'; // default shadow
      }
      else if (typeof opts.shadow === 'string') {
          shadow = opts.shadow;
      }
      var shadows = parseBoxShadow(shadow);
      for (var i = 0; i < opts.lines; i++) {
          var degrees = ~~(360 / opts.lines * i + opts.rotate);
          var backgroundLine = css(document.createElement('div'), {
              position: 'absolute',
              top: -opts.width / 2 + "px",
              width: (opts.length + opts.width) + 'px',
              height: opts.width + 'px',
              background: getColor(opts.fadeColor, i),
              borderRadius: borderRadius,
              transformOrigin: 'left',
              transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
          });
          var delay = i * opts.direction / opts.lines / opts.speed;
          delay -= 1 / opts.speed; // so initial animation state will include trail
          var line = css(document.createElement('div'), {
              width: '100%',
              height: '100%',
              background: getColor(opts.color, i),
              borderRadius: borderRadius,
              boxShadow: normalizeShadow(shadows, degrees),
              animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
          });
          backgroundLine.appendChild(line);
          el.appendChild(backgroundLine);
      }
  }
  function parseBoxShadow(boxShadow) {
      var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
      var shadows = [];
      for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
          var shadow = _a[_i];
          var matches = shadow.match(regex);
          if (matches === null) {
              continue; // invalid syntax
          }
          var x = +matches[2];
          var y = +matches[5];
          var xUnits = matches[4];
          var yUnits = matches[7];
          if (x === 0 && !xUnits) {
              xUnits = yUnits;
          }
          if (y === 0 && !yUnits) {
              yUnits = xUnits;
          }
          if (xUnits !== yUnits) {
              continue; // units must match to use as coordinates
          }
          shadows.push({
              prefix: matches[1] || '',
              x: x,
              y: y,
              xUnits: xUnits,
              yUnits: yUnits,
              end: matches[8],
          });
      }
      return shadows;
  }
  /**
   * Modify box-shadow x/y offsets to counteract rotation
   */
  function normalizeShadow(shadows, degrees) {
      var normalized = [];
      for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
          var shadow = shadows_1[_i];
          var xy = convertOffset(shadow.x, shadow.y, degrees);
          normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
      }
      return normalized.join(', ');
  }
  function convertOffset(x, y, degrees) {
      var radians = degrees * Math.PI / 180;
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      return [
          Math.round((x * cos + y * sin) * 1000) / 1000,
          Math.round((-x * sin + y * cos) * 1000) / 1000,
      ];
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  //----------------------------------------------------------------------------
  // Timer
  var Timer = /*#__PURE__*/function () {
    function Timer() {
      classCallCheck(this, Timer);

      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }

    createClass(Timer, [{
      key: "start",
      value: function start() {
        this.startTime = Timer.now();
        this.oldTime = this.startTime;
        this.running = true;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.getElapsedTime();
        this.running = false;
      }
    }, {
      key: "getElapsedTime",
      value: function getElapsedTime() {
        this.update();
        return this.elapsedTime;
      }
    }, {
      key: "update",
      value: function update() {
        var delta = 0;

        if (this.running) {
          var newTime = Timer.now();
          delta = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += delta;
        }

        return delta;
      }
    }]);

    return Timer;
  }();

  Timer.now = function () {
    var p = typeof window !== 'undefined' && window.performance;
    return p && p.now ? p.now.bind(p) : Date.now;
  }();

  var now = Timer.now;

  function createElement(tag, id, css) {
    var element = document.createElement(tag);
    element.id = id;
    element.style.cssText = css;
    return element;
  }

  var Stats = /*#__PURE__*/function () {
    function Stats() {
      classCallCheck(this, Stats);

      this.domElement = createElement('div', 'stats', 'padding:8px');
      this._text = createElement('p', 'fps', 'margin:0;color:silver;font-size:large');
      this.domElement.appendChild(this._text);
      this._startTime = now();
      this._prevTime = this._startTime;
      this._deltas = new Array(20);
      this._index = 0;
      this._total = 0.0;
      this._count = 0;
    }

    createClass(Stats, [{
      key: "end",
      value: function end() {
        var time = now();
        var delta = time - this._startTime;

        if (this._count < this._deltas.length) {
          this._count++;
        } else {
          this._total -= this._deltas[this._index];
        }

        this._total += delta;
        this._deltas[this._index] = delta;
        this._index = (this._index + 1) % this._deltas.length;
        this.ms = this._total / this._count;
        this.fps = 1000 / this.ms;

        if (time > this._prevTime + 1000) {
          this._text.textContent = this.fps.toPrecision(2);
          this._prevTime = time;
        }

        return time;
      }
    }, {
      key: "update",
      value: function update() {
        this._startTime = this.end();
      }
    }, {
      key: "show",
      value: function show(on) {
        if (on === undefined) {
          on = true;
        }

        this.domElement.style.display = on ? 'block' : 'none';
      }
    }]);

    return Stats;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  });

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  var isNativeFunction = _isNativeFunction;

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  var isNativeReflectConstruct = _isNativeReflectConstruct;

  var construct = createCommonjsModule(function (module) {
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      module.exports = _construct = Reflect.construct;
    } else {
      module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  module.exports = _construct;
  });

  var wrapNativeSuper = createCommonjsModule(function (module) {
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  module.exports = _wrapNativeSuper;
  });

  /**
   * This class introduces the simplest event system.
   */

  function isUndefOrEqual(param, value) {
    return !param || param === value;
  }
  /**
   * Creates empty dispatcher.
   *
   * @exports EventDispatcher
   * @constructor
   */


  function EventDispatcher() {
    this._handlers = {};
  }
  /**
   * Binds callback on specific event type. Optional `context` parameter
   * could be used as 'this' for the `callback`.
   * @param {string}   type       Event name.
   * @param {function} callback   Callback function.
   * @param {Object}   [context] 'This' object for the callback.
   */


  EventDispatcher.prototype.addEventListener = function (type, callback, context) {
    var handlers = this._handlers[type];

    if (!handlers) {
      this._handlers[type] = [];
      handlers = this._handlers[type];
    }

    var params = [callback, context];

    function _checkPar(par) {
      return par[0] === params[0] && par[1] === params[1];
    }

    if (___default['default'].find(handlers, _checkPar) === undefined) {
      handlers.push(params);
    }
  };
  /**
   * Removes a previously-bound callback function from an object.
   * If no `context` is specified, all versions of the `callback` with different
   * contexts will be removed.
   * If no `callback` is specified, all callbacks of the `type` will be removed.
   * If no `type` is specified, callbacks for all events will be removed.
   * @param {?string}  [type]      Event type.
   * @param {function} [callback]  Callback function.
   * @param {Object}   [context]  'This' object for the callback.
   */


  EventDispatcher.prototype.removeEventListener = function (type, callback, context) {
    var self = this;

    ___default['default'].forEach(self._handlers, function (handler, ev) {
      ___default['default'].remove(handler, function (values) {
        return isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self);
      });
    });

    this._handlers = ___default['default'].omitBy(self._handlers, function (handler) {
      return handler.length === 0;
    });
  };
  /**
   * Makes all the callbacks for the specific `event` to trigger.
   * @param {Object} event      Event.
   * @param {string} event.type Type of the event.
   */


  EventDispatcher.prototype.dispatchEvent = function (event) {
    var self = this;

    ___default['default'].forEach(this._handlers[event.type], function (callback) {
      var context = callback[1] || self;
      callback[0].apply(context, [event]);
    });
  };

  /**
   * This module contains class for logging.
   * Returns an instance of a logger that have already been created.
   * Allows users to log messages for five different levels,
   * enable console output and catch signal on each message.
   */
  var priorities = {
    debug: 0,
    info: 1,
    report: 2,
    warn: 3,
    error: 4
  };
  /**
   * Create new Logger.
   *
   * @exports Logger
   * @extends EventDispatcher
   * @constructor
   */

  function Logger() {
    EventDispatcher.call(this);
    /** Boolean flag that toggles output to browser console.
     * @type {boolean}
     */

    this.console = false;
    this._priority = priorities.warn;
  }

  Logger.prototype = Object.create(EventDispatcher.prototype);
  Logger.prototype.constructor = Logger;
  /**
   * Create new clean instance of the logger.
   * @returns {Logger}
   */

  Logger.prototype.instantiate = function () {
    return new Logger();
  };

  function verify(number) {
    if (!___default['default'].isNumber(number)) {
      throw new Error('Wrong log level specified!');
    }

    return number;
  }
  /**
   * @property {string} current threshold for signals and console output.
   * @name Logger#level
   */


  Object.defineProperty(Logger.prototype, 'level', {
    get: function get() {
      var _this = this;

      return ___default['default'].findKey(priorities, function (value) {
        return value === _this._priority;
      });
    },
    set: function set(level) {
      this._priority = verify(priorities[level]);
    }
  });
  /**
   * Returns the list of all possible level values.
   * @returns {Array}
   */

  Logger.prototype.levels = function () {
    return Object.keys(priorities);
  };
  /**
   * Add new message with specified level.
   * @param {string} level - level of the message, must be one of the
   * {'debug' | 'info' | 'report' | 'warn' | 'error'}
   * @param {string} message
   */


  Logger.prototype.message = function (level, message) {
    var priority = verify(priorities[level]);

    this._message(priority, message);
  };
  /**
   * Shortcut for message('debug', ...);
   * @param message
   */


  Logger.prototype.debug = function (message) {
    this._message(priorities.debug, message);
  };
  /**
   * Shortcut for message('info', ...);
   * @param message
   */


  Logger.prototype.info = function (message) {
    this._message(priorities.info, message);
  };
  /**
   * Shortcut for message('report', ...);
   * @param message
   */


  Logger.prototype.report = function (message) {
    this._message(priorities.report, message);
  };
  /**
   * Shortcut for message('warn', ...);
   * @param message
   */


  Logger.prototype.warn = function (message) {
    this._message(priorities.warn, message);
  };
  /**
   * Shortcut for message('error', ...);
   * @param message
   */


  Logger.prototype.error = function (message) {
    this._message(priorities.error, message);
  };
  /**
   * Add new message with specified priority.
   * @param {number} priority - priority of the message
   * @param {string} message
   * @private
   */


  Logger.prototype._message = function (priority, message) {
    if (priority < this._priority) {
      return;
    }

    var level = ___default['default'].findKey(priorities, function (value) {
      return value === priority;
    });

    message = String(message);

    if (this.console) {
      var output = "miew:".concat(level, ": ").concat(message);

      if (level === 'error') {
        console.error(output); // NOSONAR
      } else if (level === 'warn') {
        console.warn(output); // NOSONAR
      } else {
        console.log(output); // NOSONAR
      }
    }

    this.dispatchEvent({
      type: 'message',
      level: level,
      message: message
    });
  };

  var logger = new Logger();

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var browserType = {
    DEFAULT: 0,
    SAFARI: 1
  }; //----------------------------------------------------------------------------
  // Query string

  /**
   * Escape only dangerous chars in a query string component, use a plus instead of a space.
   *
   * [RFC 3986](https://tools.ietf.org/html/rfc3986) allows the following chars in the query (see 3.4):
   *
   *       A-Z a-z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ / ?
   *
   * For query string elements we need to escape ampersand, equal sign, and plus,
   * but encodeURIComponent() function encodes anything except for the following:
   *
   *       A-Z a-z 0-9 - _ . ~ ! ' ( ) *
   *
   * @param {string} text - key or value to encode
   * @param {string} excludeExp - regexp for symbols to exclude from encoding
   * @returns {string} encoded string
   */

  function encodeQueryComponent(text, excludeExp) {
    var encode = function encode(code) {
      return String.fromCharCode(parseInt(code.substr(1), 16));
    };

    return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, '+');
  }
  /**
   * Unescape dangerous chars in a query string component.
   *
   * @param {string} text - encoded key or value
   * @returns {string} decoded string
   * @see {@link encodeQueryComponent}
   */


  function decodeQueryComponent(text) {
    return decodeURIComponent(text.replace(/\+/g, ' '));
  }
  /**
   * Parse URL and extract an array of parameters.
   * @param {string?} url - URL or query string to parse
   * @returns {Array} array of (key, value) pairs.
   */


  function getUrlParameters(url) {
    url = url || window.location.search;
    var query = url.substring(url.indexOf('?') + 1);
    var search = /([^&=]+)=?([^&]*)/g;
    var result = [];
    var match;

    while ((match = search.exec(query)) !== null) {
      // eslint-disable-line no-cond-assign
      result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
    }

    return result;
  }
  /**
   * Parse URL and extract an array of parameters as a hash.
   * @param {string?} url - URL or query string to parse
   * @returns {Object}
   */


  function getUrlParametersAsDict(url) {
    var result = {};
    var a = getUrlParameters(url);

    for (var i = 0; i < a.length; ++i) {
      var _a$i = slicedToArray(a[i], 2),
          key = _a$i[0],
          value = _a$i[1];

      result[key] = value;
    }

    return result;
  }

  function resolveURL(str) {
    if (typeof URL !== 'undefined') {
      try {
        if (typeof window !== 'undefined') {
          return new URL(str, window.location).href;
        }

        return new URL(str).href;
      } catch (error) {// IE 11 has a URL object with no constructor available so just try a different approach instead
      }
    }

    if (typeof document !== 'undefined') {
      var anchor = document.createElement('a');
      anchor.href = str;
      return anchor.href;
    }

    return str;
  }
  /**
   * Generates regular expression object that includes all symbols
   * listed in the argument
   * @param symbolStr {string} - String containing characters list.
   * @returns {RegExp} - Regular expression.
   */


  function generateRegExp(symbolStr) {
    var symbolList = [];

    for (var i = 0, n = symbolStr.length; i < n; ++i) {
      symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16);
    }

    var listStr = symbolList.join('|');
    return new RegExp("%(?:".concat(listStr, ")"), 'gi');
  } //----------------------------------------------------------------------------
  // Create HTML element


  function createElement$1(tag, attrs, content) {
    var element = document.createElement(tag);
    var i;
    var n;

    if (attrs) {
      var keys = Object.keys(attrs);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        element.setAttribute(key, attrs[key]);
      }
    }

    if (content) {
      if (!(content instanceof Array)) {
        content = [content];
      }

      for (i = 0, n = content.length; i < n; ++i) {
        var child = content[i];

        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        } else if (child instanceof HTMLElement) {
          element.appendChild(child);
        }
      }
    }

    return element;
  } //----------------------------------------------------------------------------
  // Easy inheritance

  /**
   * Derive the class from the base.
   * @param cls {function} - Class (constructor) to derive.
   * @param base {function} - Class (constructor) to derive from.
   * @param members {object=} - Optional instance members to add.
   * @param statics {object=} - Optional static class members to add.
   * @returns {function} Original class.
   */


  function deriveClass(cls, base, members, statics) {
    cls.prototype = ___default['default'].assign(Object.create(base.prototype), {
      constructor: cls
    }, members);

    if (statics) {
      ___default['default'].assign(cls, statics);
    }

    return cls;
  } //----------------------------------------------------------------------------
  // Deep prototyping


  function deriveDeep(obj, needZeroOwnProperties) {
    var res = obj;
    var i;
    var n;

    if (obj instanceof Array) {
      res = new Array(obj.length);

      for (i = 0, n = obj.length; i < n; ++i) {
        res[i] = deriveDeep(obj[i]);
      }
    } else if (obj instanceof Object) {
      res = Object.create(obj);
      var keys = Object.keys(obj);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        var value = obj[key];
        var copy = deriveDeep(value);

        if (copy !== value) {
          res[key] = copy;
        }
      }

      if (needZeroOwnProperties && Object.keys(res).length > 0) {
        res = Object.create(res);
      }
    }

    return res;
  } //----------------------------------------------------------------------------
  // Colors


  function hexColor(color) {
    var hex = "0000000".concat(color.toString(16)).substr(-6);
    return "#".concat(hex);
  } //----------------------------------------------------------------------------
  // Debug tracing


  function DebugTracer(namespace) {
    var enabled = false;

    this.enable = function (on) {
      enabled = on;
    };

    var indent = 0;
    var methods = Object.keys(namespace);

    function wrap(method_, name_) {
      return function () {
        var spaces = DebugTracer.spaces.substr(0, indent * 2);

        if (enabled) {
          logger.debug("".concat(spaces + name_, " {"));
        }

        indent++;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = method_.apply(this, args); // eslint-disable-line no-invalid-this

        indent--;

        if (enabled) {
          logger.debug("".concat(spaces, "} // ").concat(name_));
        }

        return result;
      };
    }

    for (var i = 0, n = methods.length; i < n; ++i) {
      var name = methods[i];
      var method = namespace[name];

      if (method instanceof Function && name !== 'constructor') {
        namespace[name] = wrap(method, name);
      }
    }
  }

  DebugTracer.spaces = '                                                                                          ';

  var OutOfMemoryError = /*#__PURE__*/function (_Error) {
    inherits(OutOfMemoryError, _Error);

    var _super = _createSuper(OutOfMemoryError);

    function OutOfMemoryError(message) {
      var _this;

      classCallCheck(this, OutOfMemoryError);

      _this = _super.call(this);
      _this.name = 'OutOfMemoryError';
      _this.message = message;
      return _this;
    }

    return OutOfMemoryError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function allocateTyped(TypedArrayName, size) {
    var result = null;

    try {
      result = new TypedArrayName(size);
    } catch (e) {
      if (e instanceof RangeError) {
        throw new OutOfMemoryError(e.message);
      } else {
        throw e;
      }
    }

    return result;
  } //----------------------------------------------------------------------------
  // Float array conversion


  function bytesToBase64(
  /** ArrayBuffer */
  buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';

    for (var i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }

    return window.btoa(binary);
  }

  function bytesFromBase64(
  /** string */
  str) {
    var binary = window.atob(str);
    var bytes = new Uint8Array(binary.length);

    for (var i = 0; i < bytes.length; ++i) {
      bytes[i] = binary[i].charCodeAt(0);
    }

    return bytes.buffer;
  }

  function arrayToBase64(
  /** number[] */
  array,
  /** function */
  TypedArrayClass) {
    return bytesToBase64(new TypedArrayClass(array).buffer);
  }

  function arrayFromBase64(
  /** string */
  str,
  /** function */
  TypedArrayClass) {
    return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
  } // NOTE: this is 1-level comparison


  function compareOptionsWithDefaults(opts, defOpts) {
    var optsStr = [];

    if (defOpts && opts) {
      var keys = Object.keys(opts);

      for (var p = 0; p < keys.length; ++p) {
        var key = keys[p];
        var value = opts[key]; // TODO add processing for tree structure

        if (!(value instanceof Object) && typeof defOpts[key] !== 'undefined' && defOpts[key] !== value) {
          optsStr.push("".concat(key, ":").concat(value));
        }
      }

      if (optsStr.length > 0) {
        return "!".concat(optsStr.join());
      }
    }

    return '';
  }

  function isAlmostPlainObject(o) {
    if (___default['default'].isPlainObject(o)) {
      return true;
    }

    var proto = o && Object.getPrototypeOf(o);
    return !!proto && !proto.hasOwnProperty('constructor') && isAlmostPlainObject(proto);
  }
  /**
   * Build an object that contains properties (and subproperties) of `src` different from those
   * in `dst`. Objects are parsed recursively, other values (including arrays) are compared for
   * equality using `_.isEqual()`.
   * @param {!object} src - a new object to compare, may contain changed or new properties
   * @param {!object} dst - an old reference object
   */


  function objectsDiff(src, dst) {
    var diff = {};

    ___default['default'].forIn(src, function (srcValue, key) {
      var dstValue = dst[key];

      if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
        var deepDiff = objectsDiff(srcValue, dstValue);

        if (!___default['default'].isEmpty(deepDiff)) {
          diff[key] = deepDiff;
        }
      } else if (!___default['default'].isEqual(srcValue, dstValue)) {
        diff[key] = srcValue;
      }
    });

    return diff;
  }

  function forInRecursive(object, callback) {
    function iterateThrough(obj, prefix) {
      ___default['default'].forIn(obj, function (value, key) {
        var newPref = prefix + (prefix.length > 0 ? '.' : '');

        if (value instanceof Object) {
          iterateThrough(value, newPref + key);
        } else if (value !== undefined) {
          callback(value, newPref + key);
        }
      });
    }

    iterateThrough(object, '');
  }

  function enquoteString(value) {
    if (___default['default'].isString(value)) {
      return "\"".concat(value.replace(/"/g, '\\"'), "\"");
    }

    return value;
  }

  function unquoteString(value) {
    if (!___default['default'].isString(value)) {
      return value;
    }

    if (value[0] === '"' && value[value.length - 1] === '"') {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\"/g, '"');
    }

    if (value[0] === "'" && value[value.length - 1] === "'") {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\'/g, "'");
    }

    throw new SyntaxError('Incorrect string format, can\'t unqute it');
  }

  function getFileExtension(fileName) {
    return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity);
  }

  function splitFileName(fileName) {
    var ext = getFileExtension(fileName);
    var name = fileName.slice(0, fileName.length - ext.length);
    return [name, ext];
  }

  function dataUrlToBlob(url) {
    var parts = url.split(/[:;,]/);
    var partsCount = parts.length;

    if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
      return new Blob([bytesFromBase64(parts[partsCount - 1])]);
    }

    return null;
  }

  function getBrowser() {
    if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') === -1 && navigator.userAgent.indexOf('FxiOS') === -1) {
      return browserType.SAFARI;
    }

    return browserType.DEFAULT;
  }

  function shotOpen(url) {
    if (typeof window !== 'undefined') {
      window.open().document.write("<body style=\"margin:0\"><img src=\"".concat(url, "\" /></body>"));
    }
  }

  function shotDownload(dataUrl, filename) {
    if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
      return;
    }

    if (!filename) {
      filename = ['screenshot-', +new Date(), '.png'].join('');
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function download(data, filename, type) {
    var blobData = new Blob([data]);

    if (!filename) {
      filename = ['data', +new Date()].join('');
    }

    if (!type) {
      filename += blobData.type || '.bin';
    } else {
      filename += ".".concat(type);
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(blobData, filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(blobData);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function copySubArrays(src, dst, indices, itemSize) {
    for (var i = 0, n = indices.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        dst[i * itemSize + j] = src[indices[i] * itemSize + j];
      }
    }
  }

  function shallowCloneNode(node) {
    var newNode = node.cloneNode(true);
    newNode.worldPos = node.worldPos; // .style property is readonly, so "newNode.style = node.style;" won't work (and we don't need it, right?)

    return newNode;
  }

  var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
  var enquoteHelper = ['"', '', '"']; // verify and correct if needed selctor identifier

  function correctSelectorIdentifier(value) {
    if (unquotedStringRE.test(value)) {
      return value;
    } // quote incorrect identifier


    enquoteHelper[1] = value;
    return enquoteHelper.join('');
  }
  /**
   * Concatenates two TypedArray. Doesn't check null refs o type equality
   * Attention! It must be use very rarely because requires memory reallocation every time. Use MergeTypedArraysUnsafe to
   * unite array of subarrays.
   * @param{TypedArray} first  - destination array
   * @param{TypedArray} second - source array
   * @returns{TypedArray} resulting concatenated array
   */


  function concatTypedArraysUnsafe(first, second) {
    var result = new first.constructor(first.length + second.length);
    result.set(first);
    result.set(second, first.length);
    return result;
  }
  /**
   * Merges array of TypedArray into TypedArray. Doesn't check null refs o type equality
   * @param{array} array  - source array of subarrays
   * @returns{TypedArray} resulting merged array
   */


  function mergeTypedArraysUnsafe(array) {
    if (array.length <= 0) {
      return null;
    } // count the size


    var size = array.reduce(function (acc, cur) {
      return acc + cur.length;
    }, 0); // create combined array

    var result = new array[0].constructor(size);

    for (var i = 0, start = 0; i < array.length; i++) {
      var count = array[i].length;
      result.set(array[i], start);
      start += count;
    }

    return result;
  } //----------------------------------------------------------------------------
  // Exports


  var utils = {
    browserType: browserType,
    encodeQueryComponent: encodeQueryComponent,
    decodeQueryComponent: decodeQueryComponent,
    getUrlParameters: getUrlParameters,
    getUrlParametersAsDict: getUrlParametersAsDict,
    resolveURL: resolveURL,
    generateRegExp: generateRegExp,
    createElement: createElement$1,
    deriveClass: deriveClass,
    deriveDeep: deriveDeep,
    hexColor: hexColor,
    DebugTracer: DebugTracer,
    OutOfMemoryError: OutOfMemoryError,
    allocateTyped: allocateTyped,
    bytesFromBase64: bytesFromBase64,
    bytesToBase64: bytesToBase64,
    arrayFromBase64: arrayFromBase64,
    arrayToBase64: arrayToBase64,
    compareOptionsWithDefaults: compareOptionsWithDefaults,
    objectsDiff: objectsDiff,
    forInRecursive: forInRecursive,
    enquoteString: enquoteString,
    unquoteString: unquoteString,
    getBrowser: getBrowser,
    shotOpen: shotOpen,
    shotDownload: shotDownload,
    copySubArrays: copySubArrays,
    shallowCloneNode: shallowCloneNode,
    correctSelectorIdentifier: correctSelectorIdentifier,
    getFileExtension: getFileExtension,
    splitFileName: splitFileName,
    download: download,
    concatTypedArraysUnsafe: concatTypedArraysUnsafe,
    mergeTypedArraysUnsafe: mergeTypedArraysUnsafe
  };

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var JobHandle = /*#__PURE__*/function (_EventDispatcher) {
    inherits(JobHandle, _EventDispatcher);

    var _super = _createSuper$1(JobHandle);

    function JobHandle() {
      var _this;

      classCallCheck(this, JobHandle);

      _this = _super.call(this);
      _this._shouldCancel = false;
      return _this;
    }

    createClass(JobHandle, [{
      key: "cancel",
      value: function cancel() {
        this._shouldCancel = true;
        this.dispatchEvent({
          type: 'cancel'
        });
      }
    }, {
      key: "shouldCancel",
      value: function shouldCancel() {
        return this._shouldCancel;
      } // slaves use this to notify master about their events
      // master routes these notifications to a single event slot

    }, {
      key: "notify",
      value: function notify(event) {
        this.dispatchEvent({
          type: 'notification',
          slaveEvent: event
        });
      }
    }]);

    return JobHandle;
  }(EventDispatcher);

  var VERSION = 0; //----------------------------------------------------------------------------
  // DEFAULT SETTINGS
  //----------------------------------------------------------------------------

  /**
   * Polygonal complexity settings.
   *
   * @typedef PolyComplexity
   * @property {number} poor
   * @property {number} low
   * @property {number} medium
   * @property {number} high
   * @property {number} ultra
   */

  /**
   * @alias SettingsObject
   * @namespace
   */

  var defaults$1 = {
    /**
     * Default options for all available modes.
     * Use {@link Mode.id} as a dictionary key to access mode options.
     *
     * Usually you don't need to override these settings. You may specify mode options as a parameter during
     * {@link Mode} construction.
     *
     * @memberof SettingsObject#
     * @type {Object.<string, object>}
     *
     * @property {LinesModeOptions} LN - Lines mode options.
     * @property {LicoriceModeOptions} LC - Licorice mode options.
     * @property {BallsAndSticksModeOptions} BS - Balls and Sticks mode options.
     * @property {VanDerWaalsModeOptions} VW - Van der Waals mode options.
     * @property {TraceModeOptions} TR - Trace mode options.
     * @property {TubeModeOptions} TU - Tube mode options.
     * @property {CartoonModeOptions} CA - Cartoon mode options.
     * @property {QuickSurfaceModeOptions} QS - Contact Surface mode options.
     * @property {IsoSurfaceSASModeOptions} SA - Solvent Accessible Surface mode options.
     * @property {IsoSurfaceSESModeOptions} SE - Solvent Excluded Surface mode options.
     * @property {ContactSurfaceModeOptions} CS - Contact Surface mode options.
     * @property {TextModeOptions} TX - Text mode options.
     * @property {VolumeDensityModeOptions} VD - Volume Density mode options.
     */
    modes: {
      //----------------------------------------------------------------------------
      // BALLS AND STICKS
      //----------------------------------------------------------------------------

      /**
       * Balls and Sticks mode options.
       *
       * @typedef BallsAndSticksModeOptions
       *
       * @property {number} atom - Sphere radius as a fraction of Van der Waals atom radius.
       * @property {number} bond - Cylinder radius in angstroms.
       * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
       *   available space.
       * @property {boolean} multibond - Toggles rendering of multiple ordered bonds.
       * @property {number} aromrad - Minor radius of a torus for aromatic loops.
       * @property {boolean} showarom - Toggles rendering of aromatic loops.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      BS: {
        atom: 0.23,
        bond: 0.15,
        space: 0.5,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // VAN DER WAALS
      //----------------------------------------------------------------------------

      /**
       * Van der Waals mode options.
       *
       * @typedef VanDerWaalsModeOptions
       *
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      VW: {
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 8,
          high: 16,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // LINES
      //----------------------------------------------------------------------------

      /**
       * Lines mode options.
       *
       * @typedef LinesModeOptions
       *
       * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
       * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
       * @property {number} offsarom - Offset between bonds and aromatic cycle.
       * @property {number} chunkarom - Number of pieces in a-loop arc, corresponding to atom.
       * @property {number} atom - Collision radius for atoms picking.
       * @property {number} lineWidth - Line width in pixels (not used in thin lines).
       */
      LN: {
        multibond: true,
        showarom: true,
        offsarom: 0.2,
        chunkarom: 10,
        atom: 0.23,
        lineWidth: 2
      },
      //----------------------------------------------------------------------------
      // LICORICE
      //----------------------------------------------------------------------------

      /**
       * Licorice mode options.
       *
       * @typedef LicoriceModeOptions
       *
       * @property {number} bond - Bond cylinder radius.
       * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
       *   available space.
       * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
       * @property {number} aromrad - Minor radius of a torus for aromatic loops.
       * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
       * @property {PolyComplexity} polyComplexity - Poly complexity values for render modes.
       */
      LC: {
        bond: 0.20,
        space: 0.0,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // SURFACE SAS
      //----------------------------------------------------------------------------

      /**
       * Solvent Accessible Surface mode options.
       *
       * @typedef IsoSurfaceSASModeOptions
       *
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {number} probeRadius - Radius of the probe.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      SA: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      //----------------------------------------------------------------------------
      // SURFACE SES
      //----------------------------------------------------------------------------

      /**
       * Solvent Excluded Surface mode options.
       *
       * @typedef IsoSurfaceSESModeOptions
       *
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {number} probeRadius - Radius of the probe.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      SE: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      //----------------------------------------------------------------------------
      // QUICK SURFACE
      //----------------------------------------------------------------------------

      /**
       * Quick Surface mode options.
       *
       * @typedef QuickSurfaceModeOptions
       *
       * @property {number} isoValue - Isovalue of the surface to extract.
       * @property {number} scale - Radius scale for the surface being built.
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} gaussLim - Gauss lim for coloring the bigger the value, the smoother our colors are.
       * @property {PolyComplexity} gridSpacing - Poly complexity values for render modes. In this case the value
       *   corresponds to the grid density.
       */
      QS: {
        isoValue: 0.5,
        gaussLim: {
          poor: 1.5,
          low: 2.0,
          medium: 2.5,
          high: 3.0,
          ultra: 4.0
        },
        scale: 1.0,
        wireframe: false,
        gridSpacing: {
          poor: 2,
          low: 1.5,
          medium: 1,
          high: 0.5,
          ultra: 0.25
        },
        subset: '',
        zClip: false
      },
      //----------------------------------------------------------------------------
      // CONTACT SURFACE
      //----------------------------------------------------------------------------

      /**
       * Contact Surface mode options.
       *
       * @typedef ContactSurfaceModeOptions
       *
       * @property {number} isoValue - Isovalue of the surface to extract.
       * @property {number} probeRadius - Probe radius.
       * @property {number} probePositions
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Radius scale for the surface being built.
       *   Poly complexity values for render modes. In this case the value corresponds to the grid density.
       */
      CS: {
        probeRadius: 1.4,
        isoValue: 1.5,
        wireframe: false,
        probePositions: 30,
        polyComplexity: {
          poor: 0.5,
          low: 1.0,
          medium: 1.5,
          high: 1.75,
          ultra: 2.0
        },
        subset: '',
        zClip: false
      },
      //----------------------------------------------------------------------------
      // TRACE
      //----------------------------------------------------------------------------

      /**
       * Trace mode options.
       *
       * @typedef TraceModeOptions
       *
       * @property {number} radius - Cylinder radius.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      TR: {
        radius: 0.30,
        polyComplexity: {
          poor: 12,
          low: 16,
          medium: 32,
          high: 64,
          ultra: 64
        }
      },
      //----------------------------------------------------------------------------
      // TUBE
      //----------------------------------------------------------------------------

      /**
       * Tube mode options.
       *
       * @typedef TubeModeOptions
       *
       * @property {number} radius - Cylinder radius.
       * @property {number} tension - Tension for interpolation.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
       */
      TU: {
        radius: 0.30,
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      //----------------------------------------------------------------------------
      // CARTOON
      //----------------------------------------------------------------------------

      /**
       * Cartoon mode options.
       *
       * @typedef CartoonModeOptions
       *
       * @property {number} radius - Standard tube radius.
       * @property {number} depth - Height of the secondary structure ribbon.
       * @property {number} tension - Tension for interpolation.
       * @proprety {object} ss - Secondary structure parameters.
       * @proprety {object} ss.helix - Options for helices render.
       * @proprety {number} ss.helix.width - Width of the secondary structure ribbon.
       * @proprety {number} ss.helix.arrow - Secondary structure's arrow width.
       * @proprety {object} ss.strand - Options for strands render.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       * polyComplexity must be even for producing symmetric arrows.
       * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
       */
      CA: {
        radius: 0.30,
        depth: 0.25,
        ss: {
          helix: {
            width: 1.0,
            arrow: 2.0
          },
          strand: {
            width: 1.0,
            arrow: 2.0
          }
        },
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      //----------------------------------------------------------------------------
      // TEXT
      //----------------------------------------------------------------------------

      /**
       * Text mode options.
       *
       * @typedef TextModeOptions
       *
       * @property {string} template - Format string for building output text.
       * @property {string} horizontalAlign - Text alignment ('left', 'right', 'center').
       * @property {string} verticalAlign - Vertical text box alignment ('top', 'bottom', 'middle').
       * @property {number} dx - Text offset x in angstroms.
       * @property {number} dy - Text offset y in angstroms.
       * @property {number} dz - Text offset z in angstroms.
       * @property {string} fg - Color rule for foreground.
       * @property {string} bg - Color rule for background.
       * @property {boolean} showBg - Flag, that toggles background rendering.
       *
       */
      TX: {
        template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
        horizontalAlign: 'center',
        verticalAlign: 'middle',
        dx: 0,
        dy: 0,
        dz: 1,
        fg: 'none',
        bg: '0x202020',
        showBg: true
      },
      //----------------------------------------------------------------------------
      // VOLUME DENSITY
      //----------------------------------------------------------------------------

      /**
       * Volume density mode options.
       *
       * @typedef VolumeDensityModeOptions
       *
       * @property {number} kSigma - Noise threshold coefficient.
       * @property {boolean} frame - flag, that turns on box frame painting.
       * @property {boolean} isoMode - flag, that turns on IsoSurface mode instead of Volume Rendering.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      VD: {
        kSigma: 1.0,
        kSigmaMed: 2.0,
        kSigmaMax: 4.0,
        frame: true,
        isoMode: false,
        polyComplexity: {
          poor: 2,
          low: 3,
          medium: 4,
          high: 8,
          ultra: 10
        }
      }
    },

    /**
     * Default options for all available colorers.
     * Use {@link Colorer.id} as a dictionary key to access colorer options.
     *
     * Usually you don't need to override these settings. You may specify colorer options as a parameter during
     * {@link Colorer} construction.
     *
     * Not all colorers have options.
     *
     * @memberof SettingsObject#
     * @type {Object.<string, object>}
     *
     * @property {ElementColorerOptions} EL - Element colorer options.
     * @property {SequenceColorerOptions} SQ - Sequence colorer options.
     * @property {MoleculeColorerOptions} MO - Molecule colorer options.
     * @property {UniformColorerOptions} UN - Uniform colorer options.
     * @property {ConditionalColorerOptions} CO - Conditional colorer options.
     * @property {TemperatureColorerOptions} TM - Temperature colorer options.
     * @property {OccupancyColorerOptions} OC - Occupancy colorer options.
     * @property {HydrophobicityColorerOptions} HY - Hydrophobicity colorer options.
     */
    colorers: {
      /**
       * Element colorer options.
       *
       * @typedef ElementColorerOptions
       *
       * @property {number} carbon - Carbon color or -1 to use default.
       */
      EL: {
        carbon: -1
      },

      /**
       * Uniform colorer options.
       *
       * @typedef UniformColorerOptions
       *
       * @property {number} color - Single color to paint with.
       */
      UN: {
        color: 0xFFFFFF
      },

      /**
       * Conditional colorer options.
       *
       * @typedef ConditionalColorerOptions
       *
       * @property {string} subset - Selector string.
       * @property {number} color - Color of selected atoms.
       * @property {number} baseColor - Color of other atoms.
       */
      CO: {
        subset: 'charged',
        color: 0xFF0000,
        baseColor: 0xFFFFFF
      },

      /**
       * Carbon colorer options.
       *
       * @typedef CarbonColorerOptions
       *
       * @property {number} color - Single color to paint carbons
       * @property {number} factor - Color factor for not carbon atoms.
       */
      CB: {
        color: 0x909090,
        factor: 0.6
      },

      /**
       * Sequence colorer options.
       *
       * @typedef SequenceColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      SQ: {
        gradient: 'rainbow'
      },

      /**
       * Temperature colorer options.
       *
       * @typedef TemperatureColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       * @property {number} min - Minimal temperature.
       * @property {number} max - Maximal temperature.
       */
      TM: {
        gradient: 'temp',
        min: 5,
        max: 40
      },

      /**
       * Occupancy colorer options.
       *
       * @typedef OccupancyColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      OC: {
        gradient: 'reds'
      },

      /**
       * Hydrophobicity colorer options.
       *
       * @typedef HydrophobicityColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      HY: {
        gradient: 'blue-red'
      },

      /**
       * Molecule colorer options.
       *
       * @typedef MoleculeColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      MO: {
        gradient: 'rainbow'
      }
    },

    /*
     * Use antialiasing in WebGL.
     * @type {boolean}
     */
    antialias: true,

    /*
     * Camera field of view in degrees.
     * @type {number}
     */
    camFov: 45.0,

    /*
     * Camera near plane distance.
     * @type {number}
     */
    camNear: 0.5,

    /*
     * Camera far plane distance.
     * @type {number}
     */
    camFar: 100.0,
    camDistance: 2.5,
    radiusToFit: 1.0,

    /**
     * @type {number}
     * @instance
     */
    fogNearFactor: 0.5,
    // [0, 1]

    /**
     * @type {number}
     * @instance
     */
    fogFarFactor: 1,
    // [0, 1]
    fogAlpha: 1.0,
    fogColor: 0x000000,
    fogColorEnable: false,

    /**
     * Palette used for molecule coloring.
     * @type {string}
     */
    palette: 'JM',

    /*
     * Geometry resolution.
     * @type {string}
     */
    resolution: 'medium',
    autoResolution: false
    /* true */
    ,
    autoPreset: true,
    preset: 'default',
    // TODO: remove 'preset' from settings, implement autodetection
    presets: {
      // Default
      "default": [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      empty: [],
      // Wireframe
      wire: [{
        mode: 'LN',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      // Small molecules
      small: [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      // Proteins, nucleic acids etc.
      macro: [{
        mode: 'CA',
        colorer: 'SS',
        selector: 'not hetatm',
        material: 'SF'
      }, {
        mode: 'BS',
        colorer: 'EL',
        selector: 'hetatm and not water',
        material: 'SF'
      }]
    },
    objects: {
      line: {
        color: 0xFFFFFFFF,
        dashSize: 0.3,
        gapSize: 0.05
      }
    },
    //----------------------------------------------------------------------------
    bg: {
      color: 0x202020,
      transparent: false
    },
    draft: {
      clipPlane: false,
      clipPlaneFactor: 0.5,
      clipPlaneSpeed: 0.00003
    },

    /*
       * Separate group for plugins.
       * Each plugin handles its field by itself.
       */
    plugins: {},

    /**
     * @type {boolean}
     * @instance
     */
    axes: true,

    /**
     * @type {boolean}
     * @instance
     */
    fog: true,

    /**
     * @type {boolean}
     * @instance
     */
    fps: true,

    /**
     * Switch using of z-sprites for sphere and cylinder geometry
     * @type {boolean}
     * @instance
     */
    zSprites: true,
    isoSurfaceFakeOpacity: true,

    /**
     * @type {boolean}
     * @instance
     */
    suspendRender: true,
    nowater: false,

    /**
     * @type {boolean}
     * @instance
     */
    autobuild: true,

    /**
     * Anti-aliasing.
     * @type {boolean}
     * @instance
     */
    fxaa: true,

    /**
     * Outline depths
     * @type {boolean}
     * @instance
     */
    outline: {
      on: false,
      color: 0x000000,
      threshold: 0.1,
      thickness: 1
    },

    /**
     * Ambient Occlusion special effect.
     * @type {boolean}
     * @instance
     */
    ao: false,

    /**
     * Shadows options.
     *
     * @property {boolean} shadowMap - enable/disable.
     * @property {string} basic/percentage-closer filtering/non-uniform randomizing pcf.
     * @property {number} radius for percentage-closer filtering.
     */
    shadow: {
      on: false,
      type: 'random'
      /* basic, pcf, random */
      ,
      radius: 1.0
    },

    /**
     * Auto-rotation with constant speed.
     * @type {number}
     * @instance
     */
    autoRotation: 0.0,

    /**
     * Set maximum fps for animation.
     * @type {number}
     * @instance
     */
    maxfps: 30,

    /**
     * Set fbx output precision.
     * @type {number}
     * @instance
     */
    fbxprec: 4,

    /**
     * Auto-rotation axis.
     *
     * - true:  complex auto-rotation is about vertical axis
     * - false: rotation axis is defined by last user rotation
     *
     * @type {boolean}
     * @instance
     */
    autoRotationAxisFixed: true,

    /**
     * Enable zooming with mouse wheel or pinch gesture.
     * @type {boolean}
     * @instance
     */
    zooming: true,

    /**
     * Enable picking atoms & residues with left mouse button or touch.
     * @type {boolean}
     * @instance
     */
    picking: true,

    /**
     * Set picking mode ('atom', 'residue', 'chain', 'molecule').
     * @type {string}
     * @instance
     */
    pick: 'atom',

    /**
     * Make "component" and "fragment" editing modes available.
     * @type {boolean}
     * @instance
     */
    editing: false,

    /**
     * Detect aromatic loops.
     * @type {boolean}
     * @instance
     */
    aromatic: false,

    /**
     * Load only one biological unit from all those described in PDB file.
     * @type {boolean}
     * @instance
     */
    singleUnit: true,

    /**
     * Set stereo mode ('NONE', 'SIMPLE', 'DISTORTED', 'ANAGLYPH', 'WEBVR').
     * @type {string}
     * @instance
     */
    stereo: 'NONE',

    /**
     * Enable smooth transition between views
     * @type {boolean}
     * @instance
     */
    interpolateViews: true,

    /**
     * Set transparency mode ('standard', 'prepass').
     * @type {string}
     * @instance
     */
    transparency: 'prepass',

    /**
     * Mouse translation speed.
     * @type {number}
     * @instance
     */
    translationSpeed: 2,
    debug: {
      example: 3.5,
      text: 'hello!',
      good: true,
      ssaoKernelRadius: 0.7,
      ssaoFactor: 0.7,
      stereoBarrel: 0.25
    },
    use: {
      multiFile: false
    }
  }; //----------------------------------------------------------------------------
  // SETTINGS CLASS
  //----------------------------------------------------------------------------

  function Settings() {
    EventDispatcher.call(this);
    this.old = null;
    this.now = {};
    this._changed = {};
    this.reset();
  }

  utils.deriveClass(Settings, EventDispatcher, {
    defaults: defaults$1,
    set: function set(path, value) {
      if (___default['default'].isString(path)) {
        var oldValue = ___default['default'].get(this.now, path);

        if (oldValue !== value) {
          ___default['default'].set(this.now, path, value);

          this._notifyChange(path, value);
        }
      } else {
        var diff = utils.objectsDiff(path, this.now);

        if (!___default['default'].isEmpty(diff)) {
          ___default['default'].merge(this.now, diff);

          this._notifyChanges(diff);
        }
      }
    },
    get: function get(path, defaultValue) {
      return ___default['default'].get(this.now, path, defaultValue);
    },
    reset: function reset() {
      var diff = utils.objectsDiff(defaults$1, this.now);
      this.now = ___default['default'].cloneDeep(defaults$1);
      this.old = null;

      this._notifyChanges(diff);

      this._changed = {};
    },
    checkpoint: function checkpoint() {
      this.old = ___default['default'].cloneDeep(this.now);
      this._changed = {};
    },
    _notifyChange: function _notifyChange(path, value) {
      this._changed[path] = true;
      this.dispatchEvent({
        type: "change:".concat(path),
        value: value
      });
    },
    _notifyChanges: function _notifyChanges(diff) {
      var _this = this;

      utils.forInRecursive(diff, function (deepValue, deepPath) {
        _this._notifyChange(deepPath, deepValue);
      });
    },
    changed: function changed() {
      if (!this.old) {
        return [];
      }

      var old = this.old,
          now = this.now;

      var keys = ___default['default'].filter(Object.keys(this._changed), function (key) {
        return ___default['default'].get(old, key) !== ___default['default'].get(now, key);
      });

      return keys;
    },
    applyDiffs: function applyDiffs(diffs) {
      if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
        throw new Error('Settings version does not match!');
      } // VERSION shouldn't be presented inside settings structure


      delete diffs.VERSION;
      this.reset();
      this.set(diffs);
    },
    getDiffs: function getDiffs(versioned) {
      var diffs = utils.objectsDiff(this.now, defaults$1);

      if (versioned) {
        diffs.VERSION = VERSION;
      }

      return diffs;
    },
    setPluginOpts: function setPluginOpts(plugin, opts) {
      defaults$1.plugins[plugin] = ___default['default'].cloneDeep(opts);
      this.now.plugins[plugin] = ___default['default'].cloneDeep(opts);
    }
  });
  var settings = new Settings();

  var repIndex = 0;

  function asBoolean(value) {
    return !(!value || value === '0' || ___default['default'].isString(value) && value.toLowerCase() === 'false');
  }

  var adapters = {
    string: String,
    number: Number,
    "boolean": asBoolean
  }; // Level 1 assignment symbol

  var cL1Ass = '=';
  var cOptsSep = '!'; // Level 2 (options) assignment symbol

  var cL2Ass = ':'; // Level 2 (options) separator symbol

  var cLSep = ',';
  var cCommonIgnoreSymbols = '$;@/?';
  /**
   * We may (and should) leave as is for better readability:
   *
   *        $ , ; : @ / ?
   */

  /**
   * Generate regular expression for symbols excluded for first level encryption
   */

  function getLevel1ExcludedExpr() {
    var cLevel1Ignores = ':,';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
  }
  /**
   * Generate regular expression for symbols excluded for first level encryption
   * (options, etc, ..)
   */


  function getLevel2ExcludedExpr() {
    var cLevel2Ignores = ' ';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
  }

  var cL1ExclExpr = getLevel1ExcludedExpr();

  function encodeQueryComponentL1(value) {
    return utils.encodeQueryComponent(value, cL1ExclExpr);
  }

  var cL2ExclExpr = getLevel2ExcludedExpr();

  function encodeQueryComponentL2(value) {
    return utils.encodeQueryComponent(value, cL2ExclExpr);
  }

  function ensureRepList(opts) {
    var reps = opts.reps;

    if (!reps) {
      var presets = settings.now.presets;
      var preset = opts.preset || settings.now.preset;
      reps = presets[preset];

      if (!reps) {
        logger.warn("Unknown preset \"".concat(preset, "\""));

        var _Object$keys = Object.keys(presets);

        var _Object$keys2 = slicedToArray(_Object$keys, 1);

        preset = _Object$keys2[0];
        reps = presets[preset]; // fall back to any preset
      }

      opts.preset = preset;
      opts.reps = utils.deriveDeep(reps, true);
    }
  }

  function ensureRepAssign(opts, prop, value) {
    ensureRepList(opts);
    var rep = opts.reps[repIndex]; // prop specified twice therefore start new rep by cloning the current

    if (rep.hasOwnProperty(prop)) {
      repIndex = opts.reps.length;
      opts.reps[repIndex] = utils.deriveDeep(rep, true);
    }

    if (value !== undefined) {
      opts.reps[repIndex][prop] = value;
    }
  }

  function addObject(opts, params, options) {
    if (opts._objects === undefined) {
      opts._objects = [];
    }

    var _options = slicedToArray(options, 2),
        type = _options[0],
        newOpts = _options[1];

    var newObj = {
      type: type,
      params: params
    };

    if (newOpts !== undefined) {
      newObj.opts = newOpts;
    }

    opts._objects[opts._objects.length] = newObj;
  }

  function parseParams(str, params) {
    var sep = str.indexOf(',');

    if (sep >= 0) {
      params.push(str.substr(sep + 1).split(','));
      return str.substr(0, sep);
    } // keep this untouched if no params were extracted


    return str;
  }

  function extractArgs(input, defaultsDict, params) {
    if (input) {
      var bang = input.indexOf(cOptsSep);
      var inputVal = parseParams(input.substr(0, bang >= 0 ? bang : undefined), params);

      if (bang >= 0) {
        var args = input.substr(bang + 1).split(cLSep);
        input = inputVal;

        if (defaultsDict) {
          var defaults = defaultsDict[input];
          var opts = utils.deriveDeep(defaults, true);
          args.forEach(function (arg) {
            var pair = arg.split(cL2Ass, 2);
            var key = decodeURIComponent(pair[0]);
            var value = decodeURIComponent(pair[1]);

            var adapter = adapters[_typeof_1(___default['default'].get(defaults, key))];

            if (adapter) {
              ___default['default'].set(opts, key, adapter(value));
            } else {
              logger.warn("Unknown argument \"".concat(key, "\" for option \"").concat(input, "\""));
            }
          });

          if (Object.keys(opts).length > 0) {
            input = [input, opts];
          }
        }
      } else {
        input = inputVal;
      }
    }

    return input;
  }

  var actions = {
    l: 'load',
    load: String,
    t: 'type',
    type: String,
    v: 'view',
    view: String,
    u: 'unit',
    unit: Number,
    menu: asBoolean,
    // Commands
    o: 'object',
    object: function object(value, opts) {
      var params = [];
      var options = extractArgs(value, settings.defaults.objects, params);

      if (!Array.isArray(options)) {
        options = [options];
      }

      addObject(opts, params[0], options);
    },
    p: 'preset',
    preset: function preset(value, opts) {
      opts.preset = value;
      opts.reps = null;
      ensureRepList(opts);
    },
    r: 'rep',
    rep: function rep(value, opts) {
      ensureRepList(opts);
      repIndex = Number(value); // clamp the index to one greater than the last

      repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length; // create a new rep if it is adjacent to the existing ones

      if (repIndex === opts.reps.length) {
        // if there is no rep to derive from, derive from the first rep of the default
        opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings.defaults.presets["default"][0], true);
      }
    },
    s: 'select',
    select: function select(value, opts) {
      ensureRepAssign(opts, 'selector', value);
    },
    m: 'mode',
    mode: function mode(value, opts) {
      ensureRepAssign(opts, 'mode', extractArgs(value, settings.defaults.modes));
    },
    c: 'color',
    color: function color(value, opts) {
      ensureRepAssign(opts, 'colorer', extractArgs(value, settings.defaults.colorers));
    },
    mt: 'material',
    material: function material(value, opts) {
      ensureRepAssign(opts, 'material', extractArgs(value, settings.defaults.materials));
    },
    dup: function dup(value, opts) {
      ensureRepList(opts);
      var reps = opts.reps;
      var rep = reps[repIndex];
      repIndex = reps.length;
      reps[repIndex] = utils.deriveDeep(rep, true);
    },
    // Settings shortcuts
    ar: 'autoResolution'
  };

  function _fromArray(entries) {
    repIndex = 0;
    var opts = {};

    for (var i = 0, n = entries.length; i < n; ++i) {
      var
      /** string[] */
      entry = entries[i];
      var
      /** string? */
      key = entry[0];
      var
      /** string? */
      value = entry[1];
      var
      /** function|string? */
      action = actions[key]; // unwind shortcuts and aliases

      while (___default['default'].isString(action)) {
        key = action;
        action = actions[key];
      } // either set a property or use specialized parser


      if (!action) {
        var adapter = adapters[_typeof_1(___default['default'].get(settings.defaults, key))];

        if (adapter) {
          ___default['default'].set(opts, "settings.".concat(key), adapter(value));
        } else {
          logger.warn("Unknown option \"".concat(key, "\""));
        }
      } else if (___default['default'].isFunction(action)) {
        var result = action(value, opts);

        if (result !== undefined) {
          opts[key] = result;
        }
      }
    }

    return opts;
  }

  function fromAttr(attr) {
    return _fromArray(utils.getUrlParameters("?".concat(attr || '')));
  }

  function fromURL(url) {
    return _fromArray(utils.getUrlParameters(url));
  }

  function _processOptsForURL(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
    });
    return str.join(cLSep);
  }

  function _processArgsForURL(args) {
    if (!___default['default'].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0]).concat(cOptsSep).concat(_processOptsForURL(args[1]));
  }

  function _processObjForURL(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default['default'].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += ",".concat(objOpts.params.join(','));
    }

    if (objOpts.opts) {
      res += cOptsSep + _processOptsForURL(objOpts.opts);
    }

    return res;
  }

  function toURL(opts) {
    var stringList = [];
    var idx = 0;

    function checkAndAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        if (___default['default'].isEmpty(repList[i])) {
          continue;
        }

        checkAndAdd('r', i);
        checkAndAdd('s', repList[i].selector);
        checkAndAdd('m', _processArgsForURL(repList[i].mode));
        checkAndAdd('c', _processArgsForURL(repList[i].colorer));
        checkAndAdd('mt', _processArgsForURL(repList[i].material));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('o', _processObjForURL(objList[i]));
      }
    }

    checkAndAdd('l', opts.load);
    checkAndAdd('u', opts.unit);
    checkAndAdd('p', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    checkAndAdd('v', opts.view);
    utils.forInRecursive(opts.settings, function (value, key) {
      // I heard these lines in the whispers of the Gods
      // Handle preset setting in reps
      if (key === 'preset') {
        return;
      }

      checkAndAdd(key, value);
    });
    var url = '';

    if (typeof window !== 'undefined') {
      var _window = window,
          location = _window.location;
      url = "".concat(location.protocol, "//").concat(location.host).concat(location.pathname);
    }

    if (stringList.length > 0) {
      url += "?".concat(stringList.join('&'));
    }

    return url;
  }

  function _processOptsForScript(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = "".concat(key, "=").concat(utils.enquoteString(value));
    });
    return str.join(' ');
  }

  function _processArgsForScript(args) {
    if (!___default['default'].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0], " ").concat(_processOptsForScript(args[1]));
  }

  function _processObjForScript(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default['default'].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += " ".concat(objOpts.params.map(utils.enquoteString).join(' '));
    }

    if (objOpts.opts) {
      res += " ".concat(_processOptsForScript(objOpts.opts));
    }

    return res;
  }

  function _processRepsForScript(rep, index) {
    var repString = [];
    var strIdx = 0;

    function localAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        repString[strIdx++] = prefix + value;
      }
    }

    if (___default['default'].isEmpty(rep)) {
      return null;
    }

    localAdd('', index);
    localAdd('s=', utils.enquoteString(rep.selector));
    localAdd('m=', _processArgsForScript(rep.mode));
    localAdd('c=', _processArgsForScript(rep.colorer));
    localAdd('mt=', _processArgsForScript(rep.material));
    return repString.join(' ');
  }

  function toScript(opts) {
    var commandsList = [];
    var idx = 0;

    function checkAndAdd(command, value, saveQuotes) {
      if (value !== null && value !== undefined) {
        var quote = typeof value === 'string' && saveQuotes ? '"' : '';
        commandsList[idx++] = "".concat(command, " ").concat(quote).concat(value).concat(quote).trim();
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        checkAndAdd('rep', _processRepsForScript(repList[i], i));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('', _processObjForScript(objList[i]));
      }
    }

    checkAndAdd('set', 'autobuild false');
    checkAndAdd('load', opts.load, true);
    checkAndAdd('unit', opts.unit);
    checkAndAdd('preset', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    utils.forInRecursive(opts.settings, function (value, key) {
      // I heard these lines in the whispers of the Gods
      // Handle preset setting in reps
      if (key === 'preset') {
        return;
      }

      checkAndAdd("set ".concat(key), value, true);
    });
    checkAndAdd('view', opts.view);
    checkAndAdd('set', 'autobuild true');
    return commandsList.join('\n');
  }

  var options = {
    fromURL: fromURL,
    fromAttr: fromAttr,
    adapters: adapters,
    toURL: toURL,
    toScript: toScript
  };

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;

  /**
   * Atom measurements.
   *
   * @param {Residue} residue    - (required) Residue containing the atom
   * @param {string} name        - (required) Name, unique in the residue
   * @param {Element} type       - (required) Chemical element reference
   * @param {THREE.Vector3} position - Registered coordinates
   *
   * @param {number} role        - Role of atom inside monomer: Lead and wing are particularity interesting
   * @param {boolean} het        - Non-standard residue indicator
   *
   * @param {number} serial      - Serial number, unique in the model
   * @param {string} location    - Alternative location indicator (usually space or A-Z)
   * @param {number} occupancy   - Occupancy percentage, from 0 to 1
   * @param {number} temperature - Temperature
   * @param {number} charge      - Charge
   *
   * @exports Atom
   * @constructor
   */
  var Atom = /*#__PURE__*/function () {
    function Atom(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
      classCallCheck(this, Atom);

      this.index = -1;
      this.residue = residue;
      this.name = name;
      this.element = type;
      this.position = position;
      this.role = role;
      this.mask = 1 | 0;
      this.het = het;
      this.serial = serial;
      this.location = (location || ' ').charCodeAt(0);
      this.occupancy = occupancy || 1;
      this.temperature = temperature;
      this.charge = charge;
      this.hydrogenCount = -1; // explicitly invalid

      this.radicalCount = 0;
      this.valence = -1; // explicitly invalid

      this.bonds = [];
      this.flags = 0x0000;

      if (type.name === 'H') {
        this.flags |= Atom.Flags.HYDROGEN;
      } else if (type.name === 'C') {
        this.flags |= Atom.Flags.CARBON;
      }
    }

    createClass(Atom, [{
      key: "isHet",
      value: function isHet() {
        return this.het;
      }
    }, {
      key: "isHydrogen",
      value: function isHydrogen() {
        return this.element.number === 1;
      }
    }, {
      key: "getVisualName",
      value: function getVisualName() {
        var name = this.name;

        if (name.length > 0) {
          return name;
        }

        return this.element.name.trim();
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "getFullName",
      value: function getFullName() {
        var name = '';

        if (this.residue !== null) {
          if (this.residue._chain !== null) {
            name += "".concat(this.residue._chain.getName(), ".");
          }

          name += "".concat(this.residue._sequence, ".");
        }

        name += this.name;
        return name;
      }
      /**
       * Enumeration of atom flag values.
       *
       * @enum {number}
       * @readonly
       */

    }]);

    return Atom;
  }();

  defineProperty(Atom, "Flags", {
    CARBON: 0x0001,
    // OXYGEN: 0x0002,
    // NITROGEN: 0x0004,
    HYDROGEN: 0x0008,

    /** Non-polar hydrogen (it is also a HYDROGEN) */
    NONPOLARH: 0x1008
  });

  var Element = function Element(number, name, fullName, weight, radius, radiusBonding, hValency) {
    classCallCheck(this, Element);

    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  };

  defineProperty(Element, "Constants", {
    /* eslint-disable no-magic-numbers */
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(Element, "Role", {
    /* eslint-disable no-magic-numbers */
    N: Element.Constants.U1,
    CA: Element.Constants.Lead,
    C: Element.Constants.U2,
    O: Element.Constants.Wing,
    SG: Element.Constants.U18
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(Element, "ByAtomicNumber", [
  /* eslint-disable no-magic-numbers */
  null, new Element(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]), new Element(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]), new Element(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]), new Element(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]), new Element(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]), new Element(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]), new Element(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]), new Element(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]), new Element(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]), new Element(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]), new Element(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]), new Element(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]), new Element(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]), new Element(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]), new Element(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]), new Element(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]), new Element(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]), new Element(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]), new Element(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]), new Element(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]), new Element(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]), new Element(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]), new Element(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]), new Element(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]), new Element(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]), new Element(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]), new Element(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]), new Element(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]), new Element(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]), new Element(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]), new Element(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]), new Element(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]), new Element(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]), new Element(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]), new Element(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]), new Element(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]), new Element(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]), new Element(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]), new Element(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]), new Element(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]), new Element(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]), new Element(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]), new Element(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]), new Element(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]), new Element(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]), new Element(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]), new Element(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]), new Element(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]), new Element(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]), new Element(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]), new Element(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]), new Element(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]), new Element(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]), new Element(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]), new Element(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]), new Element(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]), new Element(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]), new Element(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]), new Element(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]), new Element(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]), new Element(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]), new Element(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]), new Element(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]), new Element(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]), new Element(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]), new Element(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]), new Element(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]), new Element(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]), new Element(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]), new Element(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]), new Element(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]), new Element(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]), new Element(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]), new Element(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]), new Element(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]), new Element(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]), new Element(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]), new Element(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]), new Element(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]), new Element(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]), new Element(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]), new Element(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]), new Element(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]), new Element(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]), new Element(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]), new Element(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]), new Element(87, 'FR', 'Francium', 223, 1.7, 2, [1]), new Element(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]), new Element(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]), new Element(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]), new Element(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]), new Element(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]), new Element(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]), new Element(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]), new Element(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]), new Element(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]), new Element(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]), new Element(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]), new Element(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]), new Element(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]), new Element(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]), new Element(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]), new Element(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]), new Element(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]), new Element(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]), new Element(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]), new Element(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]), new Element(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]), new Element(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])
  /* eslint-enable no-magic-numbers */
  ]);

  defineProperty(Element, "ByName", {
    // Duplicate atomic numbers (isotopes)

    /* eslint-disable no-magic-numbers */
    D: new Element(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
    T: new Element(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
    /* eslint-enable no-magic-numbers */
    // All regular elements will be added later, automatically

  });

  (function () {
    var byAtomicNumber = Element.ByAtomicNumber;
    var byName = Element.ByName;

    for (var i = 0, n = byAtomicNumber.length; i < n; ++i) {
      var element = byAtomicNumber[i];

      if (element) {
        byName[element.name] = element;
      }
    }
  })(); // find atom type by chemical element (or create if missing)


  Element.getByName = function (element) {
    var type = Element.ByName[element];

    if (!type) {
      type = Element.ByName[element] = new Element(0, element, 'Unknown', 0, 1.0, 0.01, [0]);
    }

    return type;
  };

  var cBondTypes = {
    /** Was generated manually */
    UNKNOWN: 0,

    /** Simple covalent bond */
    COVALENT: 1,

    /** Aromatic bond */
    AROMATIC: 2
  };

  function getAtomPos(atom) {
    return atom.position;
  }
  /**
   * Bond between atoms.
   *
   * @param {Atom} left     - The first atom.
   * @param {Atom} right    - The second atom.
   * @param {number} order - Order of current bond.
   * @param {number} type - Bond type.
   * @param {boolean} fixed - Indicator of a pre-specified connection (in contrast with guessed one).
   *
   * @exports Bond
   * @constructor
   */


  var Bond = /*#__PURE__*/function () {
    function Bond(left, right, order, type, fixed) {
      classCallCheck(this, Bond);

      this._left = left;
      this._right = right;
      this._fixed = fixed;
      this._index = -1;

      if (left > right) {
        throw new Error('In a bond atom indices must be in increasing order');
      }

      this._order = order;
      this._type = type;
    }

    createClass(Bond, [{
      key: "getLeft",
      value: function getLeft() {
        return this._left;
      }
    }, {
      key: "getRight",
      value: function getRight() {
        return this._right;
      }
    }, {
      key: "getOrder",
      value: function getOrder() {
        return this._order;
      }
    }, {
      key: "calcLength",
      value: function calcLength() {
        return this._left.position.distanceTo(this._right.position);
      }
    }, {
      key: "_forEachNeighbour",
      value: function _forEachNeighbour(currAtom, process) {
        var bonds = currAtom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
        }
      }
    }, {
      key: "forEachLevelOne",
      value: function forEachLevelOne(process) {
        var left = this._left;
        var right = this._right;

        this._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          process(atom);
        });

        this._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          process(atom);
        });
      }
    }, {
      key: "forEachLevelTwo",
      value: function forEachLevelTwo(process) {
        // TODO refactor this piece of an art?
        var left = this._left;
        var right = this._right;
        var self = this;

        self._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === left) {
              return;
            }

            process(l2Atom);
          });
        });

        self._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === right) {
              return;
            }

            process(l2Atom);
          });
        });
      }
    }, {
      key: "_fixDir",
      value: function _fixDir(refPoint, currDir, posGetter) {
        // count atoms to the right and to the left of the current plane
        var rightCount = 0;
        var leftCount = 0;
        var tmpVec = refPoint.clone();

        function checkDir(atom) {
          tmpVec.copy(posGetter(atom));
          tmpVec.sub(refPoint);
          var dotProd = currDir.dot(tmpVec);

          if (dotProd > 0) {
            ++rightCount;
          } else {
            ++leftCount;
          }
        }

        function checkCarbon(atom) {
          if (atom.element.name === 'C') {
            checkDir(atom);
          }
        } // count all atoms to the left and right of our plane, start from level 1 and carbons


        var stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];

        for (var stageId = 0; stageId < stages.length; ++stageId) {
          stages[stageId][0].call(this, stages[stageId][1]);

          if (leftCount > rightCount) {
            return currDir.multiplyScalar(-1);
          }

          if (leftCount < rightCount) {
            return currDir;
          }
        }

        return currDir;
      }
    }, {
      key: "calcNormalDir",
      value: function calcNormalDir(posGetter) {
        var left = this._left;
        var right = this._right;
        var first = left;
        var second = right;
        posGetter = posGetter === undefined ? getAtomPos : posGetter;

        if (left.bonds.length > right.bonds.length) {
          first = right;
          second = left;
        }

        var third = first;
        var maxNeibs = 0;
        var _second = second,
            bonds = _second.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var another = bonds[i]._left;

          if (bonds[i]._left === second) {
            another = bonds[i]._right;
          }

          if (another.bonds.length > maxNeibs && another !== first) {
            third = another;
            maxNeibs = another.bonds.length;
          }
        }

        var secondPos = posGetter(second);
        var firstV = posGetter(first).clone().sub(secondPos);
        var secondV = posGetter(third).clone().sub(secondPos);
        secondV.crossVectors(firstV, secondV);

        if (secondV.lengthSq() < 0.0001) {
          secondV.set(0, 1, 0);
        }

        firstV.normalize();
        secondV.normalize();
        firstV.crossVectors(secondV, firstV);

        if (firstV.lengthSq() < 0.0001) {
          firstV.set(0, 1, 0);
        }

        firstV.normalize();
        return this._fixDir(secondPos, firstV, posGetter);
      }
    }]);

    return Bond;
  }();

  defineProperty(Bond, "BondType", cBondTypes);

  Bond.prototype.BondType = cBondTypes;

  var cNucleicControlNames = ['C3\'', 'C3*', 'P', 'H5T', 'H3T'];
  var cNucleicWing1Names = ['OP1', 'O1P'];
  var cNucleicWing2Names = ['OP2', 'O2P'];
  var cCylinderSource = ['C3\'', 'C3*', 'C1', 'C1\'', 'C1*', 'P'];
  var cCylinderTarget = [{
    types: ['A', 'DA', 'G', 'DG'],
    atoms: ['N1']
  }, {
    types: ['C', 'DC'],
    atoms: ['N3']
  }, {
    types: ['T', 'DT', 'U', 'DU'],
    atoms: ['O4']
  }];
  /**
   * Residue instance.
   *
   * @param {Chain} chain      - Chain this residue belongs to.
   * @param {ResidueType} type - Generic residue instance type.
   * @param {number} sequence  - Sequence ID.
   * @param {string} icode     - One character insertion code (usually space or A-Z).
   *
   * @exports Residue
   * @constructor
   */

  var Residue = /*#__PURE__*/function () {
    function Residue(chain, type, sequence, icode) {
      classCallCheck(this, Residue);

      this._chain = chain;
      this._component = null;
      this._type = type;
      this._sequence = sequence;
      this._icode = icode;
      this._mask = 1 | 0;
      this._index = -1;
      this._atoms = [];
      this._secondary = null;
      this._firstAtom = null;
      this._leadAtom = null;
      this._wingAtom = null;
      this._lastAtom = null;
      this._controlPoint = null;
      this._midPoint = null;
      this._wingVector = null;
      this._cylinders = null;
      this._isValid = true;
      this._het = false;
      this._molecule = null;
      this.temperature = null;
      this.occupancy = null;
    } // Getters and setters


    createClass(Residue, [{
      key: "getChain",
      value: function getChain() {
        return this._chain;
      }
    }, {
      key: "getMolecule",
      value: function getMolecule() {
        return this._molecule;
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._type;
      }
    }, {
      key: "getSequence",
      value: function getSequence() {
        return this._sequence;
      }
    }, {
      key: "getSecondary",
      value: function getSecondary() {
        return this._secondary;
      }
    }, {
      key: "getICode",
      value: function getICode() {
        return this._icode;
      } // Other methods

    }, {
      key: "addAtom",
      value: function addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
        var atom = new Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);

        var complex = this._chain.getComplex();

        complex.addAtom(atom);

        this._atoms.push(atom);

        this._het = this._het || het;
        return atom;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (process(atoms[i])) {
            break;
          }
        }
      }
    }, {
      key: "_findAtomByName",
      value: function _findAtomByName(name) {
        var res = null;
        this.forEachAtom(function (atom) {
          if (atom.name === name) {
            res = atom;
            return true;
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_findFirstAtomInList",
      value: function _findFirstAtomInList(names) {
        var res = null;

        for (var i = 0; i < names.length; ++i) {
          res = this._findAtomByName(names[i]);

          if (res !== null) {
            return res;
          }
        }

        return res;
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          mask &= atoms[i].mask;
        }

        this._mask = mask;
      }
    }, {
      key: "getCylinderTargetList",
      value: function getCylinderTargetList() {
        var type = this._type._name;

        for (var i = 0, n = cCylinderTarget.length; i < n; ++i) {
          for (var j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
            if (type === cCylinderTarget[i].types[j]) {
              return cCylinderTarget[i].atoms;
            }
          }
        }

        return null;
      }
    }, {
      key: "_detectLeadWing",
      value: function _detectLeadWing(dst, next, getAtomPosition) {
        var leadAtom = this._findFirstAtomInList(cNucleicControlNames);

        var wingStart = this._findFirstAtomInList(cNucleicWing1Names);

        var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);

        if (wingStart === null && next !== null) {
          wingStart = next._findFirstAtomInList(cNucleicWing1Names);
        }

        if (wingEnd === null && next !== null) {
          wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
        }

        if (leadAtom === null || wingStart === null || wingEnd === null) {
          return;
        }

        dst._leadAtom = leadAtom;
        dst._controlPoint = getAtomPosition(leadAtom);
        dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
        dst._isValid = true;

        var cylSource = this._findFirstAtomInList(cCylinderSource);

        var targetList = this.getCylinderTargetList();
        var cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;

        if (cylSource === null || cylTarget === null) {
          return;
        }

        dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
      }
    }, {
      key: "calcWing",
      value: function calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
        var vectorA = currLeadPos.clone().sub(prevLeadPos);
        var vectorB = prevLeadPos.clone().sub(prevWingPos);
        vectorB.crossVectors(vectorA, vectorB);
        vectorB.crossVectors(vectorA, vectorB).normalize();

        if (prevWing !== null && prevWing.length() > 0.0001) {
          var needToNegate = vectorB.length() > 0.0001 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;

          if (needToNegate) {
            vectorB.negate();
          }
        }

        return vectorB;
      }
    }, {
      key: "_innerFinalize",
      value: function _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
        var bFirstInChain = prev === null;
        var lp = getAtomPosition(this._leadAtom);
        var currLeadPos = new THREE.Vector3(lp.x, lp.y, lp.z);

        if (chainAsNucleic) {
          this._detectLeadWing(dst, nextRes, getAtomPosition);

          return;
        }

        if (bFirstInChain) {
          // for first one in chain
          dst._midPoint = getAtomPosition(this._firstAtom).clone();
        } else {
          var prevLeadPos = prev._controlPoint; // lead point of previous monomer

          dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
          dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
        }

        dst._controlPoint = currLeadPos;
      }
    }, {
      key: "_finalize2",
      value: function _finalize2(prev, next, asNucleic) {
        // Should be called AFTER first finalize
        this._innerFinalize(prev, prev, next, this, asNucleic, function (atom) {
          return atom.position;
        });
      }
    }, {
      key: "isConnected",
      value: function isConnected(anotherResidue) {
        if (this._chain !== anotherResidue._chain) {
          return false;
        }

        if (this === anotherResidue) {
          return true;
        }

        var res = false;
        this.forEachAtom(function (atom) {
          var bonds = atom.bonds;

          for (var i = 0, n = bonds.length; i < n; ++i) {
            var bond = bonds[i];

            if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
              res = true;
              return true;
            }
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var self = this;

        var _this$_atoms = slicedToArray(this._atoms, 1);

        this._firstAtom = _this$_atoms[0];
        this._lastAtom = this._atoms[this._atoms.length - 1];
        this._leadAtom = null;
        this._wingAtom = null;
        var tempCount = 0;
        var temperature = 0; // average temperature

        var occupCount = 0;
        var occupancy = 0; // average occupancy

        this.forEachAtom(function (a) {
          if (self._leadAtom === null) {
            if (a.role === Element.Constants.Lead) {
              self._leadAtom = a;
            }
          }

          if (self._wingAtom === null) {
            if (a.role === Element.Constants.Wing) {
              self._wingAtom = a;
            }
          }

          if (a.temperature) {
            temperature += a.temperature;
            tempCount++;
          }

          if (a.occupancy) {
            occupancy += a.occupancy;
            occupCount++;
          }

          return self._leadAtom !== null && self._wingAtom !== null;
        });

        if (tempCount > 0) {
          this.temperature = temperature / tempCount;
        }

        if (occupCount > 0) {
          this.occupancy = occupancy / occupCount;
        } // Still try to make monomer look valid


        if (this._leadAtom === null || this._wingAtom === null) {
          this._isValid = false;
        }

        if (this._leadAtom === null) {
          this._leadAtom = this._firstAtom;
        }

        if (this._wingAtom === null) {
          this._wingAtom = this._lastAtom;
        }
      }
    }]);

    return Residue;
  }();

  /**
   * Residue type.
   *
   * Predefined acid or created with HET, HETNAM, etc.
   *
   * @param {string} name            - Short name, either standard (ALA, MET, etc.) or non-standard one.
   * @param {string} fullName        - Full residue name.
   * @param {string} letterCode      - 1-letter symbol.
   *
   * @exports ResidueType
   * @constructor
   */
  var ResidueType = /*#__PURE__*/function () {
    function ResidueType(name, fullName, letterCode) {
      classCallCheck(this, ResidueType);

      this._name = name;
      this._fullName = fullName;
      this.letterCode = letterCode;
      this.flags = 0x0000;
    }

    createClass(ResidueType, [{
      key: "getName",
      value: function getName() {
        return this._name;
      } // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

    }]);

    return ResidueType;
  }(); // Flag combinations


  defineProperty(ResidueType, "StandardTypes", {
    /* eslint-disable no-magic-numbers */
    ALA: new ResidueType('ALA', 'Alanine', 'A'),
    ARG: new ResidueType('ARG', 'Arginine', 'R'),
    ASN: new ResidueType('ASN', 'Asparagine', 'N'),
    ASP: new ResidueType('ASP', 'Aspartic Acid', 'D'),
    CYS: new ResidueType('CYS', 'Cysteine', 'C'),
    GLN: new ResidueType('GLN', 'Glutamine', 'Q'),
    GLU: new ResidueType('GLU', 'Glutamic Acid', 'E'),
    GLY: new ResidueType('GLY', 'Glycine', 'G'),
    HIS: new ResidueType('HIS', 'Histidine', 'H'),
    ILE: new ResidueType('ILE', 'Isoleucine', 'I'),
    LEU: new ResidueType('LEU', 'Leucine', 'L'),
    LYS: new ResidueType('LYS', 'Lysine', 'K'),
    MET: new ResidueType('MET', 'Methionine', 'M'),
    PHE: new ResidueType('PHE', 'Phenylalanine', 'F'),
    PRO: new ResidueType('PRO', 'Proline', 'P'),
    PYL: new ResidueType('PYL', 'Pyrrolysine', 'O'),
    SEC: new ResidueType('SEC', 'Selenocysteine', 'U'),
    SER: new ResidueType('SER', 'Serine', 'S'),
    THR: new ResidueType('THR', 'Threonine', 'T'),
    TRP: new ResidueType('TRP', 'Tryptophan', 'W'),
    TYR: new ResidueType('TYR', 'Tyrosine', 'Y'),
    VAL: new ResidueType('VAL', 'Valine', 'V'),
    A: new ResidueType('A', 'Adenine', 'A'),
    C: new ResidueType('C', 'Cytosine', 'C'),
    G: new ResidueType('G', 'Guanine', 'G'),
    I: new ResidueType('I', 'Inosine', 'I'),
    T: new ResidueType('T', 'Thymine', 'T'),
    U: new ResidueType('U', 'Uracil', 'U'),
    DA: new ResidueType('DA', 'Adenine', 'A'),
    DC: new ResidueType('DC', 'Cytosine', 'C'),
    DG: new ResidueType('DG', 'Guanine', 'G'),
    DI: new ResidueType('DI', 'Inosine', 'I'),
    DT: new ResidueType('DT', 'Thymine', 'T'),
    DU: new ResidueType('DU', 'Uracil', 'U'),
    '+A': new ResidueType('+A', 'Adenine', 'A'),
    '+C': new ResidueType('+C', 'Cytosine', 'C'),
    '+G': new ResidueType('+G', 'Guanine', 'G'),
    '+I': new ResidueType('+I', 'Inosine', 'I'),
    '+T': new ResidueType('+T', 'Thymine', 'T'),
    '+U': new ResidueType('+U', 'Uracil', 'U'),
    WAT: new ResidueType('WAT', 'Water', ''),
    H2O: new ResidueType('H2O', 'Water', ''),
    HOH: new ResidueType('HOH', 'Water', ''),
    DOD: new ResidueType('DOD', 'Water', ''),
    UNK: new ResidueType('UNK', 'Unknown', ''),
    UNL: new ResidueType('UNL', 'Unknown Ligand', '')
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(ResidueType, "Flags", {
    // Amino acids

    /** Amino acid residue */
    PROTEIN: 0x0001,

    /** Basic amino acid residue */
    BASIC: 0x0002,

    /** Acidic amino acid residue */
    ACIDIC: 0x0004,

    /** Polar uncharged side chain amino acid residue */
    POLAR: 0x0008,

    /** Non-polar hydrophobic side chain amino acid residue */
    NONPOLAR: 0x0010,

    /** Aromatic amino acid residue */
    AROMATIC: 0x0020,
    // Nucleic acids

    /** Nucleic residue */
    NUCLEIC: 0x0100,

    /** Purine nucleic residue */
    PURINE: 0x0200,

    /** Pyrimidine nucleic residue */
    PYRIMIDINE: 0x0400,

    /** DNA */
    DNA: 0x0800,

    /** RNA */
    RNA: 0x1000,

    /** Water */
    WATER: 0x10000
  });

  function _addFlag(flag, list) {
    for (var i = 0, n = list.length; i < n; ++i) {
      var res = ResidueType.StandardTypes[list[i]];

      if (res) {
        res.flags |= flag;
      }
    }
  }

  var Flags = ResidueType.Flags;

  _addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD']);

  _addFlag(Flags.PROTEIN, ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLY', 'GLU', 'GLN', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'PYL', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL']);

  _addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS']);

  _addFlag(Flags.ACIDIC, ['ASP', 'GLU']);

  _addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR']);

  _addFlag(Flags.NONPOLAR, ['ALA', 'ILE', 'LEU', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'GLY']);

  _addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR']);

  _addFlag(Flags.NUCLEIC, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I', 'C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I']);

  _addFlag(Flags.PYRIMIDINE, ['C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU']);

  _addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U']); // Table of kdHydrophobicity


  var hydro = {
    ILE: 4.5,
    VAL: 4.2,
    LEU: 3.8,
    PHE: 2.8,
    CYS: 2.5,
    MET: 1.9,
    ALA: 1.8,
    GLY: -0.4,
    THR: -0.7,
    SER: -0.8,
    TRP: -0.9,
    TYR: -1.3,
    PRO: -1.6,
    HIS: -3.2,
    GLU: -3.5,
    GLN: -3.5,
    ASP: -3.5,
    ASN: -3.5,
    LYS: -3.9,
    ARG: -4.5
  };

  function _addParam(param, list) {
    var keys = Object.keys(list);

    for (var i = 0, n = keys.length; i < n; ++i) {
      var key = keys[i];
      var value = list[key];
      ResidueType.StandardTypes[key][param] = value;
    }
  }

  _addParam('hydrophobicity', hydro);

  /**
   * Residues in chain are either amino acid either nucleic acid (and water)
   * There might be some modified/mutated residues, which type could not be determined by their name (nucleic or amino); In this
   * case firstly program definites the chain type (by well-known residues) and then definites modified/mutated residues
   */

  var ChainType = {
    UNKNOWN: 0,
    PROTEIN: 1,
    NUCLEIC: 2
  };
  /**
   * Residue chain.
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   * @param {string} name - One character identifier (usually space, A-Z, 0-9, or a-z).
   *
   * @exports Chain
   * @constructor
   */

  var Chain = /*#__PURE__*/function () {
    function Chain(complex, name) {
      classCallCheck(this, Chain);

      this._complex = complex;
      this._name = name;
      this._mask = 1 | 0;
      this._index = -1;
      this._residues = [];
      this.minSequence = Number.POSITIVE_INFINITY;
      this.maxSequence = Number.NEGATIVE_INFINITY;
    }

    createClass(Chain, [{
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "_determineType",
      value: function _determineType() {
        var residues = this._residues;
        var _ResidueType$Flags = ResidueType.Flags,
            PROTEIN = _ResidueType$Flags.PROTEIN,
            NUCLEIC = _ResidueType$Flags.NUCLEIC;
        this.type = ChainType.UNKNOWN;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var flags = residues[i]._type.flags;

          if ((flags & NUCLEIC) !== 0) {
            this.type = ChainType.NUCLEIC;
            break;
          } else if ((flags & PROTEIN) !== 0) {
            this.type = ChainType.PROTEIN;
            break;
          }
        }
      }
      /**
       * Finds thre residue with specified sequence number and inserion code
       * @param {Number} seqNum sequence number
       * @param {string} iCode insertion code
       * @returns {*} Residue or null if not found
       */

    }, {
      key: "findResidue",
      value: function findResidue(seqNum, iCode) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i];

          if (res._sequence === seqNum && res._icode === iCode) {
            return [res, i];
          }
        }

        return null;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._determineType();

        var residues = this._residues;
        var prev = null;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var next = i + 1 < n ? residues[i + 1] : null;
          var curr = residues[i]; // TODO: skip invalid residues

          {
              // eslint-disable-line no-constant-condition
              curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);

              prev = curr;
            }
        } // fix very first wing


        if (residues.length > 1 && residues[1]._wingVector) {
          var p = residues[1]._wingVector;
          residues[0]._wingVector = new THREE.Vector3(p.x, p.y, p.z);
        } else if (residues.length > 0) {
          residues[0]._wingVector = new THREE.Vector3(1, 0, 0);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var residues = this._residues;
        var prev = null;
        var prevData = null;
        var frameRes = frameData._residues;
        var n = residues.length;

        function getAtomPos(atom) {
          return frameData.getAtomPos(atom.index);
        }

        for (var i = 0; i < n; ++i) {
          var curr = residues[i];
          var currData = frameRes[curr._index];
          var nextRes = i + 1 < n ? residues[i + 1] : null;

          curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos);

          prev = curr;
          prevData = currData;
        }

        frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new THREE.Vector3(1, 0, 0);
      }
      /**
       * Create a new residue.
       *
       * @param {string} name - Residue name.
       * @param {number} sequence - Residue sequence number.
       * @param {string} iCode - Insertion code.
       * @returns {Residue} - Newly created residue instance.
       */

    }, {
      key: "addResidue",
      value: function addResidue(name, sequence, iCode) {
        var type = this._complex.getResidueType(name);

        if (type === null) {
          type = this._complex.addResidueType(name);
        }

        var residue = new Residue(this, type, sequence, iCode);

        this._complex.addResidue(residue);

        this._residues.push(residue);

        if (type.flags & (ResidueType.Flags.NUCLEIC | ResidueType.Flags.PROTEIN)) {
          if (this.maxSequence < sequence) {
            this.maxSequence = sequence;
          }

          if (this.minSequence > sequence) {
            this.minSequence = sequence;
          }
        }

        return residue;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this._mask = mask;
      }
    }]);

    return Chain;
  }();

  var _StructuralElement$ge;
  /** An element of protein secondary structure. */

  var StructuralElement = /*#__PURE__*/function () {
    /**
     * Create a secondary structural element of the specified type.
     *
     * @param {StructuralElement.Type} type Secondary structure type.
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     */
    function StructuralElement(type, init, term) {
      classCallCheck(this, StructuralElement);

      /**
       * Secondary structure type.
       * @type {StructuralElement.Type}
       */
      this.type = type;
      /**
       * Generic secondary structure type.
       * @type {StructuralElement.Generic}
       */

      this.generic = StructuralElement.genericByType[this.type] || 'loop';
      /**
       * Initial residue.
       * @type Residue
       */

      this.init = init;
      /**
       * Terminal residue.
       * @type Residue
       */

      this.term = term;
    }
    /**
     * An internal method for making a final pass over the complex to set all required references.
     *
     * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
     * Just copying it as-is right now and hoping for the best.
     *
     * @param {object} serialAtomMap A dictionary of atoms
     * @param {object} residueHash A dictionary of hashed residues to check.
     * @param {Complex} complex The molecular complex this element belongs to.
     */


    createClass(StructuralElement, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        if (this.init instanceof Residue && this.term instanceof Residue) {
          return;
        } // Link all intermediate residues to this structural element


        var start = complex.splitUnifiedSerial(this.init);
        var end = complex.splitUnifiedSerial(this.term);

        for (var chainId = start.chain; chainId <= end.chain; chainId++) {
          for (var serialId = start.serial; serialId <= end.serial; serialId++) {
            for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
              var hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);

              if (residueHash[hashCode]) {
                residueHash[hashCode]._secondary = this;
              }
            }
          }
        } // Replace unfined serials by objects


        this.init = residueHash[this.init];
        this.term = residueHash[this.term];
      }
    }]);

    return StructuralElement;
  }();
  /**
   * Specific type of a secondary structural element.
   * @enum {string}
   * @see StructuralElement.Generic
   */


  StructuralElement.Type = {
    /** A strand of a [beta-sheet](https://en.wikipedia.org/wiki/Beta_sheet). */
    STRAND: 'E',

    /** An isolated beta-bridge (too small for a beta-sheet). */
    BRIDGE: 'B',

    /** A [3/10 helix](https://en.wikipedia.org/wiki/310_helix) (hydrogen bonding is 3 residues apart). */
    HELIX_310: 'G',

    /** An [alpha-helix](https://en.wikipedia.org/wiki/Alpha_helix) (hydrogen bonding is 4 residues apart). */
    HELIX_ALPHA: 'H',

    /** A [pi-helix](https://en.wikipedia.org/wiki/Pi_helix) (hydrogen bonding is 5 residues apart). */
    HELIX_PI: 'I',

    /** A generic helix of unspecified bonding distance. */
    HELIX: 'X',

    /** An isolated 3/10-like helical turn. */
    TURN_310: '3',

    /** An isolated alpha-like helical turn. */
    TURN_ALPHA: '4',

    /** An isolated pi-like helical turn. */
    TURN_PI: '5',

    /** An isolated helical [turn](https://en.wikipedia.org/wiki/Turn_(biochemistry)) of unspecified bonding distance. */
    TURN: 'T',

    /** A bend (a region of high curvature). */
    BEND: 'S',

    /** Just a protein section with no particular conformation. */
    COIL: 'C'
  };
  /**
   * Generic type of a secondary structural element.
   * @enum {string}
   * @see StructuralElement.Type
   */

  StructuralElement.Generic = {
    /** A strand of a sheet. */
    STRAND: 'strand',

    /** A helix. */
    HELIX: 'helix',

    /** Just a protein section with no particular conformation. */
    LOOP: 'loop'
  };
  var StructuralElementType = StructuralElement.Type;
  var StructuralElementGeneric = StructuralElement.Generic;
  /**
   * A mapping from specific types to generic ones.
   * @type {Object<StructuralElement.Type, StructuralElement.Generic>}
   */

  StructuralElement.genericByType = (_StructuralElement$ge = {}, defineProperty(_StructuralElement$ge, StructuralElementType.STRAND, StructuralElementGeneric.STRAND), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_310, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_ALPHA, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_PI, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX, StructuralElementGeneric.HELIX), _StructuralElement$ge);

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var StructuralElementType$1 = StructuralElement.Type;
  var typeByPDBHelixClass = {
    1: StructuralElementType$1.HELIX_ALPHA,
    3: StructuralElementType$1.HELIX_PI,
    5: StructuralElementType$1.HELIX_310
  };
  /**
   * Helical secondary structure of a protein.
   * @extends StructuralElement
   */

  var Helix = /*#__PURE__*/function (_StructuralElement) {
    inherits(Helix, _StructuralElement);

    var _super = _createSuper$2(Helix);

    /**
     * Create a helix.
     *
     * @param {number} helixClass A helix class according to the
     *   [PDB Format](http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX).
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     * @param {number} serial Serial number of the helix (see PDB Format).
     * @param {string} name Helix identifier (see PDB Format).
     * @param {string} comment Comment about this helix (see PDB Format).
     * @param {number} length Length of this helix, in residues (see PDB Format).
     */
    function Helix(helixClass, init, term, serial, name, comment, length) {
      var _this;

      classCallCheck(this, Helix);

      _this = _super.call(this, typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX, init, term);
      /**
       * Serial number of the helix (see PDB Format).
       * @type {number}
       */

      _this.serial = serial;
      /**
       * Helix identifier (see PDB Format).
       * @type {string}
       */

      _this.name = name;
      /**
       * Comment about this helix (see PDB Format).
       * @type {string}
       */

      _this.comment = comment;
      /**
       * Length of this helix, in residues (see PDB Format).
       * @type {number}
       */

      _this.length = length;
      return _this;
    }

    return Helix;
  }(StructuralElement);

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  var superPropBase = _superPropBase;

  var get = createCommonjsModule(function (module) {
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  module.exports = _get;
  });

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A single strand of a sheet in a protein secondary structure.
   * @extends StructuralElement
   */

  var Strand = /*#__PURE__*/function (_StructuralElement) {
    inherits(Strand, _StructuralElement);

    var _super = _createSuper$3(Strand);

    /**
     * Create a strand.
     *
     * @param {Sheet} sheet Parent sheet this strand belongs to.
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     * @param {number} sense Sense of strand with respect to previous strand in the sheet.
     *   - 0 if the first strand,
     *   - 1 if parallel, and
     *   - -1 if anti-parallel.
     * @param {Atom} atomCur Atom in current strand (see PDB Format).
     * @param {Atom} atomPrev Atom in previous strand (see PDB Format).
     */
    function Strand(sheet, init, term, sense, atomCur, atomPrev) {
      var _this;

      classCallCheck(this, Strand);

      _this = _super.call(this, StructuralElement.Type.STRAND, init, term);
      /**
       * Parent sheet this strand belongs to.
       * @type {Sheet}
       */

      _this.sheet = sheet;
      /**
       * Sense of strand with respect to previous strand in the sheet.
       * - 0 if the first strand,
       * - 1 if parallel, and
       * - -1 if anti-parallel.
       * @type {number}
       */

      _this.sense = sense;
      /**
       * Atom in current strand (see PDB Format).
       * @type {Atom}
       */

      _this.atomCur = atomCur;
      /**
       * Atom in previous strand (see PDB Format).
       * @type {Atom}
       */

      _this.atomPrev = atomPrev;
      return _this;
    }
    /**
     * An internal method for making a final pass over the complex to set all required references.
     *
     * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
     * Just copying it as-is right now and hoping for the best.
     *
     * @param {object} serialAtomMap A dictionary of atoms
     * @param {object} residueHash A dictionary of hashed residues to check.
     * @param {Complex} complex The molecular complex this element belongs to.
     *
     * @override
     */


    createClass(Strand, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        get(getPrototypeOf(Strand.prototype), "_finalize", this).call(this, serialAtomMap, residueHash, complex);

        var as = this.atomCur;

        if (as !== null && !Number.isNaN(as)) {
          this.atomCur = serialAtomMap[as];
        }

        as = this.atomPrev;

        if (as !== null && !Number.isNaN(as)) {
          this.atomPrev = serialAtomMap[as];
        }
      }
    }]);

    return Strand;
  }(StructuralElement);

  /**
   * Sheet secondary structure of a protein.
   *
   * @param {string} name -
   * @param {number} width -
   *
   * @exports Sheet
   * @constructor
   */

  var Sheet = /*#__PURE__*/function () {
    function Sheet(name, width) {
      classCallCheck(this, Sheet);

      this._name = name;
      this._width = width;
      this._strands = [];
    } // Getters and setters


    createClass(Sheet, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this._width;
      }
    }, {
      key: "addStrand",
      value: function addStrand(strand) {
        this._strands.push(strand);

        this._width = this._strands.length;
      }
    }, {
      key: "addEmptyStrand",
      value: function addEmptyStrand() {
        this._strands.push(new Strand(null, null, null, null, null, null));
      }
    }, {
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        var s = this._strands;

        for (var i = 0, n = s.length; i < n; ++i) {
          s[i]._finalize(serialAtomMap, residueHash, complex);
        }

        if (!this._width) {
          this._width = s.length;
        }

        if (s.length !== this._width) {
          throw new Error("Sheet ".concat(this._name, " is inconsistent."));
        }
      }
    }]);

    return Sheet;
  }();

  /**
   * Atom measurements.
   *
   * @param {string} id              - SGroup id
   * @param {string} name            - Name of the group
   * @param {THREE.Vector3} position - Registered coordinates
   * @param {array} atoms            - Atoms group consists of
   * @param {object} saveNode        - XML node from file for saving
   *
   * @exports SGroup
   * @constructor
   */

  var SGroup = /*#__PURE__*/function () {
    function SGroup(id, name, position, atoms, saveNode) {
      classCallCheck(this, SGroup);

      this._id = id;
      this._name = name;
      this._position = position || new THREE.Vector3();
      this._atoms = atoms || [];
      this._charge = 0; // default group charge

      this._repeat = 1; // how many times group repeated: always > 0

      this._center = null;
      this.xmlNodeRef = saveNode || null;
    }
    /**
     * Get atom full name.
     * @returns {string} Atom full name.
     */


    createClass(SGroup, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this._position;
      }
    }, {
      key: "getCentralPoint",
      value: function getCentralPoint() {
        return this._center;
      }
    }, {
      key: "_rebuildSGroupOnAtomChange",
      value: function _rebuildSGroupOnAtomChange() {
        var nLimon = 100000000;

        if (this._center === null) {
          return; // nothing to do if we are not relative
        }

        var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);

        for (var j = 0, n = this._atoms.length; j < n; j++) {
          var aPos = this._atoms[j].position;
          bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
          bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
        }

        this._center.addVectors(bLow, bHight);

        this._center.multiplyScalar(0.5);
      }
    }]);

    return SGroup;
  }();

  /* eslint-disable */
  // DO NOT EDIT! Automatically generated from .jison

  /* parser generated by jison 0.4.18 */

  /*
    Returns a Parser object of the following structure:

    Parser: {
      yy: {}
    }

    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),

          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },

          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }


    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }


    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
      }

      return _o;
    },
        $V0 = [1, 4],
        $V1 = [1, 5],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 8],
        $V5 = [1, 9],
        $V6 = [1, 11],
        $V7 = [1, 12],
        $V8 = [5, 7, 8, 11],
        $V9 = [1, 17],
        $Va = [1, 22],
        $Vb = [1, 20],
        $Vc = [1, 21],
        $Vd = [5, 7, 8, 11, 19];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "Program": 3,
        "Expression": 4,
        "EOF": 5,
        "Selector": 6,
        "OR": 7,
        "AND": 8,
        "NOT": 9,
        "(": 10,
        ")": 11,
        "SELECTOR": 12,
        "NAMED_SELECTOR": 13,
        "SELECTOR_RANGED": 14,
        "RangeList": 15,
        "SELECTOR_NAMED": 16,
        "NameList": 17,
        "Range": 18,
        ",": 19,
        "NUMBER": 20,
        ":": 21,
        "Name": 22,
        "IDENTIFIER": 23,
        "STRING": 24,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        7: "OR",
        8: "AND",
        9: "NOT",
        10: "(",
        11: ")",
        12: "SELECTOR",
        13: "NAMED_SELECTOR",
        14: "SELECTOR_RANGED",
        16: "SELECTOR_NAMED",
        19: ",",
        20: "NUMBER",
        21: ":",
        23: "IDENTIFIER",
        24: "STRING"
      },
      productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return $$[$0 - 1];

          case 3:
            this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
            break;

          case 4:
            this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
            break;

          case 5:
            this.$ = yy.keyword('not')($$[$0]);
            break;

          case 6:
            this.$ = $$[$0 - 1];
            break;

          case 7:
            this.$ = yy.keyword($$[$0])();
            break;

          case 8:
            this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
            break;

          case 9:
          case 10:
            this.$ = yy.keyword($$[$0 - 1])($$[$0]);
            break;

          case 11:
            this.$ = new yy.RangeList($$[$0]);
            break;

          case 12:
          case 16:
            this.$ = $$[$0 - 2].append($$[$0]);
            break;

          case 13:
            this.$ = new yy.Range(Number($$[$0]));
            break;

          case 14:
            this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
            break;

          case 15:
            this.$ = new yy.ValueList($$[$0]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        1: [3]
      }, {
        5: [1, 10],
        7: $V6,
        8: $V7
      }, o($V8, [2, 2]), {
        4: 13,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 14,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 7]), o($V8, [2, 8]), {
        15: 15,
        18: 16,
        20: $V9
      }, {
        17: 18,
        20: $Va,
        22: 19,
        23: $Vb,
        24: $Vc
      }, {
        1: [2, 1]
      }, {
        4: 23,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 24,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 5]), {
        7: $V6,
        8: $V7,
        11: [1, 25]
      }, o($V8, [2, 9], {
        19: [1, 26]
      }), o($Vd, [2, 11]), o($Vd, [2, 13], {
        21: [1, 27]
      }), o($V8, [2, 10], {
        19: [1, 28]
      }), o($Vd, [2, 15]), o($Vd, [2, 17]), o($Vd, [2, 18]), o($Vd, [2, 19]), o([5, 7, 11], [2, 3], {
        8: $V7
      }), o($V8, [2, 4]), o($V8, [2, 6]), {
        18: 29,
        20: $V9
      }, {
        20: [1, 30]
      }, {
        20: $Va,
        22: 31,
        23: $Vb,
        24: $Vc
      }, o($Vd, [2, 12]), o($Vd, [2, 14]), o($Vd, [2, 16])],
      defaultActions: {
        10: [2, 1]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            tstack = [],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = tstack.pop() || lexer.lex() || EOF;

          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token;
              token = tstack.pop();
            }

            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          "case-insensitive": true
        },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

          switch ($avoiding_name_collisions) {
            case 0:
              /* skip whitespace */
              break;

            case 1:
              return 20;

            case 2:
              return 7;

            case 3:
              return 8;

            case 4:
              return 9;

            case 5:
              return 12;

            case 6:
              return 16;

            case 7:
              return 14;

            case 8:
              return 10;

            case 9:
              return 11;

            case 10:
              return 19;

            case 11:
              return 21;

            case 12:
              return '<=';

            case 13:
              return '>=';

            case 14:
              return '<';

            case 15:
              return '>';

            case 16:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
              return 24;

            case 17:
              return 13;

            case 18:
              return 23;

            case 19:
              return 5;

            case 20:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  var SelectionParser = {
    parser: parser
  };
  var SelectionParser_1 = SelectionParser.parser;

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var Range = /*#__PURE__*/function () {
    function Range(min, max) {
      classCallCheck(this, Range);

      this.min = min;
      this.max = typeof max === 'undefined' ? min : max;
    }

    createClass(Range, [{
      key: "includes",
      value: function includes(value) {
        return this.min <= value && value <= this.max;
      }
    }, {
      key: "toString",
      value: function toString() {
        var min = this.min,
            max = this.max;
        return min === max ? String(min) : [min, max].join(':');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.min, this.max];
      }
    }]);

    return Range;
  }(); // ////////////////////////////////////////////////////////////////////////////


  var List = /*#__PURE__*/function () {
    function List(arg) {
      classCallCheck(this, List);

      if (arg instanceof this.constructor) {
        return arg;
      }

      if (arg instanceof Array) {
        this._values = arg.slice(0);
      } else if (arg) {
        this._values = [arg];
      } else {
        this._values = [];
      }
    }

    createClass(List, [{
      key: "append",
      value: function append(value) {
        var values = this._values;
        values[values.length] = value;
        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        var values = this._values;
        var index = values.indexOf(value);

        if (index >= 0) {
          values.splice(index, 1);
        }

        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._values.join(',');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var values = this._values;
        var result = [];

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];
          result[i] = value.toJSON ? value.toJSON() : value;
        }

        return result;
      }
    }]);

    return List;
  }(); //----------------------------------------------------------------------------


  var RangeList = /*#__PURE__*/function (_List) {
    inherits(RangeList, _List);

    var _super = _createSuper$4(RangeList);

    function RangeList() {
      classCallCheck(this, RangeList);

      return _super.apply(this, arguments);
    }

    createClass(RangeList, [{
      key: "includes",
      value: function includes(value) {
        var list = this._values;

        for (var i = 0, n = list.length; i < n; ++i) {
          if (list[i].includes(value)) {
            return true;
          }
        }

        return false;
      }
    }]);

    return RangeList;
  }(List); //----------------------------------------------------------------------------


  var valuesArray = [];

  var ValueList = /*#__PURE__*/function (_List2) {
    inherits(ValueList, _List2);

    var _super2 = _createSuper$4(ValueList);

    function ValueList(arg, upperOnly) {
      var _this;

      classCallCheck(this, ValueList);

      var list = _this = _super2.call(this, arg);

      if (upperOnly) {
        _this.upperOnly = true;
        var values = list._values;

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];

          if (typeof value === 'string') {
            values[i] = value.toUpperCase();
          }
        }
      } else {
        _this.upperOnly = false;
      }

      return possibleConstructorReturn(_this, list);
    }

    createClass(ValueList, [{
      key: "includes",
      value: function includes(value) {
        // we do not convert to upper case here for perfomance reasons
        // if list is upper case only, value must be converted before it is sent up to  here
        return this._values.indexOf(value) !== -1;
      }
    }, {
      key: "toString",
      value: function toString() {
        // Quote values that are not correct identifiers
        var values = this._values;
        valuesArray.length = 0;

        for (var i = 0, n = values.length; i < n; ++i) {
          valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]));
        }

        return valuesArray.join(',');
      }
    }, {
      key: "_validate",
      value: function _validate(value) {
        return this.upperOnly && typeof value === 'string' ? value.toUpperCase() : value;
      }
    }, {
      key: "append",
      value: function append(value) {
        get(getPrototypeOf(ValueList.prototype), "append", this).call(this, this._validate(value));

        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        get(getPrototypeOf(ValueList.prototype), "remove", this).call(this, this._validate(value));

        return this;
      }
    }]);

    return ValueList;
  }(List);

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /** Base class for atom selectors. */

  var Selector = /*#__PURE__*/function () {
    function Selector() {
      classCallCheck(this, Selector);
    }

    createClass(Selector, [{
      key: "toString",
      value: function toString() {
        return this.keyword;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name];
      }
    }]);

    return Selector;
  }();

  Selector.prototype.name = 'Error';
  Selector.prototype.keyword = 'error';
  /** Base class for list-based atom selectors. */

  var ListSelector = /*#__PURE__*/function (_Selector) {
    inherits(ListSelector, _Selector);

    var _super = _createSuper$5(ListSelector);

    function ListSelector(list) {
      var _this;

      classCallCheck(this, ListSelector);

      _this = _super.call(this);
      _this.list = list;
      return _this;
    }

    createClass(ListSelector, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.keyword, " ").concat(this.list);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.list.toJSON()];
      }
    }]);

    return ListSelector;
  }(Selector);

  var RangeListSelector = /*#__PURE__*/function (_ListSelector) {
    inherits(RangeListSelector, _ListSelector);

    var _super2 = _createSuper$5(RangeListSelector);

    function RangeListSelector(arg) {
      classCallCheck(this, RangeListSelector);

      return _super2.call(this, new RangeList(arg));
    }

    return RangeListSelector;
  }(ListSelector);

  var ValueListSelector = /*#__PURE__*/function (_ListSelector2) {
    inherits(ValueListSelector, _ListSelector2);

    var _super3 = _createSuper$5(ValueListSelector);

    function ValueListSelector(arg, caseSensitive) {
      classCallCheck(this, ValueListSelector);

      return _super3.call(this, new ValueList(arg, !caseSensitive));
    }

    return ValueListSelector;
  }(ListSelector);

  var NoneSelector = /*#__PURE__*/function (_Selector2) {
    inherits(NoneSelector, _Selector2);

    var _super4 = _createSuper$5(NoneSelector);

    function NoneSelector() {
      classCallCheck(this, NoneSelector);

      return _super4.apply(this, arguments);
    }

    createClass(NoneSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return false;
      }
    }]);

    return NoneSelector;
  }(Selector);

  NoneSelector.prototype.name = 'None';
  NoneSelector.prototype.keyword = 'none';

  var AllSelector = /*#__PURE__*/function (_Selector3) {
    inherits(AllSelector, _Selector3);

    var _super5 = _createSuper$5(AllSelector);

    function AllSelector() {
      classCallCheck(this, AllSelector);

      return _super5.apply(this, arguments);
    }

    createClass(AllSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return true;
      }
    }]);

    return AllSelector;
  }(Selector);

  AllSelector.prototype.name = 'All';
  AllSelector.prototype.keyword = 'all';

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  // Operators
  //----------------------------------------------------------------------------

  var none = new NoneSelector();

  var PrefixOperator = /*#__PURE__*/function (_Selector) {
    inherits(PrefixOperator, _Selector);

    var _super = _createSuper$6(PrefixOperator);

    function PrefixOperator(rhs) {
      var _this;

      classCallCheck(this, PrefixOperator);

      _this = _super.call(this);
      _this.rhs = rhs || none;
      return _this;
    }

    createClass(PrefixOperator, [{
      key: "toString",
      value: function toString() {
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.rhs.toJSON()];
      }
    }]);

    return PrefixOperator;
  }(Selector);

  PrefixOperator.prototype.priority = 1;

  var InfixOperator = /*#__PURE__*/function (_Selector2) {
    inherits(InfixOperator, _Selector2);

    var _super2 = _createSuper$6(InfixOperator);

    function InfixOperator(lhs, rhs) {
      var _this2;

      classCallCheck(this, InfixOperator);

      _this2 = _super2.call(this);
      _this2.lhs = lhs || none;
      _this2.rhs = rhs || none;
      return _this2;
    }

    createClass(InfixOperator, [{
      key: "toString",
      value: function toString() {
        var lhs = this.lhs.priority && this.lhs.priority > this.priority ? "(".concat(this.lhs, ")") : this.lhs;
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(lhs, " ").concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
      }
    }]);

    return InfixOperator;
  }(Selector);

  InfixOperator.prototype.priority = 1000;

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var keywords = {}; //----------------------------------------------------------------------------
  // Named selectors
  //----------------------------------------------------------------------------

  function defineSelector(name, SelectorClass) {
    var keyword = name.toLowerCase();
    SelectorClass.prototype.keyword = keyword;
    SelectorClass.prototype.name = name;

    var factory = function factory() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return construct(SelectorClass, args);
    };

    factory.SelectorClass = SelectorClass;
    keywords[keyword] = factory;
    return SelectorClass;
  }

  defineSelector('Serial', /*#__PURE__*/function (_RangeListSelector) {
    inherits(SerialSelector, _RangeListSelector);

    var _super = _createSuper$7(SerialSelector);

    function SerialSelector() {
      classCallCheck(this, SerialSelector);

      return _super.apply(this, arguments);
    }

    createClass(SerialSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.serial);
      }
    }]);

    return SerialSelector;
  }(RangeListSelector));
  defineSelector('Name', /*#__PURE__*/function (_ValueListSelector) {
    inherits(NameSelector, _ValueListSelector);

    var _super2 = _createSuper$7(NameSelector);

    function NameSelector() {
      classCallCheck(this, NameSelector);

      return _super2.apply(this, arguments);
    }

    createClass(NameSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.name);
      }
    }]);

    return NameSelector;
  }(ValueListSelector));
  defineSelector('AltLoc', /*#__PURE__*/function (_ValueListSelector2) {
    inherits(AltLocSelector, _ValueListSelector2);

    var _super3 = _createSuper$7(AltLocSelector);

    function AltLocSelector() {
      classCallCheck(this, AltLocSelector);

      return _super3.apply(this, arguments);
    }

    createClass(AltLocSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(String.fromCharCode(atom.location));
      }
    }]);

    return AltLocSelector;
  }(ValueListSelector));
  defineSelector('Elem', /*#__PURE__*/function (_ValueListSelector3) {
    inherits(ElemSelector, _ValueListSelector3);

    var _super4 = _createSuper$7(ElemSelector);

    function ElemSelector() {
      classCallCheck(this, ElemSelector);

      return _super4.apply(this, arguments);
    }

    createClass(ElemSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.element.name);
      }
    }]);

    return ElemSelector;
  }(ValueListSelector));
  defineSelector('Residue', /*#__PURE__*/function (_ValueListSelector4) {
    inherits(ResidueSelector, _ValueListSelector4);

    var _super5 = _createSuper$7(ResidueSelector);

    function ResidueSelector() {
      classCallCheck(this, ResidueSelector);

      return _super5.apply(this, arguments);
    }

    createClass(ResidueSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._type._name);
      }
    }]);

    return ResidueSelector;
  }(ValueListSelector));
  defineSelector('Sequence', /*#__PURE__*/function (_RangeListSelector2) {
    inherits(SequenceSelector, _RangeListSelector2);

    var _super6 = _createSuper$7(SequenceSelector);

    function SequenceSelector() {
      classCallCheck(this, SequenceSelector);

      return _super6.apply(this, arguments);
    }

    createClass(SequenceSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._sequence);
      }
    }]);

    return SequenceSelector;
  }(RangeListSelector));
  defineSelector('ICode', /*#__PURE__*/function (_ValueListSelector5) {
    inherits(ICodeSelector, _ValueListSelector5);

    var _super7 = _createSuper$7(ICodeSelector);

    function ICodeSelector(arg) {
      classCallCheck(this, ICodeSelector);

      return _super7.call(this, arg, true);
    }

    createClass(ICodeSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._icode);
      }
    }]);

    return ICodeSelector;
  }(ValueListSelector));
  defineSelector('ResIdx', /*#__PURE__*/function (_RangeListSelector3) {
    inherits(ResIdxSelector, _RangeListSelector3);

    var _super8 = _createSuper$7(ResIdxSelector);

    function ResIdxSelector() {
      classCallCheck(this, ResIdxSelector);

      return _super8.apply(this, arguments);
    }

    createClass(ResIdxSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._index);
      }
    }]);

    return ResIdxSelector;
  }(RangeListSelector));
  defineSelector('Chain', /*#__PURE__*/function (_ValueListSelector6) {
    inherits(ChainSelector, _ValueListSelector6);

    var _super9 = _createSuper$7(ChainSelector);

    function ChainSelector(arg) {
      classCallCheck(this, ChainSelector);

      return _super9.call(this, arg, true);
    }

    createClass(ChainSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._chain._name);
      }
    }]);

    return ChainSelector;
  }(ValueListSelector));
  defineSelector('Hetatm', /*#__PURE__*/function (_Selector) {
    inherits(HetatmSelector, _Selector);

    var _super10 = _createSuper$7(HetatmSelector);

    function HetatmSelector() {
      classCallCheck(this, HetatmSelector);

      return _super10.apply(this, arguments);
    }

    createClass(HetatmSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return atom.het;
      }
    }]);

    return HetatmSelector;
  }(Selector));
  defineSelector('PolarH', /*#__PURE__*/function (_Selector2) {
    inherits(PolarHSelector, _Selector2);

    var _super11 = _createSuper$7(PolarHSelector);

    function PolarHSelector() {
      classCallCheck(this, PolarHSelector);

      return _super11.apply(this, arguments);
    }

    createClass(PolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.HYDROGEN;
      }
    }]);

    return PolarHSelector;
  }(Selector));
  defineSelector('NonPolarH', /*#__PURE__*/function (_Selector3) {
    inherits(NonPolarHSelector, _Selector3);

    var _super12 = _createSuper$7(NonPolarHSelector);

    function NonPolarHSelector() {
      classCallCheck(this, NonPolarHSelector);

      return _super12.apply(this, arguments);
    }

    createClass(NonPolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.NONPOLARH;
      }
    }]);

    return NonPolarHSelector;
  }(Selector));
  defineSelector('All', AllSelector);
  defineSelector('None', NoneSelector);
  var NULL_SELECTOR = keywords.none(); //----------------------------------------------------------------------------
  // Named operators
  //----------------------------------------------------------------------------

  function defineOperator(name, priority, OperatorClass) {
    OperatorClass.prototype.priority = priority;
    return defineSelector(name, OperatorClass);
  }

  defineOperator('Not', 1, /*#__PURE__*/function (_PrefixOperator) {
    inherits(NotOperator, _PrefixOperator);

    var _super13 = _createSuper$7(NotOperator);

    function NotOperator() {
      classCallCheck(this, NotOperator);

      return _super13.apply(this, arguments);
    }

    createClass(NotOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return !this.rhs.includesAtom(atom);
      }
    }]);

    return NotOperator;
  }(PrefixOperator));
  defineOperator('And', 2, /*#__PURE__*/function (_InfixOperator) {
    inherits(AndOperator, _InfixOperator);

    var _super14 = _createSuper$7(AndOperator);

    function AndOperator() {
      classCallCheck(this, AndOperator);

      return _super14.apply(this, arguments);
    }

    createClass(AndOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
      }
    }]);

    return AndOperator;
  }(InfixOperator));
  defineOperator('Or', 3, /*#__PURE__*/function (_InfixOperator2) {
    inherits(OrOperator, _InfixOperator2);

    var _super15 = _createSuper$7(OrOperator);

    function OrOperator() {
      classCallCheck(this, OrOperator);

      return _super15.apply(this, arguments);
    }

    createClass(OrOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
      }
    }]);

    return OrOperator;
  }(InfixOperator)); //----------------------------------------------------------------------------
  // Flag selectors
  //----------------------------------------------------------------------------

  function byResidueTypeFlag(flag, name) {
    return defineSelector(name, /*#__PURE__*/function (_Selector4) {
      inherits(_class, _Selector4);

      var _super16 = _createSuper$7(_class);

      function _class() {
        classCallCheck(this, _class);

        return _super16.apply(this, arguments);
      }

      createClass(_class, [{
        key: "includesAtom",
        value: function includesAtom(atom) {
          return (atom.residue._type.flags & flag) !== 0;
        }
      }]);

      return _class;
    }(Selector));
  }

  byResidueTypeFlag(ResidueType.Flags.PROTEIN, 'Protein');
  byResidueTypeFlag(ResidueType.Flags.BASIC, 'Basic');
  byResidueTypeFlag(ResidueType.Flags.ACIDIC, 'Acidic');
  byResidueTypeFlag(ResidueType.Flags.BASIC | ResidueType.Flags.ACIDIC, 'Charged');
  byResidueTypeFlag(ResidueType.Flags.POLAR, 'Polar');
  byResidueTypeFlag(ResidueType.Flags.NONPOLAR, 'NonPolar');
  byResidueTypeFlag(ResidueType.Flags.AROMATIC, 'Aromatic');
  byResidueTypeFlag(ResidueType.Flags.NUCLEIC, 'Nucleic');
  byResidueTypeFlag(ResidueType.Flags.PURINE, 'Purine');
  byResidueTypeFlag(ResidueType.Flags.PYRIMIDINE, 'Pyrimidine');
  byResidueTypeFlag(ResidueType.Flags.WATER, 'Water'); //----------------------------------------------------------------------------

  var selectors = Object.create(keywords);
  selectors.Selector = Selector;
  selectors.RangeListSelector = RangeListSelector;
  selectors.ValueListSelector = ValueListSelector;
  selectors.Range = Range;
  selectors.RangeList = RangeList;
  selectors.ValueList = ValueList;
  selectors.PrefixOperator = PrefixOperator;
  selectors.InfixOperator = InfixOperator;
  selectors.Context = Object.create({});

  selectors.GetSelector = function (key) {
    if (!selectors.Context.hasOwnProperty(key)) {
      var exc = {
        message: "selector ".concat(key, " is not registered")
      };
      throw exc;
    }

    return selectors.Context[key] || NULL_SELECTOR;
  };

  selectors.ClearContext = function () {
    Object.keys(selectors.Context).forEach(function (k) {
      delete selectors.Context[k];
    });
  };

  selectors.keyword = function (key) {
    return keywords[key.toLowerCase()] || keywords.none;
  };

  selectors.parse = function (str) {
    var res = {};

    try {
      res.selector = SelectionParser_1.parse(str);
    } catch (e) {
      res.selector = NULL_SELECTOR;
      res.error = e.message;
    }

    return res;
  };

  SelectionParser_1.yy = selectors;
  SelectionParser_1.yy.parseError = SelectionParser_1.parseError; // workaround for incorrect JISON parser generator for AMD module

  /**
   * Basic biological unit class.
   *
   * @exports BiologicalUnit
   * @constructor
   */

  var BiologicalUnit = /*#__PURE__*/function () {
    function BiologicalUnit(complex) {
      classCallCheck(this, BiologicalUnit);

      this._complex = complex;
      this._selector = selectors.keyword('All')();
      this._boundaries = {
        boundingBox: new THREE.Box3(),
        boundingSphere: new THREE.Sphere()
      };
    }

    createClass(BiologicalUnit, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        var atoms = this._complex._atoms;
        var n = atoms.length;
        var selector = this._selector;
        var boundingBox = this._boundaries.boundingBox;
        boundingBox.makeEmpty();

        if (n === 1) {
          boundingBox.expandByPoint(atoms[0].position);
          var bbc = new THREE.Vector3();
          boundingBox.getCenter(bbc);
          var s = 2 * atoms[0].element.radius;
          boundingBox.setFromCenterAndSize(bbc, new THREE.Vector3(s, s, s));
        } else {
          for (var i = 0; i < n; ++i) {
            if (selector.includesAtom(atoms[i])) {
              boundingBox.expandByPoint(atoms[i].position);
            }
          }
        } // Build bounding sphere


        var radiusSquared = 0.0;
        var center = new THREE.Vector3();
        boundingBox.getCenter(center);

        if (n === 1) {
          this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
        } else {
          for (var _i = 0; _i < n; ++_i) {
            if (!selector.includesAtom(atoms[_i])) {
              continue;
            }

            var pos = atoms[_i].position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return [];
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this._selector;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._boundaries;
      }
    }, {
      key: "finalize",
      value: function finalize() {}
    }]);

    return BiologicalUnit;
  }();

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Biological assembly.
   *
   * @exports Assembly
   * @constructor
   */

  var Assembly = /*#__PURE__*/function (_BiologicalUnit) {
    inherits(Assembly, _BiologicalUnit);

    var _super = _createSuper$8(Assembly);

    function Assembly(complex) {
      var _this;

      classCallCheck(this, Assembly);

      _this = _super.call(this, complex);
      _this.chains = [];
      _this.matrices = [];
      return _this;
    }

    createClass(Assembly, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        get(getPrototypeOf(Assembly.prototype), "computeBoundaries", this).call(this); // fix up the boundaries


        var matrices = this.matrices;
        var oldCenter = this._boundaries.boundingSphere.center;
        var oldRad = this._boundaries.boundingSphere.radius;
        var boundingBox = this._boundaries.boundingBox = new THREE.Box3();
        boundingBox.makeEmpty();

        for (var i = 0, n = matrices.length; i < n; ++i) {
          boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i]));
        }

        var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
        var center = new THREE.Vector3();
        boundingBox.getCenter(center);
        this._boundaries.boundingSphere = new THREE.Sphere().set(center, newRad);
        boundingBox.max.addScalar(oldRad);
        boundingBox.min.subScalar(oldRad);
      }
      /**
       * Mark a chain as belonging to this biological assembly.
       * @param {string} chain - chain identifier, usually a single letter
       */

    }, {
      key: "addChain",
      value: function addChain(chain) {
        this.chains[this.chains.length] = chain;
      }
      /**
       * Add a transformation matrix.
       * @param {THREE.Matrix4} matrix - transformation matrix
       */

    }, {
      key: "addMatrix",
      value: function addMatrix(matrix) {
        this.matrices[this.matrices.length] = matrix;
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.matrices;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this.chains.length > 0) {
          this._selector = selectors.keyword('Chain')(this.chains);
        } else {
          this._selector = selectors.keyword('None')();
        }
      }
    }]);

    return Assembly;
  }(BiologicalUnit);

  /**
   * This class represents connected component as a part of a complex.
   * WARNING! The whole component entity is build under the assumption that residues
   * are placed in the chains and complex in ascending order of indices
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   *
   * @exports Component
   * @constructor
   */
  var Component = /*#__PURE__*/function () {
    function Component(complex) {
      classCallCheck(this, Component);

      this._complex = complex;
      this._index = -1;
      this._residueIndices = [];
      this._cycles = [];
      this._subDivs = [];
      this._residueCount = 0;
    }

    createClass(Component, [{
      key: "getResidues",
      value: function getResidues() {
        return this._complex._residues;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residueCount;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._complex._residues;
        var resIdc = this._residueIndices;

        for (var idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
          for (var idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
            process(residues[idx]);
          }
        }
      }
    }, {
      key: "setSubDivs",
      value: function setSubDivs(subDivs) {
        this._subDivs = subDivs;
        var curr = 0;
        var resIdc = [];
        var resCnt = 0;

        for (var i = 0, n = subDivs.length; i < n; ++i) {
          if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
            var start = subDivs[curr].start;
            var end = subDivs[i].end;
            resIdc[resIdc.length] = {
              start: start,
              end: end
            };
            resCnt += end - start + 1;
            curr = i + 1;
          }
        }

        this._residueIndices = resIdc;
        this._residueCount = resCnt;
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._complex._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var bond = bonds[i];

          if (bond._left.residue._component === this) {
            process(bond);
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        this.forEachCycle(function (cycle) {
          cycle.update();
        });
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        this.forEachResidue(function (residue) {
          residue.forEachAtom(process);
        });
      }
    }, {
      key: "addCycle",
      value: function addCycle(cycle) {
        this._cycles.push(cycle);
      }
    }, {
      key: "forEachCycle",
      value: function forEachCycle(process) {
        var cycles = this._cycles;

        for (var i = 0, n = cycles.length; i < n; ++i) {
          process(cycles[i]);
        }
      }
    }, {
      key: "markResidues",
      value: function markResidues() {
        var self = this;
        self.forEachResidue(function (residue) {
          residue._component = self;
        });
      }
    }, {
      key: "_forEachSubChain",
      value: function _forEachSubChain(mask, process) {
        var residues = this._complex._residues;
        var subs = this._subDivs;

        for (var i = 0, n = subs.length; i < n; ++i) {
          for (var idx = subs[i].start, last = subs[i].end; idx <= last; ++idx) {
            var currRes = residues[idx];

            if (mask & currRes._mask && currRes._isValid) {
              var end = idx + 1;

              for (; end <= last; ++end) {
                var endRes = residues[end];

                if (!(mask & endRes._mask && endRes._isValid)) {
                  break;
                }
              }

              process(i, idx, end - 1);
              idx = end;
            }
          }
        }
      }
    }, {
      key: "getMaskedSequences",
      value: function getMaskedSequences(mask) {
        var subs = [];
        var idx = 0;

        this._forEachSubChain(mask, function (_subIdx, start, end) {
          subs[idx++] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }, {
      key: "getMaskedSubdivSequences",
      value: function getMaskedSubdivSequences(mask) {
        var subs = [];
        var currIdx = -1;
        var lastSubIdx = -1;
        var subDivs = this._subDivs;

        this._forEachSubChain(mask, function (subIdx, start, end) {
          if (lastSubIdx !== subIdx) {
            ++currIdx;
            subs[currIdx] = {
              arr: [],
              boundaries: subDivs[subIdx]
            };
            lastSubIdx = subIdx;
          }

          subs[currIdx].arr[subs[currIdx].arr.length] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }]);

    return Component;
  }();

  var cMaxPairsForHashCode = 32;
  var cHashTableSize = 1024 * 1024;
  var cNumbersPerPair = 4;
  var cMaxNeighbours = 14;
  var cInvalidVal = -1; // 89237 is a large simple number, can be used for pseudo random hash code create

  var cBigPrime = 89237;

  var AtomPairs = /*#__PURE__*/function () {
    function AtomPairs(maxPairsEstimate) {
      classCallCheck(this, AtomPairs);

      this.numPairs = 0;
      this.numMaxPairs = maxPairsEstimate;
      this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);

      for (var i = 0; i < maxPairsEstimate * cNumbersPerPair; i++) {
        this.intBuffer[i] = cInvalidVal;
      }

      this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);

      for (var _i = 0; _i < cHashTableSize * cMaxPairsForHashCode; _i++) {
        this.hashBuffer[_i] = cInvalidVal;
      }
    }
    /**
     * Destroy all pairs memory
     */


    createClass(AtomPairs, [{
      key: "destroy",
      value: function destroy() {
        this.intBuffer = null;
        this.hashBuffer = null;
      }
      /**
       * Add pair of atoms to collection
       * @param {number} indexA - Index of the 1st vertex.
       * @param {number} indexB - Index of the 2nd vertex.
       */

    }, {
      key: "addPair",
      value: function addPair(indexA, indexB) {
        var ia = indexA < indexB ? indexA : indexB;
        var ib = indexA > indexB ? indexA : indexB;
        var codeToAdd = ia + (ib << cMaxNeighbours);
        var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
        var j = hashCode * cMaxPairsForHashCode;
        var apI = 0;

        for (; apI < cMaxPairsForHashCode; apI++) {
          var code = this.hashBuffer[j + apI];

          if (code === cInvalidVal) {
            break;
          }

          if (code === codeToAdd) {
            return false;
          }
        } // add this new hash code


        if (apI >= cMaxPairsForHashCode) {
          throw new Error('addPair: increase cMaxPairsForHashCode');
        }

        this.hashBuffer[j + apI] = codeToAdd; // actually add

        if (this.numPairs >= this.numMaxPairs) {
          throw new Error('addPair: increase num pairs');
        }

        j = this.numPairs * cNumbersPerPair;
        this.intBuffer[j] = ia;
        this.intBuffer[j + 1] = ib;
        this.intBuffer[j + 2] = codeToAdd;
        this.numPairs++;
        return true;
      }
    }]);

    return AtomPairs;
  }();

  var cEstBondsMultiplier = 4;
  var cSpaceCode = 32;
  var cBondTolerance = 0.45;
  var cEpsilon = 0.001;
  /**
   * Get radius used for building bonds.
   *
   * @param {Atom} atom - Atom object.
   * @returns {number} special value for bonding radius for this atom
   */

  function _getBondingRadius(atom) {
    var element = atom.element;

    if (element) {
      return element.radiusBonding;
    }

    throw new Error('_getBondingRadius: Logic error.');
  }

  function _isAtomEligible(atom) {
    // build for all non-hetatm and for hetatm without bonds
    return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
  }
  /**
   * Bond between atoms.
   *
   * @param {Complex} complex molecular complex

   * @exports AutoBond
   * @constructor
   */


  var AutoBond = /*#__PURE__*/function () {
    function AutoBond(complex) {
      classCallCheck(this, AutoBond);

      this._complex = complex;
      this._maxRad = 1.8;

      var bBox = this._complex.getDefaultBoundaries().boundingBox;

      this._vBoxMin = bBox.min.clone();
      this._vBoxMax = bBox.max.clone();
      this._pairCollection = null;
    }
    /**
     * Add existing pairs of connectors (from pdb file after its reading)
     * @returns {number} 0
     */


    createClass(AutoBond, [{
      key: "_addExistingPairs",
      value: function _addExistingPairs() {
        var atoms = this._complex.getAtoms();

        var numAtoms = atoms.length;
        var aInd = 0;
        var collection = this._pairCollection;

        for (; aInd < numAtoms; aInd++) {
          var bonds = atoms[aInd].bonds;
          var numBondsForAtom = bonds.length;

          for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
            var bond = bonds[bInd];
            var indTo = bond._left.index;

            if (indTo === aInd) {
              collection.addPair(aInd, bond._right.index);
            }
          } // for (b) all bonds in atom

        } // for (a)


        return 0;
      }
    }, {
      key: "_findPairs",
      value: function _findPairs() {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var atoms = this._complex._atoms;
        var atomsNum = atoms.length;
        var self = this;
        var rA;
        var isHydrogenA;
        var posA;
        var locationA;
        var atomA;

        var processAtom = function processAtom(atomB) {
          if (isHydrogenA && atomB.isHydrogen()) {
            return;
          }

          var locationB = atomB.location;

          if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
            return;
          }

          var dist2 = posA.distanceToSquared(atomB.position);
          var rB = atomB.element.radiusBonding;
          var maxAcceptable =  rA + rB + cBondTolerance ;

          if (dist2 > maxAcceptable * maxAcceptable) {
            return;
          }

          if (dist2 < cEpsilon) {
            return;
          }

          self._pairCollection.addPair(atomA.index, atomB.index);
        };

        for (var i = 0; i < atomsNum; ++i) {
          atomA = atoms[i];

          if (!_isAtomEligible(atomA)) {
            continue;
          }

          rA = atomA.element.radiusBonding;
          isHydrogenA = atomA.isHydrogen();
          posA = atomA.position;
          locationA = atomA.location;
          vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
        }
      }
    }, {
      key: "_addPairs",
      value: function _addPairs() {
        var atoms = this._complex._atoms;

        for (var i = 0, k = 0; i < this._pairCollection.numPairs; i++, k += 4) {
          var iA = this._pairCollection.intBuffer[k];
          var iB = this._pairCollection.intBuffer[k + 1];

          this._addPair(atoms[iA], atoms[iB]);
        }
      }
    }, {
      key: "_addPair",
      value: function _addPair(atomA, atomB) {
        var bondsA = atomA.bonds;
        var indexA = atomA.index;
        var indexB = atomB.index;

        for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
          var bond = bondsA[j];

          if (bond._left.index === indexB || bond._right.index === indexB) {
            return;
          }
        }

        var left = indexA < indexB ? atomA : atomB;
        var right = indexA < indexB ? atomB : atomA;

        var newBond = this._complex.addBond(left, right, 0, Bond.BondType.UNKNOWN, false);

        bondsA.push(newBond);
        atomB.bonds.push(newBond);
      }
    }, {
      key: "build",
      value: function build() {

        this._buildInner();
      }
    }, {
      key: "_buildInner",
      value: function _buildInner() {
        var atoms = this._complex._atoms;

        if (atoms.length < 2) {
          return;
        }

        if (atoms[0].index < 0) {
          throw new Error('AutoBond: Atoms in complex were not indexed.');
        }

        this._calcBoundingBox();

        this._pairCollection = new AtomPairs(atoms.length * cEstBondsMultiplier);

        this._addExistingPairs();

        this._findPairs();

        this._addPairs();
      }
    }, {
      key: "_calcBoundingBox",
      value: function _calcBoundingBox() {
        var atoms = this._complex._atoms;
        var nAtoms = atoms.length;

        var maxRad = _getBondingRadius(atoms[0]);

        for (var i = 1; i < nAtoms; ++i) {
          maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
        }

        this._vBoxMax.addScalar(maxRad);

        this._vBoxMin.addScalar(-maxRad);

        this._maxRad = maxRad * 1.2;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._pairCollection) {
          this._pairCollection.destroy();
        }
      }
    }]);

    return AutoBond;
  }();

  var cCrossThresh = 0.1;
  var cAromaticType = Bond.BondType.AROMATIC;
  var cAromaticAtoms = [Element.ByName.C.number, Element.ByName.N.number // Element.ByName.O.number,
  // Element.ByName.S.number,
  ];
  /** Conditions for bonds:
     *   - Cross product with each subsequent bond to add is collinear and point to the same direction
     *   - Each pair of a adjacent bonds belong to not more than one cycle
     *   - If there is more than one candidates we try them in ascending order of angle values
     */

  var _coDirVectors = function () {
    var v1Tmp = new THREE.Vector3();
    var v2Tmp = new THREE.Vector3();
    var cp = new THREE.Vector3();
    return function (v1, v2) {
      v1Tmp.copy(v1).normalize();
      v2Tmp.copy(v2).normalize();
      cp.crossVectors(v1Tmp, v2Tmp);

      if (cp.length() > cCrossThresh) {
        return false;
      } // zero vector in out terms must be collinear to any


      return v1Tmp.dot(v2Tmp) >= 0;
    };
  }();

  function _insertAscending(arr, val) {
    var idx = 0;

    while (idx < arr.length && arr[idx] < val) {
      ++idx;
    }

    arr.splice(idx, 0, val);
  }

  function _anotherAtom(bond, currAtom) {
    return bond._left === currAtom ? bond._right : bond._left;
  }

  function _cosBetween(v1, v2) {
    var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
    return THREE.MathUtils.clamp(theta, -1, 1);
  }

  function _markAromatic(bond) {
    bond._type = cAromaticType;
  }

  var Cycle = /*#__PURE__*/function () {
    function Cycle(atomsList) {
      classCallCheck(this, Cycle);

      this.atoms = atomsList;
      this.update();
    }

    createClass(Cycle, [{
      key: "update",
      value: function update() {
        var atoms = this.atoms;
        var center = new THREE.Vector3();
        var nA = atoms.length;

        for (var j = 0; j < nA; ++j) {
          center.add(atoms[j].position);
        }

        center.multiplyScalar(1.0 / nA);
        this.center = center;
        this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var atoms = this.atoms;
        var nA = atoms.length;
        var currAtom = atoms[0];
        var nextAtom;

        function checkBond(bond) {
          if (bond._left === nextAtom || bond._right === nextAtom) {
            process(bond);
          }
        }

        for (var i = 0; i < nA; ++i) {
          nextAtom = atoms[(i + 1) % nA];
          currAtom.forEachBond(checkBond);
          currAtom = nextAtom;
        }
      }
    }]);

    return Cycle;
  }();

  function _isAromatic(bond) {
    return bond._type === cAromaticType;
  }

  function _isPossibleAromatic(bond) {
    if (bond.type === cAromaticType) {
      return true;
    }

    var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
    var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
    return rightIdx !== -1 && leftIdx !== -1;
  }

  function _checkCycleSimple(cycle) {
    return cycle.length > 3;
  }

  function _checkCycleComplex(cycle) {
    console.assert(cycle.length > 2);
    return true;
  }

  var AromaticLoopsMarker = /*#__PURE__*/function () {
    function AromaticLoopsMarker(complex) {
      classCallCheck(this, AromaticLoopsMarker);

      this._complex = complex;
      var bondsData = new Array(complex._bonds.length);
      var bondMarks = new Array(complex._bonds.length);

      for (var i = 0, n = bondsData.length; i < n; ++i) {
        bondsData[i] = [];
        bondMarks[i] = false;
      }

      this._bondsData = bondsData;
      this._bondMarks = bondMarks;

      this._resetCycles();
    }

    createClass(AromaticLoopsMarker, [{
      key: "_resetCycles",
      value: function _resetCycles() {
        this._cycles = [];
        this._currIdx = -1;
      }
    }, {
      key: "_haveSameCycle",
      value: function _haveSameCycle(bondsData, bond1, bond2) {
        var arr1 = bondsData[bond1._index];
        var arr2 = bondsData[bond2._index];
        var n1 = arr1.length;
        var n2 = arr2.length;
        var i1 = 0;
        var i2 = 0;

        while (i1 < n1 && i2 < n2) {
          if (arr1[i1] === arr2[i2]) {
            return true;
          }

          if (arr1[i1] > arr2[i2]) {
            ++i2;
          } else {
            ++i1;
          }
        }

        return false;
      }
    }, {
      key: "_tryBond",
      value: function _tryBond(prevBond, currRight, currDir) {
        var bondsOrder = [];
        var bondsData = this._bondsData;

        var currLeft = _anotherAtom(prevBond, currRight);

        var currVec = currRight.position.clone().sub(currLeft.position);
        var startAtomRef = this._currStart;
        var self = this;
        var bondMarks = this._bondMarks;
        var checkAromatic = this._checkBond;
        bondMarks[prevBond._index] = true;
        checkAromatic = checkAromatic === undefined ? _isAromatic : checkAromatic;
        currRight.forEachBond(function (newBond) {
          if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
            return;
          }

          var anotherAtom = _anotherAtom(newBond, currRight);

          var anotherVec = anotherAtom.position.clone().sub(currRight.position);
          var val = anotherAtom === startAtomRef ? -2.0 : 1 - _cosBetween(currVec, anotherVec);
          var newDir = anotherVec.cross(currVec);

          if (!_coDirVectors(newDir, currDir)) {
            return;
          }

          var idx = 0;

          while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
            ++idx;
          }

          bondsOrder.splice(idx, 0, {
            bond: newBond,
            val: val,
            dir: newDir
          });
        });

        for (var i = 0, n = bondsOrder.length; i < n; ++i) {
          var bond = bondsOrder[i].bond;
          var newRight = bond._left === currRight ? bond._right : bond._left;

          if (newRight === startAtomRef) {
            ++this._currIdx;

            this._cycles.push([currRight]);

            bondMarks[prevBond._index] = false;
            return true;
          }

          if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
            _insertAscending(bondsData[bond._index], this._currIdx);

            this._cycles[this._currIdx].push(currRight);

            bondMarks[prevBond._index] = false;
            return true;
          }
        }

        bondMarks[prevBond._index] = false;
        return false;
      }
    }, {
      key: "_startCycle",
      value: function _startCycle(bond) {
        // start from left to right
        this._currStart = bond._left;

        if (this._tryBond(bond, bond._right, new THREE.Vector3())) {
          _insertAscending(this._bondsData[bond._index], this._currIdx);

          this._cycles[this._currIdx].push(bond._left);
        }
      }
    }, {
      key: "_findLoops",
      value: function _findLoops(checkBond, checkCycle) {
        this._checkBond = checkBond;
        var complex = this._complex;
        var self = this;
        complex.forEachComponent(function (component) {
          self._resetCycles();

          component.forEachBond(function (bond) {
            if (checkBond(bond)) {
              self._startCycle(bond);
            }
          });
          var cycles = self._cycles;

          for (var i = 0, n = cycles.length; i < n; ++i) {
            var cycle = cycles[i];

            if (!checkCycle(cycle)) {
              continue;
            }

            var newCycle = new Cycle(cycle);
            newCycle.forEachBond(_markAromatic);
            component.addCycle(newCycle);
          }
        });
      }
    }, {
      key: "markCycles",
      value: function markCycles() {
        this._findLoops(_isAromatic, _checkCycleSimple);
      }
    }, {
      key: "detectCycles",
      value: function detectCycles() {
        this._findLoops(_isPossibleAromatic, _checkCycleComplex);
      }
    }]);

    return AromaticLoopsMarker;
  }();

  /**
   * Calculate min & max radius of a sphere slice between zMin & zMax
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {number} zMin - lower bound of the slice
   * @param {number} zMax - upper bound of the slice
   */

  function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
    var dzMin = zMin - center.z;
    var dzMax = zMax - center.z;
    var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0));
    var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0));
    var rMin = Math.min(rzMin, rzMax);
    var rMax;

    if (zMin <= center.z && zMax >= center.z) {
      // sphere's main diameter is inside slice
      rMax = radius;
    } else {
      rMax = Math.max(rzMin, rzMax);
    }

    return [rMin, rMax];
  }
  /**
   * Calculate min & max radius of a circle slice between yMin & yMax.
   *
   * To maintain analogy with _getSphereSliceRadiusRange we call radius what in fact is
   * half-width (along X axis) of the slice, i.e. 1D-sphere radius.
   *
   * @param {Vector3} center - center of the circle (z can be ignored)
   * @param {number} radius  - circle radius
   * @param {number} yMin - lower bound of the slice
   * @param {number} yMax - upper bound of the slice
   * @returns {Array} - array of two numbers (min & max radius, or half-width)
   */


  function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
    var dyMin = yMin - center.y;
    var dyMax = yMax - center.y;
    var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0));
    var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0));
    var rMin = Math.min(ryMin, ryMax);
    var rMax;

    if (yMin <= center.y && yMax >= center.y) {
      // slice's main diameter is inside slice
      rMax = radius;
    } else {
      rMax = Math.max(ryMin, ryMax);
    }

    return [rMin, rMax];
  }
  /**
   * VoxelWorld constructor
   *
   * @param {Box3} box - bounding box of the volume to be partitioned
   * @param {Vector3} vCellSizeHint - target voxel size (actual voxel size may differ from this)
   */


  var VoxelWorld = /*#__PURE__*/function () {
    function VoxelWorld(box, vCellSizeHint) {
      classCallCheck(this, VoxelWorld);

      this._box = box.clone();
      var size = new THREE.Vector3();
      box.getSize(size);
      this._count = size.clone().divide(vCellSizeHint).floor().max(new THREE.Vector3(1, 1, 1));
      this._last = this._count.clone().subScalar(1);
      this._cellSize = size.clone().divide(this._count);
      this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
      this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize)); // array of voxels, each element contains index of first atom in voxel

      var numVoxels = this._count.x * this._count.y * this._count.z;
      this._voxels = utils.allocateTyped(Int32Array, numVoxels);

      for (var i = 0; i < numVoxels; ++i) {
        this._voxels[i] = -1;
      } // array of atoms that stores multiple single-linked lists
      // two elements for each atom: Atom ref, index of next atom (in this array


      this._atoms = [];
    }
    /**
     * Add all atoms from a complex to voxel world
     *
     * @param {Complex} complex - complex
     */


    createClass(VoxelWorld, [{
      key: "addAtoms",
      value: function addAtoms(complex) {
        var self = this;
        var idx = this._atoms.length; // resize array of atoms

        this._atoms.length += 2 * complex.getAtomCount();
        complex.forEachAtom(function (atom) {
          // find which voxel contains this atom
          var voxelIdx = self._findVoxel(atom.position); // push current atom to the head of voxel's atom list


          self._atoms[idx] = atom;
          self._atoms[idx + 1] = self._voxels[voxelIdx];
          self._voxels[voxelIdx] = idx;
          idx += 2;
        });
      }
      /**
       * Get voxel that contains specified 3D point (we use clamp at the edges)
       *
       * @param {Vector3} point - a point in 3D
       * @returns {number} - index of voxel
       */

    }, {
      key: "_findVoxel",
      value: function _findVoxel(point) {
        var zero = VoxelWorld._zero;
        var voxel = VoxelWorld._voxel;
        voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
        return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
      }
      /**
       * Call a function for each atom in voxel
       *
       * @param {number} voxel - index of voxel
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "_forEachAtomInVoxel",
      value: function _forEachAtomInVoxel(voxel, process) {
        for (var i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
          process(this._atoms[i]);
        }
      }
      /**
       * Call a function for each voxel that is touched by given sphere. Callback also takes flag
       * isInside specifying whether voxel lies inside the sphere entirely.
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
       */

    }, {
      key: "_forEachVoxelWithinRadius",
      value: function _forEachVoxelWithinRadius(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange; // switch to a faster method unless cell size is much smaller than sphere radius

        if (radius / this._cellInnerR < 10) {
          this._forEachVoxelWithinRadiusSimple(center, radius, process);

          return;
        }

        var rRangeXY;
        var rRangeX;
        var xVal;
        var yVal;
        var zVal;
        var isInsideX;
        var isInsideY;
        var isInsideZ;
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
          rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
          yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
          yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
            rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
            xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
            xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
              process(x + this._count.x * (y + this._count.y * z), isInsideX && isInsideY && isInsideZ);
            }
          }
        }
      }
      /**
       * Call a function for each voxel that is touched by given sphere. Callback also takes flag
       * isInside specifying whether voxel lies inside the sphere entirely.
       * This is a version of method that doesn't try to "calculate" what voxels fall inside radius
       * but instead just checks all voxels inside sphere's bounding box. This should be faster
       * unless cell size is much smaller than sphere radius.
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
       */

    }, {
      key: "_forEachVoxelWithinRadiusSimple",
      value: function _forEachVoxelWithinRadiusSimple(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange;
        var vCenter = VoxelWorld._vCenter;
        var distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
        var distInside2 = -1.0;

        if (radius > this._cellOuterR) {
          distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
        } // calculate bounding box for the sphere


        xRange.set(center.x - radius, center.x + radius);
        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
        xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
        xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
        yRange.set(center.y - radius, center.y + radius);
        yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
        yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
        yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
        zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
        zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          var zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          vCenter.z = 0.5 * (zVal[0] + zVal[1]);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            var yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            vCenter.y = 0.5 * (yVal[0] + yVal[1]);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              var xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              vCenter.x = 0.5 * (xVal[0] + xVal[1]);
              var d2 = center.distanceToSquared(vCenter);

              if (d2 <= distTouch2) {
                process(x + this._count.x * (y + this._count.y * z), d2 <= distInside2);
              }
            }
          }
        }
      }
      /**
       * Call a function for each atom within given sphere
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinRadius",
      value: function forEachAtomWithinRadius(center, radius, process) {
        var self = this;
        var r2 = radius * radius;

        self._forEachVoxelWithinRadius(center, radius, function (voxel, isInside) {
          if (isInside) {
            self._forEachAtomInVoxel(voxel, process);
          } else {
            self._forEachAtomInVoxel(voxel, function (atom) {
              if (center.distanceToSquared(atom.position) <= r2) {
                process(atom);
              }
            });
          }
        });
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms defined by mask
       *
       * @param {Complex} complex - complex
       * @param {number} mask - bit mask
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinDistFromMasked",
      value: function forEachAtomWithinDistFromMasked(complex, mask, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if ((atom.mask & mask) !== 0) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms defined by selector
       *
       * @param {Complex} complex - complex
       * @param {number} selector - selector
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinDistFromSelected",
      value: function forEachAtomWithinDistFromSelected(complex, selector, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if (selector.includesAtom(atom)) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms
       *
       * @param {function} forEachAtom - enumerator of atoms in the group
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "_forEachAtomWithinDistFromGroup",
      value: function _forEachAtomWithinDistFromGroup(forEachAtom, dist, process) {
        var self = this;
        var r2 = dist * dist;
        var voxels = [];
        var atoms = [];
        var idx = 0; // build "within radius" atom list for each voxel

        forEachAtom(function (atom) {
          self._forEachVoxelWithinRadius(atom.position, dist, function (voxel, isInside) {
            if (isInside) {
              // this voxel is inside circle -- no check will be required
              voxels[voxel] = -1;
            } else if (typeof voxels[voxel] === 'undefined') {
              // this voxel isn't covered yet -- start building list of atoms
              atoms.push(atom);
              atoms.push(-1);
              voxels[voxel] = idx;
              idx += 2;
            } else if (voxels[voxel] !== -1) {
              // this voxel has a list of atoms required for distance check -- add atom to the list
              atoms.push(atom);
              atoms.push(voxels[voxel]);
              voxels[voxel] = idx;
              idx += 2;
            }
          });
        });
        var voxel;

        var processIfWithin = function processIfWithin(atom) {
          if (typeof voxels[voxel] === 'undefined') {
            return;
          }

          idx = voxels[voxel];

          if (idx === -1) {
            // this voxel is fully covered
            process(atom);
            return;
          } // check distance to each atom within radius from this voxel


          for (; idx >= 0; idx = atoms[idx + 1]) {
            if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
              process(atom);
              break;
            }
          }
        }; // for each marked voxel


        for (voxel in voxels) {
          if (voxels.hasOwnProperty(voxel)) {
            self._forEachAtomInVoxel(voxel, processIfWithin);
          }
        }
      }
    }]);

    return VoxelWorld;
  }();

  defineProperty(VoxelWorld, "_zero", new THREE.Vector3(0, 0, 0));

  defineProperty(VoxelWorld, "_voxel", new THREE.Vector3());

  defineProperty(VoxelWorld, "_xRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_yRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_zRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_vCenter", new THREE.Vector3());

  var MINIMAL_DISTANCE = 0.5;
  var MIN_HBOND_ENERGY = -9.9;
  var MAX_HBOND_ENERGY = -0.5;
  var COUPLING_CONSTANT = -27.888; // = -332 * 0.42 * 0.2

  var MAX_COUPLING_DISTANCE = 5.0; // how far is the closest atom of a potential partner residue from CA atom

  var MAX_RESIDUES_THRESHOLD = 1000;

  var HBondInfo = /*#__PURE__*/function () {
    function HBondInfo(complex) {
      classCallCheck(this, HBondInfo);

      this._complex = complex;
      this._hbonds = []; // array of bond info for each residue

      if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
        this._buildVW(); // optimized version using voxel grid

      } else {
        this._build(); // test all pairs of residues

      }
    }

    createClass(HBondInfo, [{
      key: "isBond",
      value: function isBond(from, to) {
        if (this._hbonds[from]) {
          var _this$_hbonds$from$ac = slicedToArray(this._hbonds[from].acceptor, 2),
              acc0 = _this$_hbonds$from$ac[0],
              acc1 = _this$_hbonds$from$ac[1];

          if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
            return true;
          }

          if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "_build",
      value: function _build() {
        var self = this;

        for (var i = 0; i < this._complex._residues.length - 1; ++i) {
          var ri = this._complex._residues[i];

          if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            continue;
          } // get predecessor in chain


          var preri = null;

          if (i > 0 && this._complex._residues[i - 1].getType().flags & ResidueType.Flags.PROTEIN && ri._sequence === this._complex._residues[i - 1]._sequence + 1) {
            preri = this._complex._residues[i - 1];
          }

          for (var j = i + 1; j < this._complex._residues.length; ++j) {
            var rj = this._complex._residues[j];

            if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
              continue;
            } // get predecessor in chain


            var prerj = null;

            if (this._complex._residues[j - 1].getType().flags & ResidueType.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
              prerj = this._complex._residues[j - 1];
            }

            self._calcHBondEnergy(preri, ri, rj);

            if (j !== i + 1) {
              self._calcHBondEnergy(prerj, rj, ri);
            }
          }
        }
      }
    }, {
      key: "_buildVW",
      value: function _buildVW() {
        var self = this;
        var residues = this._complex._residues;
        var ri;
        var preri;

        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var pairs = new AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);

        function processAtom(atom) {
          var rj = atom.residue;

          if (rj._index === ri._index) {
            return;
          }

          if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            return;
          }

          if (!pairs.addPair(ri._index, rj._index)) {
            // we've seen this pair
            return;
          } // get predecessor in chain


          var prerj = rj._index > 0 ? residues[rj._index - 1] : null;

          if (prerj && ((prerj.getType().flags & ResidueType.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
            prerj = null;
          }

          self._calcHBondEnergy(preri, ri, rj);

          if (rj._index !== ri._index + 1) {
            self._calcHBondEnergy(prerj, rj, ri);
          }
        }

        for (var i = 0; i < residues.length - 1; ++i) {
          ri = residues[i];

          if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            continue;
          } // get predecessor in chain


          preri = i > 0 ? residues[i - 1] : null;

          if (preri && ((preri.getType().flags & ResidueType.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
            preri = null;
          }

          vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_residueGetCO",
      value: function _residueGetCO(res) {
        var c = null;
        var o = null;
        res.forEachAtom(function (a) {
          if (a.name === 'C') {
            c = a.position;
          } else if (a.name === 'O') {
            o = a.position;
          }
        });
        return [c, o];
      } // TODO Support hydrogen defined in complex

    }, {
      key: "_residueGetNH",
      value: function _residueGetNH(prev, res) {
        var _this$_residueGetCO = this._residueGetCO(prev),
            _this$_residueGetCO2 = slicedToArray(_this$_residueGetCO, 2),
            c = _this$_residueGetCO2[0],
            o = _this$_residueGetCO2[1];

        var n;
        res.forEachAtom(function (a) {
          if (a.name === 'N') {
            n = a.position;
          }
        });

        if (c && o && n) {
          // calculate hydrogen position
          var h = c.clone();
          h.sub(o);
          h.multiplyScalar(1.0 / h.length());
          h.add(n);
          return [n, h];
        }

        return [null, null];
      }
    }, {
      key: "_calcHBondEnergy",
      value: function _calcHBondEnergy(predonor, donor, acceptor) {
        var result = 0;

        if (predonor === null) {
          return result;
        }

        if (donor.getType().getName() !== 'PRO') {
          var _this$_residueGetNH = this._residueGetNH(predonor, donor),
              _this$_residueGetNH2 = slicedToArray(_this$_residueGetNH, 2),
              n = _this$_residueGetNH2[0],
              h = _this$_residueGetNH2[1];

          var _this$_residueGetCO3 = this._residueGetCO(acceptor),
              _this$_residueGetCO4 = slicedToArray(_this$_residueGetCO3, 2),
              c = _this$_residueGetCO4[0],
              o = _this$_residueGetCO4[1];

          if (n === null || h === null || c === null || o === null) {
            return result;
          }

          var distanceHO = h.distanceTo(o);
          var distanceHC = h.distanceTo(c);
          var distanceNC = n.distanceTo(c);
          var distanceNO = n.distanceTo(o);

          if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
            result = MIN_HBOND_ENERGY;
          } else {
            result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
          } // DSSP compatibility mode:


          result = Math.round(result * 1000) / 1000;

          if (result < MIN_HBOND_ENERGY) {
            result = MIN_HBOND_ENERGY;
          }
        } // update donor


        if (typeof this._hbonds[donor._index] === 'undefined') {
          this._hbonds[donor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var donorInfo = this._hbonds[donor._index];

        if (donorInfo.acceptor.length < 2) {
          donorInfo.acceptor.push({
            residue: acceptor._index,
            energy: result
          });
        }

        if (donorInfo.acceptor.length > 1) {
          if (result < donorInfo.acceptor[0].energy) {
            donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
            donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
            donorInfo.acceptor[0].residue = acceptor._index;
            donorInfo.acceptor[0].energy = result;
          } else if (result < donorInfo.acceptor[1].energy) {
            donorInfo.acceptor[1].residue = acceptor._index;
            donorInfo.acceptor[1].energy = result;
          }
        } // update acceptor


        if (typeof this._hbonds[acceptor._index] === 'undefined') {
          this._hbonds[acceptor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var accInfo = this._hbonds[acceptor._index];

        if (accInfo.donor.length < 2) {
          accInfo.donor.push({
            residue: donor._index,
            energy: result
          });
        }

        if (accInfo.donor.length > 1) {
          if (result < accInfo.donor[0].energy) {
            accInfo.donor[1].residue = accInfo.donor[0].residue;
            accInfo.donor[1].energy = accInfo.donor[0].energy;
            accInfo.donor[0].residue = donor._index;
            accInfo.donor[0].energy = result;
          } else if (result < accInfo.donor[1].energy) {
            accInfo.donor[1].residue = donor._index;
            accInfo.donor[1].energy = result;
          }
        }

        return result;
      }
    }]);

    return HBondInfo;
  }();

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var BridgeType = Object.freeze({
    NO_BRIDGE: 0,
    PARALLEL: 1,
    ANTI_PARALLEL: 2
  });
  var HelixFlag = Object.freeze({
    START: 1,
    MIDDLE: 2,
    END: 3,
    START_AND_END: 4
  });
  var StructureType = Object.freeze({
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    TURN: 'T',
    BEND: 'S',
    LOOP: ' '
  });

  var SecondaryStructureMap = /*#__PURE__*/function () {
    function SecondaryStructureMap(complex) {
      classCallCheck(this, SecondaryStructureMap);

      this._complex = complex;

      this._build();
    }

    createClass(SecondaryStructureMap, [{
      key: "_build",
      value: function _build() {
        var self = this;
        this._hbonds = new HBondInfo(this._complex);
        this._ss = []; // DSSP map by residue
        // auxilliary data

        this._sheet = [];
        this._betaPartners = [];
        this._bend = [];

        for (var i = 0; i < this._complex.getResidues().length; ++i) {
          this._betaPartners[i] = [];
        }

        this._helixFlags = [];
        this._helixFlags[3] = [];
        this._helixFlags[4] = [];
        this._helixFlags[5] = []; // calculate peptide chain lengths

        this._chainLengths = [];

        for (var _i = 0; _i < this._complex._chains.length; ++_i) {
          var chain = this._complex._chains[_i].getResidues();

          var len = 0;

          for (; len < chain.length; ++len) {
            if ((chain[len].getType().flags & ResidueType.Flags.PROTEIN) === 0) {
              break;
            }
          }

          this._chainLengths[_i] = len;
        }

        this._buildBetaSheets();

        for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
          self._buildAlphaHelices(this._complex._chains[_i2].getResidues(), this._chainLengths[_i2], false);
        }
      }
    }, {
      key: "_buildAlphaHelices",
      value: function _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
        // Helix and Turn
        for (var stride = 3; stride <= 5; ++stride) {
          if (inResidues.length < stride) {
            break;
          }

          for (var i = 0; i + stride < chainLength; ++i) {
            if (this._hbonds.isBond(inResidues[i + stride]._index, inResidues[i]._index)
            /* && NoChainBreak(res[i], res[i + stride]) */
            ) {
                this._helixFlags[stride][inResidues[i + stride]._index] = HelixFlag.END;

                for (var j = i + 1; j < i + stride; ++j) {
                  if (typeof this._helixFlags[stride][inResidues[j]._index] === 'undefined') {
                    this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
                  }
                }

                if (this._helixFlags[stride][inResidues[i]._index] === HelixFlag.END) {
                  this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START_AND_END;
                } else {
                  this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START;
                }
              }
          }
        }

        for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
          var kappa = this._kappa(inResidues[_i3 - 2], inResidues[_i3], inResidues[_i3 + 2]);

          this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70;
        }

        for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
          if (this._isHelixStart(inResidues[_i4]._index, 4) && this._isHelixStart(inResidues[_i4 - 1]._index, 4)) {
            for (var _j = _i4; _j <= _i4 + 3; ++_j) {
              this._ss[inResidues[_j]._index] = StructureType.HELIX_ALPHA;
            }
          }
        }

        for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
          if (this._isHelixStart(inResidues[_i5]._index, 3) && this._isHelixStart(inResidues[_i5 - 1]._index, 3)) {
            var empty = true;

            for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
              empty = typeof this._ss[inResidues[_j2]._index] === 'undefined' || this._ss[inResidues[_j2]._index] === StructureType.HELIX_310;
            }

            if (empty) {
              for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
                this._ss[inResidues[_j3]._index] = StructureType.HELIX_310;
              }
            }
          }
        }

        for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
          if (this._isHelixStart(inResidues[_i6]._index, 5) && this._isHelixStart(inResidues[_i6 - 1]._index, 5)) {
            var _empty = true;

            for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
              _empty = typeof this._ss[inResidues[_j4]._index] === 'undefined' || this._ss[inResidues[_j4]._index] === StructureType.HELIX_PI || inPreferPiHelices && this._ss[inResidues[_j4]._index] === StructureType.HELIX_ALPHA;
            }

            if (_empty) {
              for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
                this._ss[inResidues[_j5]._index] = StructureType.HELIX_PI;
              }
            }
          }
        }

        for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
          if (typeof this._ss[inResidues[_i7]._index] === 'undefined') {
            var isTurn = false;

            for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
              for (var k = 1; k < _stride && !isTurn; ++k) {
                isTurn = _i7 >= k && this._isHelixStart(inResidues[_i7 - k]._index, _stride);
              }
            }

            if (isTurn) {
              this._ss[inResidues[_i7]._index] = StructureType.TURN;
            } else if (this._bend[inResidues[_i7]._index]) {
              this._ss[inResidues[_i7]._index] = StructureType.BEND;
            }
          }
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_cosinusAngle",
      value: function _cosinusAngle(p1, p2, p3, p4) {
        var v12 = p1.clone().sub(p2);
        var v34 = p3.clone().sub(p4);
        var result = 0;
        var x = v12.dot(v12) * v34.dot(v34);

        if (x > 0) {
          result = v12.dot(v34) / Math.sqrt(x);
        }

        return result;
      }
    }, {
      key: "_kappa",
      value: function _kappa(prevPrev, res, nextNext) {
        var curCA = this._residueGetCAlpha(res);

        var ppCA = this._residueGetCAlpha(prevPrev);

        var nnCA = this._residueGetCAlpha(nextNext);

        if (curCA === null || ppCA === null || nnCA === null) {
          return 180;
        }

        var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);

        var skap = Math.sqrt(1 - ckap * ckap);
        return Math.atan2(skap, ckap) * 180 / Math.PI;
      }
    }, {
      key: "_isHelixStart",
      value: function _isHelixStart(res, stride) {
        return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
      }
    }, {
      key: "_buildBetaSheets",
      value: function _buildBetaSheets() {
        // find bridges
        // check each chain against each other chain, and against itself
        var bridges = [];

        for (var a = 0; a < this._complex._chains.length; ++a) {
          var lenA = this._chainLengths[a];

          if (lenA <= 4) {
            continue;
          }

          var chainA = this._complex._chains[a].getResidues();

          for (var b = a; b < this._complex._chains.length; ++b) {
            var lenB = this._chainLengths[b];

            if (lenB <= 4) {
              continue;
            }

            var chainB = this._complex._chains[b].getResidues();

            for (var i = 1; i + 1 < lenA; ++i) {
              var ri = chainA[i];
              var j = 1;

              if (b === a) {
                j = i + 3; // check for self-bridges forward down the chain
              }

              for (; j + 1 < lenB; ++j) {
                var rj = chainB[j];

                var type = this._testBridge(chainA, i, chainB, j);

                if (type === BridgeType.NO_BRIDGE) {
                  continue;
                } // there is a bridge, try to attach it to previously found sequence


                var found = false;

                var _iterator = _createForOfIteratorHelper(bridges),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var bridge = _step.value;

                    if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                      continue;
                    }

                    if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.push(rj._index);
                      found = true;
                      break;
                    }

                    if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.unshift(rj._index);
                      found = true;
                      break;
                    }
                  } // this bridge cannot be attached anywhere, start a new sequence

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                if (!found) {
                  bridges.push({
                    type: type,
                    i: [ri._index],
                    chainI: ri.getChain()._index,
                    j: [rj._index],
                    chainJ: rj.getChain()._index
                  });
                }
              }
            }
          }
        } // extend ladders


        bridges.sort(function (a, b) {
          if (a.chainI < b.chainI || a.chainI === b.chainI && a.i[0] < b.i[0]) {
            return -1;
          }

          return 1;
        });

        for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
          for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
            var ibi = bridges[_i8].i[0];
            var iei = bridges[_i8].i[bridges[_i8].i.length - 1];
            var jbi = bridges[_i8].j[0];
            var jei = bridges[_i8].j[bridges[_i8].j.length - 1];
            var ibj = bridges[_j6].i[0];
            var iej = bridges[_j6].i[bridges[_j6].i.length - 1];
            var jbj = bridges[_j6].j[0];
            var jej = bridges[_j6].j[bridges[_j6].j.length - 1];

            if (bridges[_i8].type !== bridges[_j6].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
              continue;
            }

            var bulge = false;

            if (bridges[_i8].type === BridgeType.PARALLEL) {
              bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
            } else {
              bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
            }

            if (bulge) {
              bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i);

              if (bridges[_i8].type === BridgeType.PARALLEL) {
                bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j);
              } else {
                bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j);
              }

              bridges.splice(_j6--, 1);
            }
          }
        } // Sheet


        var ladderset = new Set();

        for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
          ladderset.add(bridges[_i9]);
        }

        var sheet = 1;
        var ladder = 0;

        while (ladderset.size > 0) {
          var _bridge = ladderset.values().next().value;
          ladderset["delete"](_bridge);
          var sheetset = new Set();
          sheetset.add(_bridge);
          var toMove = void 0;

          do {
            toMove = new Set();

            var _iterator2 = _createForOfIteratorHelper(sheetset.values()),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _a = _step2.value;

                var _iterator4 = _createForOfIteratorHelper(ladderset.values()),
                    _step4;

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _b = _step4.value;

                    if (this._areBridgesLinked(_a, _b)) {
                      toMove.add(_b);
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            var _iterator3 = _createForOfIteratorHelper(toMove.values()),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                _bridge = _step3.value;
                sheetset.add(_bridge);
                ladderset["delete"](_bridge);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } while (toMove.size > 0);

          var _iterator5 = _createForOfIteratorHelper(sheetset.values()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _bridge = _step5.value;
              _bridge.ladder = ladder;
              _bridge.sheet = sheet;
              _bridge.link = sheetset;
              ++ladder;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          ++sheet;
        }

        for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
          var _bridge2 = bridges[_i10]; // find out if any of the i and j set members already have
          // a bridge assigned, if so, we're assigning bridge 2

          var betai = 0;
          var betaj = 0;

          for (var l = 0; l < _bridge2.i.length; ++l) {
            if (this._betaPartners[_bridge2.i[l]][0]) {
              betai = 1;
              break;
            }
          }

          for (var _l = 0; _l < _bridge2.j.length; ++_l) {
            if (this._betaPartners[_bridge2.j[_l]][0]) {
              betaj = 1;
              break;
            }
          }

          var ss = StructureType.BRIDGE;

          if (_bridge2.i.length > 1) {
            ss = StructureType.STRAND;
          }

          if (_bridge2.type === BridgeType.PARALLEL) {
            var _j7 = 0;

            for (var k = 0; k < _bridge2.i.length; ++k) {
              this._betaPartners[_bridge2.i[k]][betai] = {
                residue: _bridge2.j[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }

            _j7 = 0;

            for (var _k = 0; _k < _bridge2.j.length; ++_k) {
              this._betaPartners[_bridge2.j[_k]][betaj] = {
                residue: _bridge2.i[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }
          } else {
            var _j8 = _bridge2.j.length - 1;

            for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
              this._betaPartners[_bridge2.i[_k2]][betai] = {
                residue: _bridge2.j[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }

            _j8 = _bridge2.i.length - 1;

            for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
              this._betaPartners[_bridge2.j[_k3]][betaj] = {
                residue: _bridge2.i[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }
          }

          for (var _k4 = _bridge2.i[0]; _k4 <= _bridge2.i[_bridge2.i.length - 1]; ++_k4) {
            if (this._ss[_k4] !== StructureType.STRAND) {
              this._ss[_k4] = ss;
              this._sheet[_k4] = _bridge2.sheet;
            }
          }

          for (var _k5 = _bridge2.j[0]; _k5 <= _bridge2.j[_bridge2.j.length - 1]; ++_k5) {
            if (this._ss[_k5] !== StructureType.STRAND) {
              this._ss[_k5] = ss;
              this._sheet[_k5] = _bridge2.sheet;
            }
          }
        }
      }
    }, {
      key: "_testBridge",
      value: function _testBridge(chainA, from, chainB, to) {
        var result = BridgeType.NO_BRIDGE;
        var a = chainA[from - 1]._index;
        var b = chainA[from]._index;
        var c = chainA[from + 1]._index;
        var d = chainB[to - 1]._index;
        var e = chainB[to]._index;
        var f = chainB[to + 1]._index;

        var isBond = this._hbonds.isBond.bind(this._hbonds);

        if (isBond(c, e) && isBond(e, a) || isBond(f, b) && isBond(b, d)) {
          result = BridgeType.PARALLEL;
        } else if (isBond(c, d) && isBond(f, a) || isBond(e, b) && isBond(b, e)) {
          result = BridgeType.ANTI_PARALLEL;
        }

        return result;
      } // return true if any of the residues in bridge a is identical to any of the residues in bridge b

    }, {
      key: "_areBridgesLinked",
      value: function _areBridgesLinked(a, b) {
        var ai = new Set(a.i);
        var aj = new Set(a.j);

        var _iterator6 = _createForOfIteratorHelper(b.i),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var i = _step6.value;

            if (ai.has(i) || aj.has(i)) {
              return true;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        var _iterator7 = _createForOfIteratorHelper(b.j),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _i11 = _step7.value;

            if (ai.has(_i11) || aj.has(_i11)) {
              return true;
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return false;
      }
    }, {
      key: "_hasChainBreak",
      value: function _hasChainBreak(from, to) {
        for (var i = from + 1; i <= to; ++i) {
          if (this._complex._residues[i]._sequence !== this._complex._residues[i - 1]._sequence + 1) {
            return true;
          }
        }

        return false;
      }
    }]);

    return SecondaryStructureMap;
  }();
  SecondaryStructureMap.StructureType = StructureType;

  var _helixClassMap, _loopMap;
  var VOXEL_SIZE = 5.0;
  var StructureType$1 = SecondaryStructureMap.StructureType;
  var StructuralElementType$2 = StructuralElement.Type; // see http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX

  var helixClassMap = (_helixClassMap = {}, defineProperty(_helixClassMap, StructureType$1.HELIX_ALPHA, 1), defineProperty(_helixClassMap, StructureType$1.HELIX_PI, 3), defineProperty(_helixClassMap, StructureType$1.HELIX_310, 5), _helixClassMap);
  var loopMap = (_loopMap = {}, defineProperty(_loopMap, StructureType$1.BRIDGE, StructuralElementType$2.BRIDGE), defineProperty(_loopMap, StructureType$1.TURN, StructuralElementType$2.TURN), defineProperty(_loopMap, StructureType$1.BEND, StructuralElementType$2.BEND), defineProperty(_loopMap, StructureType$1.LOOP, StructuralElementType$2.COIL), _loopMap);
  /**
   * The entire complex of the molecules under study.
   *
   * @exports Complex
   * @constructor
   */

  var Complex = /*#__PURE__*/function () {
    function Complex() {
      classCallCheck(this, Complex);

      this._chains = [];
      this._components = [];
      this._helices = [];
      this._sheets = [];
      this.structures = [];
      this._residueTypes = Object.create(ResidueType.StandardTypes);
      this._atoms = [];
      this._residues = [];
      this._bonds = [];
      this._sgroups = [];
      this._molecules = [];
      this._maskNeedsUpdate = false;
      this.metadata = {};
      this.symmetry = [];
      this.units = [new BiologicalUnit(this)];
      this._currentUnit = 0; // default biological unit is the asymmetric unit
    }

    createClass(Complex, [{
      key: "addAtom",
      value: function addAtom(atom) {
        var index = this._atoms.length;

        this._atoms.push(atom);

        return index;
      }
    }, {
      key: "addSheet",
      value: function addSheet(sheet) {
        var index = this._sheets.length;

        this._sheets.push(sheet);

        return index;
      }
    }, {
      key: "addHelix",
      value: function addHelix(helix) {
        var index = this._helices.length;

        this._helices.push(helix);

        return index;
      }
    }, {
      key: "getAtoms",
      value: function getAtoms() {
        return this._atoms;
      }
    }, {
      key: "getBonds",
      value: function getBonds() {
        return this._bonds;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "addResidue",
      value: function addResidue(residue) {
        var index = this._residues.length;

        this._residues.push(residue);

        return index;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        this.forEachChain(function (chain) {
          chain.updateToFrame(frameData);
        });
      }
    }, {
      key: "addResidueType",
      value: function addResidueType(resName) {
        var rt = this._residueTypes[resName] = new ResidueType(resName, 'Unknown', '');
        return rt;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "getSGroupCount",
      value: function getSGroupCount() {
        return this._sgroups.length;
      }
    }, {
      key: "getSGroups",
      value: function getSGroups() {
        return this._sgroups;
      }
      /*
         Extract atom by its fullname: #chainName#.#residueId#.#atomName#
         */

    }, {
      key: "getAtomByFullname",
      value: function getAtomByFullname(fullName) {
        var parts = fullName.split('.');

        if (parts.length !== 3) {
          return null;
        }

        var chainName = parts[0];
        var resId = parseInt(parts[1], 10);

        if (Number.isNaN(resId)) {
          return null;
        }

        var atomName = parts[2].toUpperCase();
        var currAtom = null;
        this.forEachChain(function (chain) {
          if (currAtom) {
            return;
          }

          if (chain._name.localeCompare(chainName) === 0) {
            chain.forEachResidue(function (residue) {
              if (currAtom) {
                return;
              }

              if (residue._sequence === resId) {
                residue.forEachAtom(function (atom) {
                  if (currAtom) {
                    return;
                  }

                  if (atomName.localeCompare(atom.name) === 0) {
                    currAtom = atom;
                  }
                });
              }
            });
          }
        });
        return currAtom;
      }
      /**
       * Create a new chain.
       *
       * @param {string} name - Chain name.
       * @returns {Chain} - Newly created chain.
       */

    }, {
      key: "addChain",
      value: function addChain(name) {
        var result = new Chain(this, name);

        this._chains.push(result);

        return result;
      }
    }, {
      key: "getChain",
      value: function getChain(name) {
        for (var i = 0, n = this._chains.length; i < n; ++i) {
          var chain = this._chains[i];

          if (chain.getName() === name) {
            return chain;
          }
        }

        return null;
      }
    }, {
      key: "getChainCount",
      value: function getChainCount() {
        return this._chains.length;
      }
    }, {
      key: "getMolecules",
      value: function getMolecules() {
        return this._molecules;
      }
    }, {
      key: "getMoleculeCount",
      value: function getMoleculeCount() {
        return this._molecules.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          process(atoms[i]);
        }
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "forEachChain",
      value: function forEachChain(process) {
        var chains = this._chains;

        for (var i = 0, n = chains.length; i < n; ++i) {
          process(chains[i]);
        }
      }
    }, {
      key: "forEachMolecule",
      value: function forEachMolecule(process) {
        var molecules = this._molecules;
        var n = molecules.length;

        for (var i = 0; i < n; ++i) {
          process(molecules[i]);
        }
      }
    }, {
      key: "forEachSGroup",
      value: function forEachSGroup(process) {
        var groups = this._sgroups;

        for (var i = 0, n = groups.length; i < n; ++i) {
          process(groups[i]);
        }
      }
    }, {
      key: "forEachComponent",
      value: function forEachComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "forEachVisibleComponent",
      value: function forEachVisibleComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "addBond",
      value: function addBond(left, right, order, type, fixed) {
        var bond = new Bond(left, right, order, type, fixed);

        this._bonds.push(bond);

        return bond;
      }
    }, {
      key: "getBondCount",
      value: function getBondCount() {
        return this._bonds.length;
      }
    }, {
      key: "getResidueType",
      value: function getResidueType(name) {
        return this._residueTypes[name] || null;
      }
    }, {
      key: "getUnifiedSerial",
      value: function getUnifiedSerial(chain, serial, iCode) {
        /* eslint-disable no-magic-numbers */
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        /* eslint-enable no-magic-numbers */

        return serial + iCode * maxSerial + chain * chainShift;
      }
    }, {
      key: "splitUnifiedSerial",
      value: function splitUnifiedSerial(uniSerial) {
        /* eslint-disable no-magic-numbers */
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        /* eslint-enable no-magic-numbers */

        var chainId = Math.floor(uniSerial / chainShift);
        var remnant = uniSerial - chainId * chainShift;
        var insCode = Math.floor(remnant / maxSerial);
        var ser = remnant - insCode * maxSerial;
        return {
          chain: chainId,
          serial: ser,
          iCode: insCode
        };
      }
    }, {
      key: "_fillCmpEdit",
      value: function _fillCmpEdit() {
        var self = this;
        var components = this._components;

        function addComp() {
          var comp = new Component(self);
          comp._index = components.length;
          components[comp._index] = comp;
          return comp;
        }

        this.forEachChain(function (chain) {
          var residues = chain._residues;
          var resCount = residues.length;

          if (resCount < 1) {
            return;
          }

          var comp = addComp();
          var currStart = residues[0]._index;

          for (var i = 0; i < resCount; ++i) {
            var currRes = residues[i];
            currRes._component = comp;
            var nextRes = i === resCount - 1 ? null : residues[i + 1];

            if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
              // the last condition is broken and incorrect
              // the refactoring of the Component is required in order to fix this issue
              comp.setSubDivs([{
                start: currStart,
                end: currRes._index
              }]);

              if (nextRes) {
                currStart = nextRes._index;
                comp = addComp();
              }
            }
          }
        });
      } // This function was added in the moment of despair
      // It was the dark times for miew

    }, {
      key: "_fillCmpNoedit",
      value: function _fillCmpNoedit() {
        var comp = new Component(this);
        comp._index = 0;
        var residues = this._residues;
        var resCount = residues.length;

        if (resCount === 0) {
          return;
        }

        var currSubDivs = [];
        var currStart = 0;

        for (var i = 0; i < resCount; ++i) {
          var currRes = residues[i];
          currRes._component = comp;
          var nextRes = i === resCount - 1 ? null : residues[i + 1];

          if (!nextRes || !currRes.isConnected(nextRes)) {
            // wrap up this interval
            currSubDivs[currSubDivs.length] = {
              start: currStart,
              end: i
            };

            if (nextRes) {
              currStart = i + 1;
            }
          }
        }

        comp.setSubDivs(currSubDivs);
        this._components[comp._index] = comp;
      }
      /**
       * Fill components information.
       * @param {boolean} enableEditing - Restructure Complex to enable per-component editing.
       */

    }, {
      key: "_fillComponents",
      value: function _fillComponents(enableEditing) {
        if (enableEditing) {
          this._fillCmpEdit();
        } else {
          this._fillCmpNoedit();
        }
      }
    }, {
      key: "getCurrentUnit",
      value: function getCurrentUnit() {
        return this._currentUnit;
      }
    }, {
      key: "getDefaultBoundaries",
      value: function getDefaultBoundaries() {
        return this.units[0].getBoundaries();
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this.units[this._currentUnit].getBoundaries();
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.units[this._currentUnit].getTransforms();
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this.units[this._currentUnit].getSelector();
      }
    }, {
      key: "resetCurrentUnit",
      value: function resetCurrentUnit() {
        this._currentUnit = 0;
        this.setCurrentUnit(1);
      }
    }, {
      key: "setCurrentUnit",
      value: function setCurrentUnit(newUnit) {
        if (newUnit !== null && newUnit !== undefined && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
          this._currentUnit = newUnit;
          return true;
        }

        return false;
      }
    }, {
      key: "_computeBounds",
      value: function _computeBounds() {
        var units = this.units;

        for (var i = 0, n = units.length; i < n; ++i) {
          units[i].computeBoundaries();
        }
      }
    }, {
      key: "onAtomPositionChanged",
      value: function onAtomPositionChanged() {
        this.forEachChain(function (a) {
          a._finalize();
        });
        this.forEachComponent(function (c) {
          c.update();
        }); // Update bounding sphere and box

        this._computeBounds();

        this._finalizeBonds();

        this.forEachSGroup(function (s) {
          s._rebuildSGroupOnAtomChange();
        });
      }
    }, {
      key: "update",
      value: function update() {
        if (this._maskNeedsUpdate) {
          this.updateStructuresMask();
          this._maskNeedsUpdate = false;
        }
      }
    }, {
      key: "_finalizeBonds",
      value: function _finalizeBonds() {
        var bonds = this.getBonds();
        var n = bonds.length;

        for (var i = 0; i < n; ++i) {
          bonds[i]._index = i;
        }
      }
      /**
       * Finalizes complex's inner data(i.e. after parsing).
       * @param {objects} opts - Build bonds automatically.
       * @param {boolean} opts.needAutoBonding     - Build bonds automatically.
       * @param {boolean} opts.detectAromaticLoops - Find/mark aromatic loops.
       * @param {boolean} opts.enableEditing       - Restructure Complex to enable per-component editing.
       * @param {Array<Atom>} [opts.serialAtomMap] - Array of atoms ordered by their serials.
       */

    }, {
      key: "finalize",
      value: function finalize(opts) {
        opts = opts || {}; // Put bonds into atoms

        var bonds = this._bonds;
        var i;
        var n; // remove invalid bonds

        for (i = bonds.length - 1; i >= 0; i--) {
          var bond = bonds[i];

          if (bond._left === null || bond._right === null) {
            bonds.splice(i, 1);
          } else {
            bond._left.bonds.push(bond);

            bond._right.bonds.push(bond);
          }
        }

        var residues = this._residues;

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._finalize();
        }

        this.forEachChain(function (a) {
          a._finalize();
        }); // WARNING! this MUST be done BEFORE computeBounds is called

        var units = this.units;

        for (i = 0, n = units.length; i < n; ++i) {
          units[i].finalize();
        } // try setting first biomolecule by defaults


        this.setCurrentUnit(1);
        var residueHash = {};

        for (i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i]; // This code is extremely dangerous for non-PDB formats

          residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
        }

        var structures = this.structures;

        for (i = 0, n = structures.length; i < n; ++i) {
          structures[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var helices = this._helices;

        for (i = 0, n = helices.length; i < n; ++i) {
          helices[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var sheets = this._sheets;

        for (i = 0, n = sheets.length; i < n; ++i) {
          sheets[i]._finalize(opts.serialAtomMap, residueHash, this);
        } // Update bounding sphere and box


        this._computeBounds();

        var atoms = this._atoms;

        for (i = 0, n = atoms.length; i < n; ++i) {
          var currAtom = atoms[i];
          currAtom.index = i;
        }

        if (opts.needAutoBonding) {
          var autoConnector = new AutoBond(this);
          autoConnector.build();
          autoConnector.destroy();
        }

        var chains = this._chains;

        for (i = 0, n = chains.length; i < n; ++i) {
          chains[i]._index = i;
        }

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._index = i;
        } // mark non-polar hydrogens


        for (i = 0, n = atoms.length; i < n; ++i) {
          var atom = atoms[i];

          if (atom.flags & Atom.Flags.HYDROGEN && atom.bonds.length === 1) {
            var _bond = atom.bonds[0];
            var other = _bond._left !== atom && _bond._left || _bond._right;

            if (other.flags & Atom.Flags.CARBON) {
              atom.flags |= Atom.Flags.NONPOLARH;
            }
          }
        }

        this._finalizeBonds();

        this._fillComponents(opts.enableEditing);

        var marker = new AromaticLoopsMarker(this);
        marker.markCycles();

        if (opts.detectAromaticLoops) {
          // TODO remove this condition clause, it is for debug purposes only!
          marker.detectCycles(); // TODO add conditional detection
        }

        this._finalizeMolecules();
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // add reference to molecule into residue
        for (var i = 0; i < this._molecules.length; i++) {
          var molecule = this._molecules[i];
          var count = molecule.residues.length;

          for (var j = 0; j < count; j++) {
            var residue = molecule.residues[j];
            residue._molecule = molecule;
          }
        }
      }
    }, {
      key: "updateStructuresMask",
      value: function updateStructuresMask() {
        var updater = function updater(structure) {
          return structure.collectMask();
        };

        this.forEachResidue(updater);
        this.forEachChain(updater);
        this.forEachMolecule(updater);
      }
    }, {
      key: "countAtomsByMask",
      value: function countAtomsByMask(mask) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if ((atom.mask & mask) !== 0) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "getNumAtomsBySelector",
      value: function getNumAtomsBySelector(selector) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom)) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "resetAtomMask",
      value: function resetAtomMask(mask) {
        this.forEachAtom(function (atom) {
          atom.mask = mask;
        });
      }
    }, {
      key: "markAtoms",
      value: function markAtoms(selector, mask) {
        var setMask = mask;
        var clearMask = ~setMask;
        var count = 0;
        var totalSelector = selectors.keyword('And')(selector, this.getSelector());
        this.forEachAtom(function (atom) {
          if (totalSelector.includesAtom(atom)) {
            atom.mask |= setMask;
            count++;
          } else {
            atom.mask &= clearMask;
          }
        });
        this._maskNeedsUpdate = true;
        return count;
      }
    }, {
      key: "markAtomsAdditionally",
      value: function markAtomsAdditionally(selector, mask) {
        var setMask = mask;
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
            atom.mask |= setMask;
            count++;
          }
        });
        return count;
      }
    }, {
      key: "clearAtomBits",
      value: function clearAtomBits(mask) {
        var clearMask = ~mask;
        this.forEachAtom(function (atom) {
          atom.mask &= clearMask;
        });

        var reseter = function reseter(a) {
          a._mask &= clearMask;
        };

        this.forEachAtom(reseter);
        this.forEachResidue(reseter);
        this.forEachChain(reseter);
        this.forEachMolecule(reseter);
      }
    }, {
      key: "getAtomNames",
      value: function getAtomNames() {
        if (this.hasOwnProperty('_atomNames')) {
          return this._atomNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.name] = 1;
        });
        this._atomNames = Object.keys(dict);
        return this._atomNames;
      }
    }, {
      key: "getElements",
      value: function getElements() {
        if (this.hasOwnProperty('_elements')) {
          return this._elements;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.element.name] = 1;
        });
        this._elements = Object.keys(dict);
        return this._elements;
      }
    }, {
      key: "getResidueNames",
      value: function getResidueNames() {
        if (this.hasOwnProperty('_residueNames')) {
          return this._residueNames;
        }

        var dict = {};
        this.forEachResidue(function (res) {
          dict[res._type._name] = 1;
        });
        this._residueNames = Object.keys(dict);
        return this._residueNames;
      }
    }, {
      key: "getChainNames",
      value: function getChainNames() {
        if (this.hasOwnProperty('_chainNames')) {
          return this._chainNames;
        }

        var dict = {};
        this.forEachChain(function (chain) {
          dict[chain._name] = 1;
        });
        this._chainNames = Object.keys(dict);
        return this._chainNames;
      }
    }, {
      key: "getAltLocNames",
      value: function getAltLocNames() {
        if (this.hasOwnProperty('_altlocNames')) {
          return this._altlocNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[String.fromCharCode(atom.location)] = 1;
        });
        this._altlocNames = Object.keys(dict);
        return this._altlocNames;
      }
    }, {
      key: "getVoxelWorld",
      value: function getVoxelWorld() {
        if (!this.hasOwnProperty('_voxelWorld')) {
          try {
            this._voxelWorld = new VoxelWorld(this.getDefaultBoundaries().boundingBox, new THREE.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));

            this._voxelWorld.addAtoms(this);
          } catch (e) {
            logger.warn('Unable to create voxel world');
            this._voxelWorld = null;
          }
        }

        return this._voxelWorld;
      }
      /**
       * Simple function to make unified routine procedure without code duplication.
       * @param {Array} srcArray   - Source chemical structure array (will be part of resulting chemical structure array).
       * @param {Array} dstArray   - Resulting chemical structure array.
       * @param {number} param     - Parameter for processor.
       * @param {function} functor - Processor for every element in array.
       */

    }, {
      key: "addElement",
      value: function addElement(srcArray, dstArray, param, functor) {
        var length = srcArray.length;

        for (var i = 0; i < length; ++i) {
          var elem = srcArray[i];
          functor(elem, param);
          dstArray.push(elem);
        }
      } // this function joins multiple complexes into one (this)
      // atom, bond, ... objects are reused -- so input complexes are no longer valid

    }, {
      key: "joinComplexes",
      value: function joinComplexes(complexes) {
        // clear target complex
        this._chains = [];
        this._components = [];
        this._helices = [];
        this._sheets = [];
        this.structures = [];
        this._atoms = [];
        this._residues = [];
        this._bonds = [];
        this._sgroups = [];
        var self = this;
        var atomBias = 0;
        var bondBias = 0;
        var residueBias = 0;
        var chainBias = 0;
        var componentBias = 0;

        function processAtom(atom, bias) {
          atom.serial += bias;
          atom.index += bias;
        }

        function processBond(bond, bias) {
          bond._index += bias;
        }

        function processResidue(residue, bias) {
          residue._index += bias;
        }

        function processChain(chain, bias) {
          chain._complex = self;
          chain._index += bias;
        }

        function processComponent(component, bias) {
          component._complex = self;
          component._index += bias;
        }
        /**
         * Simple function to do nothing.
         */


        function doNothing() {}

        for (var i = 0; i < complexes.length; ++i) {
          var c = complexes[i];
          this.addElement(c._atoms, this._atoms, atomBias, processAtom);
          this.addElement(c._bonds, this._bonds, bondBias, processBond);
          this.addElement(c._residues, this._residues, residueBias, processResidue);
          this.addElement(c._chains, this._chains, chainBias, processChain);
          this.addElement(c._sheets, this._sheets, 0, doNothing);
          this.addElement(c._helices, this._helices, 0, doNothing);
          this.addElement(c._sgroups, this._sgroups, 0, doNothing);
          this.addElement(c._components, this._components, componentBias, processComponent);
          this.addElement(c.structures, this.structures, 0, doNothing); // merge residue types

          for (var rt in c._residueTypes) {
            if (c._residueTypes.hasOwnProperty(rt)) {
              this._residueTypes[rt] = c._residueTypes[rt];
            }
          }

          atomBias += c._atoms.length;
          bondBias += c._bonds.length;
          residueBias += c._residues.length;
          chainBias += c._chains.length;
          componentBias += c._components.length;
        }

        this._computeBounds();
      }
      /**
       * Replace secondary structure with calculated one.
       *
       * DSSP algorithm implementation is used.
       *
       * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
       * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
       */

    }, {
      key: "dssp",
      value: function dssp() {
        var ssMap = new SecondaryStructureMap(this);
        var structures = this.structures = [];
        var helices = this._helices = [];
        var sheets = this._sheets = [];

        var getSheet = function getSheet(index) {
          var item = sheets[index];

          if (!item) {
            item = sheets[index] = new Sheet(String(index), 0);
          }

          return item;
        };

        var lastCode;
        var lastSheetIndex;
        var lastHelixIndex = 0;
        var curStructure = null;

        for (var i = 0, n = this._residues.length; i < n; ++i) {
          var curCode = ssMap._ss[i];
          var curResidue = this._residues[i];
          var curSheetIndex = ssMap._sheet[i]; // expand the last structure

          if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
            curResidue._secondary = curStructure;

            if (curStructure) {
              curStructure.term = curResidue;
            }

            if (curStructure instanceof Helix) {
              curStructure.length++;
            }

            continue;
          } // create a new structure


          var helixClass = helixClassMap[curCode];
          var loopType = loopMap[curCode];

          if (curCode === StructureType$1.STRAND) {
            var curSheet = getSheet(curSheetIndex);
            curStructure = new Strand(curSheet, curResidue, curResidue, 0, null, null);
            curSheet.addStrand(curStructure);
          } else if (helixClass !== undefined) {
            lastHelixIndex++;
            curStructure = new Helix(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), '', 1);
            helices.push(curStructure);
          } else if (loopType !== undefined) {
            curStructure = new StructuralElement(loopType, curResidue, curResidue);
          } else {
            curStructure = null;
          }

          if (curStructure) {
            structures.push(curStructure);
          }

          curResidue._secondary = curStructure;
          lastCode = curCode;
          lastSheetIndex = curSheetIndex;
        }

        this._sheets = sheets.filter(function (_sheet) {
          return true;
        }); // squeeze sheets array
      }
    }]);

    return Complex;
  }();

  Complex.prototype.id = 'Complex';
  Complex.prototype.name = '';

  function pow2ceil(v) {
    var p = 2;
    v = v - 1 >> 1;

    while (v) {
      p <<= 1;
      v >>= 1;
    }

    return p;
  }
  /**
   * Volume constructor
   *
   * @param {Object} type - Float32Array, Int8Array, etc...
   * @param {Object|Array} dimensions - number of data points on each axis (x, y, z)
   * @param {Box3} box - bounding box defining data place in metric space,
   *                     it's corners correspond to extreme data points
   * @param {Number} vecSize - dimension of the field data point (1 = scalar, 3 = 3D vector)
   * @param {Object} data - typed array of the same type as specified by the 1st parameter,
   *                        layout: point by point along X,
   *                                row by row along Y,
   *                                plane by plane along Z
   * @param {Number} volumeInfo - volume info values to define threshold to filter the noise
   */


  var Volume = /*#__PURE__*/function () {
    function Volume(type, dimensions, box, vecSize, data, volumeInfo) {
      classCallCheck(this, Volume);

      this._box = box.clone();
      this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
      this._volumeInfo = volumeInfo;

      if (dimensions instanceof Array) {
        var _dimensions = slicedToArray(dimensions, 3);

        this._dimX = _dimensions[0];
        this._dimY = _dimensions[1];
        this._dimZ = _dimensions[2];
      } else {
        this._dimX = dimensions.x;
        this._dimY = dimensions.y;
        this._dimZ = dimensions.z;
      }

      this._dimX = Math.max(Math.floor(this._dimX), 1);
      this._dimY = Math.max(Math.floor(this._dimY), 1);
      this._dimZ = Math.max(Math.floor(this._dimZ), 1);
      this._rowElements = this._dimVec * this._dimX;
      this._planeElements = this._rowElements * this._dimY;
      this._totalElements = this._planeElements * this._dimZ;
      this._data = data || utils.allocateTyped(type, this._totalElements); // override getter/setter for vector fields

      switch (this._dimVec) {
        case 1:
          break;

        case 2:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1]];
          };

          this.setValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
          };

          this.addValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
          };

          break;

        case 3:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
          };

          this.setValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
            this._data[idx + 2] = c;
          };

          this.addValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
            this._data[idx + 2] += c;
          };

          break;

        default:
          throw new Error('Volume: invalid vector dimension');
      }
    } // default getter assumes it's a scalar field


    createClass(Volume, [{
      key: "getValue",
      value: function getValue(x, y, z) {
        return this._data[x + y * this._rowElements + z * this._planeElements];
      } // default setter assumes it's a scalar field

    }, {
      key: "setValue",
      value: function setValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] = val;
      } // default adder assumes it's a scalar field

    }, {
      key: "addValue",
      value: function addValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] += val;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions() {
        return [this._dimX, this._dimY, this._dimZ];
      }
    }, {
      key: "getBox",
      value: function getBox() {
        return this._box;
      }
    }, {
      key: "getVolumeInfo",
      value: function getVolumeInfo() {
        return this._volumeInfo;
      }
    }, {
      key: "getCellSize",
      value: function getCellSize() {
        var boxSize = new THREE.Vector3();

        this._box.getSize(boxSize);

        var res = new THREE.Vector3();
        res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
        res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
        res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
        return res;
      }
    }, {
      key: "computeGradient",
      value: function computeGradient() {
        if (this._dimVec !== 1) {
          // gradient can only be computed for scalar fields
          return null;
        } // create a 3D vector field of gradients


        var gradient = new Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3); // calculate cell side lengths

        var vl = this.getCellSize(); // gradient axis scaling values and averaging factors, to correctly
        // calculate the gradient for volumes with irregular cell spacing

        var vs = new THREE.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z); // TODO Check for intended bug in VMD (min is zero)

        function clamp(val, min, max) {
          return Math.min(max, Math.max(min, val));
        }

        var xSize = this._dimX;
        var ySize = this._dimY;
        var zSize = this._dimZ;
        var volMap = this._data;

        function _voxelValue(x, y, z) {
          return volMap[z * xSize * ySize + y * xSize + x];
        }

        for (var zi = 0; zi < zSize; ++zi) {
          var zm = clamp(zi - 1, 0, zSize - 1);
          var zp = clamp(zi + 1, 0, zSize - 1);

          for (var yi = 0; yi < ySize; ++yi) {
            var ym = clamp(yi - 1, 0, ySize - 1);
            var yp = clamp(yi + 1, 0, ySize - 1);

            for (var xi = 0; xi < xSize; ++xi) {
              var xm = clamp(xi - 1, 0, xSize - 1);
              var xp = clamp(xi + 1, 0, xSize - 1); // Calculate the volume gradient at each grid cell.
              // Gradients are now stored unnormalized, since we need them in pure
              // form in order to draw field lines etc.  Shading code will now have
              // to do renormalization for itself on-the-fly.
              // XXX this gradient is only correct for orthogonal grids, since
              // we're using the array index offsets rather to calculate the gradient
              // rather than voxel coordinate offsets.  This will have to be
              // re-worked for non-orthogonal datasets.

              gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
            }
          }
        }

        return gradient;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        var data = this._data; // get min/max

        var min = data[0];
        var max = data[0];

        for (var i = 1; i < data.length; ++i) {
          min = Math.min(min, data[i]);
          max = Math.max(max, data[i]);
        }

        var d = 1.0 / (max - min);

        if (d === 0) {
          return;
        } // normalize


        for (var _i = 0; _i < data.length; ++_i) {
          data[_i] = d * (data[_i] - min);
        }
      }
    }, {
      key: "getTiledTextureStride",
      value: function getTiledTextureStride() {
        return [this._dimX + 2, this._dimY + 2];
      }
    }, {
      key: "buildTiledTexture",
      value: function buildTiledTexture() {
        var tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
        var width = tilesX * (this._dimX + 2) - 1;
        width = pow2ceil(width);
        tilesX = Math.floor(width / (this._dimX + 2));
        var tilesY = Math.ceil(this._dimZ / tilesX);
        var height = tilesY * (this._dimY + 2) - 1;
        height = pow2ceil(height);
        var data = new Uint8Array(width * height);
        var src;
        var dst;

        for (var tileRow = 0; tileRow < tilesY; ++tileRow) {
          // process each pixel row of this tile row
          for (var row = 0; row < this._dimY; ++row) {
            src = tileRow * tilesX * this._planeElements + row * this._rowElements;
            dst = width * (tileRow * (this._dimY + 2) + row); // copy a series of rows through several XY planes

            for (var t = 0; t < tilesX; ++t) {
              // copy one row of one XY plane
              for (var x = 0; x < this._dimX; ++x) {
                data[dst++] = 255.0 * this._data[src++];
              } // repeat last pixel of previous tile


              data[dst++] = 255.0 * this._data[src - 1];

              if (t < tilesX - 1) {
                // skip to the same row of next XY plane
                src += this._planeElements - this._rowElements; // repeat first pixel of next tile

                data[dst++] = 255.0 * this._data[src];
              }
            }
          }
        } // fill pixels between tile rows with copy of edge pixels


        for (var _tileRow = 0; _tileRow < tilesY; ++_tileRow) {
          // copy last pixel row of this tile row to the following pixel row of the texture
          src = width * (_tileRow * (this._dimY + 2) + this._dimY - 1);
          dst = src + width;

          for (var _x = 0; _x < width; ++_x) {
            data[dst++] = data[src++];
          }

          if (_tileRow < tilesY - 1) {
            // copy first pixel row of next tile row to the preceding pixel row of the texture
            src = width * (_tileRow + 1) * (this._dimY + 2);
            dst = src - width;

            for (var _x2 = 0; _x2 < width; ++_x2) {
              data[dst++] = data[src++];
            }
          }
        }

        var texture = new THREE.DataTexture(data, width, height, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter);
        texture.needsUpdate = true;
        return texture;
      }
      /* ********************************************************************************
       *
       * Methods that provide direct access to internal array (for better performance)
       *
       ******************************************************************************** */

    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getDirectIdx",
      value: function getDirectIdx(x, y, z) {
        return x * this._dimVec + y * this._rowElements + z * this._planeElements;
      }
    }, {
      key: "getStrideX",
      value: function getStrideX() {
        return this._dimVec;
      }
    }, {
      key: "getStrideY",
      value: function getStrideY() {
        return this._rowElements;
      }
    }, {
      key: "getStrideZ",
      value: function getStrideZ() {
        return this._planeElements;
      }
    }]);

    return Volume;
  }();

  Volume.prototype.id = 'Volume';

  /**
   * Residue Molecule.
   *
   * @param {Complex} complex - Molecular complex this Molecule belongs to.
   * @param {String} name - Molecule's name.
   * @param {Integer} index - Molecule's index in file.
   *
   * @exports Molecule
   * @constructor
   */
  var Molecule = /*#__PURE__*/function () {
    function Molecule(complex, name, index) {
      classCallCheck(this, Molecule);

      this.complex = complex;
      this.name = name || '';
      this.residues = [];
      this.mask = 1 | 0;
      this.index = index || -1; // start with 1
    }

    createClass(Molecule, [{
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this.mask = mask;
      }
    }]);

    return Molecule;
  }();

  var chem = {
    Atom: Atom,
    Element: Element,
    Bond: Bond,
    Residue: Residue,
    ResidueType: ResidueType,
    Chain: Chain,
    Helix: Helix,
    Strand: Strand,
    Sheet: Sheet,
    SGroup: SGroup,
    Assembly: Assembly,
    Complex: Complex,
    Volume: Volume,
    VoxelWorld: VoxelWorld,
    selectors: selectors,
    Molecule: Molecule
  };

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CSS2DObject = /*#__PURE__*/function (_THREE$Object3D) {
    inherits(CSS2DObject, _THREE$Object3D);

    var _super = _createSuper$9(CSS2DObject);

    function CSS2DObject(element) {
      var _this;

      classCallCheck(this, CSS2DObject);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._element = element;
      _this._element.style.position = 'absolute';

      _this.addEventListener('removed', function () {
        if (self._element.parentNode !== null) {
          self._element.parentNode.removeChild(self._element);
        }
      });

      return _this;
    }

    createClass(CSS2DObject, [{
      key: "getElement",
      value: function getElement() {
        return this._element;
      }
      /**
       * Sets label transparency.
       *
       * @param {number} transp    - in [0; 1] 1 means fully transparent
       */

    }, {
      key: "setTransparency",
      value: function setTransparency(transp) {
        var el = this.getElement();

        if (el === null) {
          return;
        }

        if (transp === 1.0) {
          el.style.display = 'none';
          return;
        }

        el.style.display = 'inline';
        var op = 1.0 - transp;
        var top = op.toString();
        var op100 = op * 100;
        el.style.opacity = top;
        el.style.filter = "alpha(opacity=".concat(op100, ")"); // IE fallback
      }
    }, {
      key: "clone",
      value: function clone() {
        var obj = new CSS2DObject(this._element);
        obj.copy(this);
        return obj;
      }
    }]);

    return CSS2DObject;
  }(THREE.Object3D);

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var RCGroup = /*#__PURE__*/function (_THREE$Group) {
    inherits(RCGroup, _THREE$Group);

    var _super = _createSuper$a(RCGroup);

    function RCGroup() {
      classCallCheck(this, RCGroup);

      return _super.apply(this, arguments);
    }

    createClass(RCGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (!this.visible) {
          return;
        }

        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          children[i].raycast(raycaster, intersects);
        }
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].enableSubset) {
            children[i].enableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].disableSubset) {
            children[i].disableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.children.length === 0;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].updateToFrame) {
            children[i].updateToFrame(frameData);
          }
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
          }
        }

        return totalSubset;
      }
    }]);

    return RCGroup;
  }(THREE.Group);

  var vertexScreenQuadShader = "uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n";

  var fragmentScreenQuadFromTex = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform float opacity;\n\nvoid main() {\n  vec4 color = texture2D(srcTex, vUv);\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\n}\n";

  var fragmentScreenQuadFromTexWithDistortion = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform float coef;\n\nvoid main() {\n  vec2 uv = vUv * 2.0 - 1.0;\n  float r2 = dot(uv, uv);\n  vec2 tc = uv * (1.0 + coef * r2);\n  if (!all(lessThan(abs(tc), vec2(1.0))))\n    discard;\n  tc = 0.5 * (tc + 1.0);\n  gl_FragColor = texture2D(srcTex, tc);\n}\n";

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var LAYERS = {
    DEFAULT: 0,
    VOLUME: 1,
    TRANSPARENT: 2,
    PREPASS_TRANSPARENT: 3,
    VOLUME_BFPLANE: 4,
    COLOR_FROM_POSITION: 5,
    SHADOWMAP: 6
  };
  var SELECTION_LAYERS = [// These layers, that are used in the selection by ray casting
  LAYERS.DEFAULT, LAYERS.TRANSPARENT];

  THREE.Object3D.prototype.resetTransform = function () {
    this.position.set(0, 0, 0);
    this.quaternion.set(0, 0, 0, 1);
    this.scale.set(1, 1, 1);
  }; // update world matrix of this object and all its ancestors


  THREE.Object3D.prototype.updateMatrixWorldRecursive = function () {
    if (this.parent != null) {
      this.parent.updateMatrixWorldRecursive();
    }

    this.updateMatrixWorld();
  }; // add object to parent, saving objects' world transform


  THREE.Object3D.prototype.addSavingWorldTransform = function () {
    var _worldMatrixInverse = new THREE.Matrix4();

    return function (object) {
      if (object instanceof THREE.Object3D) {
        _worldMatrixInverse.copy(this.matrixWorld).invert();

        _worldMatrixInverse.multiply(object.matrixWorld);

        object.matrix.copy(_worldMatrixInverse);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
        this.add(object);
      }
    };
  }(); // render a tiny transparent quad in the center of the screen


  THREE.WebGLRenderer.prototype.renderDummyQuad = function () {
    var _material = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false
    });

    var _scene = new THREE.Scene();

    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.01, 0.01), _material);

    _scene.add(_quad);

    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function () {
      this.render(_scene, _camera);
    };
  }();

  THREE.WebGLRenderer.prototype.renderScreenQuad = function () {
    var _scene = new THREE.Scene();

    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1.0, 1.0));

    _scene.add(_quad);

    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function (material) {
      _quad.material = material;
      this.render(_scene, _camera);
    };
  }();

  THREE.Matrix4.prototype.isIdentity = function () {
    var identity = new THREE.Matrix4();
    return function () {
      return identity.equals(this);
    };
  }();

  THREE.Matrix4.prototype.applyToPointsArray = function (array, stride, w) {
    if (!array || !stride || stride < 3) {
      return array;
    }

    w = w || 0; // use point as normal by default

    var e = this.elements;

    for (var i = 0; i < array.length; i += stride) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      var persp = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      array[i] = (e[0] * x + e[4] * y + e[8] * z + e[12] * w) * persp;
      array[i + 1] = (e[1] * x + e[5] * y + e[9] * z + e[13] * w) * persp;
      array[i + 2] = (e[2] * x + e[6] * y + e[10] * z + e[14] * w) * persp;
    }

    return array;
  };

  var ScreenQuadMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(ScreenQuadMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$b(ScreenQuadMaterial);

    function ScreenQuadMaterial(params) {
      classCallCheck(this, ScreenQuadMaterial);

      if (params.uniforms === undefined) {
        params.uniforms = {};
      }

      params.uniforms.srcTex = {
        type: 't',
        value: null
      };
      params.vertexShader = vertexScreenQuadShader;
      params.transparent = false;
      params.depthTest = false;
      params.depthWrite = false;
      return _super.call(this, params);
    }

    return ScreenQuadMaterial;
  }(THREE.RawShaderMaterial);

  THREE.WebGLRenderer.prototype.renderScreenQuadFromTex = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        opacity: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTex,
      transparent: true
    });

    return function (srcTex, opacity) {
      _material.uniforms.srcTex.value = srcTex;
      _material.transparent = opacity < 1.0;
      _material.uniforms.opacity.value = opacity;
      this.renderScreenQuad(_material);
    };
  }();

  THREE.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        coef: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTexWithDistortion
    });

    return function (srcTex, coef) {
      _material.uniforms.srcTex.value = srcTex;
      _material.uniforms.coef.value = coef;
      this.renderScreenQuad(_material);
    };
  }();
  /**
   * @param {number} angle - Field of view in degrees.
   */


  THREE.PerspectiveCamera.prototype.setMinimalFov = function (angle) {
    if (this.aspect >= 1.0) {
      this.fov = angle;
    } else {
      this.fov = THREE.MathUtils.radToDeg(2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(angle) * 0.5) / this.aspect));
    }
  };
  /**
   * @param {THREE.PerspectiveCamera} camera - Base camera for this stereo camera.
   * @param {number} angle - Field of view in degrees.
   */


  THREE.StereoCamera.prototype.updateHalfSized = function (camera, angle) {
    var originalAspect = camera.aspect;
    var originalFov = camera.fov;
    camera.aspect = originalAspect / 2.0;
    camera.setMinimalFov(angle);
    camera.updateProjectionMatrix();
    this.update(camera);
    camera.aspect = originalAspect;
    camera.fov = originalFov;
    camera.updateProjectionMatrix();
  };
  /**
   * @param {number} radius - Radius of bounding sphere in angstroms to fit on screen.
   * @param {number} angle - Field of view in degrees.
   */


  THREE.PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
    this.position.z = radius / Math.sin(0.5 * THREE.MathUtils.degToRad(angle));
  };
  /**
   * @param {RCGroup} gfxObj - All objects on scene.
   * @param {THREE.PerspectiveCamera} camera - Camera used for rendering.
   * @param {number} clipPlane - Distance to clip plane.
   * @param {number} fogFarPlane - Distance to fog far plane.
   */


  THREE.Raycaster.prototype.intersectVisibleObject = function (gfxObj, camera, clipPlane, fogFarPlane) {
    var intersects = this.intersectObject(gfxObj, false);

    if (intersects.length === 0) {
      return null;
    } // find point closest to camera that doesn't get clipped by camera near plane or clipPlane (if it exists)


    var nearPlane = Math.min(camera.near, clipPlane);
    var i;
    var p = intersects[0];
    var v = new THREE.Vector3();

    for (i = 0; i < intersects.length; ++i) {
      p = intersects[i];
      v.copy(p.point);
      v.applyMatrix4(camera.matrixWorldInverse);

      if (v.z <= -nearPlane) {
        break;
      }
    }

    if (i === intersects.length) {
      return null;
    } // check that selected intersection point is not clipped by camera far plane or occluded by fog (if it exists)


    var farPlane = Math.min(camera.far, fogFarPlane);
    v.copy(p.point);
    v.applyMatrix4(camera.matrixWorldInverse);

    if (v.z <= -farPlane) {
      return null;
    }

    return p;
  };

  THREE.Matrix4.prototype.extractScale = function () {
    var _v = new THREE.Vector3();

    return function (scale) {
      if (scale === undefined) {
        logger.debug('extractScale(): new is too expensive operation to do it on-the-fly');
        scale = _v.clone();
      }

      var te = this.elements;
      scale.x = _v.set(te[0], te[1], te[2]).length();
      scale.y = _v.set(te[4], te[5], te[6]).length();
      scale.z = _v.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

      var det = this.determinant();

      if (det < 0) {
        scale.x = -scale.x;
      }

      return scale;
    };
  }();

  function _calcCylinderMatrix(posBegin, posEnd, radius) {
    var posCenter = posBegin.clone().lerp(posEnd, 0.5);
    var matScale = new THREE.Matrix4();
    matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
    var matRotHalf = new THREE.Matrix4();
    matRotHalf.makeRotationX(Math.PI / 2);
    var matRotLook = new THREE.Matrix4();
    var vUp = new THREE.Vector3(0, 1, 0);
    matRotLook.lookAt(posCenter, posEnd, vUp);
    matRotLook.multiply(matRotHalf);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(posCenter);
    return matRotLook;
  }

  function _calcChunkMatrix(eye, target, up, rad) {
    var matScale = new THREE.Matrix4();
    matScale.makeScale(rad.x, rad.y, 0);
    var matRotLook = new THREE.Matrix4();
    matRotLook.lookAt(eye, target, up);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(eye);
    return matRotLook;
  }

  function _groupHasGeometryToRender(group) {
    var hasGeoms = false;
    group.traverse(function (node) {
      if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
        hasGeoms = true;
      }
    });
    return hasGeoms;
  }

  function _buildDistorionMesh(widthSegments, heightSegements, coef) {
    // solve equation r_u = r_d * (1 + k * r_d^2)
    // for r_d using iterations
    // takes: r_u^2
    // returns: r_d / r_u  factor that can be used to distort point coords
    function calcInverseBarrel(r2) {
      var epsilon = 1e-5;
      var prevR2 = 0.0;
      var curR2 = r2;
      var dr = 1.0;

      while (Math.abs(curR2 - prevR2) > epsilon) {
        dr = 1.0 + coef * curR2;
        prevR2 = curR2;
        curR2 = r2 / (dr * dr);
      }

      return 1.0 / dr;
    }

    var geo = new THREE.PlaneBufferGeometry(2.0, 2.0, widthSegments, heightSegements);
    var pos = geo.getAttribute('position');

    for (var i = 0; i < pos.count; ++i) {
      var x = pos.array[3 * i];
      var y = pos.array[3 * i + 1];
      var c = calcInverseBarrel(x * x + y * y);
      pos.setXY(i, c * x, c * y);
    }

    return geo;
  }

  THREE.BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
    console.assert(this.itemSize === attribute.itemSize, 'false: BufferAttribute.copyAtList buffers have different item size.');
    var itemSize = this.itemSize;

    for (var i = 0, n = indexList.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
      }
    }

    return this;
  };

  function fillArray(array, value, startIndex, endIndex) {
    startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
    endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;

    for (var i = startIndex; i < endIndex; ++i) {
      array[i] = value;
    }
  }
  /** @param {THREE.Object3D} object - Parent object. */


  function removeChildren(object) {
    var children = object.children;

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];
      child.parent = null;
      child.dispatchEvent({
        type: 'removed'
      });
    }

    object.children = [];
  }

  function clearTree(object) {
    object.traverse(function (obj) {
      if (obj instanceof THREE.Mesh || obj instanceof THREE.LineSegments || obj instanceof THREE.Line) {
        obj.geometry.dispose();
      }
    });
    removeChildren(object);
  }

  function destroyObject(object) {
    clearTree(object);

    if (object.parent) {
      object.parent.remove(object);
    } else {
      object.dispatchEvent({
        type: 'removed'
      });
    }
  }

  function belongToSelectLayers(object) {
    for (var i = 0; i < SELECTION_LAYERS.length; i++) {
      if ((object.layers.mask >> SELECTION_LAYERS[i] & 1) === 1) {
        return true;
      }
    }

    return false;
  }

  function processObjRenderOrder(root, idMaterial) {
    // set renderOrder to 0 for Backdrop and to 1 in other cases to render Backdrop earlier all other materials
    var renderOrder = +(idMaterial !== 'BA');
    root.traverse(function (object) {
      if (object.isGroup) {
        object.renderOrder = renderOrder;
      }
    });
  }

  function applySelectionMaterial(geo) {
    geo.traverse(function (node) {
      if ('material' in node) {
        node.material = node.material.clone(true); // using z-offset to magically fix selection rendering artifact (on z-sprites)

        node.material.setValues({
          depthFunc: THREE.LessEqualDepth,
          overrideColor: true,
          fog: false,
          lights: false,
          shadowmap: false
        });
        node.material.setUberOptions({
          fixedColor: new THREE.Color(0xFFFF00),
          zOffset: -1e-6
        });
      }
    });
  }

  function getMiddlePoint(point1, point2, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.set(0, 0, 0);
    result.addScaledVector(point1, 0.5);
    result.addScaledVector(point2, 0.5);
    return result;
  } // Monkey-patch for "InstancedBufferGeometry.instanceCount becomes undefined after copy()"
  // https://github.com/mrdoob/three.js/issues/22151


  var _oldInstancedBufferGeometryCopy = THREE.InstancedBufferGeometry.prototype.copy;

  THREE.InstancedBufferGeometry.prototype.copy = function (source) {
    _oldInstancedBufferGeometryCopy.call(this, source);

    if (this.instanceCount === undefined) {
      this.instanceCount = Infinity;
    }
  };

  var gfxutils = {
    calcCylinderMatrix: _calcCylinderMatrix,
    calcChunkMatrix: _calcChunkMatrix,
    groupHasGeometryToRender: _groupHasGeometryToRender,
    buildDistorionMesh: _buildDistorionMesh,
    RCGroup: RCGroup,
    fillArray: fillArray,
    clearTree: clearTree,
    destroyObject: destroyObject,
    belongToSelectLayers: belongToSelectLayers,
    processObjRenderOrder: processObjRenderOrder,
    applySelectionMaterial: applySelectionMaterial,
    getMiddlePoint: getMiddlePoint,
    LAYERS: LAYERS
  };

  function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _defaultBoundaries = {
    boundingBox: new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
    boundingSphere: new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1)
  };

  var Visual = /*#__PURE__*/function (_gfxutils$RCGroup) {
    inherits(Visual, _gfxutils$RCGroup);

    var _super = _createSuper$c(Visual);

    function Visual(name, dataSource) {
      var _this;

      classCallCheck(this, Visual);

      _this = _super.call(this, name, dataSource);
      _this.name = name;
      _this._dataSource = dataSource;
      return _this;
    }

    createClass(Visual, [{
      key: "release",
      value: function release() {
        if (this.parent) {
          this.parent.remove(this);
        }
      }
    }, {
      key: "getDataSource",
      value: function getDataSource() {
        return this._dataSource;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return _defaultBoundaries;
      }
    }]);

    return Visual;
  }(gfxutils.RCGroup);

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function _ensureArray(x) {
    if (x === null || x === undefined || Array.isArray(x)) {
      return x;
    }

    return [x];
  }
  /** An indexed list of objects or classes. */


  var EntityList = /*#__PURE__*/function () {
    /**
     * Create a list of objects.
     * The objects can be indexed by one or more properties for the later retrieval.
     *
     * @param {!Array<Object>=} entities A list of objects to automatically register at creation time.
     * @param {!Array<string>=} indices A list of property names to use for case-insensitive indexing.
     *   By default, a single `.id` property is used.
     * @see EntityList#register
     */
    function EntityList() {
      var _this = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id'];

      classCallCheck(this, EntityList);

      this._list = [];
      this._dict = {};
      this._indices = toConsumableArray(indices);

      this._indices.forEach(function (index) {
        _this._dict[index] = {};
      });

      entities.forEach(function (entity) {
        return _this.register(entity);
      });
    }
    /**
     * Add a value to the end of a list.
     * The list will contain only one copy of the value.
     *
     * @param {!Array} list An array.
     * @param {*} value A value to add.
     * @see EntityList.unregisterFromList
     * @see EntityList.registerInDict
     */


    createClass(EntityList, [{
      key: "register",

      /**
       * Add an entity to this list.
       *
       * @param {!Object} entity An object or a class to register. The object must include all
       *   properties specified as indices on construction.
       * @see EntityList#unregister
       */
      value: function register(entity) {
        var _this2 = this;

        EntityList.registerInList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.registerInDict(_this2._dict[index], _ensureArray(entity[index]), entity);
        });
      }
      /**
       * Remove an entity from this list.
       *
       * @param {!Object} entity An object or a class to unregister. The object may be
       *   missing from the list but it must include all properties specified as indices
       *   on construction.
       * @see EntityList#register
       */

    }, {
      key: "unregister",
      value: function unregister(entity) {
        var _this3 = this;

        EntityList.unregisterFromList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.unregisterFromDict(_this3._dict[index], _ensureArray(entity[index]), entity);
        });
      }
      /**
       * An ordered list of all registered entities.
       * It is a read-only copy, use {@link EntityList#register} and {@link EntityList#unregister}
       * to modify it.
       *
       * @type {!Array<Object>}
       */

    }, {
      key: "keys",

      /**
       * Retrieve a list of keys for the index.
       *
       * @param {string=} index One of the indices specified during the list construction. If omitted,
       *   the first of the indices is used.
       * @returns {!Array<string>} An unordered list of keys in the index, i.e. particular property
       *   values for all registered entities.
       */
      value: function keys(index) {
        return Object.keys(this._dict[index || this._indices[0]]);
      }
      /**
       * Retrieve an entity by its key.
       *
       * @param {string} key A case-insensitive property value to look-up.
       * @param {string=} index One of the indices specified during the list construction. If omitted,
       *   the first of the indices is used.
       * @returns {Object=} An object registered in the index under the key. If there are multiple
       *   objects under the same key, the first one is returned.
       */

    }, {
      key: "get",
      value: function get(key, index) {
        var dict = this._dict[index || this._indices[0]];

        if (dict) {
          var values = dict[key && key.toLowerCase()];
          return values && values.length > 0 ? values[0] : undefined;
        }

        return undefined;
      }
    }, {
      key: "all",
      get: function get() {
        return toConsumableArray(this._list);
      }
      /**
       * The first registered entity.
       * Use it if you do not care which entity you are referring to.
       *
       * @type {Object=}
       */

    }, {
      key: "first",
      get: function get() {
        return this._list[0];
      }
    }], [{
      key: "registerInList",
      value: function registerInList(list, value) {
        if (!list.includes(value)) {
          list.push(value);
        }
      }
      /**
       * Remove a value from a list if it is there.
       *
       * @param {!Array} list An array.
       * @param {*} value A value to remove.
       * @see EntityList.registerInList
       */

    }, {
      key: "unregisterFromList",
      value: function unregisterFromList(list, value) {
        var pos = list.indexOf(value);

        if (pos !== -1) {
          list.splice(pos, 1);
        }
      }
      /**
       * Add a value to a dictionary.
       * The value may be stored under multiple different keys (aliases).
       * There might be multiples values stored under the same key.
       *
       * @param {!Object<string,*>} dict A dictionary.
       * @param {!Array<string>} keys An array of keys.
       * @param {*} value A value to add.
       * @see EntityList.unregisterFromDict
       * @see EntityList.registerInList
       */

    }, {
      key: "registerInDict",
      value: function registerInDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key] = dict[key] || [];

          if (!list.includes(value)) {
            list.push(value);
          }
        });
      }
      /**
       * Remove a value from a dictionary.
       * The value may be stored under multiple different keys (aliases).
       * There might be multiples values stored under the same key.
       *
       * @param {!Object<string,*>} dict A dictionary.
       * @param {!Array<string>} keys An array of keys.
       * @param {*} value A value to add.
       * @see EntityList.registerInDict
       */

    }, {
      key: "unregisterFromDict",
      value: function unregisterFromDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key];

          if (list) {
            var pos = list.indexOf(value);

            if (pos !== -1) {
              list.splice(pos, 1);
            }

            if (list.length === 0) {
              delete dict[key];
            }
          }
        });
      }
    }]);

    return EntityList;
  }();

  function makeContextDependent(prototype) {
    Object.defineProperties(prototype, {
      logger: {
        get: function get() {
          return this.context && this.context.logger ? this.context.logger : logger;
        }
      },
      settings: {
        get: function get() {
          return this.context && this.context.settings ? this.context.settings : settings;
        }
      }
    });
  }

  function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CollisionSphere = /*#__PURE__*/function () {
    function CollisionSphere(position, radius) {
      classCallCheck(this, CollisionSphere);

      this._position = position;
      this._radius = radius;
    }

    createClass(CollisionSphere, [{
      key: "raycast",
      value: function raycast(raycaster) {
        var sphere = CollisionSphere._sphere;
        sphere.set(this._position, this._radius);
        var p = new THREE.Vector3();

        if (raycaster.ray.intersectSphere(sphere, p)) {
          return {
            distance: raycaster.ray.origin.distanceTo(p),
            point: p
          };
        }

        return null;
      }
    }]);

    return CollisionSphere;
  }();

  defineProperty(CollisionSphere, "_sphere", new THREE.Sphere());

  var SphereCollisionGeo = function SphereCollisionGeo(base) {
    return /*#__PURE__*/function (_base) {
      inherits(_class, _base);

      var _super = _createSuper$d(_class);

      function _class(count) {
        var _this;

        classCallCheck(this, _class);

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));
        _this._objects = new Array(count);
        _this.boundingSphere = null;
        _this.boundingBox = null;
        return _this;
      }

      createClass(_class, [{
        key: "setSphere",
        value: function setSphere(idx, position, radius) {
          this._objects[idx] = new CollisionSphere(position, radius);
        }
      }, {
        key: "raycast",
        value: function raycast(raycaster, intersects) {
          // TODO raycast with bounding sphere? How to deal with updates?
          for (var i = 0, n = this._objects.length; i < n; ++i) {
            var inters = this._objects[i].raycast(raycaster);

            if (inters) {
              inters.chunkIdx = i;
              intersects.push(inters);
            }
          }
        }
      }, {
        key: "computeBoundingBox",
        value: function computeBoundingBox() {
          var objects = this._objects;
          var boundingBox = this.boundingBox;

          if (boundingBox === null) {
            this.boundingBox = boundingBox = new THREE.Box3();
          }

          boundingBox.makeEmpty();

          for (var i = 0, n = objects.length; i < n; ++i) {
            boundingBox.expandByPoint(objects[i]._position);
          }
        }
      }, {
        key: "computeBoundingSphere",
        value: function computeBoundingSphere() {
          this.computeBoundingBox();
          var objects = this._objects;
          var boundingBox = this.boundingBox; // Build bounding sphere

          var radiusSquared = 0.0;
          var center = new THREE.Vector3();
          boundingBox.getCenter(center);

          for (var i = 0, n = objects.length; i < n; ++i) {
            var pos = objects[i]._position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }

          this.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }]);

      return _class;
    }(base);
  };

  function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor = new THREE.Color();
  var OFFSET_SIZE = 4;
  var COLOR_SIZE = 3;
  var copySubArrays$1 = utils.copySubArrays;

  function setArrayXYZ(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  var InstancedSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(InstancedSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$e(InstancedSpheresGeometry);

    function InstancedSpheresGeometry(spheresCount, sphereComplexity, useZSprites) {
      var _this;

      classCallCheck(this, InstancedSpheresGeometry);

      _this = _super.call(this, spheresCount);
      _this._sphGeometry = useZSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new THREE.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);

      _this._init(spheresCount, _this._sphGeometry);

      return _this;
    }

    createClass(InstancedSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        setArrayXYZW(this._offsets, itemIdx * OFFSET_SIZE, itemPos.x, itemPos.y, itemPos.z, itemRad);
        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal) {
        tmpColor.set(colorVal);
        setArrayXYZ(this._colors, itemIdx * COLOR_SIZE, tmpColor.r, tmpColor.g, tmpColor.b);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('offset').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[chunkIndices[i]] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._sphGeometry);

        copySubArrays$1(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE);
        copySubArrays$1(this._colors, geom._colors, chunkIndices, COLOR_SIZE);
        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(spheresCount, sphereGeo) {
        this.copy(sphereGeo);
        this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE);
        this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);

        ___default['default'].fill(alpha, 1.0);

        this.setAttribute('offset', new THREE.InstancedBufferAttribute(this._offsets, OFFSET_SIZE, false, 1));
        this.setAttribute('color', new THREE.InstancedBufferAttribute(this._colors, COLOR_SIZE, false, 1));
        this.setAttribute('alphaColor', new THREE.InstancedBufferAttribute(alpha, 1, false, 1));
      }
    }]);

    return InstancedSpheresGeometry;
  }(SphereCollisionGeo(THREE.InstancedBufferGeometry));

  function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This class adds raycasting interface to indexed
   * THREE.BufferGeometry.
   * @constructor
   */

  var RaycastableBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(RaycastableBufferGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$f(RaycastableBufferGeometry);

    function RaycastableBufferGeometry() {
      classCallCheck(this, RaycastableBufferGeometry);

      return _super.apply(this, arguments);
    }

    createClass(RaycastableBufferGeometry, [{
      key: "uvIntersection",
      // This method was copied from three.js
      value: function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
        var barycoord = RaycastableBufferGeometry._barycoord;
        THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
        uv1.multiplyScalar(barycoord.x);
        uv2.multiplyScalar(barycoord.y);
        uv3.multiplyScalar(barycoord.z);
        uv1.add(uv2).add(uv3);
        return uv1.clone();
      }
    }, {
      key: "checkIntersection",
      value: function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
        var intersect = ray.intersectTriangle(pA, pB, pC, false, point);

        if (intersect === null) {
          return null;
        }

        return {
          point: point.clone()
        };
      }
    }, {
      key: "checkBufferGeometryIntersection",
      value: function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
        var vA = RaycastableBufferGeometry._vA;
        var vB = RaycastableBufferGeometry._vB;
        var vC = RaycastableBufferGeometry._vC;
        var intersectionPoint = RaycastableBufferGeometry._intersectionPoint;
        vA.fromBufferAttribute(position, a);
        vB.fromBufferAttribute(position, b);
        vC.fromBufferAttribute(position, c);
        var intersection = this.checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);

        if (intersection) {
          if (uv) {
            var uvA = RaycastableBufferGeometry._uvA;
            var uvB = RaycastableBufferGeometry._uvB;
            var uvC = RaycastableBufferGeometry._uvC;
            uvA.fromBufferAttribute(uv, a);
            uvB.fromBufferAttribute(uv, b);
            uvC.fromBufferAttribute(uv, c);
            intersection.uv = this.uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
          }

          var normal = new THREE.Vector3();
          THREE.Triangle.getNormal(vA, vB, vC, normal);
          intersection.face = new THREE.Face3(a, b, c, normal);
          intersection.faceIndex = a;
        }

        return intersection;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var ray = raycaster.ray;

        if (this.boundingSphere === null) {
          this.computeBoundingSphere();
        }

        if (raycaster.ray.intersectsSphere(this.boundingSphere) === false) {
          return;
        }

        if (this.boundingBox !== null) {
          if (ray.intersectsBox(this.boundingBox) === false) {
            return;
          }
        }

        var a;
        var b;
        var c;
        var index = this.index,
            _this$attributes = this.attributes,
            position = _this$attributes.position,
            uv = _this$attributes.uv;

        if (index === null) {
          return;
        } // indexed buffer geometry


        for (var i = 0, l = index.count; i < l; i += 3) {
          a = index.getX(i);
          b = index.getX(i + 1);
          c = index.getX(i + 2);
          var intersection = this.checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics

            intersects.push(intersection);
          }
        }
      }
    }]);

    return RaycastableBufferGeometry;
  }(THREE.BufferGeometry);

  defineProperty(RaycastableBufferGeometry, "_vA", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_vB", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_vC", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_uvA", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_uvB", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_uvC", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_barycoord", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_intersectionPoint", new THREE.Vector3());

  function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT = 65535;
  var VEC_SIZE = 3;
  var tmpColor$1 = new THREE.Color();
  /**
   * This class represents geometry which consists of separate chunks.
   * Each chunk has same index and similar geometry with equal points and faces count.
   * Each chunk has by default only one color.
   * @constructor
   */

  var ChunkedObjectsGeometry = /*#__PURE__*/function (_RaycastableBufferGeo) {
    inherits(ChunkedObjectsGeometry, _RaycastableBufferGeo);

    var _super = _createSuper$g(ChunkedObjectsGeometry);

    function ChunkedObjectsGeometry(chunkGeo, chunksCount) {
      var _this;

      classCallCheck(this, ChunkedObjectsGeometry);

      _this = _super.call(this);

      if (_this.constructor === ChunkedObjectsGeometry) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._chunkGeo = chunkGeo;

      _this._init(chunkGeo, chunksCount);

      return _this;
    }

    createClass(ChunkedObjectsGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('normal').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor$1.set(colorVal);
        var colors = this._colors;
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          var idx = i * VEC_SIZE;
          colors[idx] = tmpColor$1.r;
          colors[idx + 1] = tmpColor$1.g;
          colors[idx + 2] = tmpColor$1.b;
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          ___default['default'].fill(alphaArr, value, left, left + chunkSize);
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];

        get(getPrototypeOf(ChunkedObjectsGeometry.prototype), "raycast", this).call(this, raycaster, inters);

        var facesPerChunk = this._chunkGeo.index.count / 3;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('faceIndex')) {
            continue;
          }

          inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
          intersects.push(inters[i]);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE.BufferGeometry();

        this._init.call(geom, this._chunkGeo, instanceCount);

        var srcPos = this._positions;
        var srcNorm = this._normals;
        var srcColor = this._colors;
        var dstPos = geom._positions;
        var dstNorm = geom._normals;
        var dstColor = geom._colors;
        var chunkSize = this._chunkSize * VEC_SIZE;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var ptIdxBegin = chunkIndices[i] * chunkSize;
          var ptIdxEnd = ptIdxBegin + chunkSize;
          dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        }

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(chunkGeo, chunksCount) {
        var chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
        var chunkIndex = chunkGeo.index.array;
        var chunkIndexSize = chunkIndex.length;
        var pointsCount = this._chunkSize * chunksCount;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT;
        var indexSize = chunkIndexSize * chunksCount;
        var index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default['default'].fill(alpha, 1.0);

        for (var i = 0; i < chunksCount; ++i) {
          var offset = i * chunkIndexSize;
          var posOffset = i * chunkSize;
          index.set(chunkIndex, offset);

          for (var j = 0; j < chunkIndexSize; ++j) {
            index[offset + j] += posOffset;
          }
        }

        this.setIndex(new THREE.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE.BufferAttribute(this._positions, VEC_SIZE));
        this.setAttribute('normal', new THREE.BufferAttribute(this._normals, VEC_SIZE));
        this.setAttribute('color', new THREE.BufferAttribute(this._colors, VEC_SIZE));
        this.setAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
      }
    }]);

    return ChunkedObjectsGeometry;
  }(RaycastableBufferGeometry);

  function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$1 = 3;

  var SimpleSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(SimpleSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$h(SimpleSpheresGeometry);

    function SimpleSpheresGeometry(spheresCount, sphereComplexity) {
      var _this;

      classCallCheck(this, SimpleSpheresGeometry);

      var sphGeometry = new THREE.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
      _this = _super.call(this, spheresCount, sphGeometry, spheresCount);
      var normals = _this._normals;
      var geoNormals = sphGeometry.attributes.normal.array;
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$1);

      for (var i = 0; i < spheresCount; ++i) {
        normals.set(geoNormals, chunkSize * VEC_SIZE$1 * i);
      }

      return _this;
    }

    createClass(SimpleSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        var tmpPos = this._tmpPositions;
        var chunkSize = this._chunkSize;
        var geoPos = this._chunkPos;

        for (var i = 0; i < chunkSize; ++i) {
          var idx = i * 3;
          tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
          tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
          tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
        }

        this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$1);

        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }]);

    return SimpleSpheresGeometry;
  }(SphereCollisionGeo(ChunkedObjectsGeometry));

  function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$2 = 3;
  var centerPos = new THREE.Vector3();
  var tmpVector = new THREE.Vector3();
  var normMtx = new THREE.Matrix3();

  var Simple2CCylindersGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(Simple2CCylindersGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$i(Simple2CCylindersGeometry);

    function Simple2CCylindersGeometry(instanceCount, polyComplexity) {
      var _this;

      classCallCheck(this, Simple2CCylindersGeometry);

      var cylGeometry = new THREE.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, 2 * instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$2);
      return _this;
    }

    createClass(Simple2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2;
        var secondOffset = firstOffset + chunkSize * VEC_SIZE$2;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        centerPos.lerpVectors(botPos, topPos, 0.5);
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
        normMtx.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE$2;
          tmpVector.fromArray(geoPos, idx);
          tmpVector.applyMatrix4(mtx1);
          tmpVector.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, firstOffset); // now shift center to get another part of the cylinder


        centerPos.sub(botPos);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE$2;
          tmpArray[idx] += centerPos.x;
          tmpArray[idx + 1] += centerPos.y;
          tmpArray[idx + 2] += centerPos.z;
        }

        this._positions.set(tmpArray, secondOffset);

        for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
          idx = _i2 * VEC_SIZE$2;
          tmpVector.fromArray(geoNorm, idx);
          tmpVector.applyMatrix3(normMtx);
          tmpVector.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, firstOffset);

        this._normals.set(tmpArray, secondOffset);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var first = 2 * itemIdx;

        get(getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, first, colorVal1);

        var second = first + 1;

        get(getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, second, colorVal2);
      }
    }]);

    return Simple2CCylindersGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_POINTS_COUNT_16BIT = 65536;
  var PTS_PER_TRIANGLE = 3;

  var CylinderBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(CylinderBufferGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$j(CylinderBufferGeometry);

    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
      var _this;

      classCallCheck(this, CylinderBufferGeometry);

      _this = _super.call(this);
      var thetaStart = 0;
      var thetaLength = 2 * Math.PI;
      _this.type = 'CylinderBufferGeometry';
      _this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded
      };
      var hasTop = openEnded === false && radiusTop > 0;
      var hasBottom = openEnded === false && radiusBottom > 0;
      var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
      var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
      var heightHalf = height / 2;
      /* eslint-disable no-magic-numbers */

      var positions = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var normals = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var indices = new THREE.Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
      /* eslint-enable no-magic-numbers */

      var uvs = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
      console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'false: Cylinder Geometry has too many vertices (65536 max).');
      var currVtxIdx = 0;
      var currFaceIdx = 0;
      var tanTheta = -(radiusBottom - radiusTop) / height; // setup cylinder data

      for (var y = 0; y <= heightSegments; y++) {
        // faces
        if (y !== heightSegments) {
          for (var i = 0; i < radialSegments; i++) {
            var v1 = currVtxIdx + i;
            var v2 = currVtxIdx + radialSegments + i;
            var v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
            var v4 = currVtxIdx + (i + 1) % radialSegments;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
            currFaceIdx++;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
            currFaceIdx++;
          }
        } // vertices


        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (var x = 0; x < radialSegments; x++) {
          var u = x / radialSegments;
          var vx = radius * Math.sin(u * thetaLength + thetaStart);
          var vy = v * height - heightHalf;
          var vz = radius * Math.cos(u * thetaLength + thetaStart);
          var normal = new THREE.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
          positions.setXYZ(currVtxIdx, vx, vy, vz);
          normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
          uvs.setXY(currVtxIdx, u, v);
          ++currVtxIdx;
        }
      } // top cap


      if (hasTop) {
        var startTIdx = currVtxIdx;
        var lastIdx = currVtxIdx + radialSegments;

        for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
          var currSrcIdx = currVtxIdx - radialSegments;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
          normals.setXYZ(currVtxIdx, 0, 1, 0);
          uvs.setXY(currVtxIdx, 1, 1);
          var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        ++currVtxIdx;
      } // bottom cap


      if (hasBottom) {
        var startBIdx = currVtxIdx;
        var lastBIdx = currVtxIdx + radialSegments;

        for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
          var currSrcBIdx = fBIdx;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
          normals.setXYZ(currVtxIdx, 0, -1, 0);
          uvs.setXY(currVtxIdx, 0, 0);
          var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
      }

      _this.setIndex(indices);

      _this.setAttribute('position', positions);

      _this.setAttribute('normal', normals);

      _this.setAttribute('uv', uvs);

      return _this;
    }

    createClass(CylinderBufferGeometry, [{
      key: "clone",
      value: function clone() {
        var parameters = this.parameters;
        return new CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
      }
    }]);

    return CylinderBufferGeometry;
  }(THREE.BufferGeometry);

  function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor$2 = new THREE.Color();
  var invMatrix = new THREE.Matrix4();
  var OFFSET_SIZE$1 = 4;
  var COLOR_SIZE$1 = 3;
  var copySubArrays$2 = utils.copySubArrays;

  function setArrayXYZ$1(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$1(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function sortNumber(a, b) {
    return a - b;
  }

  function _prepareCylinderInfo(chunkIndices) {
    chunkIndices.sort(sortNumber);
    var chunksIdx = [];
    var cylinderInfo = [];

    for (var i = 0, n = chunkIndices.length; i < n; ++i) {
      var val = chunkIndices[i];
      var even = (val | 0) % 2 === 0;
      var newPar = {
        first: false,
        second: false
      };

      if (even) {
        newPar.first = true;
        newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;

        if (newPar.second) {
          ++i;
        }
      } else {
        newPar.second = true;
      }

      chunksIdx.push(Math.floor(val / 2));
      cylinderInfo.push(newPar);
    }

    return {
      indices: chunksIdx,
      cylinderInfo: cylinderInfo
    };
  }

  function _assignOpacity(cylinderInfo, color1, color2) {
    for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
      var info = cylinderInfo[i];

      if (!info.first) {
        color1[COLOR_SIZE$1 * i] = -0.5;
      }

      if (!info.second) {
        color2[COLOR_SIZE$1 * i] = -0.5;
      }
    }
  }

  var Instanced2CCylindersGeometry = /*#__PURE__*/function (_THREE$InstancedBuffe) {
    inherits(Instanced2CCylindersGeometry, _THREE$InstancedBuffe);

    var _super = _createSuper$k(Instanced2CCylindersGeometry);

    function Instanced2CCylindersGeometry(instanceCount, polyComplexity, useZSprites, openEnded) {
      var _this;

      classCallCheck(this, Instanced2CCylindersGeometry);

      _this = _super.call(this);
      _this._useZSprites = useZSprites;
      _this._cylGeometry = useZSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, openEnded);

      _this._init(instanceCount, _this._cylGeometry, _this._useZSprites);

      _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3);
      return _this;
    }

    createClass(Instanced2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        var me = matrix.elements;
        var mtxOffset = itemIdx * OFFSET_SIZE$1;

        this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);

        setArrayXYZW$1(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
        setArrayXYZW$1(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
        setArrayXYZW$1(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);

        if (this._useZSprites) {
          invMatrix.copy(matrix).invert();
          me = invMatrix.elements;
          setArrayXYZW$1(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
          setArrayXYZW$1(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
          setArrayXYZW$1(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
        }
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var colorIdx = itemIdx * COLOR_SIZE$1;
        tmpColor$2.set(colorVal1);
        setArrayXYZ$1(this._color1, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
        tmpColor$2.set(colorVal2);
        setArrayXYZ$1(this._color2, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        this._collisionGeo.computeBoundingSphere();

        this.boundingSphere = this._collisionGeo.boundingSphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        this._collisionGeo.computeBoundingBox();

        this.boundingBox = this._collisionGeo.boundingBox;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        this._collisionGeo.raycast(raycaster, intersects);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('matVector1').needsUpdate = true;
        this.getAttribute('matVector2').needsUpdate = true;
        this.getAttribute('matVector3').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('color2').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;

        if (this._useZSprites) {
          this.getAttribute('invmatVector1').needsUpdate = true;
          this.getAttribute('invmatVector2').needsUpdate = true;
          this.getAttribute('invmatVector3').needsUpdate = true;
        }

        this._collisionGeo.finishUpdate();
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var info = _prepareCylinderInfo(chunkIndices);

        var cylinderIndices = info.indices;
        var instanceCount = cylinderIndices.length;
        var geom = new THREE.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);

        copySubArrays$2(this._matVector1, geom._matVector1, cylinderIndices, OFFSET_SIZE$1);
        copySubArrays$2(this._matVector2, geom._matVector2, cylinderIndices, OFFSET_SIZE$1);
        copySubArrays$2(this._matVector3, geom._matVector3, cylinderIndices, OFFSET_SIZE$1);

        if (this._useZSprites) {
          copySubArrays$2(this._invmatVector1, geom._invmatVector1, cylinderIndices, OFFSET_SIZE$1);
          copySubArrays$2(this._invmatVector2, geom._invmatVector2, cylinderIndices, OFFSET_SIZE$1);
          copySubArrays$2(this._invmatVector3, geom._invmatVector3, cylinderIndices, OFFSET_SIZE$1);
        }

        copySubArrays$2(this._color1, geom._color1, cylinderIndices, COLOR_SIZE$1);
        copySubArrays$2(this._color2, geom._color2, cylinderIndices, COLOR_SIZE$1);

        _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "getGeoParams",
      value: function getGeoParams() {
        return this._cylGeometry.parameters;
      }
    }, {
      key: "_init",
      value: function _init(instanceCount, cylinderGeo, useZSprites) {
        this.copy(cylinderGeo);
        this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._color1 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
        this._color2 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);

        ___default['default'].fill(alpha, 1.0);

        this.setAttribute('matVector1', new THREE.InstancedBufferAttribute(this._matVector1, OFFSET_SIZE$1, false, 1));
        this.setAttribute('matVector2', new THREE.InstancedBufferAttribute(this._matVector2, OFFSET_SIZE$1, false, 1));
        this.setAttribute('matVector3', new THREE.InstancedBufferAttribute(this._matVector3, OFFSET_SIZE$1, false, 1));
        this.setAttribute('color', new THREE.InstancedBufferAttribute(this._color1, COLOR_SIZE$1, false, 1));
        this.setAttribute('color2', new THREE.InstancedBufferAttribute(this._color2, COLOR_SIZE$1, false, 1));
        this.setAttribute('alphaColor', new THREE.InstancedBufferAttribute(this._alpha, 1, false, 1));

        if (useZSprites) {
          this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this.setAttribute('invmatVector1', new THREE.InstancedBufferAttribute(this._invmatVector1, OFFSET_SIZE$1, false, 1));
          this.setAttribute('invmatVector2', new THREE.InstancedBufferAttribute(this._invmatVector2, OFFSET_SIZE$1, false, 1));
          this.setAttribute('invmatVector3', new THREE.InstancedBufferAttribute(this._invmatVector3, OFFSET_SIZE$1, false, 1));
        }
      }
    }]);

    return Instanced2CCylindersGeometry;
  }(THREE.InstancedBufferGeometry);

  function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$3 = 3;
  var TRI_SIZE = 3;
  var tmpPrev = new THREE.Vector3();
  var tmpNext = new THREE.Vector3();
  var tmpRes = new THREE.Vector3();
  var simpleNormal = new THREE.Vector3(1.0, 0.0, 0.0);
  var normalOnCut = new THREE.Vector3();
  var nearRingPt = new THREE.Vector3();

  function _createExtrudedChunkGeometry(shape, ringsCount) {
    var geo = new THREE.BufferGeometry();
    var ptsCount = shape.length;
    var totalPts = ptsCount * ringsCount;
    var type = totalPts <= 65536 ? Uint16Array : Uint32Array;
    var facesPerChunk = (ringsCount - 1) * ptsCount * 2;
    var indices = new THREE.BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
    var currVtxIdx = 0;
    var currFaceIdx = 0;

    for (var y = 0; y < ringsCount; y++) {
      // faces
      if (y !== ringsCount - 1) {
        for (var i = 0; i < ptsCount; i++) {
          var v1 = currVtxIdx + i;
          var v2 = currVtxIdx + ptsCount + i;
          var v3 = currVtxIdx + ptsCount + (i + 1) % ptsCount;
          var v4 = currVtxIdx + (i + 1) % ptsCount;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
          currFaceIdx++;
        }
      }

      currVtxIdx += ptsCount;
    }

    geo.setIndex(indices);
    var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, VEC_SIZE$3));
    geo._positions = shape;
    return geo;
  }

  var ExtrudedObjectsGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(ExtrudedObjectsGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$l(ExtrudedObjectsGeometry);

    function ExtrudedObjectsGeometry(shape, ringsCount, chunksCount) {
      var _this;

      classCallCheck(this, ExtrudedObjectsGeometry);

      var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);

      _this = _super.call(this, chunkGeo, chunksCount);
      _this._ringsCount = ringsCount;
      var tmpShape = _this._tmpShape = [];

      for (var i = 0; i < shape.length; ++i) {
        tmpShape[i] = new THREE.Vector3();
      }

      return _this;
    }

    createClass(ExtrudedObjectsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, matrices) {
        var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var ptsCount = this._chunkGeo._positions.length;
        var ringsCount = this._ringsCount;
        var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$3;

        this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);

        if (hasSlope) {
          this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
        } else {
          this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
        }

        if (hasCut) {
          this._addCut(ptsCount, ringsCount, chunkStartIdx);
        }
      }
    }, {
      key: "_setPoints",
      value: function _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
        var tmpShape = this._tmpShape;
        var positions = this._positions;
        var shape = this._chunkGeo._positions;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i) {
          var mtx = matrices[i];

          for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
            tmpShape[j].copy(shape[j]).applyMatrix4(mtx).toArray(positions, vtxIdx);
          }
        }
      }
    }, {
      key: "_setBaseNormals",
      value: function _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
        var nPtsInRing = ptsCount * VEC_SIZE$3;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, false);
        }
      }
    }, {
      key: "_setSlopeNormals",
      value: function _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
        var normals = this._normals;
        var nPtsInRing = ptsCount * VEC_SIZE$3;
        var vtxIdx = chunkStartIdx; // First ring
        // In all cases, besides cut, second ring is coincident to first. So values of first ring's normals doesn't
        // matter (In the cut case special handler will be applied later and will set them to correct values)

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
          simpleNormal.toArray(normals, vtxIdx);
        } // second ring
        // If it isn't first Item we take normals' values from the last ring of the previous item (these rings are coincident)
        // else we count normals' values based on next ring information


        if (vtxIdx - 2 * nPtsInRing > 0) {
          for (var _j = 0; _j < ptsCount; ++_j, vtxIdx += VEC_SIZE$3) {
            tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
          }
        } else {
          this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);

          vtxIdx += nPtsInRing;
        } // other rings
        // we count normals' values based on previous ring information


        for (var i = 2; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
        }
      } // Counting normals:
      // - Slope
      //   Radius changes throught part => normals aren't parallel with the plane contains section points
      //   normal = vTangentInSectionPlane x vToSuchPointInPrevSection (all vectors are scaled for being 1 in length)
      // - No slope
      //   Radius doesn't change throught part => normals are parallel with the plane contains section points
      //   normal = vToPrevPointInSection + vToNextPointInSection (all vectors are scaled for being 1 in length)

    }, {
      key: "_countNormalsInRing",
      value: function _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
        var tmpShape = this._tmpShape;
        var normals = this._normals;
        tmpShape[0].fromArray(this._positions, vtxIdx);
        tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * VEC_SIZE$3);

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
          if (j < ptsCount - 1) {
            tmpShape[j + 1].fromArray(this._positions, vtxIdx + VEC_SIZE$3);
          }

          if (isSlope) {
            nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
            tmpPrev.subVectors(tmpShape[(j + ptsCount - 1) % ptsCount], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], nearRingPt).normalize();
            tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
          } else {
            tmpPrev.subVectors(tmpShape[j], tmpShape[(j + ptsCount - 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
          }
        }
      }
    }, {
      key: "_addCut",
      value: function _addCut(ptsCount, ringsCount, chunkStartIdx) {
        // Nothing to do if item is flat or only line
        if (ptsCount < 3 || ringsCount < 2) {
          return;
        }

        var positions = this._positions;
        var normals = this._normals;
        var tmpShape = this._tmpShape;
        var nPtsInRing = ptsCount * VEC_SIZE$3; // Normal to the cut plane is equal to cross product of two vectors which are lying in it

        tmpShape[0].fromArray(positions, chunkStartIdx);
        tmpShape[1].fromArray(positions, chunkStartIdx + VEC_SIZE$3);
        tmpShape[2].fromArray(positions, chunkStartIdx + 2 * VEC_SIZE$3);
        tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
        tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
        normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
        var vtxIdx = chunkStartIdx; // First and second rings normals' values are equal to value of normal to the cutting plane

        for (var j = 0; j < ptsCount * 2; ++j, vtxIdx += VEC_SIZE$3) {
          normalOnCut.toArray(normals, vtxIdx);
        }

        if (ringsCount > 2) {
          // Third ring points are coincident to first ring points, but have different normals. It makes sharp angle near cut
          for (var _j2 = 0; _j2 < ptsCount; ++_j2, vtxIdx += VEC_SIZE$3) {
            tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
          }
        }
      }
    }]);

    return ExtrudedObjectsGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT$1 = 65535;
  var VERTEX_PER_SEGMENT = 4;
  var POS_SIZE = 4;
  var DIR_SIZE = 3;
  var COL_SIZE = 3;
  var tmpColor$3 = new THREE.Color();
  var direction = new THREE.Vector3();

  function setArrayXYZ$2(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$2(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
    var start = startSegmentIdx * VERTEX_PER_SEGMENT;
    var end = start + segmentsCount * VERTEX_PER_SEGMENT;
    return arr.subarray(start * elemSize, end * elemSize);
  }
  /**
   * This class represents lines geometry which consists of screen-aligned narrow quad of variable width.
   *
   * @constructor
   *
   * @param {number}  segmentsCount   Number of segments per chunk.
   * collision geometry.
   */


  var ThickLinesGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(ThickLinesGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$m(ThickLinesGeometry);

    function ThickLinesGeometry(segmentsCount) {
      var _this;

      classCallCheck(this, ThickLinesGeometry);

      _this = _super.call(this);

      _this._initVertices(segmentsCount);

      return _this;
    }

    createClass(ThickLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;
        this.getAttribute('direction').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(segmentIdx, colorVal) {
        tmpColor$3.set(colorVal);
        var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
      }
    }, {
      key: "setSegment",
      value: function setSegment(segmentIdx, pos1, pos2) {
        direction.subVectors(pos1, pos2);
        direction.normalize();
        var positions = this._positions;
        var directions = this._directions;
        var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
        var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(startSegIdx, endSegIdx, value) {
        var start = startSegIdx * VERTEX_PER_SEGMENT;
        var end = endSegIdx * VERTEX_PER_SEGMENT;

        ___default['default'].fill(this.alpha, value, end, start);

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubsetSegments",
      value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
        return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
      }
    }, {
      key: "getSubsetColors",
      value: function getSubsetColors(startSegmentIdx, segmentsCount) {
        return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
      }
    }, {
      key: "getSubsetOpacities",
      value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
        return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
      }
    }, {
      key: "getNumVertexPerSegment",
      value: function getNumVertexPerSegment() {
        return VERTEX_PER_SEGMENT;
      }
    }, {
      key: "getPositionSize",
      value: function getPositionSize() {
        return POS_SIZE;
      }
    }, {
      key: "setSegments",
      value: function setSegments(startSegmentIdx, positions) {
        var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;

        if (positions instanceof Array && positions.length === 2) {
          this._positions.set(positions[0], startPos);

          var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;

          this._directions.set(positions[1], startDir); // dirs are geo part of vertex

        } else {
          this._positions.set(positions, startPos);
        }
      }
    }, {
      key: "setColors",
      value: function setColors(startSegmentIdx, colors) {
        var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;

        this._colors.set(colors, start);
      }
    }, {
      key: "_initVertices",
      value: function _initVertices(segmentsCount) {
        this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
        var pointsCount = this._buffersSize;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT$1;
        this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
        this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default['default'].fill(alpha, 1.0);

        var index = this._index;
        var indexOffset = 0;
        var pointOffset = 0;

        for (var j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
          index[indexOffset] = pointOffset;
          index[indexOffset + 1] = pointOffset + 1;
          index[indexOffset + 2] = pointOffset + 3;
          index[indexOffset + 3] = pointOffset;
          index[indexOffset + 4] = pointOffset + 2;
          index[indexOffset + 5] = pointOffset + 3;
        }

        this.setIndex(new THREE.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE.BufferAttribute(this._positions, POS_SIZE));
        this.setAttribute('color', new THREE.BufferAttribute(this._colors, COL_SIZE));
        this.setAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
        this.setAttribute('direction', new THREE.BufferAttribute(this._directions, DIR_SIZE));
      }
    }]);

    return ThickLinesGeometry;
  }(THREE.BufferGeometry);

  function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This class represents geometry which consists lines. This can build bounding volumes
   * @constructor
   *
   * @param {number}  segmentsCount   Number of segments per chunk.
   */

  var LinesGeometry = /*#__PURE__*/function (_BaseLinesGeometry) {
    inherits(LinesGeometry, _BaseLinesGeometry);

    var _super = _createSuper$n(LinesGeometry);

    function LinesGeometry() {
      classCallCheck(this, LinesGeometry);

      return _super.apply(this, arguments);
    }

    createClass(LinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var boundingBox = this.boundingBox; // Build bounding sphere

        var radiusSquared = 0.0;
        var center = new THREE.Vector3();

        if (boundingBox) {
          boundingBox.getCenter(center);
        }

        var positions = this._positions;
        var sphere = this.boundingSphere || new THREE.Sphere();
        var size = this._positions.length;
        var pos = new THREE.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          pos.set(positions[i], positions[i + 1], positions[i + 2]);
          var lengthSquared = center.distanceToSquared(pos);

          if (radiusSquared < lengthSquared) {
            radiusSquared = lengthSquared;
          }
        }

        sphere.set(center, Math.sqrt(radiusSquared));
        this.boundingSphere = sphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var positions = this._positions;
        var box = new THREE.Box3();
        var size = this._positions.length;
        var tmpVec = new THREE.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          tmpVec.set(positions[i], positions[i + 1], positions[i + 2]);
          box.expandByPoint(tmpVec);
        }

        this.boundingBox = box;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }]);

    return LinesGeometry;
  }(ThickLinesGeometry);

  function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$4 = 3;
  var tmpVector$1 = new THREE.Vector3();
  var normMtx$1 = new THREE.Matrix3();

  var CylinderCollisionGeo = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(CylinderCollisionGeo, _ChunkedObjectsGeomet);

    var _super = _createSuper$o(CylinderCollisionGeo);

    function CylinderCollisionGeo(instanceCount, polyComplexity) {
      var _this;

      classCallCheck(this, CylinderCollisionGeo);

      var cylGeometry = new THREE.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$4);
      return _this;
    }

    createClass(CylinderCollisionGeo, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var itemOffset = chunkSize * itemIdx * VEC_SIZE$4;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        normMtx$1.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE$4;
          tmpVector$1.fromArray(geoPos, idx);
          tmpVector$1.applyMatrix4(mtx1);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, itemOffset);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE$4;
          tmpVector$1.fromArray(geoNorm, idx);
          tmpVector$1.applyMatrix3(normMtx$1);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, itemOffset);
      }
    }]);

    return CylinderCollisionGeo;
  }(ChunkedObjectsGeometry);

  function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD = 0.1;
  /**
   * This class represents geometry which consists of separate chunks.
   * Each chunk has same index and similar geometry with equal points and faces count.
   * Each chunk has by default only one color.
   * @constructor
   *
   * @param {number}  chunksCount     Total chunks count.
   * @param {number}  segmentsCount   Number of segments per chunk.
   * @param {boolean} enableCollision Enable or disable collision where each segment is
   *                                  a collidable cylinder.
   * collision geometry.
   */

  var ChunkedLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    inherits(ChunkedLinesGeometry, _LinesGeometry);

    var _super = _createSuper$p(ChunkedLinesGeometry);

    function ChunkedLinesGeometry(chunksCount, segmentsCount, enableCollision) {
      var _this;

      classCallCheck(this, ChunkedLinesGeometry);

      _this = _super.call(this, chunksCount * segmentsCount);

      _this._init(segmentsCount);

      _this._collisionGeo = enableCollision ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
      return _this;
    }

    createClass(ChunkedLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingSphere();
          this.boundingSphere = collisionGeo.boundingSphere;
          return;
        }

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingSphere", this).call(this);
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingBox();
          this.boundingBox = collisionGeo.boundingBox;
          return;
        }

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingBox", this).call(this);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var collisionGeo = this._collisionGeo;

        if (!collisionGeo) {
          return;
        }

        var segCount = this._chunkSize;

        this._collisionGeo.raycast(raycaster, intersects);

        for (var i = 0, n = intersects.length; i < n; ++i) {
          var chunkIdx = intersects[i].chunkIdx;

          if (chunkIdx === undefined) {
            continue;
          }

          chunkIdx = chunkIdx / segCount | 0;
          intersects[i].chunkIdx = chunkIdx;
        }
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setColor", this).call(this, i, colorVal);
        }
      }
    }, {
      key: "setSegment",
      value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
        var chunkSize = this._chunkSize;
        var idx = chunkIdx * chunkSize + segIdx;

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setSegment", this).call(this, idx, pos1, pos2);

        if (this._collisionGeo) {
          this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setOpacity", this).call(this, left, left + chunkSize - 1, value);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var chunkSize = this._chunkSize;
        var subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false);

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var startSegIdx = chunkIndices[i] * chunkSize;
          subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
          subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(chunkSize) {
        this._chunkSize = chunkSize;
      }
    }]);

    return ChunkedLinesGeometry;
  }(LinesGeometry);

  function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD$1 = 0.3;
  var tmpVector$2 = new THREE.Vector3();

  var TwoColorLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    inherits(TwoColorLinesGeometry, _LinesGeometry);

    var _super = _createSuper$q(TwoColorLinesGeometry);

    function TwoColorLinesGeometry(segmentsCount) {
      var _this;

      classCallCheck(this, TwoColorLinesGeometry);

      _this = _super.call(this, segmentsCount * 2);

      _this._init(segmentsCount);

      _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3);
      return _this;
    }

    createClass(TwoColorLinesGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos) {
        this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD$1);

        var offset = 2 * itemIdx; // there are two points per segment

        tmpVector$2.lerpVectors(botPos, topPos, 0.5);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset, botPos, tmpVector$2);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset + 1, tmpVector$2, topPos);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var offset = 2 * itemIdx; // there are two points per segment

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset, colorVal1);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset + 1, colorVal2);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (this._collisionGeo) {
          this._collisionGeo.raycast(raycaster, intersects);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(segmentIndices) {
        var instanceCount = segmentIndices.length;
        var subset = new TwoColorLinesGeometry(instanceCount, false);

        for (var i = 0, n = instanceCount; i < n; ++i) {
          var startSegIdx = segmentIndices[i];
          subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1));
          subset.setColors(i, this.getSubsetColors(startSegIdx, 1));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(segmentsCount) {
        this._segCounts = segmentsCount * 2;
      }
    }]);

    return TwoColorLinesGeometry;
  }(LinesGeometry); // (???)parent = LinesGeometry.prototype;

  function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
  var vecCount = vectors.length;
  var tempPos1 = new THREE.Vector3();
  var tempPos2 = new THREE.Vector3();

  var CrossGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(CrossGeometry, _SphereCollisionGeo);

    var _super = _createSuper$r(CrossGeometry);

    function CrossGeometry(chunksCount) {
      classCallCheck(this, CrossGeometry);

      return _super.call(this, chunksCount, chunksCount, vecCount / 2 | 0, false);
    }

    createClass(CrossGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        this.setSphere(itemIdx, itemPos, itemRad);

        for (var i = 0; i < vecCount / 2; ++i) {
          var first = i * 2;
          tempPos1.x = itemPos.x + vectors[first].x * itemRad;
          tempPos1.y = itemPos.y + vectors[first].y * itemRad;
          tempPos1.z = itemPos.z + vectors[first].z * itemRad;
          var second = first + 1;
          tempPos2.x = itemPos.x + vectors[second].x * itemRad;
          tempPos2.y = itemPos.y + vectors[second].y * itemRad;
          tempPos2.z = itemPos.z + vectors[second].z * itemRad;
          this.setSegment(itemIdx, i, tempPos1, tempPos2);
        }
      }
    }]);

    return CrossGeometry;
  }(SphereCollisionGeo(ChunkedLinesGeometry));

  function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var POS_RAD_SIZE = 4;
  var COLOR_SIZE$2 = 3;
  var tmpColor$4 = new THREE.Color();
  /**
   * This is a base class for isosurface algorithms.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var IsoSurfaceGeometry = /*#__PURE__*/function (_RaycastableBufferGeo) {
    inherits(IsoSurfaceGeometry, _RaycastableBufferGeo);

    var _super = _createSuper$s(IsoSurfaceGeometry);

    function IsoSurfaceGeometry(spheresCount, opts) {
      var _this;

      classCallCheck(this, IsoSurfaceGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.zClip = _this._opts.zClip;
      _this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
      _this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$2);
      return _this;
    }

    createClass(IsoSurfaceGeometry, [{
      key: "setItem",
      value: function setItem(chunkIdx, pos, radius) {
        var posRad = this._posRad;
        var idx = POS_RAD_SIZE * chunkIdx;
        posRad[idx++] = pos.x;
        posRad[idx++] = pos.y;
        posRad[idx++] = pos.z;
        posRad[idx] = radius;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor$4.set(colorVal);
        var colors = this._colors;
        var idx = COLOR_SIZE$2 * chunkIdx;
        colors[idx++] = tmpColor$4.r;
        colors[idx++] = tmpColor$4.g;
        colors[idx] = tmpColor$4.b;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this._build();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity() {// not implemented
      }
    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return IsoSurfaceGeometry;
  }(RaycastableBufferGeometry);

  /**
   * Class for marching cube
   * Stores 8 points and 8 float values are stored together in linear array
   * Int values for has intersection or not - in integer32 linear array
   * Int values for bits flags - in integer32 linear array
   *
   */

  var IsoSurfaceMarchCube = /*#__PURE__*/function () {
    function IsoSurfaceMarchCube() {
      classCallCheck(this, IsoSurfaceMarchCube);

      this.pointsValuesLinear = null;
      this.hasIntersection = null;
      this.bitsInside = null;
    }

    createClass(IsoSurfaceMarchCube, [{
      key: "create",
      value: function create(numCellsPerSide) {
        var vx7000000 = 0x7000000;
        var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;

        if (n3 > vx7000000) {
          throw new Error('Too large cube dimension: lead to memory huge uasge');
        }

        this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
        this.hasIntersection = utils.allocateTyped(Int32Array, n3);
        this.bitsInside = utils.allocateTyped(Int32Array, n3);
        return 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.bitsInside = null;
        this.hasIntersection = null;
        this.pointsValuesLinear = null;
      }
    }]);

    return IsoSurfaceMarchCube;
  }();
  /* eslint-disable no-magic-numbers */


  IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];

  var edgeTable = [0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0];

  function _voxelGradientFast(v, point, grad) {
    var g = v.getValue(point.x, point.y, point.z);
    grad.set(g[0], g[1], g[2]);
  } // Helper class GridCell


  var GridCell = function GridCell() {
    classCallCheck(this, GridCell);

    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);

    for (var i = 0; i < this._arrSize; ++i) {
      this.p[i] = new THREE.Vector3();
      this.g[i] = new THREE.Vector3();
    }

    this.cubeIndex = 0;
  }; // Helper class Triangle


  var Triangle = function Triangle() {
    classCallCheck(this, Triangle);

    this.a = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.b = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.c = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
  };

  function createArray(arrSize) {
    var arr = new Array(arrSize);

    for (var i = 0; i < arrSize; ++i) {
      arr[i] = new THREE.Vector3();
    }

    return arr;
  }

  var IsoSurface = /*#__PURE__*/function () {
    function IsoSurface() {
      classCallCheck(this, IsoSurface);

      this._numTriangles = 0;
      this._numVertices = 0;
      this._position = [];
      this._normals = [];
      this._colors = null;
      this._indices = [];
      this._volumetricData = null;
      this._xAxis = new THREE.Vector3();
      this._yAxis = new THREE.Vector3();
      this._zAxis = new THREE.Vector3();
      this._xDir = new THREE.Vector3();
      this._yDir = new THREE.Vector3();
      this._zDir = new THREE.Vector3();
    }

    createClass(IsoSurface, [{
      key: "_prepareAxesAndDirs",
      value: function _prepareAxesAndDirs() {
        var volData = this._volumetricData;
        var cellSize = volData.getCellSize(); // calculate cell axes

        var xAxis = this._xAxis;
        var yAxis = this._yAxis;
        var zAxis = this._zAxis;
        var xDir = this._xDir;
        var yDir = this._yDir;
        var zDir = this._zDir;
        xAxis.set(cellSize.x, 0, 0);
        yAxis.set(0, cellSize.y, 0);
        zAxis.set(0, 0, cellSize.z);
        xDir.set(1, 0, 0);
        yDir.set(0, 1, 0);
        zDir.set(0, 0, 1); // flip normals if coordinate system is in the wrong handedness

        var tmp = new THREE.Vector3();
        tmp.crossVectors(xDir, yDir);

        if (tmp.dot(zDir) < 0) {
          xDir.negate();
          yDir.negate();
          zDir.negate();
        } // check that the grid is in the all-positive octant of the coordinate system


        if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
          return false;
        } // check that the grid is axis-aligned


        var notZero = function notZero(axe) {
          return Math.abs(axe) > Number.EPSILON;
        };

        return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
      }
    }, {
      key: "_vertexInterp",
      value: function _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
        var p1 = grid.p[ind1];
        var p2 = grid.p[ind2];
        var n1 = grid.g[ind1];
        var n2 = grid.g[ind2];
        var valP1 = grid.val[ind1];
        var valP2 = grid.val[ind2];
        var isoDiffP1 = isoLevel - valP1;
        var diffValP2P1 = valP2 - valP1;
        var mu = 0.0;

        if (Math.abs(diffValP2P1) > 0.0) {
          mu = isoDiffP1 / diffValP2P1;
        }

        mu = mu > 1.0 ? 1.0 : mu;
        vertex.lerpVectors(p1, p2, mu);
        normal.lerpVectors(n1, n2, mu);
      }
    }, {
      key: "_polygonize",
      value: function _polygonize(grid, isoLevel, triangles) {
        var cubeIndex = grid.cubeIndex;
        var i = 0;
        var arrSize = IsoSurface._arrSize;
        var firstIndices = IsoSurface._firstIndices;
        var secondIndices = IsoSurface._secondIndices;
        var vertexList = IsoSurface._vertexList;
        var normalList = IsoSurface._normalList;

        for (; i < arrSize; ++i) {
          if (edgeTable[cubeIndex] & 1 << i) {
            this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
          }
        }

        var triCount = 0;
        var triTblIdx = cubeIndex * 16;
        var triTable = IsoSurface._triTable;

        for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
          triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
          triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);
          triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
          triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
          ++triCount;
        }

        return triCount;
      }
    }, {
      key: "_doGridPosNorms",
      value: function _doGridPosNorms(isoValue, step, appendSimple) {
        var vol = this._volumetricData;

        var volData = this._volumetricData.getData();

        var dim = vol.getDimensions();
        var xSize = dim[0];
        var ySize = dim[1];
        var zSize = dim[2];
        var stepX = step * vol.getStrideX();
        var stepY = step * vol.getStrideY();
        var stepZ = step * vol.getStrideZ();
        var gc = new GridCell();
        var gcVal = gc.val;
        var gcValSize = gc.val.length;
        var additions = [new THREE.Vector3(0, 0, 0), // 0
        new THREE.Vector3(step, 0, 0), // 1
        new THREE.Vector3(step, step, 0), // 2
        new THREE.Vector3(0, step, 0), // 3
        new THREE.Vector3(0, 0, step), // 4
        new THREE.Vector3(step, 0, step), // 5
        new THREE.Vector3(step, step, step), // 6
        new THREE.Vector3(0, step, step) // 7
        ];
        var tmpTriCount = 5;
        var triangles = new Array(tmpTriCount);

        for (var j = 0; j < tmpTriCount; ++j) {
          triangles[j] = new Triangle();
        }

        var appendVertex;
        var self = this;
        var positions = this._position;
        var normals = this._normals;

        if (appendSimple) {
          // Special case for axis-aligned grid with positive unit vector normals
          appendVertex = function () {
            var axis = new THREE.Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
            return function (triVertex) {
              var vertex = triVertex.p.clone();
              vertex.multiply(axis);
              positions.push(vertex.add(self._origin));
              normals.push(triVertex.n.clone());
            };
          }();
        } else {
          appendVertex = function () {
            var posMtx = new THREE.Matrix3();
            posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
            var normMtx = new THREE.Matrix3();
            normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);
            return function (triVertex) {
              positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self._origin));
              normals.push(triVertex.n.clone().applyMatrix3(normMtx));
            };
          }();
        }

        var indices = this._indices;
        var globTriCount = 0;

        for (var z = 0; z < zSize - step; z += step) {
          for (var y = 0; y < ySize - step; y += step) {
            var idx = vol.getDirectIdx(0, y, z);

            for (var x = 0; x < xSize - step; x += step, idx += stepX) {
              /* eslint-disable no-multi-spaces */

              /* eslint-disable computed-property-spacing */
              gcVal[0] = volData[idx];
              gcVal[1] = volData[idx + stepX];
              gcVal[3] = volData[idx + stepY];
              gcVal[2] = volData[idx + stepX + stepY];
              gcVal[4] = volData[idx + stepZ];
              gcVal[5] = volData[idx + stepX + stepZ];
              gcVal[7] = volData[idx + stepY + stepZ];
              gcVal[6] = volData[idx + stepX + stepY + stepZ];
              /* eslint-enable no-multi-spaces */

              /* eslint-enable computed-property-spacing */
              // Determine the index into the edge table which
              // tells us which vertices are inside of the surface

              var cubeIndex = 0;
              var i = 0;

              for (; i < gcValSize; ++i) {
                if (gcVal[i] < isoValue) {
                  cubeIndex |= 1 << i;
                }
              }

              if (edgeTable[cubeIndex] === 0) {
                continue;
              }

              gc.cubeIndex = cubeIndex;

              for (i = 0; i < gcValSize; ++i) {
                gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);

                _voxelGradientFast(this._gradient, gc.p[i], gc.g[i]);
              } // calculate vertices and facets for this cube,
              // calculate normals by interpolating between the negated
              // normalized volume gradients for the 8 reference voxels


              var triCount = this._polygonize(gc, isoValue, triangles);

              globTriCount += triCount; // append triangles using different techniques

              for (i = 0; i < triCount; ++i) {
                indices.push(this._numTriangles * 3);
                indices.push(this._numTriangles * 3 + 1);
                indices.push(this._numTriangles * 3 + 2);
                ++this._numTriangles;
                appendVertex(triangles[i].a);
                appendVertex(triangles[i].b);
                appendVertex(triangles[i].c);
              }
            }
          }
        }

        return globTriCount;
      }
    }, {
      key: "compute",
      value: function compute(volData, origin, isoValue, step) {
        this._volumetricData = volData;
        this._origin = origin;
        this._gradient = volData.computeGradient();

        this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
      }
    }, {
      key: "_remapIndices",
      value: function _remapIndices(vertexMap, idcCount) {
        var indices = this._indices;
        var newIndices = utils.allocateTyped(Uint32Array, idcCount);

        for (var i = 0; i < idcCount; ++i) {
          indices[i] = vertexMap[indices[i]];
          newIndices[i] = indices[i];
        }

        this._indices = newIndices;
      }
    }, {
      key: "_remapVertices",
      value: function _remapVertices(vertices, normals, count) {
        var newPositions = utils.allocateTyped(Float32Array, count * 3);
        var newNormals = utils.allocateTyped(Float32Array, count * 3);

        for (var i = 0; i < count; ++i) {
          var pos = vertices[i];
          newPositions[i * 3] = pos.x;
          newPositions[i * 3 + 1] = pos.y;
          newPositions[i * 3 + 2] = pos.z;
          var norm = normals[i].normalize();
          newNormals[i * 3] = norm.x;
          newNormals[i * 3 + 1] = norm.y;
          newNormals[i * 3 + 2] = norm.z;
        }

        this._position = newPositions;
        this._normals = newNormals;
      }
    }, {
      key: "vertexFusion",
      value: function vertexFusion(offset, len) {
        var faceVer = this._indices.length;
        var vertices = this._position;
        var normals = this._normals;
        var oldVerCount = vertices.length | 0;

        if (faceVer === 0 || oldVerCount === 0) {
          return;
        }

        var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
        vMap[0] = 0;
        var newVer = 1;
        var i = 1;

        for (; i < oldVerCount; ++i) {
          var start = newVer - offset < 0 ? 0 : newVer - offset;
          var end = start + len > newVer ? newVer : start + len;
          var matchedIndex = -1;

          for (var j = start; j < end; ++j) {
            if (Math.abs(vertices[i] - vertices[j]) < Number.EPSILON) {
              matchedIndex = j;
              break;
            }
          }

          if (matchedIndex !== -1) {
            vMap[i] = matchedIndex;
          } else {
            vertices[newVer].copy(vertices[i]);
            normals[newVer].copy(normals[i]);
            vMap[i] = newVer;
            ++newVer;
          }
        }

        this._remapIndices(vMap, faceVer);

        this._remapVertices(vertices, normals, newVer);
      } // Assign per-vertex colors from a volumetric texture map (same dimensions as the original volumetric data).
      // Along with color dominating atom is determined for each vertex
      // and vertices with atom out of "visible" subset get filtered out.
      // XXX only handles orthogonal volumes currently

    }, {
      key: "setColorVolTex",
      value: function setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
        var i;
        var idx;
        var numVerts = this._position.length / 3;
        var vertices = this._position;
        var origin = this._origin;

        var dim = this._volumetricData.getDimensions();

        var xs = dim[0] - 1;
        var ys = dim[1] - 1;
        var zs = dim[2] - 1;
        var colorData = colorMap.getData();
        var strideX = colorMap.getStrideX();
        var strideY = colorMap.getStrideY();
        var strideZ = colorMap.getStrideZ();
        var atomWeightData;
        var atomStrideX;
        var atomStrideY;
        var atomStrideZ;

        if (visibilitySelector !== null) {
          atomWeightData = atomWeightMap.getData();
          atomStrideX = atomWeightMap.getStrideX();
          atomStrideY = atomWeightMap.getStrideY();
          atomStrideZ = atomWeightMap.getStrideZ();
        }

        var xInv = 1.0 / this._xAxis.x;
        var yInv = 1.0 / this._yAxis.y;
        var zInv = 1.0 / this._zAxis.z;
        var atomLookup = [];
        var atomWeights = [];
        var colors = utils.allocateTyped(Float32Array, numVerts * 3);

        function interp(mu, idx1, idx2, c) {
          c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
          c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
          c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
        }

        function collectWeight(ai, coefX, coefY, coefZ) {
          var a = atomMap[ai]; // atomWeightMap is a scalar field, so index into atom map should be the same

          if (a != null) {
            atomLookup[a.index] = a;
            var w = coefX * coefY * coefZ * atomWeightData[ai];

            if (typeof atomWeights[a.index] === 'undefined') {
              atomWeights[a.index] = w;
            } else {
              atomWeights[a.index] += w;
            }
          }
        }

        var vMap = utils.allocateTyped(Int32Array, numVerts);
        var newVerCount = 0;

        for (i = 0; i < numVerts; i++) {
          var ind = i * 3;
          var vx = (vertices[ind] - origin.x) * xInv;
          var vy = (vertices[ind + 1] - origin.y) * yInv;
          var vz = (vertices[ind + 2] - origin.z) * zInv;
          var x = Math.min(Math.max(vx, 0), xs) | 0;
          var y = Math.min(Math.max(vy, 0), ys) | 0;
          var z = Math.min(Math.max(vz, 0), zs) | 0;
          var mux = vx - x;
          var muy = vy - y;
          var muz = vz - z;

          if (visibilitySelector != null) {
            // collect atom weights
            atomLookup = [];
            atomWeights = [];
            idx = atomWeightMap.getDirectIdx(x, y, z);
            collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
            collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
            collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
            collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
            collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
            collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz); // find dominant atom

            var maxWeight = 0.0;
            var dominantIdx = -1;

            for (var atomIdx in atomWeights) {
              if (atomWeights[atomIdx] > maxWeight) {
                dominantIdx = atomIdx;
                maxWeight = atomWeights[atomIdx];
              }
            }

            if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
              // this vertex doesn't belong to visible subset and will be skipped
              vMap[i] = -1;
              continue;
            }
          }

          vMap[i] = newVerCount++; // color tri-linear interpolation

          var dx = x < xs ? strideX : 0;
          var dy = y < ys ? strideY : 0;
          var dz = z < zs ? strideZ : 0;
          var c0 = [0, 0, 0];
          var c1 = [0, 0, 0];
          var c2 = [0, 0, 0];
          var c3 = [0, 0, 0];
          idx = colorMap.getDirectIdx(x, y, z);
          interp(mux, idx, idx + dx, c0);
          interp(mux, idx + dy, idx + dx + dy, c1);
          interp(mux, idx + dz, idx + dx + dz, c2);
          interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
          var cz0 = [0, 0, 0];
          cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
          cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
          cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
          var cz1 = [0, 0, 0];
          cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
          cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
          cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
          colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
          colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
          colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
        }

        this._colors = colors;

        if (visibilitySelector != null) {
          // shift visible vertices towards beginning of array
          for (i = 0; i < numVerts; ++i) {
            var j = vMap[i];

            if (j < 0) {
              continue;
            } // assert: j <= i


            this._position[j * 3] = this._position[i * 3];
            this._position[j * 3 + 1] = this._position[i * 3 + 1];
            this._position[j * 3 + 2] = this._position[i * 3 + 2];
            this._normals[j * 3] = this._normals[i * 3];
            this._normals[j * 3 + 1] = this._normals[i * 3 + 1];
            this._normals[j * 3 + 2] = this._normals[i * 3 + 2];
            this._colors[j * 3] = this._colors[i * 3];
            this._colors[j * 3 + 1] = this._colors[i * 3 + 1];
            this._colors[j * 3 + 2] = this._colors[i * 3 + 2];
          } // rebuild index list


          var numTriangles = this._indices.length / 3;
          var newTriCount = 0;

          for (i = 0; i < numTriangles; ++i) {
            var i0 = vMap[this._indices[3 * i]];
            var i1 = vMap[this._indices[3 * i + 1]];
            var i2 = vMap[this._indices[3 * i + 2]];

            if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
              this._indices[3 * newTriCount] = i0;
              this._indices[3 * newTriCount + 1] = i1;
              this._indices[3 * newTriCount + 2] = i2;
              ++newTriCount;
            }
          } // shrink arrays to data size


          this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
          this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
          this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
          this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
        }
      }
    }, {
      key: "toMesh",
      value: function toMesh() {
        var geo = new THREE.BufferGeometry();
        geo.setIndex(new THREE.BufferAttribute(this._indices, 1));
        geo.setAttribute('position', new THREE.BufferAttribute(this._position, 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(this._normals, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(this._colors, 3));
        geo.computeBoundingSphere();
        return geo;
      }
    }]);

    return IsoSurface;
  }();

  defineProperty(IsoSurface, "_triTable", IsoSurfaceMarchCube.prototype.striIndicesMarchCube);

  defineProperty(IsoSurface, "_arrSize", 12);

  defineProperty(IsoSurface, "_firstIndices", [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]);

  defineProperty(IsoSurface, "_secondIndices", [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]);

  defineProperty(IsoSurface, "_vertexList", createArray(IsoSurface._arrSize));

  defineProperty(IsoSurface, "_normalList", createArray(IsoSurface._arrSize));

  function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This is a base class for volumetric maps based isosurface algorithms.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var VolumeSurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    inherits(VolumeSurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$t(VolumeSurfaceGeometry);

    function VolumeSurfaceGeometry() {
      classCallCheck(this, VolumeSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(VolumeSurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        var params = this._opts;
        this.numVoxels = [128, 128, 128];
        this.xAxis = new THREE.Vector3(1.0, 0.0, 0.0);
        this.yAxis = new THREE.Vector3(0.0, 1.0, 0.0);
        this.zAxis = new THREE.Vector3(0.0, 0.0, 1.0);
        this.origin = new THREE.Vector3(0.0, 0.0, 0.0);
        this._visibilitySelector = params.visibilitySelector;

        this._calcSurface(params);
      }
    }, {
      key: "_findMinMax",
      value: function _findMinMax(posRadArray) {
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;
        var maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
        var minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];

        for (var i = 1; i < itemsCount; ++i) {
          var ind = i * itemSize;

          for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
            var tmpVal = posRadArray[ind + itemIdx];
            maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
            minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
          }
        }

        return {
          maxPosRad: maxPosRad,
          minPosRad: minPosRad
        };
      }
    }, {
      key: "_findNumVoxels",
      value: function _findNumVoxels(posRadArray, params) {
        var numVoxels = this.numVoxels;

        var minMaxValues = this._findMinMax(posRadArray);

        var minCoordRad = minMaxValues.minPosRad;
        var maxCoordRad = minMaxValues.maxPosRad; // minrad

        if (minCoordRad[3] > 4.0) {
          params.gridSpacing *= minCoordRad[3];
        }

        var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
        var padRad = gridPadding;
        padRad = 0.65 * Math.sqrt(4.0 / 3.0 * Math.PI * padRad * padRad * padRad);
        gridPadding = Math.max(gridPadding, padRad);
        var i = 0;

        for (; i < 3; ++i) {
          minCoordRad[i] -= gridPadding;
          maxCoordRad[i] += gridPadding;
        }

        for (i = 0; i < 3; ++i) {
          numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
        }

        this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
        this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
        this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;

        var _minCoordRad = slicedToArray(minCoordRad, 3);

        this.origin.x = _minCoordRad[0];
        this.origin.y = _minCoordRad[1];
        this.origin.z = _minCoordRad[2];
        return {
          bbox: minMaxValues,
          dim: numVoxels
        };
      }
    }, {
      key: "_makeSurface",
      value: function _makeSurface(surface, params) {
        var isoSurf = new IsoSurface();
        isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
        isoSurf.vertexFusion(9, 9); // normalization is included

        if (isoSurf._numTriangles > 0) {
          isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
          this.setIndex(new THREE.BufferAttribute(isoSurf._indices, 1));
          this.setAttribute('position', new THREE.BufferAttribute(isoSurf._position, 3));
          this.setAttribute('normal', new THREE.BufferAttribute(isoSurf._normals, 3));
          this.setAttribute('color', new THREE.BufferAttribute(isoSurf._colors, 3));
        } else {
          // geometry should have at least empty position attributes to be processed in wireframe mode by three.js
          this.setAttribute('position', new THREE.BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
        }
      }
    }, {
      key: "_calcSurface",
      value: function _calcSurface(params) {
        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };

        if (packedArrays.posRad.length === 0) {
          return;
        }

        var boundaries = this._findNumVoxels(packedArrays.posRad, params);

        var box = new THREE.Box3(this.origin, new THREE.Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));

        var surface = this._computeSurface(packedArrays, box, boundaries, params);

        this._makeSurface(surface, params);
      }
    }]);

    return VolumeSurfaceGeometry;
  }(IsoSurfaceGeometry);

  function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Volume$1 = chem.Volume;
  /**
   * This class implements 'quick' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var QuickSurfGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    inherits(QuickSurfGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$u(QuickSurfGeometry);

    function QuickSurfGeometry() {
      classCallCheck(this, QuickSurfGeometry);

      return _super.apply(this, arguments);
    }

    createClass(QuickSurfGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        // beware of shifting this multiple times!
        this._shiftByOrigin(packedArrays.posRad);

        var surface = {
          volMap: new Volume$1(Float32Array, this.numVoxels, box),
          volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
        };

        if (this._visibilitySelector != null) {
          surface.atomMap = [];
          surface.atomWeightMap = new Volume$1(Float32Array, this.numVoxels, box);
        }

        this.gaussdensity(surface, packedArrays, null, params);
        return surface;
      }
    }, {
      key: "gaussdensity",
      value: function gaussdensity(surface, packedArrays, atomicNum, params) {
        var numAtoms = packedArrays.posRad.length / 4;
        var posRad = packedArrays.posRad,
            colors = packedArrays.colors;
        var numVoxels = this.numVoxels;
        var radScale = params.radScale,
            gaussLim = params.gaussLim,
            gridSpacing = params.gridSpacing;
        var invIsoValue = 1.0 / params.isoValue;
        var invGridSpacing = 1.0 / gridSpacing;
        var maxVoxelX = numVoxels[0] - 1;
        var maxVoxelY = numVoxels[1] - 1;
        var maxVoxelZ = numVoxels[2] - 1; // TODO is densityMap and volTexMap initialized?

        var volMap = surface.volMap,
            volTexMap = surface.volTexMap;
        var volData = volMap.getData();
        var strideX = volMap.getStrideX();
        var volTexData = volTexMap.getData();
        var texStrideX = volTexMap.getStrideX();
        var atomWeightData;

        if (this._visibilitySelector != null) {
          atomWeightData = surface.atomWeightMap.getData();
        }

        var atomMap = surface.atomMap;

        for (var i = 0; i < numAtoms; ++i) {
          var ind = i * 4;
          var scaledRad = posRad[ind + 3] * radScale;
          var atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i];
          var radInv = 1 / (2 * scaledRad * scaledRad);
          var radLim = gaussLim * scaledRad;
          var radLim2 = radLim * radLim;
          radLim *= invGridSpacing;
          var tmp = posRad[ind] * invGridSpacing;
          var xMin = Math.max(tmp - radLim | 0, 0);
          var xMax = Math.min(tmp + radLim | 0, maxVoxelX);
          tmp = posRad[ind + 1] * invGridSpacing;
          var yMin = Math.max(tmp - radLim | 0, 0);
          var yMax = Math.min(tmp + radLim | 0, maxVoxelY);
          tmp = posRad[ind + 2] * invGridSpacing;
          var zMin = Math.max(tmp - radLim | 0, 0);
          var zMax = Math.min(tmp + radLim | 0, maxVoxelZ);
          var dz = zMin * gridSpacing - posRad[ind + 2];

          for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
            var dy = yMin * gridSpacing - posRad[ind + 1];

            for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
              var dy2dz2 = dy * dy + dz * dz;

              if (dy2dz2 >= radLim2) {
                continue;
              }

              var addr = volMap.getDirectIdx(xMin, y, z);
              var texAddr = volTexMap.getDirectIdx(xMin, y, z);
              var dx = xMin * gridSpacing - posRad[ind];

              for (var x = xMin; x <= xMax; ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
                var r2 = dx * dx + dy2dz2;
                var expVal = -r2 * radInv;
                var density = Math.exp(expVal) * atomicNumFactor; // store most relevant atom (with highest density)

                if (this._visibilitySelector != null && density > atomWeightData[addr]) {
                  // NOSONAR
                  atomWeightData[addr] = density; // we use same index into atom map and atomWeightMap

                  atomMap[addr] = packedArrays.atoms[i];
                }

                volData[addr] += density; // TODO check for volTexMap routine?

                density *= invIsoValue;
                var colInd = i * 3;
                volTexData[texAddr] += density * colors[colInd];
                volTexData[texAddr + 1] += density * colors[colInd + 1];
                volTexData[texAddr + 2] += density * colors[colInd + 2];
              }
            }
          }
        }
      }
    }, {
      key: "_shiftByOrigin",
      value: function _shiftByOrigin(posRadArray) {
        var originX = this.origin.x;
        var originY = this.origin.y;
        var originZ = this.origin.z;
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;

        for (var i = 0; i < itemsCount; ++i) {
          var ind = i * itemSize;
          posRadArray[ind] -= originX;
          posRadArray[ind + 1] -= originY;
          posRadArray[ind + 2] -= originZ;
        }
      }
    }]);

    return QuickSurfGeometry;
  }(VolumeSurfaceGeometry);

  /**
   * Modifed from SpatialHash
   *
   * Main differences are:
   * - Optimized grid size to ensure we only ever need to look +/-1 cell
   * - Aware of atomic radii and will only output atoms within rAtom + rExtra
   *   (see withinRadii method)
   *
   * (Uses rounding rather than bitshifting as consequence of arbitrary grid size)
   * @class
   * @param {Float32Array} posRad - x, y, z coordinates and radiuses
   * @param {Float32Array} min - xyz min coordinates
   * @param {Float32Array} max - xyz max coordinates
   * @param {number} maxDistance - max distance
   */

  function AVHash(posRad, min, max, maxDistance) {
    var itemSize = 4;
    var nAtoms = posRad.length / itemSize;
    var minX = min[0];
    var minY = min[1];
    var minZ = min[2];
    var maxX = max[0];
    var maxY = max[1];
    var maxZ = max[2];

    function hashFunc(w, minW) {
      return Math.floor((w - minW) / maxDistance);
    }

    var iDim = hashFunc(maxX, minX) + 1;
    var jDim = hashFunc(maxY, minY) + 1;
    var kDim = hashFunc(maxZ, minZ) + 1;
    var nCells = iDim * jDim * kDim;
    var jkDim = jDim * kDim;
    /* Get cellID for cartesian x,y,z */

    var cellID = function cellID(x, y, z) {
      return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
    };
    /* Initial building, could probably be optimized further */


    var preHash = [];
    var i;
    var cid;

    for (i = 0; i < nAtoms; i++) {
      var iIdx = itemSize * i;
      cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);

      if (preHash[cid] === undefined) {
        preHash[cid] = [i];
      } else {
        preHash[cid].push(i);
      }
    }

    var cellOffsets = utils.allocateTyped(Uint32Array, nCells);
    var cellLengths = utils.allocateTyped(Uint16Array, nCells);
    var data = utils.allocateTyped(Uint32Array, nAtoms);
    var offset = 0;
    var maxCellLength = 0;
    var j;

    for (i = 0; i < nCells; i++) {
      var start = cellOffsets[i] = offset;
      var subArray = preHash[i];

      if (subArray !== undefined) {
        for (j = 0; j < subArray.length; j++) {
          data[offset] = subArray[j];
          offset++;
        }
      }

      var cellLength = offset - start;
      cellLengths[i] = cellLength;

      if (cellLength > maxCellLength) {
        maxCellLength = cellLength;
      }
    } // Maximum number of neighbours we could ever produce (27 adjacent cells of equal population)


    this.neighbourListLength = 27 * maxCellLength + 1;
    /**
     * Populate the supplied out array with atom indices that are within rAtom + rExtra
     * of x,y,z
     *
     * -1 in out array indicates the end of the list
     *
     * @param  {number} x - x coordinate
     * @param  {number} y - y coordinate
     * @param  {number} z - z coordinate
     * @param  {number} rExtra - additional radius
     * @param  {Float32Array} out - pre-allocated output array
     * @return {undefined}
     */

    this.withinRadii = function (x, y, z, rExtra, out) {
      var outIdx = 0;
      var nearI = hashFunc(x, minX);
      var nearJ = hashFunc(y, minY);
      var nearK = hashFunc(z, minZ);
      var loI = Math.max(0, nearI - 1);
      var loJ = Math.max(0, nearJ - 1);
      var loK = Math.max(0, nearK - 1);
      var hiI = Math.min(iDim - 1, nearI + 1);
      var hiJ = Math.min(jDim - 1, nearJ + 1);
      var hiK = Math.min(kDim - 1, nearK + 1);

      for (i = loI; i <= hiI; ++i) {
        var iOffset = i * jkDim;

        for (j = loJ; j <= hiJ; ++j) {
          var jOffset = j * kDim;

          for (var k = loK; k <= hiK; ++k) {
            cid = iOffset + jOffset + k;
            var cellStart = cellOffsets[cid];
            var cellEnd = cellStart + cellLengths[cid];

            for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
              var atomIndex = data[dataIndex];
              var baseIndex = itemSize * atomIndex;
              var dx = posRad[baseIndex] - x;
              var dy = posRad[baseIndex + 1] - y;
              var dz = posRad[baseIndex + 2] - z;
              var rSum = posRad[baseIndex + 3] + rExtra;

              if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
                out[outIdx++] = data[dataIndex];
              }
            }
          }
        }
      } // Add terminator


      out[outIdx] = -1;
    };
  }

  function ContactSurface(packedArrays, boundaries, params, _indexList) {
    // Field generation method adapted from AstexViewer (Mike Hartshorn)
    // by Fred Ludlow.
    // Other parts based heavily on NGL (Alexander Rose) EDT Surface class
    //
    // Should work as a drop-in alternative to EDTSurface (though some of
    // the EDT paramters are not relevant in this method).
    var itemSize = 4;
    var posRad = packedArrays.posRad,
        colors = packedArrays.colors,
        atoms = packedArrays.atoms;
    var nAtoms = posRad.length / itemSize;
    var bbox = boundaries.bbox;
    var min = bbox.minPosRad;
    var max = bbox.maxPosRad;
    var r2; // Atom positions, expanded radii (squared)

    var maxRadius; // Parameters

    var probeRadius;
    var scaleFactor;
    var probePositions; // Cache last value for obscured test

    var lastClip = -1; // Grid params

    var dim;
    var grid;
    var volTex;
    var weights;
    var weightsMap = null;
    var atomMap = null;
    var visibilitySelector = null; // grid indices -> xyz coords

    var gridx;
    var gridy;
    var gridz; // Lookup tables:

    var sinTable;
    var cosTable; // Spatial Hash

    var hash; // Neighbour array to be filled by hash

    var neighbours; // Vectors for Torus Projection

    var mid = new THREE.Vector3(0.0, 0.0, 0.0);
    var n1 = new THREE.Vector3(0.0, 0.0, 0.0);
    var n2 = new THREE.Vector3(0.0, 0.0, 0.0);
    var ngTorus;

    function uniformArray(TypeName, n, a) {
      var array = utils.allocateTyped(TypeName, n);

      for (var innI = 0; innI < n; ++innI) {
        array[innI] = a;
      }

      return array;
    }

    function fillGridDim(a, start, step) {
      for (var innI = 0; innI < a.length; innI++) {
        a[innI] = start + step * innI;
      }
    }

    function initializeGrid() {
      scaleFactor = params.scaleFactor;
      dim = boundaries.dim;
      ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
      var gridSize = dim[0] * dim[1] * dim[2];
      grid = uniformArray(Float32Array, gridSize, -1001.0);
      volTex = utils.allocateTyped(Float32Array, gridSize * 3);
      weights = utils.allocateTyped(Float32Array, gridSize);

      if (visibilitySelector) {
        weightsMap = utils.allocateTyped(Float32Array, gridSize);
        atomMap = [];
      }

      gridx = utils.allocateTyped(Float32Array, dim[0]);
      gridy = utils.allocateTyped(Float32Array, dim[1]);
      gridz = utils.allocateTyped(Float32Array, dim[2]);
      fillGridDim(gridx, min[0], 1 / scaleFactor);
      fillGridDim(gridy, min[1], 1 / scaleFactor);
      fillGridDim(gridz, min[2], 1 / scaleFactor);
    }

    function initializeAngleTables() {
      var theta = 0.0;
      var step = 2 * Math.PI / probePositions;
      cosTable = utils.allocateTyped(Float32Array, probePositions);
      sinTable = utils.allocateTyped(Float32Array, probePositions);

      for (var innI = 0; innI < probePositions; innI++) {
        cosTable[innI] = Math.cos(theta);
        sinTable[innI] = Math.sin(theta);
        theta += step;
      }
    }

    function initializeHash() {
      hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
      neighbours = new Int32Array(hash.neighbourListLength);
    }

    function init() {
      probeRadius = params.probeRadius;
      scaleFactor = params.scaleFactor;
      probePositions = params.probePositions;
      visibilitySelector = params.visibilitySelector;
      r2 = utils.allocateTyped(Float32Array, nAtoms);
      maxRadius = 0;

      for (var innI = 0; innI < nAtoms; ++innI) {
        var rExt = posRad[innI * itemSize + 3] += probeRadius;

        if (rExt > maxRadius) {
          maxRadius = rExt;
        }

        r2[innI] = rExt * rExt;
      }

      initializeGrid();
      initializeAngleTables();
      initializeHash();
      lastClip = -1;
    }

    function singleAtomObscures(ai, innX, innY, innZ) {
      var innCI = itemSize * ai;
      var ra2 = r2[ai];
      var dx = posRad[innCI] - innX;
      var dy = posRad[innCI + 1] - innY;
      var dz = posRad[innCI + 2] - innZ;
      var d2 = dx * dx + dy * dy + dz * dz;
      return d2 < ra2;
    }

    function obscured(innX, innY, innZ, a, b) {
      // Is the point at x,y,z obscured by any of the atoms
      // specifeid by indices in neighbours. Ignore indices
      // a and b (these are the relevant atoms in projectPoints/Torii)
      // Cache the last clipped atom (as very often the same one in
      // subsequent calls)
      var ai;

      if (lastClip !== -1) {
        ai = lastClip;

        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          return ai;
        }

        lastClip = -1;
      }

      var ni = 0;
      ai = neighbours[ni];

      while (ai >= 0) {
        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          lastClip = ai;
          return ai;
        }

        ai = neighbours[++ni];
      }

      lastClip = -1;
      return -1;
    }

    function projectPoints() {
      // For each atom:
      //     Iterate over a subsection of the grid, for each point:
      //         If current value < 0.0, unvisited, set positive
      //
      //         In any case: Project this point onto surface of the atomic sphere
      //         If this projected point is not obscured by any other atom
      //             Calcualte delta distance and set grid value to minimum of
      //             itself and delta
      // Should we alias frequently accessed closure constiables??
      // Assume JS engine capable of optimizing this
      // anyway...
      var maxRad = 4.0;
      var sigma = maxRad / 3;
      var sigma2Inv = 1 / (2 * sigma * sigma);

      for (var innI = 0; innI < nAtoms; innI++) {
        var innCI = itemSize * innI;
        var ax = posRad[innCI];
        var ay = posRad[innCI + 1];
        var az = posRad[innCI + 2];
        var ar = posRad[innCI + 3];
        var ar2 = r2[innI];
        hash.withinRadii(ax, ay, az, ar, neighbours); // Number of grid points, round this up...

        var ng = Math.ceil(ar * scaleFactor); // Center of the atom, mapped to grid points (take floor)

        var iax = Math.floor(scaleFactor * (ax - min[0]));
        var iay = Math.floor(scaleFactor * (ay - min[1]));
        var iaz = Math.floor(scaleFactor * (az - min[2])); // Extents of grid to consider for this atom

        var minx = Math.max(0, iax - ng);
        var miny = Math.max(0, iay - ng);
        var minz = Math.max(0, iaz - ng); // Add two to these points:
        // - iax are floor'd values so this ensures coverage
        // - these are loop limits (exclusive)

        var maxx = Math.min(dim[0], iax + ng + 2);
        var maxy = Math.min(dim[1], iay + ng + 2);
        var maxz = Math.min(dim[2], iaz + ng + 2);
        var colIdx = innI * 3;
        var cr = colors[colIdx];
        var cg = colors[colIdx + 1];
        var cb = colors[colIdx + 2];

        for (var iz = minz; iz < maxz; iz++) {
          var dz = gridz[iz] - az;
          var zOffset = dim[1] * dim[0] * iz;

          for (var iy = miny; iy < maxy; iy++) {
            var dy = gridy[iy] - ay;
            var dzy2 = dz * dz + dy * dy;
            var zyOffset = zOffset + dim[0] * iy;

            for (var ix = minx; ix < maxx; ix++) {
              var idx = ix + zyOffset;
              var dx = gridx[ix] - ax;
              var d2 = dzy2 + dx * dx;

              if (d2 < ar2) {
                var w = Math.exp(-d2 * sigma2Inv);
                var cIdx = idx * 3;
                volTex[cIdx] += cr * w;
                volTex[cIdx + 1] += cg * w;
                volTex[cIdx + 2] += cb * w;
                weights[idx] += w;

                if (visibilitySelector !== null && w > weightsMap[idx]) {
                  weightsMap[idx] = w;
                  atomMap[idx] = atoms[innI];
                }

                if (grid[idx] < 0.0) {
                  // Unvisited, make positive
                  grid[idx] = -grid[idx];
                } // Project on to the surface of the sphere
                // sp is the projected point ( dx, dy, dz ) * ( ra / d )


                var d = Math.sqrt(d2);
                var ap = ar / d;
                var spx = dx * ap;
                var spy = dy * ap;
                var spz = dz * ap;
                spx += ax;
                spy += ay;
                spz += az;

                if (obscured(spx, spy, spz, innI, -1) === -1) {
                  var dd = ar - d;

                  if (dd < grid[idx]) {
                    grid[idx] = dd;
                  }
                }
              }
            }
          }
        }
      }
    }

    function normalToLine(out, p) {
      out.x = out.y = out.z = 1.0;

      if (p.x !== 0) {
        out.x = (p.y + p.z) / -p.x;
      } else if (p.y !== 0) {
        out.y = (p.x + p.z) / -p.y;
      } else if (p.z !== 0) {
        out.z = (p.x + p.y) / -p.z;
      }

      return out;
    }

    function projectTorus(a, b) {
      var aIdx = itemSize * a;
      var bIdx = itemSize * b;
      var xa = posRad[aIdx];
      var ya = posRad[aIdx + 1];
      var za = posRad[aIdx + 2];
      var r1 = posRad[aIdx + 3];
      var dx = mid.x = posRad[bIdx] - xa;
      var dy = mid.y = posRad[bIdx + 1] - ya;
      var dz = mid.z = posRad[bIdx + 2] - za;
      var innR2 = posRad[bIdx + 3];
      var d2 = dx * dx + dy * dy + dz * dz; // This check now redundant as already done in AVHash.withinRadii
      // if( d2 > (( r1 + r2 ) * ( r1 + r2 )) ){ return; }

      var d = Math.sqrt(d2); // Find angle between a->b vector and the circle
      // of their intersection by cosine rule

      var cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d); // distance along a->b at intersection

      var dmp = r1 * cosA;
      mid.normalize(); // Create normal to line

      normalToLine(n1, mid);
      n1.normalize(); // Cross together for second normal vector

      n2.crossVectors(mid, n1);
      n2.normalize(); // r is radius of circle of intersection

      var rInt = Math.sqrt(r1 * r1 - dmp * dmp);
      n1.multiplyScalar(rInt);
      n2.multiplyScalar(rInt);
      mid.multiplyScalar(dmp);
      mid.x += xa;
      mid.y += ya;
      mid.z += za;
      lastClip = -1;
      var ng = ngTorus;

      for (var innI = 0; innI < probePositions; innI++) {
        var cost = cosTable[innI];
        var sint = sinTable[innI];
        var px = mid.x + cost * n1.x + sint * n2.x;
        var py = mid.y + cost * n1.y + sint * n2.y;
        var pz = mid.z + cost * n1.z + sint * n2.z;

        if (obscured(px, py, pz, a, b) === -1) {
          // As above, iterate over our grid...
          // px, py, pz in grid coords
          var iax = Math.floor(scaleFactor * (px - min[0]));
          var iay = Math.floor(scaleFactor * (py - min[1]));
          var iaz = Math.floor(scaleFactor * (pz - min[2]));
          var minx = Math.max(0, iax - ng);
          var miny = Math.max(0, iay - ng);
          var minz = Math.max(0, iaz - ng);
          var maxx = Math.min(dim[0], iax + ng + 2);
          var maxy = Math.min(dim[1], iay + ng + 2);
          var maxz = Math.min(dim[2], iaz + ng + 2);

          for (var iz = minz; iz < maxz; iz++) {
            dz = pz - gridz[iz];
            var zOffset = dim[1] * dim[0] * iz;

            for (var iy = miny; iy < maxy; iy++) {
              dy = py - gridy[iy];
              var dzy2 = dz * dz + dy * dy;
              var zyOffset = zOffset + dim[0] * iy;

              for (var ix = minx; ix < maxx; ix++) {
                dx = px - gridx[ix];
                d2 = dzy2 + dx * dx;
                var idx = ix + zyOffset;
                var current = grid[idx];

                if (current > 0.0 && d2 < current * current) {
                  grid[idx] = Math.sqrt(d2);
                }
              }
            }
          }
        }
      }
    }

    function projectTorii() {
      for (var innI = 0; innI < nAtoms; innI++) {
        var innIdx = itemSize * innI;
        hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
        var ia = 0;
        var ni = neighbours[ia];

        while (ni >= 0) {
          if (innI < ni) {
            projectTorus(innI, ni);
          }

          ni = neighbours[++ia];
        }
      }
    }

    function fixNegatives() {
      for (var innI = 0, n = grid.length; innI < n; innI++) {
        if (grid[innI] < 0) grid[innI] = 0;
        var w = weights[innI];

        if (w > 0) {
          w = 1 / w;
          var innInnI = innI * 3;
          volTex[innInnI] *= w;
          volTex[innInnI + 1] *= w;
          volTex[innInnI + 2] *= w;
        }
      }
    }

    function getVolume() {
      // Basic steps are:
      // 1) Initialize
      // 2) Project points
      // 3) Project torii
      console.time('ContactSurface.getVolume');
      console.time('ContactSurface.init');
      init();
      console.timeEnd('ContactSurface.init');
      console.time('ContactSurface.projectPoints');
      projectPoints();
      console.timeEnd('ContactSurface.projectPoints');
      console.time('ContactSurface.projectTorii');
      projectTorii();
      console.timeEnd('ContactSurface.projectTorii');
      fixNegatives();
      console.timeEnd('ContactSurface.getVolume');
    }

    this.build = function () {
      // type and cutoff left in for compatibility with EDTSurface.getSurface
      // function signature
      getVolume();
      this.volTexMap = volTex;
      this.weightsMap = weightsMap;
      this.atomMap = atomMap;
      this.volMap = grid;
    };
  }

  function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$w(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Volume$2 = chem.Volume;
  /**
   * This class implements 'contact' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var ContactSurfaceGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    inherits(ContactSurfaceGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$v(ContactSurfaceGeometry);

    function ContactSurfaceGeometry() {
      classCallCheck(this, ContactSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(ContactSurfaceGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        var contactSurface = new ContactSurface(packedArrays, boundaries, params);
        contactSurface.build();
        var surface = {
          volMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
          volTexMap: new Volume$2(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
          atomMap: contactSurface.atomMap,
          atomWeightMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
        };
        return surface;
      }
    }]);

    return ContactSurfaceGeometry;
  }(VolumeSurfaceGeometry);

  /**
   * Class for colored atom. Need for atom structure clusterization
   *
   * @param {Vector3} vCenter   Center of atom
   * @param {number}  radiusAt  Radius of atom
   */

  var IsoSurfaceAtomColored = function IsoSurfaceAtomColored(vCenter, radiusAt) {
    classCallCheck(this, IsoSurfaceAtomColored);

    this.coord = new THREE.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0.0;
    this.colorZ = 0.0;
    this.atomType = 0;
    this.srcAtom = null;
  };

  /* jshint bitwise: false */

  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {number} numAtoms     - Number of atoms in molecule
   * @param {Element} atoms      - Array of atoms
   * @param {Vector3} vBoxMin     - Bounding box min
   * @param {Vector3} vBoxMax     - Bounding box max
   * @param {number} probeRadius     - Normals for output
   *
   */

  var IsosurfaceBuildNormals = /*#__PURE__*/function () {
    function IsosurfaceBuildNormals(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
      classCallCheck(this, IsosurfaceBuildNormals);

      this._numAtoms = numAtoms;
      this._atoms = atoms;
      this._vBoxMin = new THREE.Vector3();
      this._vBoxMax = new THREE.Vector3();

      this._vBoxMin.copy(vBoxMin);

      this._vBoxMax.copy(vBoxMax);

      this._probeRadius = probeRadius;
      this._atomsList = null;
      this._voxelList = null;
    }

    createClass(IsosurfaceBuildNormals, [{
      key: "createVoxels",
      value: function createVoxels() {
        var numAtomsRefs;
        var rad;
        var ATOM_VOXEL_REF_SCALE = 4.5;
        var numAtoms = this._numAtoms | 0;
        var atoms = this._atoms;
        var dx = this._vBoxMax.x - this._vBoxMin.x;
        var dy = this._vBoxMax.y - this._vBoxMin.y;
        var dz = this._vBoxMax.z - this._vBoxMin.z;
        var w = dx < dy ? dx : dy;
        w = dz < w ? dz : w;
        var maxRad = 0.0;
        var aveRad = 0.0;
        var i;

        for (i = 0; i < numAtoms; i++) {
          rad = (atoms[i].radius + this._probeRadius) * 2.0;
          maxRad = rad > maxRad ? rad : maxRad;
          aveRad += rad;
        }

        var numCells = Math.floor(w / maxRad);

        if (numCells < 2) {
          numCells = 2;
        }

        aveRad /= numAtoms;
        this._numCells = numCells;
        this._aveRad = aveRad;
        this._maxRad = maxRad;
        var side = numCells;
        var side2 = numCells * numCells;
        var side3 = numCells * numCells * numCells;
        var xScale = this._xScale = 1.0 / (this._vBoxMax.x - this._vBoxMin.x);
        var yScale = this._yScale = 1.0 / (this._vBoxMax.y - this._vBoxMin.y);
        var zScale = this._zScale = 1.0 / (this._vBoxMax.z - this._vBoxMin.z); // estimate number of individual atom refs in each voxel list

        var maxAtomsRefs = 0;
        var xNumVoxMult = xScale * numCells;
        var yNumVoxMult = yScale * numCells;
        var zNumVoxMult = zScale * numCells;

        for (i = 0; i < numAtoms; i++) {
          var radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var diaAffect = radAffect * 2.0;
          var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
          var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
          var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8); // avoid case numVox? == 0
          // also use loop i <=

          numVoxX++;
          numVoxY++;
          numVoxZ++;
          maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
        } // for (i)
        // maxAtomsRefs = numAtoms * MAX_ATOMS_IN_SINGLE_VOXEL;


        this._voxelList = utils.allocateTyped(Int32Array, side3);
        var atomsList = [];
        atomsList.length = maxAtomsRefs;

        if (this._voxelList === null || atomsList === null) {
          return 0 - 1;
        } // init voxel list


        for (i = 0; i < side3; i++) {
          this._voxelList[i] = -1;
        }

        numAtomsRefs = 0; // create voxel lists

        for (i = 0; i < numAtoms; i++) {
          // use multiplier 4 to locate this atom in different voxels
          rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
          var yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
          var zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
          var xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
          var yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
          var zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
          xIndMin = xIndMin >= 0 ? xIndMin : 0;
          yIndMin = yIndMin >= 0 ? yIndMin : 0;
          zIndMin = zIndMin >= 0 ? zIndMin : 0;
          xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
          yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
          zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;

          for (var z = zIndMin; z <= zIndMax; z++) {
            for (var y = yIndMin; y <= yIndMax; y++) {
              for (var x = xIndMin; x <= xIndMax; x++) {
                // add atom with index "i" to this voxel list
                var indVoxel = x + y * side + z * side2; // assert indVoxel >= 0
                // assert indVoxel < side3
                // add first

                if (this._voxelList[indVoxel] < 0) {
                  atomsList[numAtomsRefs * 2 + 0] = i;
                  atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
                  this._voxelList[indVoxel] = numAtomsRefs;
                  numAtomsRefs++; // assert numAtomsRefs < maxAtomsRefs - 1

                  continue;
                } // insert into head of list


                var indexNext = this._voxelList[indVoxel];
                this._voxelList[indVoxel] = numAtomsRefs;
                atomsList[numAtomsRefs * 2 + 0] = i;
                atomsList[numAtomsRefs * 2 + 1] = indexNext;
                numAtomsRefs++;
              } // for (x)

            } // for (y)

          } // for (z)

        } // for (i)
        // convert Array to Int32Array


        this._atomsList = Int32Array.from(atomsList);
        return 0;
      }
    }, {
      key: "destroyVoxels",
      value: function destroyVoxels() {
        this._atomsList = null;
        this._voxelList = null;
        this._atoms = null;
        this._vertices = null;
        this._vBoxMin = null;
        this._vBoxMax = null;
      }
      /**
       * Enumerate all atoms affecting specified point
       *
       * @param {Vector3}    point    - point in 3D
       * @param {func(atom)} process  - function to call for each atom
       */

    }, {
      key: "forEachRelatedAtom",
      value: function forEachRelatedAtom(point, process) {
        // find corresponding voxel
        var xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
        var yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
        var zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
        var indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells; // run through atoms affecting this voxel

        var atoms = this._atoms;

        for (var ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
          var indexAtom = this._atomsList[ref * 2];
          process(atoms[indexAtom]);
        }
      }
      /**
       * Get atom closest to specified point
       *
       * @param {Vector3} point  - point in 3D
       *
       * @returns {IsoSurfaceAtomColored} atom, or null if not found
       */

    }, {
      key: "getClosestAtom",
      value: function getClosestAtom(point) {
        var closest = null;
        var minDist2 = Number.MAX_VALUE;
        this.forEachRelatedAtom(point, function (atom) {
          var dist2 = point.distanceToSquared(atom.coord);

          if (dist2 < minDist2) {
            minDist2 = dist2;
            closest = atom;
          }
        });
        return closest;
      }
      /**
       * Build normals for isosurface, using atoms information
       *
       * @param {number} numVertices  - Number of vertices in final geometry (to render)
       * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
       * @param {Vector3} normals     - Normals for output
       *
       * @returns {number} 0, if success
       */

    }, {
      key: "buildNormals",
      value: function buildNormals(numVertices, vertices, normals) {
        var self = this;
        var numCloseAtoms = 0;
        var vx = 0;
        var vy = 0;
        var vz = 0;
        var dist2;
        var vNormalX = 0;
        var vNormalY = 0;
        var vNormalZ = 0;
        var koef = 0;
        var w = 0;
        var r25 = 2.5;
        var r01 = 0.1;
        var maxRadAffect = this._aveRad * r25;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var expScale = -this._aveRad * r01; // some stats
        // numSlowAtoms = 0;

        var gatherNormals = function gatherNormals(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          } // get weight for gaussian smoothing


          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = Math.exp(expScale * koef);
          vNormalX += dx * w;
          vNormalY += dy * w;
          vNormalZ += dz * w;
          numCloseAtoms++;
        };

        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          numCloseAtoms = 0;
          vNormalX = vNormalY = vNormalZ = 0.0;
          this.forEachRelatedAtom(vertices[i], gatherNormals);

          dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;

          if (numCloseAtoms > 0) {
            koef = 1.0 / Math.sqrt(dist2);
            vNormalX *= koef;
            vNormalY *= koef;
            vNormalZ *= koef;
          }

          normals[i].x = vNormalX;
          normals[i].y = vNormalY;
          normals[i].z = vNormalZ;
        } // for (i) all vertices


        return 0;
      }
      /**
       * Build vertex colors for isosurface, using atoms information
       *
       * @param {number} numVertices  - Number of vertices in final geometry (to render)
       * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
       * @param {Vector3} colors                - Colors for output
       * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
       *
       * @returns {number} 0, if success
       */

    }, {
      key: "buildColors",
      value: function buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
        var self = this;
        var vx = 0.0;
        var vy = 0.0;
        var vz = 0.0;
        var koef = 0.0;
        var w = 0.0;
        var KOEF_ADD = 0.8;
        var maxRadAffect = radiusColorSmoothness;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var colorsClose = [];
        var weights = [];
        var weightsSum = 0;

        var gatherColors = function gatherColors(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          var dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          } // get weight for gaussian smoothing


          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = 1.0 / (KOEF_ADD + koef);
          colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
          weights.push(w); // save weights for use

          weightsSum += w; // calc sum of weights fo further normalization
        }; // process all vertices, one by one


        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          colorsClose = [];
          weights = [];
          weightsSum = 0;
          this.forEachRelatedAtom(vertices[i], gatherColors); // normalized weighted sum of colors

          for (var j = 0; j < colorsClose.length; ++j) {
            var weightNormalized = weights[j] / weightsSum;
            colors[i].x += colorsClose[j][0] * weightNormalized;
            colors[i].y += colorsClose[j][1] * weightNormalized;
            colors[i].z += colorsClose[j][2] * weightNormalized;
          }
        } // for (i) all vertices


        return 0;
      }
    }]);

    return IsosurfaceBuildNormals;
  }();

  /**
   * Class for geometry (triangle mesh) representation
   *
   *
   * @param {number} maxNumVertices Maximum possible number of vertices in mesh
   * @param {number} maxNumTriangles Maximum possible number of triangles in mesh
   * @param {boolean} needVertexColors Obvious
   */

  var IsoSurfaceGeo = /*#__PURE__*/function () {
    function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
      classCallCheck(this, IsoSurfaceGeo);

      this._maxNumVertices = maxNumVertices;
      this._maxNumTriangles = maxNumTriangles;
      this._vertices = new Array(maxNumVertices);
      this._normals = new Array(maxNumVertices);
      this._colors = null;

      if (needVertexColors) {
        this._colors = new Array(maxNumVertices);
      }

      this._indices = new Array(maxNumTriangles * (1 + 2));
      this._numVertices = 0;
      this._numTriangles = 0;
      var i;

      for (i = 0; i < maxNumVertices; i++) {
        this._vertices[i] = new THREE.Vector3();
        this._normals[i] = new THREE.Vector3();
      }

      for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
        this._indices[i] = -1;
      }

      if (needVertexColors) {
        for (i = 0; i < maxNumVertices; i++) {
          this._colors[i] = new THREE.Vector3();
        }
      }
    }

    createClass(IsoSurfaceGeo, [{
      key: "destroy",
      value: function destroy() {
        this._vertices = null;
        this._normals = null;
        this._indices = null;
      }
    }]);

    return IsoSurfaceGeo;
  }();

  function _createSuper$w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$x(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLOR_SIZE$3 = 3;
  var HASH_SIZE = 32768;
  var Element$1 = chem.Element;
  /**
   * This class implements 'quick' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var SSIsosurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    inherits(SSIsosurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$w(SSIsosurfaceGeometry);

    function SSIsosurfaceGeometry() {
      classCallCheck(this, SSIsosurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(SSIsosurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        // convert geoOut into arrays of positions, indices, normals
        this._innerBuild();

        var geoOut = this.getGeo();
        this.destroy();

        this._fromGeo(geoOut);
      }
    }, {
      key: "_fromGeo",
      value: function _fromGeo(geoOut) {
        var colors = null;
        var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);

        if (geoOut._colors !== null) {
          colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        }

        var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);

        for (var i = 0, j = 0; i < geoOut._numVertices; i++) {
          positions[j + 0] = geoOut._vertices[i].x;
          positions[j + 1] = geoOut._vertices[i].y;
          positions[j + 2] = geoOut._vertices[i].z;
          normals[j + 0] = geoOut._normals[i].x;
          normals[j + 1] = geoOut._normals[i].y;
          normals[j + 2] = geoOut._normals[i].z;
          j += 3;
        }

        if (colors !== null) {
          for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
            colors[_j + 0] = geoOut._colors[_i].x;
            colors[_j + 1] = geoOut._colors[_i].y;
            colors[_j + 2] = geoOut._colors[_i].z;
          }
        }

        var numTri3 = geoOut._numTriangles * (1 + 2);

        for (var _i2 = 0; _i2 < numTri3; _i2++) {
          indices[_i2] = geoOut._indices[_i2];
        }

        this.setIndex(new THREE.BufferAttribute(indices, 1));
        this.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        this.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        this.computeBoundingBox();
        this.computeBoundingSphere();
        geoOut.destroy();
      }
    }, {
      key: "convertToAtomsColored",
      value: function convertToAtomsColored(packedArrays, atomsColored) {
        var atoms = packedArrays.atoms,
            colors = packedArrays.colors;

        for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
          var vCenter = atoms[i].position;
          var radius = atoms[i].element.radius;
          atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius);
          var nm = atoms[i].element.number;
          atomsColored[i].atomType = this.getType(nm);
          var cIdx = COLOR_SIZE$3 * i;
          atomsColored[i].colorX = colors[cIdx++];
          atomsColored[i].colorY = colors[cIdx++];
          atomsColored[i].colorZ = colors[cIdx];
          atomsColored[i].srcAtom = atoms[i];
        }
      }
    }, {
      key: "getGeo",
      value: function getGeo() {
        return this.geoOut;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.atoms = null;
        this.hashLines = null;
        this.hashEntries = null;
      }
      /**
       * Calculates bounding box for array with spheres (atoms)
       *
       * @param {Object}  atoms      Atoms array
       * @param {Vector3} vBoxMin    Bounding box min point
       * @param {Vector3} vBoxMax    Bounding box max point
       */

    }, {
      key: "getBoundingBox",
      value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
        var bigNum = 10000000.0;
        vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
        vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
        var probeRadius2 = this.probeRadius * this.atomRadiusScale;
        var radMax = 0.0;

        for (var i = 0, num = atoms.length; i < num; i++) {
          var vCenter = atoms[i].coord;
          var rad = atoms[i].radius + probeRadius2;
          radMax = rad > radMax ? rad : radMax;

          if (vCenter.x - rad < vBoxMin.x) {
            vBoxMin.x = vCenter.x - rad;
          }

          if (vCenter.y - rad < vBoxMin.y) {
            vBoxMin.y = vCenter.y - rad;
          }

          if (vCenter.z - rad < vBoxMin.z) {
            vBoxMin.z = vCenter.z - rad;
          }

          if (vCenter.x + rad > vBoxMax.x) {
            vBoxMax.x = vCenter.x + rad;
          }

          if (vCenter.y + rad > vBoxMax.y) {
            vBoxMax.y = vCenter.y + rad;
          }

          if (vCenter.z + rad > vBoxMax.z) {
            vBoxMax.z = vCenter.z + rad;
          }
        }

        vBoxMin.x -= radMax;
        vBoxMin.y -= radMax;
        vBoxMin.z -= radMax;
        vBoxMax.x += radMax;
        vBoxMax.y += radMax;
        vBoxMax.z += radMax;
      }
      /**
       * Calculate (x,y,z) cordinate of the cell corner point
       *
       * @param {Vector3} vBoxMin Bounding box min point
       * @param {Vector3} vBoxMax Bounding box max point
       * @param {number} x Cell integer x coordinate
       * @param {number} y Cell integer y coordinate
       * @param {number} z Cell integer z coordinate
       * @param {number} numPoints NUm points in cell on side
       * @param {Vector3} vOut Output vector
       */

    }, {
      key: "getCornerCoord",
      value: function getCornerCoord(vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
        var invNP = 1.0 / (numPoints - 1.0);
        var tx = x * invNP;
        var ty = y * invNP;
        var tz = z * invNP;
        vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx;
        vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty;
        vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz;
      }
      /**
       * Calculate point of intersection of sphere surface
       * and cell edge, given by [indexA, indexB] line
       *
       * @param {number} indexA Cell vertex index in [0..11]
       * @param {number} indexB Cell vertex index in [0..11]
       * @param {array}  sign   Sign array for all 8 vertices
       * @param {object} cube   Cube
       * @param {number} indexPointValue for value placement
       * @param {Vector3} vOut  Point of intersection
       */

    }, {
      key: "buildEdgePoint",
      value: function buildEdgePoint(indexA, indexB, sign, cube, indexPointValue, vOut) {
        if (sign[indexA] ^ sign[indexB]) {
          var cTwentyFour = 24;
          var t = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
          var xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
          var ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
          var za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
          var xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
          var yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
          var zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
          vOut.x = xa * (1.0 - t) + xb * t;
          vOut.y = ya * (1.0 - t) + yb * t;
          vOut.z = za * (1.0 - t) + zb * t;
        }
      }
      /**
       * Check if triangle is visible (vertices are close to atoms included in visibility set)
       *
       * @param {Vector3} v0 Vertex #0
       * @param {Vector3} v1 Vertex #1
       * @param {Vector3} v2 Vertex #2
       * @returns {boolean} true if triangle is visible
       */

    }, {
      key: "isTriangleVisible",
      value: function isTriangleVisible(v0, v1, v2) {
        var a0 = this.voxelWorld.getClosestAtom(v0);
        var a1 = this.voxelWorld.getClosestAtom(v1);
        var a2 = this.voxelWorld.getClosestAtom(v2);

        if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
          return false;
        }

        return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
      }
      /**
       * Add triangle to result geometry
       *
       * @param {Vector3} v0 Vertex #0
       * @param {Vector3} v1 Vertex #1
       * @param {Vector3} v2 Vertex #2
       * @returns {boolean} false if no more triangles can be added
       */

    }, {
      key: "addTriangle",
      value: function addTriangle(v0, v1, v2) {
        if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
          return true;
        }

        var geo = this.geoOut;

        if (geo._numTriangles >= this.maxNumTriangles) {
          return false;
        } // Add vertex with optimize


        var indInGeo0 = this.addVertexToGeo(geo, v0);
        var indInGeo1 = this.addVertexToGeo(geo, v1);
        var indInGeo2 = this.addVertexToGeo(geo, v2);

        if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
          return false;
        }

        var itr = 3 * geo._numTriangles;
        geo._indices[itr + 0] = indInGeo0;
        geo._indices[itr + 1] = indInGeo1;
        geo._indices[itr + 2] = indInGeo2;
        geo._numTriangles++;
        return true;
      }
      /**
       * Build result geometry (triangle mesh) from marching cube cells
       *
       * @param {number} meshRes Marchnig cube vertex count on each side
       * @param {Vector3} vBoxMin Bounding box point min
       * @param {Vector3} vBoxMax Bounding box point max
       * @param {number} corners float values array for each cube point
       * @param {Vector3} vCellStep vector to next cube cell diagonal point
       * @param {object} cube IsoSurfaceMarchCube object
       * @returns {number} 0, if success (<0) is error
       */

    }, {
      key: "buildGeoFromCorners",
      value: function buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
        var arrSize = 12;
        var cNumVerts = 8;
        var numCells = meshRes - 1;
        var side = meshRes;
        var side2 = meshRes * meshRes;
        var vaEdges = new Array(arrSize);

        for (var i = 0; i < arrSize; i++) {
          vaEdges[i] = new THREE.Vector3();
        }

        var sign = [];

        for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
          sign[_i3] = 1.0;
        }

        var vCorner = new THREE.Vector3();
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              if (!cube.hasIntersection[indCell]) {
                // next cell
                indCell++;
                continue;
              }

              var bitsInside = cube.bitsInside[indCell];
              this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);
              var indPointValues = indCell * (2 << 2 + 2);

              for (var _i4 = 0, j = 0; _i4 < cNumVerts; _i4++) {
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.x;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.y;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.z;
              }

              cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y; // now current cell has intersections (from -x to +x) on some cube edges

              var indValues = indPointValues + 24;

              for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
                sign[_i5] = cube.pointsValuesLinear[indValues + _i5] < 0.0 ? 1 : 0;
              }

              this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
              this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
              this.buildEdgePoint(2, 3, sign, cube, indPointValues, vaEdges[2]);
              this.buildEdgePoint(3, 0, sign, cube, indPointValues, vaEdges[3]);
              this.buildEdgePoint(4, 5, sign, cube, indPointValues, vaEdges[4]);
              this.buildEdgePoint(5, 6, sign, cube, indPointValues, vaEdges[5]);
              this.buildEdgePoint(6, 7, sign, cube, indPointValues, vaEdges[6]);
              this.buildEdgePoint(7, 4, sign, cube, indPointValues, vaEdges[7]);
              this.buildEdgePoint(0, 4, sign, cube, indPointValues, vaEdges[8]);
              this.buildEdgePoint(1, 5, sign, cube, indPointValues, vaEdges[9]);
              this.buildEdgePoint(2, 6, sign, cube, indPointValues, vaEdges[10]);
              this.buildEdgePoint(3, 7, sign, cube, indPointValues, vaEdges[11]);
              var offs = bitsInside * (2 << 1 + 2);

              for (var numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
                // s_triIndicesMarchCube is external array, defined in mold_ind.js
                var i0 = cube.striIndicesMarchCube[offs + indTri];

                if (i0 < 0) {
                  break;
                }

                var i1 = cube.striIndicesMarchCube[offs + indTri + 1];
                var i2 = cube.striIndicesMarchCube[offs + indTri + 2];

                if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
                  return 0 - 2;
                }
              } // for numTri
              // next cell (cube)


              indCell++;
            } // for (x)

          } // for (z)

        } // for (y)


        return 0;
      }
      /**
       * Returns number of cell with intersection with at least one sphere.
       * Using this number, we can estimate required number of vertices
       * and triangles to build result mesh.
       *
       * @param {number} side Number of points in cube voxels
       * @param {number} numCells Number of cells in cube voxels (per direction)
       * @param {array} corners Array of float values for cube corner points
       * @param {object} cube IsoSurfaceMarchCube object
       * @returns {number} numIntersectedCells
       */

    }, {
      key: "getNumIntersectedCells",
      value: function getNumIntersectedCells(side, numCells, corners, cube) {
        var side2 = side * side;
        var cNumVerts = 8;
        var numIntersectedCells = 0;
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              var cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
              var indCorner = x + indZ + indY;
              cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
              cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side]; // check read exception
              // assert(side2 + indCorner + side + 1 < side3);
              // get bit flags inside

              var bitsInside = 0;

              for (var i = 0; i < cNumVerts; ++i) {
                if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
                  bitsInside |= 1 << i;
                }
              }

              if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
                cube.hasIntersection[indCell] = false;
              } else {
                cube.hasIntersection[indCell] = true;
                numIntersectedCells++;
              }

              cube.bitsInside[indCell] = bitsInside; // next cell

              indCell++;
            } // for (x)

          } // for (z)

        } // for (y)


        return numIntersectedCells;
      }
    }, {
      key: "getType",
      value: function getType(letter) {
        /* eslint-disable no-magic-numbers */
        var atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
        /* eslint-enable no-magic-numbers */

        if (letter < 1 || letter > atomT.length / 2 || Object.keys(Element$1.ByAtomicNumber).length * 2 !== atomT.length) {
          throw new Error('atomT.length  should be equal Element.ByAtomicNumber.length * 2');
        }

        return atomT[letter * 2];
      }
      /**
       * Calculate values for marching cube grid points
       * positive values are outside sphere, negative - is inside
       *
       * @param {array} corners array of float values
       * @param {number} side Number of point in cube in 1 dimennsion
       * @param {Vector3} vBoxMin Bounding box min point
       * @param {Vector3} vBoxMax Bounding box max point
       * @param {array} atoms Array of input atoms
       * @param {number} probeRad radius for atom probing
       */

    }, {
      key: "calculateGridCorners",
      value: function calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
        var side2 = side * side;
        var side3 = side2 * side;
        var vCorner = new THREE.Vector3();
        var vDif = new THREE.Vector3();
        /* eslint-disable no-magic-numbers */

        var aLot = +1.0e12;
        /* eslint-enable no-magic-numbers */

        for (var i = 0; i < side3; i++) {
          corners[i] = aLot; // to large value
        }

        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);

        for (var s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
          var atom = atoms[s];
          var radius = atom.radius + probeRad;
          var fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
          var fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
          var fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
          var indXMin = Math.floor(fx);
          var indYMin = Math.floor(fy);
          var indZMin = Math.floor(fz);
          var indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
          var indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
          var indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
          indXMax++;
          indYMax++;
          indZMax++;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var y = indYMin; y <= indYMax; y++) {
            var indY = y * side2;

            for (var z = indZMin; z <= indZMax; z++) {
              var indZ = z * side;

              for (var x = indXMin; x <= indXMax; x++) {
                var ind = indY + indZ + x;
                this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
                vDif.x = vCorner.x - atom.coord.x;
                vDif.y = vCorner.y - atom.coord.y;
                vDif.z = vCorner.z - atom.coord.z;
                var distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z); // val: < 0, if inside sphere
                // val: > 0, if outside sphere

                var val = distToSphere - radius;

                if (val < corners[ind]) {
                  corners[ind] = val;
                }
              } // for (x)

            } // for (z)

          } // for (y)

        } // for (s)

      }
      /**
       * Create memory pool for vertex hash management
       *
       * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
       * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
       * @returns {number} 0, if success. (<0) is non memory
       */

    }, {
      key: "createVertexHash",
      value: function createVertexHash(maxNumVertices, maxNumTriangles) {
        this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);

        if (this.hashLines === null) {
          return 0 - 1;
        }

        for (var i = 0, j = 0; i < HASH_SIZE; i++) {
          this.hashLines[j++] = 0; // num vertices in this hash line

          this.hashLines[j++] = 0 - 1; // index of the first entry
        }

        this.maxNumVertices = maxNumVertices;
        this.maxNumTriangles = maxNumTriangles;
        this.numHashEtriesAllocated = maxNumVertices;
        this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);

        if (this.hashEntries === null) {
          return 0 - 1;
        }

        for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
          this.hashEntries[_j2++] = 0 - 1; // index of vertex

          this.hashEntries[_j2++] = 0 - 1; // next hash entry index
        }

        this.numHashEntryIndex = 0;
        return 0;
      }
      /**
       * Allocate and return new hash entry. Just check possible amount.
       *
       * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
       */

    }, {
      key: "getNewHashEntry",
      value: function getNewHashEntry() {
        if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
          var i = this.numHashEntryIndex;
          this.numHashEntryIndex++;
          return i;
        }

        return 0 - 1;
      }
      /**
       * Add vertex to geometry structure
       * using vertex hash table to quickly check, is this vertex already exist in geometry
       *
       * @param {object} geoOut Geometry to build
       * @param {Vector3} vAdd Vertex to add
       * @returns {number} index of added (or existing) vertex in geometry.
       */

    }, {
      key: "addVertexToGeo",
      value: function addVertexToGeo(geoOut, vAdd) {
        var entry;
        var oneHynberes = 0.01;
        var n815851 = 815851;
        var n37633 = 37633;
        var n2453543 = 2453543;
        var r106 = 1.0e-6;
        var hashResolution = this.marCubeResoultion << 2;
        var v = new THREE.Vector3();
        var ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
        var iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
        var iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
        var iHash = ix * n815851 + iz * n37633 + iy * n2453543;
        iHash &= HASH_SIZE - 1;
        var hLineIndex = iHash + iHash; // search vertex via hash
        // search in hash list

        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
            var ind = this.hashEntries[entry * 2 + 0]; // vertex index

            v.copy(geoOut._vertices[ind]);
            v.x -= vAdd.x;
            v.y -= vAdd.y;
            v.z -= vAdd.z;
            var dot2 = v.x * v.x + v.y * v.y + v.z * v.z;

            if (dot2 < r106) {
              return ind;
            } // if (found)

          } // for (entry)

        } // search
        // add new vertex to geometry


        if (geoOut._numVertices >= this.maxNumVertices) {
          return 0 - 1;
        }

        var iVertAdd = geoOut._numVertices;

        geoOut._vertices[iVertAdd].copy(vAdd); // add to hash


        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          entry = this.getNewHashEntry();

          if (entry < 0) {
            return 0 - 1;
          }

          var entryFirst = this.hashLines[hLineIndex + 1];
          this.hashLines[hLineIndex + 1] = entry;
          this.hashEntries[entry * 2 + 0] = iVertAdd;
          this.hashEntries[entry * 2 + 1] = entryFirst;
          this.hashLines[hLineIndex + 0]++; // num vertices in line ++
        }

        geoOut._numVertices++;
        return iVertAdd;
      }
      /**
       *
       * @param {number} side some placeholder description
       * @param {number} probeSphereRadius some placeholder description
       * @param {object} vBoxMin some placeholder description
       * @param {object} vBoxMax some placeholder description
       * @param {object} geoOut some placeholder description
       * @param {object} corners some placeholder description
       * @returns {number} always 0
       */

    }, {
      key: "modifyExcludedFromGeo",
      value: function modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
        var ind;
        var distToSphere;
        var distToBorder;
        var r11 = 1.1;

        function innerBlockWorkAround() {
          if (distToBorder > 0.0) {
            // point is inside probe sphere
            if (corners[ind] < 0.0) {
              corners[ind] = distToBorder; // was inside surface, now is oustide ( > 0)
            }

            if (distToBorder > corners[ind]) {
              corners[ind] = distToBorder; // find positive maximum
            }
          } else if (distToBorder > corners[ind]) {
            // point is outside sphere
            corners[ind] = distToBorder; // find negative maximum
          }
        }

        var side2 = side * side;
        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
        var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
        var sideInv = 1.0 / (side - 1);

        for (var i = 0; i < geoOut._numVertices; i++) {
          var vCenter = geoOut._vertices[i];
          var radEst = probeSphereRadius * r11;
          var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
          var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
          var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
          var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
          var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
          var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
          indXMin = indXMin >= 0 ? indXMin : 0;
          indYMin = indYMin >= 0 ? indYMin : 0;
          indZMin = indZMin >= 0 ? indZMin : 0;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var iy = indYMin; iy <= indYMax; iy++) {
            var indY = iy * side2;

            for (var iz = indZMin; iz <= indZMax; iz++) {
              var indZ = iz * side;

              for (var ix = indXMin; ix <= indXMax; ix++) {
                ind = indY + indZ + ix; // getCornerCoord(vBoxMin, vBoxMax, ix, iy, iz, side, &vCorner);

                var t = ix * sideInv;
                var xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t;
                t = iy * sideInv;
                var yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t;
                t = iz * sideInv;
                var zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t;
                var dx = xCorner - vCenter.x;
                var dy = yCorner - vCenter.y;
                var dz = zCorner - vCenter.z;
                var dist2 = dx * dx + dy * dy + dz * dz;

                if (dist2 < probeSpRad2) {
                  distToSphere = Math.sqrt(dist2);
                  distToBorder = -(distToSphere - probeSphereRadius);
                  innerBlockWorkAround();
                } // if (dist from corner point to sphere center more 2 radiuses)

              } // for (ix)

            } // for (iz)

          } // for (iy)

        } // for (i) all geo vertices


        return 0;
      }
    }, {
      key: "_innerBuild",
      value: function _innerBuild() {
        var ok;
        var expandFactor = 1.2; // performance test
        // this.performanceTest();
        // Create temporary atoms (but colored)

        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };
        this.complex = this._opts.parent;
        this.atoms = packedArrays.atoms;
        this.meshResolution = this._opts.gridSpacing;
        this.atomRadiusScale = this._opts.radScale;
        this.colorMode = this._opts.colorMode;
        this.probeRadius = this._opts.probeRadius;
        this.useVertexColors = true;
        this.excludeProbe = this._opts.excludeProbe;
        this.visibilitySelector = this._opts.visibilitySelector;
        this.geoOut = null;
        this.hashLines = null;
        this.hashEntries = null;
        this.numHashEtriesAllocated = 0;
        this.numHashEntryIndex = 0;
        this.maxNumVertices = 0;
        this.maxNumTriangles = 0;
        var atomsColored = new Array(this.atoms.length);
        this.convertToAtomsColored(packedArrays, atomsColored); // find bbox for spheres scene

        var vBoxMin = this.vBoxMin = new THREE.Vector3();
        var vBoxMax = this.vBoxMax = new THREE.Vector3();
        this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
        var marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2); // build grid corners for Marching cube algorithm

        var side = marCubeResoultion;
        var side2 = side * side;
        var side3 = side2 * side;
        var corners = utils.allocateTyped(Float32Array, side3);
        var rProbeRadius = this.probeRadius * this.atomRadiusScale;
        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
        var numCells = marCubeResoultion - 1;
        var cube = new IsoSurfaceMarchCube();
        ok = cube.create(numCells);

        if (ok < 0) {
          return ok;
        } // copy corners to cells


        var vCellStep = new THREE.Vector3();
        vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
        vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
        vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
        var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
        var maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
        var maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

        if (ok < 0) {
          return ok;
        } // build voxel world (used to check triangle-to-atom tie and to calculate normals and colors)


        var probeRadForNormalsColors = rProbeRadius;

        if (this.excludeProbe) {
          probeRadForNormalsColors = 0.01;
        }

        this.voxelWorld = new IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
        this.voxelWorld.createVoxels();
        ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);

        if (this.excludeProbe) {
          // using 3d mesh (geoOut) as a surface points
          // move probe sphere and try to minimuze corners values
          this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners); // delete old builded geo

          this.geoOut._vertices = null;
          this.geoOut._colors = null;
          this.geoOut._indices = null;
          this.geoOut._normals = null;
          this.geoOut._numVertices = 0;
          this.geoOut._numTriangles = 0;
          this.geoOut = null; // estimage geo vertices budget again

          numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
          maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
          maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2); // creates empty new geometry

          this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
          ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

          if (ok < 0) {
            return ok;
          } // build vertices and triangles from corners values


          ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
        } // build vertex normals


        this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals); // More value : more smooth color mixing
        // value about 0.7: very rough colors borders

        var radiusColorSmoothness = 6.5;

        if (this.excludeProbe) {
          radiusColorSmoothness -= 1.5;
        }

        if (this.useVertexColors) {
          this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
        }

        this.voxelWorld.destroyVoxels();
        this.voxelWorld = null; // remove objects

        cube.destroy();
        return ok;
      }
    }]);

    return SSIsosurfaceGeometry;
  }(IsoSurfaceGeometry); // All code below must be erased from every device and each developer's memory

  function _createSuper$x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function createLabel(fieldTxt, className) {
    var text = document.createElement('div');
    text.className = className;

    if (typeof fieldTxt === 'string') {
      var spanText = document.createElement('span');
      spanText.style.fontSize = '150%';
      var strings = fieldTxt.split('\n');

      for (var i = 0, n = strings.length; i < n; ++i) {
        var spanNodeP = document.createElement('span');
        var spanNodeText = document.createTextNode(strings[i]);
        spanNodeP.appendChild(spanNodeText);
        spanText.appendChild(spanNodeP);

        if (i < n - 1) {
          spanText.appendChild(document.createElement('br'));
        }
      }

      text.appendChild(spanText);
    } else {
      text.appendChild(fieldTxt);
    }

    text.worldPos = new THREE.Vector3();
    return text;
  }

  var LabelsGeometry = /*#__PURE__*/function (_EventDispatcher) {
    inherits(LabelsGeometry, _EventDispatcher);

    var _super = _createSuper$x(LabelsGeometry);

    function LabelsGeometry(instanceCount, opts) {
      var _this;

      classCallCheck(this, LabelsGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.items = [];
      _this.needsUpdate = false;
      var xTranslation = -50;
      var yTranslation = -50;

      switch (opts.horizontalAlign) {
        case 'left':
          xTranslation = 0;
          break;

        case 'right':
          xTranslation = -100;
          break;
      }

      switch (opts.verticalAlign) {
        case 'top':
          yTranslation = -100;
          break;

        case 'bottom':
          yTranslation = 0;
          break;
      }

      var deltaPos = new THREE.Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
      _this.userData = {
        translation: "translate(".concat(xTranslation, "%, ").concat(yTranslation, "%)"),
        offset: deltaPos
      };
      return _this;
    }

    createClass(LabelsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, fieldTxt) {
        var opts = this._opts;
        var text = this.items[itemIdx] || createLabel(fieldTxt, 'label');
        text.worldPos.copy(itemPos);
        text.style.textAlign = opts.horizontalAlign;
        text.style.verticalAlign = opts.verticalAlign;
        this.items[itemIdx] = text;
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, fColor, bColor) {
        var text = this.items[itemIdx];
        text.opts = {
          color: fColor,
          background: bColor
        };
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.needsUpdate = true;
        this.dispatchEvent({
          type: 'update'
        });
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
      } // unimplemented functions

    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "setOpacity",
      value: function setOpacity() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return LabelsGeometry;
  }(EventDispatcher);

  var geometries = {
    InstancedSpheresGeometry: InstancedSpheresGeometry,
    SimpleSpheresGeometry: SimpleSpheresGeometry,
    Simple2CCylindersGeometry: Simple2CCylindersGeometry,
    Instanced2CCylindersGeometry: Instanced2CCylindersGeometry,
    ExtrudedObjectsGeometry: ExtrudedObjectsGeometry,
    ChunkedLinesGeometry: ChunkedLinesGeometry,
    TwoColorLinesGeometry: TwoColorLinesGeometry,
    CrossGeometry: CrossGeometry,
    QuickSurfGeometry: QuickSurfGeometry,
    ContactSurfaceGeometry: ContactSurfaceGeometry,
    SSIsosurfaceGeometry: SSIsosurfaceGeometry,
    LabelsGeometry: LabelsGeometry
  };

  var vertexShader = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\n\nattribute vec3 normal;\n\n#ifdef NORMALS_TO_G_BUFFER\n  varying vec3 viewNormal;\n#endif\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  varying vec3 vNormal;\n#endif\n\n#ifdef THICK_LINE\n  attribute vec4 position; // W contains vert pos or neg offset\n#else\n  attribute vec3 position;\n#endif\n\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;\n\n#ifdef ATTR_ALPHA_COLOR\n  attribute float alphaColor;\n  varying float alphaCol;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  attribute vec3 color;\n  varying vec3 vColor;\n#endif\n\n#ifdef ATTR_COLOR2\n  attribute vec3 color2;\n  varying vec3 vColor2;\n  attribute vec2 uv;\n  #ifndef CYLINDER_SPRITE\n    varying vec2 vUv;\n  #endif\n#endif\n\n#ifdef INSTANCED_POS\n  attribute vec4 offset;\n  #ifdef SPHERE_SPRITE\n    varying vec4 instOffset;\n  varying vec4 spritePosEye;\n  #endif\n#endif\n\n#ifdef INSTANCED_MATRIX\n  attribute vec4 matVector1;\n  attribute vec4 matVector2;\n  attribute vec4 matVector3;\n  attribute vec4 invmatVector1;\n  attribute vec4 invmatVector2;\n  attribute vec4 invmatVector3;\n\n  #ifdef CYLINDER_SPRITE\n    varying vec4 matVec1;\n    varying vec4 matVec2;\n    varying vec4 matVec3;\n    varying vec4 invmatVec1;\n    varying vec4 invmatVec2;\n    varying vec4 invmatVec3;\n    varying vec4 spritePosEye;\n  #endif\n#endif\n\nuniform mat4 modelViewMatrix; // optional\nuniform mat4 projectionMatrix; // optional\nuniform mat3 normalMatrix; // optional\nuniform mat4 modelMatrix; // optional\n\n#ifdef DASHED_LINE\n  attribute float lineDistance;\n  varying float vLineDistance;\n#endif\n\n#ifdef THICK_LINE\n  attribute vec3 direction;\n  uniform mat4 projMatrixInv;\n  uniform vec2 viewport;\n  uniform float lineWidth;\n\n  vec4 transform(vec4 coord){\n    return projectionMatrix * modelViewMatrix * coord;\n  }\n\n  vec2 project(vec4 device){\n    vec3 device_normal = device.xyz/device.w;\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\n    return clip_pos * viewport;\n  }\n\n  vec4 unproject(vec2 screen, float z, float w){\n    vec2 clip_pos = screen/viewport;\n    vec2 device_normal = clip_pos*2.0-1.0;\n    return vec4(device_normal*w, z, w);\n  }\n#endif\n\n\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\nvoid main() {\n\n#ifdef ATTR_ALPHA_COLOR\n  alphaCol = alphaColor;\n#endif\n\n#ifdef INSTANCED_MATRIX\n  vec3 objectNormal = vec3(\n    dot(normal, matVector1.xyz),\n    dot(normal, matVector2.xyz),\n    dot(normal, matVector3.xyz));\n#else\n  vec3 objectNormal = vec3( normal );\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  vNormal = normalize(transformedNormal);\n#endif\n\n#ifdef NORMALS_TO_G_BUFFER\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\n#endif\n\n  vec4 localPos = vec4(position.xyz, 1.0);\n  vec4 worldPos = modelMatrix * localPos;\n  vec4 mvPosition = modelViewMatrix * localPos;\n\n// make thick line offset\n#ifdef THICK_LINE\n   // get screen pos\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\n   vec2 sPos = project(dPos);\n   // move pos forward\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\n   // get screen offset pos\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\n   vec2 sPos2 = project(dPos2);\n   // screen line direction\n   vec2 sDir = normalize(sPos2 - sPos);\n   // vertex offset (orthogonal to line direction)\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\n   // move screen vertex\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\n   // get moved pos in view space\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\n#endif // THICK_LINE\n\n#ifdef INSTANCED_POS\n  #ifdef SPHERE_SPRITE\n    instOffset = offset;\n\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\n    float scale = length(modelViewMatrix[0]);\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\n    posEye.w = offset.w * scale;\n\n    spritePosEye = posEye;\n #else\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\n    worldPos = modelMatrix * localPos;\n    mvPosition = modelViewMatrix * localPos;\n  #endif\n#endif\n\n#ifdef INSTANCED_MATRIX\n  #ifdef CYLINDER_SPRITE\n    matVec1 = matVector1;\n    matVec2 = matVector2;\n    matVec3 = matVector3;\n    invmatVec1 = invmatVector1;\n    invmatVec2 = invmatVector2;\n    invmatVec3 = invmatVector3;\n\n    // calculate eye coords of cylinder endpoints\n    vec4 v = vec4(0, -0.5, 0, 1);\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\n    v.y = 0.5;\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\n\n    // sprite is placed at the center of cylinder\n    vec4 posEye;\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\n    posEye.w = 1.0;\n    spritePosEye = posEye;\n\n    // cylinder radius in eye space\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\n    vec2 spriteSize;\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // In ortho projection we skip z coordinate\n      // basic sprite size at screen plane (covers only cylinder axis)\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\n\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\n    #else\n      // basic sprite size at screen plane (covers only cylinder axis)\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\n\n      // full sprite size in eye coords\n      float minZ = min(abs(p1.z), abs(p2.z));\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\n    #endif\n\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\n  #else\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\n    worldPos = modelMatrix * localPos;\n    mvPosition = modelViewMatrix * localPos;\n  #endif\n#endif\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  vWorldPosition = worldPos.xyz;\n  vViewPosition = - mvPosition.xyz;\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t  vec4 worldPosition;\n\t  // see THREE.WebGLProgram.unrollLoops\n\t  #pragma unroll_loop_start\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\n\t  }\n\t  #pragma unroll_loop_end\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  vColor = color.xyz;\n#endif\n\n#ifdef ATTR_COLOR2\n  vColor2 = color2;\n  #ifndef CYLINDER_SPRITE\n    vUv = uv;\n  #endif\n#endif\n\n#ifdef DASHED_LINE\n  vLineDistance = lineDistance;\n#endif\n}\n";

  var fragmentShader = "#if defined (NORMALS_TO_G_BUFFER)\n  #define fragColor gl_FragData[0]\n#else\n  #define fragColor gl_FragColor\n#endif\n\n#ifdef ATTR_ALPHA_COLOR\n  varying float alphaCol;\n#endif\n\n#ifdef COLOR_FROM_POS\n  uniform mat4 world2colorMatrix;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\n\n    #ifdef SHADOWMAP_PCF_RAND\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\n      // unroll_loop and unroll_loop has pattern:\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\n      uniform sampler2D noiseTex;\n      uniform vec2 noiseTexelSize;\n      uniform vec2 srcTexelSize;\n      uniform mat4 projectionMatrix;\n    #endif\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  varying vec3 vColor;\n#endif\n\n#ifdef ATTR_COLOR2\n  varying vec3 vColor2;\n  #ifndef CYLINDER_SPRITE\n    varying vec2 vUv;\n  #endif\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform vec3 fixedColor;\nuniform float opacity;\nuniform float zClipValue;\nuniform float clipPlaneValue;\n\n#ifdef NORMALS_TO_G_BUFFER\n  varying vec3 viewNormal;\n#endif\n\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\n#ifdef USE_FOG\n  uniform vec3 fogColor;\n  uniform float fogAlpha;\n  uniform float fogNear;\n  uniform float fogFar;\n#endif\n\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\nvarying vec3 vViewPosition;\n\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  varying vec3 vNormal;\n#endif\n\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\n  uniform float nearPlaneValue;\n#endif\n\n#ifdef SPHERE_SPRITE\n  varying vec4 spritePosEye;\n#endif\n\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n  uniform float zOffset;\n\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\n    uniform mat4 projectionMatrix;\n  #endif\n\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\n  }\n#endif\n\n#ifdef SPHERE_SPRITE\n  varying vec4 instOffset;\n  uniform mat4 modelMatrix;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 invModelViewMatrix;\n  uniform mat3 normalMatrix;\n\n\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\n\n    // intersect XZ-projected ray with circle\n    float a = dot(ray, ray);\n    float b = dot(ray, origin);\n    float c = dot(origin, origin) - 1.0;\n    float det = b * b - a * c;\n    if (det < 0.0) return false;\n    float t1 = (-b - sqrt(det)) / a;\n    float t2 = (-b + sqrt(det)) / a;\n\n    // calculate both intersection points\n    vec3 p1 = origin + ray * t1;\n    vec3 p2 = origin + ray * t2;\n\n    // choose nearest point inside frustum\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\n      // t1 is always smaller than t2 (from calculations)\n      point = p1;\n      frontFaced = 1.0;\n      return true;\n    #else\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\n      if (t1 >= 0.0) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (t2 >= 0.0) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #endif\n\n    return false;\n  }\n\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\n    vec3 origin, ray;\n\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // transform vector from sprite center to curPixel into sphere local coords\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\n\n      // transform camera orientation vector into sphere local coords\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n    #else\n      // find point of intersection near plane by the ray from camera to curPixel\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\n\n      // transform intersection point into sphere local coords\n      v = invModelViewMatrix * v;\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\n\n      // transform vector from camera pos to curPixel into sphere local coords\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\n    #endif\n    ray = normalize(ray);\n\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\n  }\n#endif\n\n#ifdef CYLINDER_SPRITE\n  varying vec4 matVec1;\n  varying vec4 matVec2;\n  varying vec4 matVec3;\n  varying vec4 invmatVec1;\n  varying vec4 invmatVec2;\n  varying vec4 invmatVec3;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 invModelViewMatrix;\n  uniform mat3 normalMatrix;\n\n  varying vec4 spritePosEye;\n\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\n\n    // intersect XZ-projected ray with circle\n    float a = dot(ray.xz, ray.xz);\n    float b = dot(ray.xz, origin.xz);\n    float c = dot(origin.xz, origin.xz) - 1.0;\n    float det = b * b - a * c;\n    if (det < 0.0) return false;\n    float t1 = (-b - sqrt(det)) / a;\n    float t2 = (-b + sqrt(det)) / a;\n\n    // calculate both intersection points\n    vec3 p1 = origin + ray * t1;\n    vec3 p2 = origin + ray * t2;\n\n    float halfHeight = 0.5;\n\n    // choose nearest point\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #else\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #endif\n\n    return false;\n  }\n\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\n    vec3 origin, ray;\n    vec4 v;\n\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // transform vector from sprite center to curPixel into cylinder local coords\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n\n      // transform camera orientation vector into cylinder local coords\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n    #else\n      // find point of intersection near plane by the ray from camera to curPixel\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\n\n      // transform intersection point into cylinder local coords\n      v = invModelViewMatrix * v;\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n\n      // transform vector from camera pos to curPixel into cylinder local coords\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n    #endif\n    ray = normalize(ray);\n\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\n  }\n#endif\n\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n  vec4 r = vec4( fract( v * PackFactors ), v );\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n  return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n  return dot( v, UnpackFactors );\n}\n\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\n#ifdef TOON_SHADING\n  #define LOW_TOON_BORDER 0.0\n  #define MEDIUM_TOON_BORDER 0.7\n  #define HIGH_TOON_BORDER 1.0\n\n  #define MEDIUM_TOON_RANGE 0.5\n  #define HIGH_TOON_RANGE 0.95\n#endif\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\n  struct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n  };\n\n  struct BlinnPhongMaterial {\n    vec3  diffuseColor;\n    vec3  specularColor;\n    float specularShininess;\n  };\n\n  struct GeometricContext {\n    vec3 normal;\n    vec3 viewDir;\n  };\n\n  struct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n  };\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n  struct DirectionalLightShadow {\n     vec2 shadowMapSize;\n     float shadowBias;\n     float shadowRadius;\n   };\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\n\n  uniform vec3 ambientLightColor;\n\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\n\n  #if defined(SHADOWMAP)\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n  \t}\n\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\n   \t  float shadow = 0.0;\n\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\n      shadowCoord.xyz /= shadowCoord.w;\n\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n      bool inFrustum = all( inFrustumVec );\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n      bool frustumTest = all( frustumTestVec );\n\n      if ( frustumTest ) {\n        #ifdef SHADOWMAP_BASIC\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n      \t#endif\n\n      \t#ifdef SHADOWMAP_PCF_SHARP\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\n\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\n\n            shadow = (\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n            ) * ( 1.0 / 9.0 );\n        #endif\n\n        #ifdef SHADOWMAP_PCF_RAND\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\n\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\n\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\n\n          vec2 offset;\n          #pragma unroll_loop_start\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\n          }\n          #pragma unroll_loop_end\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\n        #endif\n      }\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\n   }\n  #endif\n\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\n\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  } // validated\n\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n    // Original approximation by Christophe Schlick '94\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\n  } // validated\n\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n    return 0.25;\n  }\n\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n  }\n\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\n\n    vec3 F = F_Schlick( specularColor, dotLH );\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n    float D = D_BlinnPhong( shininess, dotNH );\n\n    return F * ( G * D );\n  } // validated\n\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\n    #ifdef TOON_SHADING\n      if(dotNL < MEDIUM_TOON_RANGE){\n        dotNL = LOW_TOON_BORDER;\n      }\n      else if(dotNL < HIGH_TOON_RANGE){\n        dotNL = MEDIUM_TOON_BORDER;\n      }\n      else{\n        dotNL = HIGH_TOON_BORDER;\n      }\n    #endif\n\n    vec3 irradiance = dotNL * directLight.color * PI;\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\n  }\n\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n  }\n\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\n    vec3 irradiance = ambientLightColor * PI;\n\n    float shadowMask = 1.0;\n    // see THREE.WebGLProgram.unrollLoops\n  \t#pragma unroll_loop_start\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n  \t    #ifdef SHADOWMAP\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\n        #endif\n\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\n  \t\t}\n  \t\t#pragma unroll_loop_end\n\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\n\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\n  }\n#endif\n\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\n#ifdef DASHED_LINE\n  uniform float dashedLineSize;\n  uniform float dashedLinePeriod;\n  varying float vLineDistance;\n#endif\n\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\nvoid main() {\n\n#ifdef CLIP_PLANE\n  if (vViewPosition.z < clipPlaneValue) discard;\n#endif\n\n#ifdef ZCLIP\n  if (vViewPosition.z < zClipValue) discard;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n  #if NUM_DIR_LIGHTS > 0\n    // see THREE.WebGLProgram.unrollLoops\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\n    }\n    #pragma unroll_loop_end\n  #endif\n#endif\n\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\n  vec4 pixelPosEye;\n\n#ifdef SPHERE_SPRITE\n\n  vec3 viewNormalSprites;\n  float frontFaced = 1.0;\n  vec3 normal;\n\n/* quick-and-dirty method\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\n  float r2 = dot(normal.xy, normal.xy);\n  if (r2 > 1.0) discard;\n  float normalZ = sqrt(1.0 - r2);\n  normal.z = normalZ;\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\n  pixelPosEye.z += spritePosEye.w * normalZ;\n*/\n\n  // ray-trace sphere surface\n  {\n    vec3 p;\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\n    pixelPosWorld = modelMatrix * v;\n    pixelPosEye = modelViewMatrix * v;\n    normal = normalize(normalMatrix * p);\n    #ifdef NORMALS_TO_G_BUFFER\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\n    #endif\n\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\n      #if NUM_DIR_LIGHTS > 0\n        // see THREE.WebGLProgram.unrollLoops\n        #pragma unroll_loop_start\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\n          }\n        #pragma unroll_loop_end\n      #endif\n    #endif\n  }\n#endif\n\n#ifdef CYLINDER_SPRITE\n  vec3 normal;\n  vec3 viewNormalSprites;\n  float frontFaced = 1.0;\n  float cylinderY = 0.0;\n\n  // ray-trace cylinder surface\n  {\n    vec3 p;\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\n\n    cylinderY = 0.5 * (p.y + 1.0);\n\n    vec4 v = vec4(p, 1.0);\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\n    pixelPosWorld = modelMatrix * v;\n    pixelPosEye = modelViewMatrix * v;\n\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\n    normal = vec3(\n      dot(localNormal, matVec1.xyz),\n      dot(localNormal, matVec2.xyz),\n      dot(localNormal, matVec3.xyz));\n    #ifdef NORMALS_TO_G_BUFFER\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\n    #endif\n\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\n      #if NUM_DIR_LIGHTS > 0\n        // see THREE.WebGLProgram.unrollLoops\n        #pragma unroll_loop_start\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\n          }\n        #pragma unroll_loop_end\n      #endif\n    #endif\n\n    normal = normalize(normalMatrix * normal);\n  }\n#endif\n\n  #ifdef ATTR_COLOR\n    vec3 vertexColor = vColor;\n  #else\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\n  #endif\n\n  #ifdef ATTR_COLOR2\n    #ifdef CYLINDER_SPRITE\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\n    #else\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\n    #endif\n      // choose either color or color2\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\n  #endif\n\n  // negative red component is a special condition\n  if (vertexColor.x < 0.0) discard;\n\n  #ifdef DASHED_LINE\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\n  #endif\n\n  // transparency prepass writes only z, so we don't need to calc the color\n  #ifdef PREPASS_TRANSP\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n    #endif\n    return;\n  #endif\n\n    float totalOpacity = opacity;\n\n  #ifdef ATTR_ALPHA_COLOR\n    totalOpacity *= alphaCol;\n  #endif\n\n  // discard fully transparent pixels\n  if (totalOpacity == 0.0) discard;\n\n  #ifdef FAKE_OPACITY\n    // discard pixels in checker pattern\n    vec2 dm_coord = floor(gl_FragCoord.xy);\n    dm_coord = fract(dm_coord * 0.5);\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\n    vec4 diffuseColor = vec4(diffuse, 1.0);\n  #else\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\n  #endif\n\n  float flipNormal;\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n    flipNormal = 1.0;\n    #ifdef DOUBLE_SIDED\n      flipNormal = float( gl_FrontFacing );\n    #endif\n    vec3 normal = normalize( vNormal ) * flipNormal;\n  #endif\n\n    diffuseColor.rgb *= vertexColor;\n\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n  #endif\n\n  #ifdef NORMALS_TO_G_BUFFER\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\n      vec3 viewNormaInColor = viewNormalSprites;\n    #else\n      vec3 viewNormaInColor = viewNormal;\n      float frontFaced = float( gl_FrontFacing );\n    #endif\n    // [-1, 1] -> [0, 1]\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\n  #endif\n\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\n    vec3 viewDir;\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      viewDir = -pixelPosEye.xyz;\n    #else\n      viewDir = vViewPosition;\n    #endif\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\n  #else\n    vec3 outgoingLight = diffuseColor.rgb;\n  #endif\n\n  #ifdef COLOR_FROM_DEPTH\n    float depth = 0.0;\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n      depth = gl_FragDepthEXT;\n    #else\n      depth = gl_FragCoord.z;\n    #endif\n    fragColor = packDepthToRGBA(depth);\n    return;\n  #endif\n\n  #ifdef COLOR_FROM_POS\n    fragColor = world2colorMatrix * pixelPosWorld;\n  #else\n    #ifdef OVERRIDE_COLOR\n      fragColor = vec4(fixedColor, diffuseColor.a);\n    #else\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\n    #endif\n\n    #ifdef USE_FOG\n      float viewDistance;\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n        viewDistance = abs(pixelPosEye.z);\n      #else\n        viewDistance = vViewPosition.z;\n      #endif\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\n      #ifdef FOG_TRANSPARENT\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\n      #else\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\n      #endif\n    #endif\n\n  #endif\n}\n";

  var capabilities = {
    precision: 'mediump',

    /**
     *
     * @param {THREE.WebGLRenderer} renderer
     */
    init: function init(renderer) {
      this.precision = renderer.capabilities.getMaxPrecision('highp');
    }
  };

  var noiseWidth = 4;
  var noiseHeight = 4;

  var _noiseData = new Uint8Array([24, 52, 0, 254, 145, 0, 122, 0, 0, 7, 170, 0, 34, 214, 0, 173, 8, 0, 86, 249, 0, 160, 4, 0, 226, 46, 0, 224, 211, 0, 3, 157, 0, 174, 247, 0, 12, 182, 0, 220, 216, 0, 1, 109, 0, 253, 154, 0]);

  var _noiseWrapS = THREE.RepeatWrapping;
  var _noiseWrapT = THREE.RepeatWrapping;
  var _noiseMinFilter = THREE.NearestFilter;
  var _noiseMagFilter = THREE.NearestFilter;
  var _noiseMapping = THREE.UVMapping;
  var noiseTexture = new THREE.DataTexture(_noiseData, noiseWidth, noiseHeight, THREE.RGBFormat, THREE.UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
  noiseTexture.needsUpdate = true;
  var noise = {
    noiseWidth: noiseWidth,
    noiseHeight: noiseHeight,
    noiseTexture: noiseTexture
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  // If you want to change length of _samplesKernel, please, remember change it in Uber.frag too.
  // You can easy find places for replace using word:_samplesKernel

  var _samplesKernel = [new THREE.Vector2(-0.541978, 0.840393), new THREE.Vector2(0.125533, -0.992089), new THREE.Vector2(0.374329, 0.927296), new THREE.Vector2(-0.105475, 0.994422)];
  var defaultUniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
    // are updated automatically by three.js (see THREE.ShaderLib.common)
    diffuse: {
      value: new THREE.Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    specular: {
      type: 'c',
      value: new THREE.Color(0x111111)
    },
    shininess: {
      type: 'f',
      value: 30
    },
    fixedColor: {
      type: 'c',
      value: new THREE.Color(0xffffff)
    },
    zOffset: {
      type: 'f',
      value: 0.0
    },
    zClipValue: {
      type: 'f',
      value: 0.0
    },
    clipPlaneValue: {
      type: 'f',
      value: 0.0
    },
    nearPlaneValue: {
      type: 'f',
      value: -0.5
    },
    invModelViewMatrix: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    world2colorMatrix: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    dashedLineSize: {
      type: 'f',
      value: 0.1
    },
    dashedLinePeriod: {
      type: 'f',
      value: 0.2
    },
    projMatrixInv: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    viewport: {
      type: 'v2',
      value: new THREE.Vector2()
    },
    lineWidth: {
      type: 'f',
      value: 2.0
    },
    // default value must be the same as settings
    fogAlpha: {
      type: 'f',
      value: 1.0
    },
    samplesKernel: {
      type: 'v2v',
      value: null
    },
    noiseTex: {
      type: 't',
      value: null
    },
    noiseTexelSize: {
      type: 'v2',
      value: null
    },
    srcTexelSize: {
      type: 'v2',
      value: null
    }
  }]);
  var uberOptionNames = ['shininess', 'opacity', 'zOffset', 'diffuse', 'specular', 'fixedColor', 'zClipCoef', 'zClipValue', 'clipPlaneValue', 'world2colorMatrix', 'dashedLineSize', 'dashedLinePeriod', 'projMatrixInv', 'viewport', 'lineWidth', 'fogAlpha', 'samplesKernel', 'noiseTex', 'noiseTexelSize', 'srcTexelSize'];

  function UberMaterial(params) {
    THREE.RawShaderMaterial.call(this); // add fog

    this.fog = true; // used for instanced geometry

    this.instancedPos = false;
    this.instancedMatrix = false; // atoms and links color

    this.attrColor = false; // second link color for cylinders

    this.attrColor2 = false; //

    this.attrAlphaColor = false; // overrides color for all vertices (used in selection)

    this.overrideColor = false; // zsrpites

    this.sphereSprite = false;
    this.cylinderSprite = false; // clip Surfs individually

    this.zClip = false; // clip scene with global clip plane

    this.clipPlane = false; // enable fake (chess-like) opacity

    this.fakeOpacity = false; // render only depth, don't take care about the pixel color (used for transparency depth prepass)

    this.prepassTransparancy = false; // used to render pixel positions

    this.colorFromPos = false; // used to render shadowmap

    this.shadowmap = false; // used to describe shadowmap type

    this.shadowmapType = 'random'; // used to render pixel view deph

    this.colorFromDepth = false; // mark that rendering is for orthographic camera

    this.orthoCam = false; // used to render dashed line

    this.dashedLine = false; // mark as transparent

    this.transparent = true; // mark as thick lines

    this.thickLine = false; // makes fog begin transparency (required for transparent background)

    this.fogTransparent = false; // used to render surface normals to G buffer for ssao effect

    this.normalsToGBuffer = false; // used for toon material

    this.toonShading = false; // uber options of "root" materials are inherited from single uber-options object that resides in prototype

    this.uberOptions = Object.create(UberMaterial.prototype.uberOptions); // set default values

    THREE.RawShaderMaterial.prototype.setValues.call(this, {
      uniforms: THREE.UniformsUtils.clone(defaultUniforms),
      vertexShader: this.precisionString() + vertexShader,
      fragmentShader: this.precisionString() + fragmentShader,
      lights: true,
      fog: true,
      side: THREE.DoubleSide
    });
    this.setValues(params);
  }

  UberMaterial.prototype = Object.create(THREE.RawShaderMaterial.prototype);
  UberMaterial.prototype.constructor = UberMaterial;

  UberMaterial.prototype.precisionString = function () {
    var precision = capabilities.precision;
    var str = "precision ".concat(precision, " float;\n") + "precision ".concat(precision, " int;\n\n");
    return str;
  }; // properties that convert to uniforms


  UberMaterial.prototype.uberOptions = {
    diffuse: new THREE.Color(0xffffff),
    // used in phong lighting
    specular: new THREE.Color(0x111111),
    // used in phong lighting
    shininess: 30,
    // used in phong lighting
    opacity: 1,
    // set mesh opacity
    fixedColor: new THREE.Color(0xffffff),
    // color to override (see OVERRIDE_COLOR)
    zOffset: 0.0,
    // used fo zsprites (see SPHERE_SPRITE CYLINDER_SPRITE)
    zClipCoef: 2.0,
    // use for Surfs clipping (mesh param, isn't used in shader)  FIXME move to representation param
    zClipValue: 0.0,
    //  value to clip Surfs in shader  (see ZCLIP)
    clipPlaneValue: 0.0,
    // value to clip scene globally (see CLIPPLANE)
    world2colorMatrix: new THREE.Matrix4(),
    dashedLineSize: 0.1,
    dashedLinePeriod: 0.3,
    projMatrixInv: new THREE.Matrix4(),
    viewport: new THREE.Vector2(800, 600),
    lineWidth: 2.0,
    fogAlpha: 1.0,
    samplesKernel: _samplesKernel,
    noiseTex: noise.noiseTexture,
    noiseTexelSize: new THREE.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight),
    srcTexelSize: new THREE.Vector2(1.0 / 800.0, 1.0 / 600.0),
    copy: function copy(source) {
      this.diffuse.copy(source.diffuse);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.opacity = source.opacity;
      this.fixedColor.copy(source.fixedColor);
      this.zOffset = source.zOffset;
      this.zClipCoef = source.zClipCoef;
      this.zClipValue = source.zClipValue;
      this.clipPlaneValue = source.clipPlaneValue;
      this.world2colorMatrix.copy(source.world2colorMatrix);
      this.dashedLineSize = source.dashedLineSize;
      this.dashedLinePeriod = source.dashedLinePeriod;
      this.projMatrixInv = source.projMatrixInv;
      this.viewport = source.viewport;
      this.lineWidth = source.lineWidth; // used for thick lines only

      this.toonShading = source.toonShading;
      this.fogAlpha = source.fogAlpha;
      this.samplesKernel = source.samplesKernel;
      this.noiseTex = source.noiseTex;
      this.noiseTexelSize = source.noiseTexelSize;
      this.srcTexelSize = source.srcTexelSize;
    }
  };

  UberMaterial.prototype.copy = function (source) {
    THREE.RawShaderMaterial.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
    this.defines = _objectSpread({}, source.defines);
    this.extensions = source.extensions;
    this.fog = source.fog;
    this.instancedPos = source.instancedPos;
    this.instancedMatrix = source.instancedMatrix;
    this.attrColor = source.attrColor;
    this.attrColor2 = source.attrColor2;
    this.attrAlphaColor = source.attrAlphaColor;
    this.overrideColor = source.overrideColor;
    this.sphereSprite = source.sphereSprite;
    this.cylinderSprite = source.cylinderSprite;
    this.zClip = source.zClip;
    this.clipPlane = source.clipPlane;
    this.fakeOpacity = source.fakeOpacity;
    this.colorFromPos = source.colorFromPos;
    this.shadowmap = source.shadowmap;
    this.shadowmapType = source.shadowmapType;
    this.colorFromDepth = source.colorFromDepth;
    this.orthoCam = source.orthoCam;
    this.prepassTransparancy = source.prepassTransparancy;
    this.dashedLine = source.dashedLine;
    this.thickLine = source.thickLine;
    this.fogTransparent = source.fogTransparent;
    this.normalsToGBuffer = source.normalsToGBuffer;
    this.toonShading = source.toonShading;
    this.uberOptions.copy(source.uberOptions);
    return this;
  }; // create copy of this material
  // its options are prototyped after this material's options


  UberMaterial.prototype.createInstance = function () {
    var inst = new UberMaterial();
    inst.copy(this);
    inst.uberOptions = Object.create(this.uberOptions);
    return inst;
  };

  UberMaterial.prototype.setValues = function (values) {
    if (typeof values === 'undefined') {
      return;
    } // set direct values


    THREE.RawShaderMaterial.prototype.setValues.call(this, values);
    var defines = {};
    var extensions = {};

    if (this.fog) {
      defines.USE_FOG = 1;
    }

    if (this.instancedPos) {
      defines.INSTANCED_POS = 1;
    }

    if (this.instancedMatrix) {
      defines.INSTANCED_MATRIX = 1;
    }

    if (this.attrColor) {
      defines.ATTR_COLOR = 1;
    }

    if (this.attrColor2) {
      defines.ATTR_COLOR2 = 1;
    }

    if (this.attrAlphaColor) {
      defines.ATTR_ALPHA_COLOR = 1;
    }

    if (this.overrideColor) {
      defines.OVERRIDE_COLOR = 1;
    }

    if (this.sphereSprite) {
      defines.SPHERE_SPRITE = 1;
      extensions.fragDepth = 1;
    }

    if (this.cylinderSprite) {
      defines.CYLINDER_SPRITE = 1;
      extensions.fragDepth = 1;
    }

    if (this.zClip) {
      defines.ZCLIP = 1;
    }

    if (this.clipPlane) {
      defines.CLIP_PLANE = 1;
    }

    if (this.fakeOpacity) {
      defines.FAKE_OPACITY = 1;
    }

    if (this.lights) {
      defines.USE_LIGHTS = 1;
    }

    if (this.colorFromPos) {
      defines.COLOR_FROM_POS = 1;
    }

    if (this.shadowmap) {
      defines.SHADOWMAP = 1;

      if (this.shadowmapType === 'pcf') {
        defines.SHADOWMAP_PCF_SHARP = 1;
      } else if (this.shadowmapType === 'random') {
        defines.SHADOWMAP_PCF_RAND = 1;
      } else {
        defines.SHADOWMAP_BASIC = 1;
      }
    }

    if (this.colorFromDepth) {
      defines.COLOR_FROM_DEPTH = 1;
    }

    if (this.orthoCam) {
      defines.ORTHOGRAPHIC_CAMERA = 1;
    }

    if (this.prepassTransparancy) {
      defines.PREPASS_TRANSP = 1;
    }

    if (this.dashedLine) {
      defines.DASHED_LINE = 1;
    }

    if (this.thickLine) {
      defines.THICK_LINE = 1;
    }

    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }

    if (this.normalsToGBuffer) {
      extensions.drawBuffers = 1;
      defines.NORMALS_TO_G_BUFFER = 1;
    }

    if (this.toonShading) {
      defines.TOON_SHADING = 1;
    } // set dependent values


    this.defines = defines;
    this.extensions = extensions;
  };

  UberMaterial.prototype.setUberOptions = function (values) {
    if (typeof values === 'undefined') {
      return;
    }

    for (var key in values) {
      if (!values.hasOwnProperty(key)) {
        continue;
      }

      if (this.uberOptions[key] instanceof THREE.Color) {
        this.uberOptions[key] = values[key].clone();
      } else {
        this.uberOptions[key] = values[key];
      }
    }
  };

  UberMaterial.prototype.clone = function (shallow) {
    if (!shallow) {
      return THREE.Material.prototype.clone.call(this);
    }

    return this.createInstance();
  };

  UberMaterial.prototype.updateUniforms = function () {
    var self = this;
    uberOptionNames.forEach(function (p) {
      if (self.uniforms.hasOwnProperty(p)) {
        if (self.uberOptions[p] instanceof THREE.Color || self.uberOptions[p] instanceof THREE.Matrix4) {
          self.uniforms[p].value = self.uberOptions[p].clone();
        } else {
          self.uniforms[p].value = self.uberOptions[p];
        }
      }
    });
  };

  function _createSuper$y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  function UberObject (SuperClass) {
    var NewObjectType = /*#__PURE__*/function (_SuperClass) {
      inherits(NewObjectType, _SuperClass);

      var _super = _createSuper$y(NewObjectType);

      function NewObjectType() {
        var _this;

        classCallCheck(this, NewObjectType);

        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(rest));
        _this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
        return _this;
      }

      createClass(NewObjectType, [{
        key: "onBeforeRender",
        value: function onBeforeRender(renderer, scene, camera, geometry, material, group) {
          this._onBeforeRender(renderer, scene, camera, geometry, material, group);

          this._update();
        }
      }, {
        key: "_onBeforeRender",
        value: function _onBeforeRender() {}
      }, {
        key: "_update",
        value: function _update() {
          var material = this.material;

          if (!material) {
            return;
          }

          if (material instanceof UberMaterial) {
            material.updateUniforms();
          }
        }
      }]);

      return NewObjectType;
    }(SuperClass);

    return NewObjectType;
  }

  function _createSuper$z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$A(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh = UberObject(THREE.Mesh);

  var ZSpriteMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ZSpriteMesh, _Mesh);

    var _super = _createSuper$z(ZSpriteMesh);

    function ZSpriteMesh() {
      var _this;

      classCallCheck(this, ZSpriteMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    createClass(ZSpriteMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        Mesh.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var material = this.material;

        if (!material) {
          return;
        }

        if (material.uniforms.invModelViewMatrix) {
          // NOTE: update of modelViewMatrix inside threejs is done after onBeforeRender call,
          // so we have to do it manually in that place
          this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld); // get inverse matrix

          material.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
          material.uniforms.nearPlaneValue.value = camera.near;
          material.uniformsNeedUpdate = true;
        }
      }
    }]);

    return ZSpriteMesh;
  }(Mesh);

  function _createSuper$A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$B(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$1 = UberObject(THREE.Mesh);

  var ZClippedMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ZClippedMesh, _Mesh);

    var _super = _createSuper$A(ZClippedMesh);

    function ZClippedMesh(geometry, material) {
      var _this;

      classCallCheck(this, ZClippedMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    createClass(ZClippedMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera) {
        Mesh$1.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var geo = this.geometry;
        var material = this.material;

        if (!geo.zClip || !material.uberOptions) {
          return;
        }

        var zClipCoef = 0.5;
        var modelView = ZClippedMesh._modelView;
        var mvLength = ZClippedMesh._mvLength;
        var center = ZClippedMesh._center;
        modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
        var s = mvLength.setFromMatrixColumn(modelView, 0).length();
        center.copy(geo.boundingSphere.center);
        this.localToWorld(center);
        material.uberOptions.zClipValue = camera.position.z - center.z - s * (zClipCoef * geo.boundingSphere.radius);
      }
    }]);

    return ZClippedMesh;
  }(Mesh$1);

  defineProperty(ZClippedMesh, "_mvLength", new THREE.Vector3());

  defineProperty(ZClippedMesh, "_center", new THREE.Vector3());

  defineProperty(ZClippedMesh, "_modelView", new THREE.Matrix4());

  function _createSuper$B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$C(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TextMesh = /*#__PURE__*/function (_THREE$Group) {
    inherits(TextMesh, _THREE$Group);

    var _super = _createSuper$B(TextMesh);

    function TextMesh(geometry, _material) {
      var _this;

      classCallCheck(this, TextMesh);

      _this = _super.call(this);
      _this.geometry = geometry;

      var self = assertThisInitialized(_this);

      self.initialized = false;

      _this.geometry.addEventListener('update', function () {
        self.update();
      });

      return _this;
    }

    createClass(TextMesh, [{
      key: "init",
      value: function init() {
        var children = this.children;

        for (var i = children.length - 1; i >= 0; --i) {
          this.remove(children[i]);
        }

        var _this$geometry = this.geometry,
            items = _this$geometry.items,
            userData = _this$geometry.userData;

        for (var _i = 0, n = items.length; _i < n; ++_i) {
          var srcItem = items[_i];

          if (!srcItem) {
            continue;
          }

          var item = utils.shallowCloneNode(srcItem);
          var label = new CSS2DObject(item);
          label.userData = ___default['default'].clone(userData);
          var el = label.getElement();
          el.style.visibility = 'visible';
          label.source = srcItem;
          this.add(label);
        }

        this.initialized = true;
      }
    }, {
      key: "update",
      value: function update() {
        var geo = this.geometry;

        if (!geo.needsUpdate) {
          return;
        }

        var children = this.children;

        if (!this.initialized) {
          this.init();
        }

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];
          var item = child.source;
          child.position.copy(item.worldPos);
          child.userData.color = item.opts.color;
          child.userData.background = item.opts.background;
        }
      }
    }]);

    return TextMesh;
  }(THREE.Group);

  function _createSuper$C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$D(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$2 = UberObject(THREE.Mesh);

  var SimpleMesh = /*#__PURE__*/function (_Mesh) {
    inherits(SimpleMesh, _Mesh);

    var _super = _createSuper$C(SimpleMesh);

    function SimpleMesh(geometry, material) {
      var _this;

      classCallCheck(this, SimpleMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return SimpleMesh;
  }(Mesh$2);

  function _createSuper$D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$E(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$3 = UberObject(THREE.Mesh);

  var _viewport = new THREE.Vector2();

  var ThickLineMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ThickLineMesh, _Mesh);

    var _super = _createSuper$D(ThickLineMesh);

    function ThickLineMesh() {
      classCallCheck(this, ThickLineMesh);

      return _super.apply(this, arguments);
    }

    createClass(ThickLineMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!material.uberOptions) {
          return;
        }

        material.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
        renderer.getSize(_viewport);
        material.uberOptions.viewport.set(_viewport.width, _viewport.height);
      }
    }]);

    return ThickLineMesh;
  }(Mesh$3);

  function _createSuper$E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$F(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$4 = UberObject(THREE.Mesh);

  var InstancedMesh = /*#__PURE__*/function (_Mesh) {
    inherits(InstancedMesh, _Mesh);

    var _super = _createSuper$E(InstancedMesh);

    function InstancedMesh() {
      var _this;

      classCallCheck(this, InstancedMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return InstancedMesh;
  }(Mesh$4);

  var meshes = {
    ZClipped: ZClippedMesh,
    ZSprite: ZSpriteMesh,
    Text: TextMesh,
    Line: UberObject(THREE.Line),
    LineSegments: UberObject(THREE.LineSegments),
    Mesh: SimpleMesh,
    ThickLineMesh: ThickLineMesh,
    Instanced: InstancedMesh
  };

  function setMatParams(params, uniforms) {
    return function (material) {
      material.setValues(params);
      material.setUberOptions(uniforms);
    };
  }

  function _createInstancedCylinders(useZSprites, openEnded) {
    return {
      Geometry: function Geometry(a, b) {
        return new geometries.Instanced2CCylindersGeometry(a, b, useZSprites, openEnded);
      },
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedMatrix: true,
        attrColor: true,
        attrColor2: true,
        attrAlphaColor: true,
        cylinderSprite: useZSprites
      })
    };
  }

  function _createLineSegmentsGeoTriplet(geo, renderParams) {
    var thickLines = geo.prototype instanceof ThickLinesGeometry;
    var lineWidth = renderParams.lineWidth || 0;
    return {
      Geometry: geo,
      Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
      initMaterial: setMatParams({
        lights: false,
        attrColor: true,
        attrAlphaColor: true,
        thickLine: thickLines
      }, {
        lineWidth: lineWidth
      })
    };
  }

  function _createSimpleGeoTriplet(geoClass) {
    return {
      Geometry: geoClass,
      Object: meshes.Mesh,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: true
      })
    };
  }

  function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
    var surfaceOpts = {
      wireframe: !!renderParams.wireframe,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity,
      zClip: renderParams.zClip
    };
    return {
      Geometry: geoClass,
      Object: meshes.ZClipped,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: false,
        wireframe: surfaceOpts.wireframe,
        fakeOpacity: surfaceOpts.fakeOpacity,
        zClip: surfaceOpts.zClip
      })
    };
  }

  var MeshCreator = /*#__PURE__*/function () {
    function MeshCreator() {
      classCallCheck(this, MeshCreator);
    }

    createClass(MeshCreator, null, [{
      key: "createSpheres",
      value: function createSpheres(caps, settings) {
        var useZSprites = settings.now.zSprites;
        return {
          Geometry: function Geometry(a, b) {
            return new geometries.InstancedSpheresGeometry(a, b, useZSprites);
          },
          Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
          initMaterial: setMatParams({
            instancedPos: true,
            attrColor: true,
            attrAlphaColor: true,
            sphereSprite: useZSprites
          })
        };
      }
    }, {
      key: "create2CClosedCylinders",
      value: function create2CClosedCylinders(_caps, _settings) {
        return _createInstancedCylinders(false, false);
      }
    }, {
      key: "create2CCylinders",
      value: function create2CCylinders(caps, settings) {
        return _createInstancedCylinders(settings.now.zSprites, true);
      }
    }, {
      key: "create2CLines",
      value: function create2CLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
      }
    }, {
      key: "createCrosses",
      value: function createCrosses(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
      }
    }, {
      key: "createExtrudedChains",
      value: function createExtrudedChains(_caps, _settings) {
        return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
      }
    }, {
      key: "createChunkedLines",
      value: function createChunkedLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
      }
    }, {
      key: "createQuickSurface",
      value: function createQuickSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createContactSurface",
      value: function createContactSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createSASSES",
      value: function createSASSES(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createLabels",
      value: function createLabels(_caps, _settings) {
        return {
          Geometry: geometries.LabelsGeometry,
          Object: meshes.Text,
          initMaterial: function initMaterial() {}
        };
      }
    }]);

    return MeshCreator;
  }();

  function _createSuper$F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$G(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TransformGroup = /*#__PURE__*/function (_THREE$Object3D) {
    inherits(TransformGroup, _THREE$Object3D);

    var _super = _createSuper$F(TransformGroup);

    function TransformGroup(geometry, geoParams, material, transforms) {
      var _this;

      classCallCheck(this, TransformGroup);

      _this = _super.call(this);
      _this._geometry = geometry;
      _this._geoParams = geoParams;
      var mat = material.createInstance();
      geoParams.initMaterial(mat);
      _this._material = mat;
      _this._transforms = transforms.length > 0 ? transforms : [new THREE.Matrix4()];

      var meshes = _this._createMeshes(geometry);

      for (var i = 0, n = meshes.length; i < n; ++i) {
        _this.add(meshes[i]);
      }

      return _this;
    }

    createClass(TransformGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var ray = TransformGroup._ray;
        var inverseMatrix = TransformGroup._inverseMatrix;
        var children = this.children;
        ray.copy(raycaster.ray);

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];

          if (!gfxutils.belongToSelectLayers(child)) {
            continue;
          }

          child.updateMatrixWorld();
          var mtx = child.matrixWorld;
          inverseMatrix.copy(mtx).invert();
          raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
          var childIntersects = [];

          this._geometry.raycast(raycaster, childIntersects);

          for (var j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
            var inters = childIntersects[j];

            if (inters.point) {
              inters.point.applyMatrix4(mtx);
              inters.distance = ray.origin.distanceTo(inters.point);
            }

            inters.object = child;
            intersects[intersects.length] = inters;
          }
        }

        raycaster.ray.copy(ray);
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var geos = this._geometry.getSubset(chunkIndices);

        var subset = [];
        var subIdx = 0;

        for (var i = 0, n = geos.length; i < n; ++i) {
          var _meshes = this._createMeshes(geos[i]);

          for (var j = 0, meshCnt = _meshes.length; j < meshCnt; ++j) {
            subset[subIdx++] = _meshes[j];
          }
        }

        return subset;
      }
    }, {
      key: "_createMeshes",
      value: function _createMeshes(geometry) {
        var transforms = this._transforms;
        var Mesh = this._geoParams.Object;
        var material = this._material;
        var meshes = [];

        for (var i = 0, n = transforms.length; i < n; ++i) {
          var mesh = new Mesh(geometry, material);
          mesh.applyMatrix4(transforms[i]);
          meshes[i] = mesh;
        }

        return meshes;
      }
    }]);

    return TransformGroup;
  }(THREE.Object3D);

  defineProperty(TransformGroup, "_inverseMatrix", new THREE.Matrix4());

  defineProperty(TransformGroup, "_ray", new THREE.Ray());

  function _createSuper$G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$H(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function wrapper(Name, args) {
    var params = [Name].concat(args);
    return Name.bind.apply(Name, toConsumableArray(params));
  }

  var ChemGroup = /*#__PURE__*/function (_RCGroup) {
    inherits(ChemGroup, _RCGroup);

    var _super = _createSuper$G(ChemGroup);

    function ChemGroup(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
      var _this;

      classCallCheck(this, ChemGroup);

      _this = _super.call(this);

      if (_this.constructor === ChemGroup) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._selection = selection;
      _this._mode = mode;
      _this._colorer = colorer;
      _this._chunksIdc = selection.chunks;
      _this._polyComplexity = polyComplexity;
      _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))();
      _this._mesh = new TransformGroup(_this._geo, geoParams, material, transforms);

      _this.add(_this._mesh);

      _this._build();

      return _this;
    }

    createClass(ChemGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        throw new Error('ChemGroup subclass must override _makeGeoArgs() method');
      }
      /**
       * Builds subset geometry by ATOMS index list
       *
       * @param {Number} mask - Representation mask
       * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
       * @returns {Array} Subset geometry
       */

    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : false;

        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return [];
        }

        return this._mesh.getSubset(chunksList);
      }
    }, {
      key: "_changeSubsetOpacity",
      value: function _changeSubsetOpacity(mask, value, innerOnly) {
        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return;
        }

        this._geo.setOpacity(chunksList, value);
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 1.0, innerOnly);
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 0.0, innerOnly);
      }
    }]);

    return ChemGroup;
  }(RCGroup);

  function _createSuper$H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$I(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(AtomsGroup, _ChemGroup);

    var _super = _createSuper$H(AtomsGroup);

    function AtomsGroup() {
      classCallCheck(this, AtomsGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var atoms = this._selection.atoms;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var atomsIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var atomIdx = atomsIdc[inters[i].chunkIdx];

          if (atomIdx < atoms.length) {
            inters[i].atom = atoms[atomIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var atoms = this._selection.atoms;
        var atomsIdc = this._chunksIdc;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];

          if ((atom.mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return AtomsGroup;
  }(ChemGroup);

  function _createSuper$I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$J(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSphereGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AtomsSphereGroup, _AtomsGroup);

    var _super = _createSuper$I(AtomsSphereGroup);

    function AtomsSphereGroup() {
      classCallCheck(this, AtomsSphereGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSphereGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, atom.position, mode.calcAtomRadius(atom));
          geo.setColor(i, colorer.getAtomColor(atom, parent));
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var mode = this._mode;
        var colorer = this._colorer;
        var updateColor = frameData.needsColorUpdate(colorer);
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), mode.calcAtomRadius(atom));

          if (updateColor) {
            geo.setColor(i, frameData.getAtomColor(colorer, atom));
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsSphereGroup;
  }(AtomsGroup);

  function _createSuper$J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$K(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSurfaceGroup = /*#__PURE__*/function (_AtomsSphereGroup) {
    inherits(AtomsSurfaceGroup, _AtomsSphereGroup);

    var _super = _createSuper$J(AtomsSurfaceGroup);

    function AtomsSurfaceGroup() {
      classCallCheck(this, AtomsSurfaceGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSurfaceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        return [n, opts];
      }
    }]);

    return AtomsSurfaceGroup;
  }(AtomsSphereGroup);

  function _createSuper$K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$L(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSASSESGroupStub = /*#__PURE__*/function (_AtomsSphereGroup) {
    inherits(AtomsSASSESGroupStub, _AtomsSphereGroup);

    var _super = _createSuper$K(AtomsSASSESGroupStub);

    function AtomsSASSESGroupStub() {
      classCallCheck(this, AtomsSASSESGroupStub);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSASSESGroupStub, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        opts.selection = this._selection;
        opts.colorMode = this._colorer;
        return [n, opts];
      }
    }]);

    return AtomsSASSESGroupStub;
  }(AtomsSphereGroup);

  function _createSuper$L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$M(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function adjustColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;

    if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
      r = r * 3 / 10;
      g = g * 3 / 10;
      b = b * 3 / 10;
    } else {
      r = 255 - (255 - r) * 3 / 10;
      g = 255 - (255 - g) * 3 / 10;
      b = 255 - (255 - b) * 3 / 10;
    }

    return r << 16 | g << 8 | b;
  }

  function inverseColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;
    return 255 - r << 16 | 255 - g << 8 | 255 - b;
  }

  function getAtomText(atom) {
    if (atom.name.getNode() !== null) {
      return atom.name.getNode();
    }

    return atom.getVisualName();
  }

  var colorMappings = {
    none: function none(c) {
      return c;
    },
    adjust: adjustColor,
    inverse: inverseColor
  };

  function propagateColor(color, rule) {
    var result;

    if (colorMappings.hasOwnProperty(rule)) {
      result = utils.hexColor(colorMappings[rule](color));
    } else {
      var val = parseInt(rule, 16);

      if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
        result = utils.hexColor(val);
      } else {
        result = '#000000';
      }
    }

    return result;
  }

  var templateMappings = {
    serial: function serial(a) {
      return a.serial;
    },
    name: function name(a) {
      return a.getVisualName();
    },
    elem: function elem(a) {
      return a.element.name;
    },
    residue: function residue(a) {
      return a.residue.getType().getName();
    },
    sequence: function sequence(a) {
      return a.residue.getSequence();
    },
    chain: function chain(a) {
      return a.residue.getChain().getName();
    },
    hetatm: function hetatm(a) {
      return a.isHet();
    },
    water: function water(a) {
      return a.residue.getType().getName() === 'HOH' || a.residue.getType().getName() === 'WAT';
    }
  };

  var parseTemplate = function parseTemplate(atom, str) {
    return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function (m) {
      var key = m.replace(/\s+/g, '');
      key = key.substring(2, key.length - 2).toLowerCase();

      if (templateMappings.hasOwnProperty(key)) {
        return templateMappings[key](atom);
      }

      return 'null';
    });
  };

  var AtomsTextGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AtomsTextGroup, _AtomsGroup);

    var _super = _createSuper$L(AtomsTextGroup);

    function AtomsTextGroup() {
      classCallCheck(this, AtomsTextGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsTextGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var opts = this._mode.getLabelOpts();

        return [this._selection.chunks.length, opts];
      }
    }, {
      key: "_build",
      value: function _build() {
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = colorer.getAtomColor(atom, parent);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, atom.position, text);
          geo.setColor(i, fgColor, bgColor);
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var colorer = this._colorer;
        var geo = this._geo;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = frameData.getAtomColor(colorer, atom);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text);

          if (updateColor) {
            geo.setColor(i, fgColor, bgColor);
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsTextGroup;
  }(AtomsGroup);

  function _createSuper$M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$N(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega);
    return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
  }

  var AromaticGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AromaticGroup, _AtomsGroup);

    var _super = _createSuper$M(AromaticGroup);

    function AromaticGroup() {
      classCallCheck(this, AromaticGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticGroup, [{
      key: "_buildInner",
      value: function _buildInner(radOffset, addChunk) {
        var chunksToIdx = this._selection.chunks;
        var prevVector = new THREE.Vector3();
        var currVector = new THREE.Vector3();
        var segmentsHeight = this._segmentsHeight;
        var leprStep = 1.0 / segmentsHeight;
        var colorer = this._colorer;
        var _this$_selection = this._selection,
            cycles = _this$_selection.cycles,
            parent = _this$_selection.parent;
        var chunkIdx = 0;
        var currAtomIdx = chunksToIdx[chunkIdx];

        for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
          var cycle = cycles[cIdx];
          var cycAtoms = cycle.atoms;
          var chunkPoints = [];
          var tmpDir = [];
          var center = cycle.center;
          var cycleRad = cycle.radius - radOffset;
          var n = cycAtoms.length;
          var i = 0;
          var prevPos = cycAtoms[n - 1].position;
          var currPos = cycAtoms[i].position;
          prevVector.subVectors(prevPos, center);
          currVector.subVectors(currPos, center);
          var upDir = currVector.clone().cross(prevVector).normalize();

          for (; i < n; ++i) {
            var omega = prevVector.angleTo(currVector);
            tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize();
            currPos = cycAtoms[(i + 1) % n].position;
            prevVector.copy(currVector);
            currVector.subVectors(currPos, center);
          }

          for (i = 0; i < n; ++i) {
            if (cycAtoms[i].index !== currAtomIdx) {
              continue;
            }

            var start = tmpDir[i];
            var end = tmpDir[(i + 1) % n];
            var color = colorer.getAtomColor(cycAtoms[i], parent);
            var currAngle = start.angleTo(end);

            for (var j = 0; j <= segmentsHeight; ++j) {
              chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
            }

            addChunk(chunkIdx++, color, chunkPoints, center, upDir);
            currAtomIdx = chunksToIdx[chunkIdx];
          }
        }
      }
    }]);

    return AromaticGroup;
  }(AtomsGroup);

  function _createSuper$N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$O(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      var a = -2 * i / parts * Math.PI;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  var calcChunkMatrix = gfxutils.calcChunkMatrix;

  var AromaticTorusGroup = /*#__PURE__*/function (_AromaticGroup) {
    inherits(AromaticTorusGroup, _AromaticGroup);

    var _super = _createSuper$N(AromaticTorusGroup);

    function AromaticTorusGroup() {
      classCallCheck(this, AromaticTorusGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticTorusGroup, [{
      key: "_build",
      value: function _build() {
        var segmentsHeight = this._segmentsHeight;

        var torusRad = this._mode.getAromRadius();

        var radiusV = new THREE.Vector2(torusRad, torusRad);
        var radOffset = this._mode.calcStickRadius() + 2 * torusRad;
        var lookAtVector = new THREE.Vector3();
        var mtc = [];
        var geo = this._geo;

        this._buildInner(radOffset, function (chunkIdx, color, points, center, upDir) {
          for (var j = 0; j <= segmentsHeight; ++j) {
            var currPoint = points[j];
            var currDir = currPoint.clone().sub(center).cross(upDir);
            lookAtVector.addVectors(currPoint, currDir);
            mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
          }

          geo.setItem(chunkIdx, mtc);
          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._polyComplexity;
        return [_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
      }
    }]);

    return AromaticTorusGroup;
  }(AromaticGroup);

  function _createSuper$O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$P(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticLinesGroup = /*#__PURE__*/function (_AromaticGroup) {
    inherits(AromaticLinesGroup, _AromaticGroup);

    var _super = _createSuper$O(AromaticLinesGroup);

    function AromaticLinesGroup() {
      classCallCheck(this, AromaticLinesGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticLinesGroup, [{
      key: "_build",
      value: function _build() {
        var _this = this;

        var geo = this._geo;

        var radOffset = this._mode.getAromaticOffset();

        this._buildInner(radOffset, function (chunkIdx, color, points) {
          var prevPt = points[0]; // do not replace with start

          for (var j = 1; j <= _this._segmentsHeight; ++j) {
            var currPoint = points[j];
            geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
            prevPt = currPoint;
          }

          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._mode.getAromaticArcChunks();
        return [this._selection.chunks.length, this._segmentsHeight, true];
      }
    }]);

    return AromaticLinesGroup;
  }(AromaticGroup);

  function _createSuper$P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(ResiduesGroup, _ChemGroup);

    var _super = _createSuper$P(ResiduesGroup);

    function ResiduesGroup() {
      classCallCheck(this, ResiduesGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[inters[i].chunkIdx];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesGroup;
  }(ChemGroup);

  function _createSuper$Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$R(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicItemGroup = /*#__PURE__*/function (_ResiduesGroup) {
    inherits(NucleicItemGroup, _ResiduesGroup);

    var _super = _createSuper$Q(NucleicItemGroup);

    function NucleicItemGroup() {
      classCallCheck(this, NucleicItemGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicItemGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finalize();
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunkIdx = 0;
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList[chunkIdx++] = 2 * i;
            chunksList[chunkIdx++] = 2 * i + 1;
          }
        }

        return chunksList;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finishUpdate();
      }
    }]);

    return NucleicItemGroup;
  }(ResiduesGroup);

  function _createSuper$R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$S(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicCylindersGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    inherits(NucleicCylindersGroup, _NucleicItemGroup);

    var _super = _createSuper$R(NucleicCylindersGroup);

    function NucleicCylindersGroup() {
      classCallCheck(this, NucleicCylindersGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicCylindersGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
        geo.setColor(chunkIdx, color, color);
      }
    }]);

    return NucleicCylindersGroup;
  }(NucleicItemGroup);

  function _createSuper$S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$T(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicSpheresGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    inherits(NucleicSpheresGroup, _NucleicItemGroup);

    var _super = _createSuper$S(NucleicSpheresGroup);

    function NucleicSpheresGroup() {
      classCallCheck(this, NucleicSpheresGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicSpheresGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length * 2, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        var idx = chunkIdx * 2;
        geo.setItem(idx, cyl1, stickRad);
        geo.setColor(idx, color);
        idx++;
        geo.setItem(idx, cyl2, stickRad);
        geo.setColor(idx, color);
      }
    }]);

    return NucleicSpheresGroup;
  }(NucleicItemGroup);

  var Smooth = createCommonjsModule(function (module, exports) {
  /*
  Smooth.js version 0.1.7

  Turn arrays into smooth functions.

  Copyright 2012 Spencer Cohen
  Licensed under MIT license (see "Smooth.js MIT license.txt")
  */

  /*Constants (these are accessible by Smooth.WHATEVER in user space)
  */

  (function() {
    var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v, validateNumber, validateVector,
      __hasProp = Object.prototype.hasOwnProperty,
      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

    Enum = {
      /*Interpolation methods
      */
      METHOD_NEAREST: 'nearest',
      METHOD_LINEAR: 'linear',
      METHOD_CUBIC: 'cubic',
      METHOD_LANCZOS: 'lanczos',
      METHOD_SINC: 'sinc',
      /*Input clipping modes
      */
      CLIP_CLAMP: 'clamp',
      CLIP_ZERO: 'zero',
      CLIP_PERIODIC: 'periodic',
      CLIP_MIRROR: 'mirror',
      /* Constants for control over the cubic interpolation tension
      */
      CUBIC_TENSION_DEFAULT: 0,
      CUBIC_TENSION_CATMULL_ROM: 0
    };

    defaultConfig = {
      method: Enum.METHOD_CUBIC,
      cubicTension: Enum.CUBIC_TENSION_DEFAULT,
      clip: Enum.CLIP_CLAMP,
      scaleTo: 0,
      sincFilterSize: 2,
      sincWindow: void 0
    };

    /*Index clipping functions
    */

    clipClamp = function(i, n) {
      return Math.max(0, Math.min(i, n - 1));
    };

    clipPeriodic = function(i, n) {
      i = i % n;
      if (i < 0) i += n;
      return i;
    };

    clipMirror = function(i, n) {
      var period;
      period = 2 * (n - 1);
      i = clipPeriodic(i, period);
      if (i > n - 1) i = period - i;
      return i;
    };

    /*
    Abstract scalar interpolation class which provides common functionality for all interpolators
    
    Subclasses must override interpolate().
    */

    AbstractInterpolator = (function() {

      function AbstractInterpolator(array, config) {
        this.array = array.slice(0);
        this.length = this.array.length;
        if (!(this.clipHelper = {
          clamp: this.clipHelperClamp,
          zero: this.clipHelperZero,
          periodic: this.clipHelperPeriodic,
          mirror: this.clipHelperMirror
        }[config.clip])) {
          throw "Invalid clip: " + config.clip;
        }
      }

      AbstractInterpolator.prototype.getClippedInput = function(i) {
        if ((0 <= i && i < this.length)) {
          return this.array[i];
        } else {
          return this.clipHelper(i);
        }
      };

      AbstractInterpolator.prototype.clipHelperClamp = function(i) {
        return this.array[clipClamp(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperZero = function(i) {
        return 0;
      };

      AbstractInterpolator.prototype.clipHelperPeriodic = function(i) {
        return this.array[clipPeriodic(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperMirror = function(i) {
        return this.array[clipMirror(i, this.length)];
      };

      AbstractInterpolator.prototype.interpolate = function(t) {
        throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
      };

      return AbstractInterpolator;

    })();

    NearestInterpolator = (function(_super) {

      __extends(NearestInterpolator, _super);

      function NearestInterpolator() {
        NearestInterpolator.__super__.constructor.apply(this, arguments);
      }

      NearestInterpolator.prototype.interpolate = function(t) {
        return this.getClippedInput(Math.round(t));
      };

      return NearestInterpolator;

    })(AbstractInterpolator);

    LinearInterpolator = (function(_super) {

      __extends(LinearInterpolator, _super);

      function LinearInterpolator() {
        LinearInterpolator.__super__.constructor.apply(this, arguments);
      }

      LinearInterpolator.prototype.interpolate = function(t) {
        var k;
        k = Math.floor(t);
        t -= k;
        return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
      };

      return LinearInterpolator;

    })(AbstractInterpolator);

    CubicInterpolator = (function(_super) {

      __extends(CubicInterpolator, _super);

      function CubicInterpolator(array, config) {
        this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
        CubicInterpolator.__super__.constructor.apply(this, arguments);
      }

      CubicInterpolator.prototype.getTangent = function(k) {
        return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
      };

      CubicInterpolator.prototype.interpolate = function(t) {
        var k, m, p, t2, t3;
        k = Math.floor(t);
        m = [this.getTangent(k), this.getTangent(k + 1)];
        p = [this.getClippedInput(k), this.getClippedInput(k + 1)];
        t -= k;
        t2 = t * t;
        t3 = t * t2;
        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
      };

      return CubicInterpolator;

    })(AbstractInterpolator);

    sin = Math.sin, PI = Math.PI;

    sinc = function(x) {
      if (x === 0) {
        return 1;
      } else {
        return sin(PI * x) / (PI * x);
      }
    };

    makeLanczosWindow = function(a) {
      return function(x) {
        return sinc(x / a);
      };
    };

    makeSincKernel = function(window) {
      return function(x) {
        return sinc(x) * window(x);
      };
    };

    SincFilterInterpolator = (function(_super) {

      __extends(SincFilterInterpolator, _super);

      function SincFilterInterpolator(array, config) {
        SincFilterInterpolator.__super__.constructor.apply(this, arguments);
        this.a = config.sincFilterSize;
        if (!config.sincWindow) throw 'No sincWindow provided';
        this.kernel = makeSincKernel(config.sincWindow);
      }

      SincFilterInterpolator.prototype.interpolate = function(t) {
        var k, n, sum, _ref, _ref2;
        k = Math.floor(t);
        sum = 0;
        for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
          sum += this.kernel(t - n) * this.getClippedInput(n);
        }
        return sum;
      };

      return SincFilterInterpolator;

    })(AbstractInterpolator);

    getColumn = function(arr, i) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        row = arr[_i];
        _results.push(row[i]);
      }
      return _results;
    };

    makeScaledFunction = function(f, baseScale, scaleRange) {
      var scaleFactor, translation;
      if (scaleRange.join === '0,1') {
        return f;
      } else {
        scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
        translation = scaleRange[0];
        return function(t) {
          return f(scaleFactor * (t - translation));
        };
      }
    };

    getType = function(x) {
      return Object.prototype.toString.call(x).slice('[object '.length, -1);
    };

    validateNumber = function(n) {
      if (isNaN(n)) throw 'NaN in Smooth() input';
      if (getType(n) !== 'Number') throw 'Non-number in Smooth() input';
      if (!isFinite(n)) throw 'Infinity in Smooth() input';
    };

    validateVector = function(v, dimension) {
      var n, _i, _len;
      if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input';
      if (v.length !== dimension) throw 'Inconsistent dimension in Smooth() input';
      for (_i = 0, _len = v.length; _i < _len; _i++) {
        n = v[_i];
        validateNumber(n);
      }
    };

    isValidNumber = function(n) {
      return (getType(n) === 'Number') && isFinite(n) && !isNaN(n);
    };

    normalizeScaleTo = function(s) {
      var invalidErr;
      invalidErr = "scaleTo param must be number or array of two numbers";
      switch (getType(s)) {
        case 'Number':
          if (!isValidNumber(s)) throw invalidErr;
          s = [0, s];
          break;
        case 'Array':
          if (s.length !== 2) throw invalidErr;
          if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr;
          break;
        default:
          throw invalidErr;
      }
      return s;
    };

    shallowCopy = function(obj) {
      var copy, k, v;
      copy = {};
      for (k in obj) {
        if (!__hasProp.call(obj, k)) continue;
        v = obj[k];
        copy[k] = v;
      }
      return copy;
    };

    Smooth = function(arr, config) {
      var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
      if (config == null) config = {};
      properties = {};
      config = shallowCopy(config);
      properties.config = shallowCopy(config);
      if (config.scaleTo == null) config.scaleTo = config.period;
      if (config.sincFilterSize == null) {
        config.sincFilterSize = config.lanczosFilterSize;
      }
      for (k in defaultConfig) {
        if (!__hasProp.call(defaultConfig, k)) continue;
        v = defaultConfig[k];
        if (config[k] == null) config[k] = v;
      }
      if (!(interpolatorClass = {
        nearest: NearestInterpolator,
        linear: LinearInterpolator,
        cubic: CubicInterpolator,
        lanczos: SincFilterInterpolator,
        sinc: SincFilterInterpolator
      }[config.method])) {
        throw "Invalid method: " + config.method;
      }
      if (config.method === 'lanczos') {
        config.sincWindow = makeLanczosWindow(config.sincFilterSize);
      }
      if (arr.length < 2) throw 'Array must have at least two elements';
      properties.count = arr.length;
      smoothFunc = (function() {
        var _i, _j, _len, _len2;
        switch (getType(arr[0])) {
          case 'Number':
            properties.dimension = 'scalar';
            if (Smooth.deepValidation) {
              for (_i = 0, _len = arr.length; _i < _len; _i++) {
                n = arr[_i];
                validateNumber(n);
              }
            }
            interpolator = new interpolatorClass(arr, config);
            return function(t) {
              return interpolator.interpolate(t);
            };
          case 'Array':
            properties.dimension = dimension = arr[0].length;
            if (!dimension) throw 'Vectors must be non-empty';
            if (Smooth.deepValidation) {
              for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                v = arr[_j];
                validateVector(v, dimension);
              }
            }
            interpolators = (function() {
              var _results;
              _results = [];
              for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
                _results.push(new interpolatorClass(getColumn(arr, i), config));
              }
              return _results;
            })();
            return function(t) {
              var interpolator, _k, _len3, _results;
              _results = [];
              for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                interpolator = interpolators[_k];
                _results.push(interpolator.interpolate(t));
              }
              return _results;
            };
          default:
            throw "Invalid element type: " + (getType(arr[0]));
        }
      })();
      if (config.clip === 'periodic') {
        baseDomainEnd = arr.length;
      } else {
        baseDomainEnd = arr.length - 1;
      }
      config.scaleTo || (config.scaleTo = baseDomainEnd);
      properties.domain = normalizeScaleTo(config.scaleTo);
      smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
      properties.domain.sort();
      /*copy properties
      */
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        smoothFunc[k] = v;
      }
      return smoothFunc;
    };

    for (k in Enum) {
      if (!__hasProp.call(Enum, k)) continue;
      v = Enum[k];
      Smooth[k] = v;
    }

    Smooth.deepValidation = true;

    ( exports !== null ? exports : window).Smooth = Smooth;

  }).call(commonjsGlobal);
  });
  var Smooth_1 = Smooth.Smooth;

  var ResidueType$1 = chem.ResidueType;
  var calcMatrix = gfxutils.calcChunkMatrix;

  function _buildStructureInterpolator(points, tension) {
    var path = Smooth_1(points, {
      method: Smooth_1.METHOD_CUBIC,
      clip: Smooth_1.CLIP_CLAMP,
      cubicTension: tension,
      scaleTo: 1
    });
    return function (t, argTrans) {
      var transformT = argTrans;

      if (transformT === null) {
        // map our range to the [second .. last but one]
        transformT = function transformT(tt) {
          return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
        };
      }

      var newt = transformT(t);
      var ans = path(newt);
      return new THREE.Vector3(ans[0], ans[1], ans[2]);
    };
  }

  function _addPoints(centerPoints, topPoints, idx, residue) {
    if (!residue._isValid) {
      centerPoints[idx] = centerPoints[idx - 1];
      topPoints[idx] = topPoints[idx - 1];
      return;
    }

    var cp = residue._controlPoint;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    var tp = cp.clone().add(residue._wingVector);
    topPoints[idx] = [tp.x, tp.y, tp.z];
  }

  function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
    var nucleic = (residue._type.flags & ResidueType$1.Flags.NUCLEIC) !== 0;
    var nameFrom = nucleic ? 'C5\'' : 'N';
    var nameTo = nucleic ? 'C3\'' : 'C';
    var posFrom;
    var posTo;
    residue.forEachAtom(function (atom) {
      var name = atom.getVisualName();

      if (!posFrom && name === nameFrom) {
        posFrom = atom.position;
      } else if (!posTo && name === nameTo) {
        posTo = atom.position;
      }
    }); // provide a fallback for unknown residues

    if (!(posFrom && posTo)) {
      posFrom = residue._firstAtom.position;
      posTo = residue._lastAtom.position;
    }

    if (posFrom && posTo) {
      var shift = posTo.clone().sub(posFrom);
      var wing = residue._wingVector;
      var cp = residue._controlPoint;
      var tp = cp.clone().add(wing);
      var cpPrev = cp.clone().sub(shift);
      var tpPrev = cpPrev.clone().add(wing);
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cp.x, cp.y, cp.z];
      topPoints[idx] = [tp.x, tp.y, tp.z];
      ++idx;
      var cpNext = cp.clone().add(shift);
      var tpNext = cpNext.clone().add(wing);
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
      ++idx;
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    }
  }

  function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
    var left = boundaries.start;
    var right = boundaries.end;

    function _prevIdx(idx) {
      return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
    }

    function _nextIdx(idx) {
      return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
    }

    var topPoints = [];
    var centerPoints = [];
    var arrIdx = 0;

    function _extrapolate2(currIdx, otherIdx) {
      var cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);

      var tp = cp.clone().add(residues[currIdx]._wingVector);
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    } // a single disconnected residue


    var prevIdx = _prevIdx(firstIdx);

    var nextIdx = _nextIdx(lastIdx);

    if (prevIdx === nextIdx) {
      _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);

      return {
        centerPoints: centerPoints,
        topPoints: topPoints
      };
    } // Two points (prev-prev and next-next) are added to support edge conditions for cubic splines, they are ignored
    // Another two (prev and next) were added to support the outside of the sub chain
    // prev and prev-prev


    if (firstIdx === prevIdx) {
      // do the extrapolation
      _extrapolate2(firstIdx, _nextIdx(firstIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);

      _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
    } // main loop


    for (var idx = firstIdx; idx <= lastIdx; ++idx) {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
    } // next and next-next


    if (nextIdx === _nextIdx(nextIdx)) {
      // do the extrapolation
      _extrapolate2(lastIdx, _prevIdx(lastIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);

      _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
    }

    return {
      centerPoints: centerPoints,
      topPoints: topPoints
    };
  }

  var CartoonHelper = /*#__PURE__*/function () {
    function CartoonHelper(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
      classCallCheck(this, CartoonHelper);

      var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);

      this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
      this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
      this._shift = 0.5 / (endIdx - startIdx + 2);
      this._valueStep = (1.0 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
      this._segmentsCount = segmentsCount;
    }

    createClass(CartoonHelper, [{
      key: "prepareMatrices",
      value: function prepareMatrices(idx, firstRad, secondRad) {
        var mtcCount = this._segmentsCount;
        var outMtc = new Array(mtcCount);
        var currRad = new THREE.Vector2(0, 0);
        var topInterp = this._topInterp;
        var cenInterp = this._centerInterp;
        var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;

        for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
          var lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1));
          currRad.lerpVectors(firstRad, secondRad, lerpVal);
          var currTop = topInterp(currentValue, null);
          var currCenter = cenInterp(currentValue, null);
          currentValue += this._valueStep;
          var nextCenter = cenInterp(currentValue, null);
          outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
        }

        return outMtc;
      }
    }]);

    return CartoonHelper;
  }();

  function _createSuper$T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$U(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape$1(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      // starts from pi/2 because it's important that points are lied on the angles of arrows (visual issues if not)
      var a = Math.PI / 2.0 - 2 * Math.PI * i / parts;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
    for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      var subs = subDiv[subDivI].arr;
      var boundaries = subDiv[subDivI].boundaries;

      for (var i = 0, n = subs.length; i < n; ++i) {
        var idc = [subs[i].start, subs[i].end];
        var matrixHelper = new CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
        var prevLast = null;
        var startIdx = subs[i].start * 2;
        var endIdx = subs[i].end * 2 + 1;
        var prevSecondRad = mode.getResidueRadius(residues[0], 0);

        for (var idx = startIdx; idx <= endIdx; ++idx) {
          var resIdx = idx / 2 | 0;
          var currRes = residues[resIdx];
          var firstRad = mode.getResidueRadius(currRes, idx % 2);
          var secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
          var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
          mtc.unshift(prevLast === null ? mtc[0] : prevLast); // Slope - radius is changed along this residue part

          var hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y; // Cut - end radius of previous part not equal to start radius of this part. First section of this part lies in the orthogonal plane

          var hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
          callback(currRes, mtc, hasSlope, hasCut);
          prevLast = mtc[segmentsHeight];
          prevSecondRad = secondRad;
        }
      }
    }
  }

  var ResiduesSubseqGroup = /*#__PURE__*/function (_ResiduesGroup) {
    inherits(ResiduesSubseqGroup, _ResiduesGroup);

    var _super = _createSuper$T(ResiduesSubseqGroup);

    function ResiduesSubseqGroup() {
      classCallCheck(this, ResiduesSubseqGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesSubseqGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var cmpMultiplier = this._mode.getHeightSegmentsRatio();

        this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
        return [_createShape$1(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];

        _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var color = colorer.getResidueColor(currRes, parent);
          chunkIdc[chunkIdx] = currRes._index;
          geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
          geo.setColor(chunkIdx++, color);
        });

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var frameRes = frameData.getResidues();
        var chunkIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          geo.setItem(chunkIdx, mtc);

          if (updateColor) {
            geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
          }

          chunkIdx++;
        });

        geo.finalize();
      }
    }]);

    return ResiduesSubseqGroup;
  }(ResiduesGroup);

  function _createSuper$U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$V(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesTraceGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(ResiduesTraceGroup, _ChemGroup);

    var _super = _createSuper$U(ResiduesTraceGroup);

    function ResiduesTraceGroup() {
      classCallCheck(this, ResiduesTraceGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesTraceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var subDiv = this._selection.subdivs;
        var chunksCount = 0;

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            chunksCount += subs[i].end - subs[i].start;
          }
        }

        return [chunksCount, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              chunkIdc[chunkIdx] = {
                first: prevRes._index,
                second: currRes._index
              };
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
              geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);

              if (updateColor) {
                geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              }

              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        geo.finalize();
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];
        var residues = this._selection.residues;

        this._mesh.raycast(raycaster, inters);

        var chunksToIdx = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
          var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunksToIdx = this._chunksIdc;
        var residues = this._selection.residues;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var chunk = chunksToIdx[i];

          if (residues[chunk.first]._mask & mask) {
            chunksList.push(i * 2);
          }

          if (residues[chunk.second]._mask & mask) {
            chunksList.push(i * 2 + 1);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesTraceGroup;
  }(ChemGroup);

  function _createSuper$V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$W(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }

  var BondsGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(BondsGroup, _ChemGroup);

    var _super = _createSuper$V(BondsGroup);

    function BondsGroup() {
      classCallCheck(this, BondsGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var drawMultiple = this._mode.drawMultiorderBonds();

        var showAromatic = this._mode.showAromaticLoops();

        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var bondsCount = 0;

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          bondsCount += this.getBondOrder(bonds[bondsIdc[i]], drawMultiple, showAromatic);
        }

        return [bondsCount, this._polyComplexity];
      }
    }, {
      key: "getBondOrder",
      value: function getBondOrder(bond, drawMultiple, showAromatic) {
        var bondOrder = 1;

        if (drawMultiple && (!showAromatic || bond._type !== Bond.BondType.AROMATIC)) {
          bondOrder = getCylinderCount(bond._order);
        }

        return bondOrder;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var bonds = this._selection.bonds;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var bondsIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];

          if (bondIdx < bonds.length) {
            var bond = bonds[bondIdx];
            inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask, innerOnly) {
        var chunksList = [];
        var bonds = this._selection.bonds;
        var chunksToIdx = this._chunksIdc;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var bond = bonds[chunksToIdx[i]];

          if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
            chunksList.push(2 * i);
          }

          if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
            chunksList.push(2 * i + 1);
          }
        }

        return chunksList;
      }
    }]);

    return BondsGroup;
  }(ChemGroup);

  function _createSuper$W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$X(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BondsCylinderGroup = /*#__PURE__*/function (_BondsGroup) {
    inherits(BondsCylinderGroup, _BondsGroup);

    var _super = _createSuper$W(BondsCylinderGroup);

    function BondsCylinderGroup() {
      classCallCheck(this, BondsCylinderGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsCylinderGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            chunksToIdx[currBondIdx] = bond._index;
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsCylinderGroup;
  }(BondsGroup);

  function _createSuper$X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var STEP_SIZE = 0.15;

  var BondsLinesGroup = /*#__PURE__*/function (_BondsGroup) {
    inherits(BondsLinesGroup, _BondsGroup);

    var _super = _createSuper$X(BondsLinesGroup);

    function BondsLinesGroup() {
      classCallCheck(this, BondsLinesGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsLinesGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE.Vector3();
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
            chunksToIdx[currBondIdx] = bond._index;

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE.Vector3();
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsLinesGroup;
  }(BondsGroup);

  var groups = {
    AtomsSphereGroup: AtomsSphereGroup,
    AtomsSurfaceGroup: AtomsSurfaceGroup,
    AtomsSASSESGroupStub: AtomsSASSESGroupStub,
    AtomsTextGroup: AtomsTextGroup,
    AromaticTorusGroup: AromaticTorusGroup,
    AromaticLinesGroup: AromaticLinesGroup,
    NucleicCylindersGroup: NucleicCylindersGroup,
    NucleicSpheresGroup: NucleicSpheresGroup,
    ResiduesSubseqGroup: ResiduesSubseqGroup,
    ResiduesTraceGroup: ResiduesTraceGroup,
    BondsCylinderGroup: BondsCylinderGroup,
    BondsLinesGroup: BondsLinesGroup
  };

  function _createSuper$Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(AtomsProcessor, _RCGroup);

    var _super = _createSuper$Y(AtomsProcessor);

    function AtomsProcessor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, AtomsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      _this._mode = mode;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var atomCount = 0;
        component.forEachAtom(function (atom) {
          if (!self._checkAtom(atom, mask)) {
            return;
          }

          atomsIdc[atomCount++] = atom.index;
        });

        if (atomCount === 0) {
          return;
        }

        var atomsGroup = new AtomsGroup(geoParams, {
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    createClass(AtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        return atom.mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AtomsProcessor;
  }(RCGroup);

  function _createSuper$Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$_(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var OrphanAtomsProcessor = /*#__PURE__*/function (_AtomsProcessor) {
    inherits(OrphanAtomsProcessor, _AtomsProcessor);

    var _super = _createSuper$Z(OrphanAtomsProcessor);

    function OrphanAtomsProcessor() {
      classCallCheck(this, OrphanAtomsProcessor);

      return _super.apply(this, arguments);
    }

    createClass(OrphanAtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        if (!(atom.mask & mask)) {
          return false;
        }

        var bonds = atom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          if (bonds[i]._left.mask & mask && bonds[i]._right.mask & mask) {
            return false;
          }
        }

        return true;
      }
    }]);

    return OrphanAtomsProcessor;
  }(AtomsProcessor);

  function _createSuper$_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$$(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(ResiduesProcessor, _RCGroup);

    var _super = _createSuper$_(ResiduesProcessor);

    function ResiduesProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, ResiduesProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var chunksCount = 0;
        var resIdc = [];
        component.forEachResidue(function (residue) {
          if (self._checkResidue(residue, mask)) {
            resIdc[chunksCount++] = residue._index;
          }
        });

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    createClass(ResiduesProcessor, [{
      key: "checkResidue",
      value: function checkResidue(residue, mask) {
        return residue._mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return ResiduesProcessor;
  }(RCGroup);

  function _createSuper$$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$10(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$10() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicProcessor = /*#__PURE__*/function (_ResidueProcessor) {
    inherits(NucleicProcessor, _ResidueProcessor);

    var _super = _createSuper$$(NucleicProcessor);

    function NucleicProcessor() {
      classCallCheck(this, NucleicProcessor);

      return _super.apply(this, arguments);
    }

    createClass(NucleicProcessor, [{
      key: "_checkResidue",
      value: function _checkResidue(residue, mask) {
        return mask & residue._mask && residue._cylinders !== null;
      }
    }]);

    return NucleicProcessor;
  }(ResiduesProcessor);

  function _createSuper$10(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$11(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$11() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SubseqsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(SubseqsProcessor, _RCGroup);

    var _super = _createSuper$10(SubseqsProcessor);

    function SubseqsProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, SubseqsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var subDivs = component.getMaskedSubdivSequences(mask);
        var chunksCount = 0;
        var resIdc = [];

        for (var subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
          var subs = subDivs[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            for (var j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
              resIdc[chunksCount++] = residues[j]._index;
            }
          }
        }

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          subdivs: subDivs,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    createClass(SubseqsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return SubseqsProcessor;
  }(RCGroup);

  function _createSuper$11(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$12(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$12() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BondsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(BondsProcessor, _RCGroup);

    var _super = _createSuper$11(BondsProcessor);

    function BondsProcessor(BondsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, BondsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var bonds = complex.getBonds();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var bondsIdc = [];
        var bondsCount = 0;
        component.forEachBond(function (bond) {
          var atom1 = bond._left;
          var atom2 = bond._right;

          if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
            return;
          }

          bondsIdc[bondsCount++] = bond._index;
        });

        if (bondsCount === 0) {
          return;
        }

        var bondsGroup = new BondsGroup(geoParams, {
          bonds: bonds,
          chunks: bondsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        bondsGroup._component = component;
        self.add(bondsGroup);
      });
      return _this;
    }

    createClass(BondsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return BondsProcessor;
  }(RCGroup);

  function _createSuper$12(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$13(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$13() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(AromaticProcessor, _RCGroup);

    var _super = _createSuper$12(AromaticProcessor);

    function AromaticProcessor(AromaticGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, AromaticProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();

      if (!mode.showAromaticLoops()) {
        return possibleConstructorReturn(_this);
      }

      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var chunksCount = 0;
        var cycles = [];
        var cycleIdx = 0;
        component.forEachCycle(function (cycle) {
          var cycAtoms = cycle.atoms;
          var perCycle = 0;

          for (var i = 0, n = cycAtoms.length; i < n; ++i) {
            if ((cycAtoms[i].mask & mask) !== 0) {
              ++perCycle;
              atomsIdc[chunksCount++] = cycAtoms[i].index;
            }
          }

          if (perCycle > 0) {
            cycles[cycleIdx++] = cycle;
          }
        });
        var atomsGroup = new AromaticGroup(geoParams, {
          cycles: cycles,
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    createClass(AromaticProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AromaticProcessor;
  }(RCGroup);

  var processors = {
    Atoms: AtomsProcessor,
    OrphanAtoms: OrphanAtomsProcessor,
    Residues: ResiduesProcessor,
    Nucleic: NucleicProcessor,
    Subseqs: SubseqsProcessor,
    Bonds: BondsProcessor,
    Aromatic: AromaticProcessor
  };

  function _bakeGroup(triplet, Processor, Group) {
    return function (complex, colorer, mode, polyComplexity, mask, material) {
      return new Processor(Group, triplet, complex, colorer, mode, polyComplexity, mask, material);
    };
  }

  var GroupsFactory = /*#__PURE__*/function () {
    function GroupsFactory() {
      classCallCheck(this, GroupsFactory);
    }

    createClass(GroupsFactory, null, [{
      key: "AtomsSpheres",
      value: function AtomsSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "OrphanedAtomsCrosses",
      value: function OrphanedAtomsCrosses(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createCrosses(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "BondsCylinders",
      value: function BondsCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
      }
    }, {
      key: "BondsLines",
      value: function BondsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.create2CLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
      }
    }, {
      key: "CartoonChains",
      value: function CartoonChains(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
      }
    }, {
      key: "TraceChains",
      value: function TraceChains(caps, settings) {
        var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
      }
    }, {
      key: "NucleicSpheres",
      value: function NucleicSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
      }
    }, {
      key: "NucleicCylinders",
      value: function NucleicCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
      }
    }, {
      key: "ALoopsTorus",
      value: function ALoopsTorus(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
      }
    }, {
      key: "ALoopsLines",
      value: function ALoopsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createChunkedLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
      }
    }, {
      key: "QuickSurfGeo",
      value: function QuickSurfGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createQuickSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "ContactSurfaceGeo",
      value: function ContactSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createContactSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "SASSESSurfaceGeo",
      value: function SASSESSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createSASSES(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
      }
    }, {
      key: "TextLabelsGeo",
      value: function TextLabelsGeo(caps, settings) {
        var gfxTriplet = MeshCreator.createLabels(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
      }
    }]);

    return GroupsFactory;
  }();

  /**
   * Create new mode.
   *
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the mode after its creation.
   *
   * @exports Mode
   * @this Mode
   * @abstract
   * @constructor
   * @classdesc Basic class for all available modes used for building and displaying molecule geometry.
   */

  var Mode = /*#__PURE__*/function () {
    function Mode(opts) {
      classCallCheck(this, Mode);

      if (this.constructor === Mode) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Mode options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.opts = ___default['default'].merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
    }
    /**
     * Get mode identification, probably with options.
     * @returns {string|Array} Mode identifier string ({@link Mode#id}) or two-element array containing both mode
     *   identifier and options ({@link Mode#opts}).
     * Options are returned if they were changed during or after the mode creation.
     */


    createClass(Mode, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
        var groupList = this.depGroups;
        var groupCount = groupList.length;
        var group = new gfxutils.RCGroup();
        var self = this;

        for (var i = 0; i < groupCount; ++i) {
          var currGroup = groupList[i];
          var renderParams = {};

          if (___default['default'].isArray(currGroup)) {
            renderParams = currGroup[1].call(this);
            var _currGroup = currGroup;

            var _currGroup2 = slicedToArray(_currGroup, 1);

            currGroup = _currGroup2[0];
          }

          var Group = GroupsFactory[currGroup](null, this.settings, renderParams);
          var newGroup = new Group(complex, colorer, self, polyComplexity, mask, material);

          if (newGroup.children.length > 0) {
            group.add(newGroup);
          }
        }

        return group;
      }
    }]);

    return Mode;
  }();

  makeContextDependent(Mode.prototype);
  /**
  * Mode identifier.
  * @type {string}
  */

  Mode.prototype.id = '__';
  /**
   * Mode geo groups.
   * @type {Array}
   */

  Mode.prototype.depGroups = [];

  function _createSuper$13(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$14(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$14() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function getRenderParams() {
    return {
      lineWidth: this.opts.lineWidth
    };
  }

  var LinesMode = /*#__PURE__*/function (_Mode) {
    inherits(LinesMode, _Mode);

    var _super = _createSuper$13(LinesMode);

    function LinesMode(opts) {
      var _this;

      classCallCheck(this, LinesMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits

      var groups = _this.depGroups;

      for (var i = 0, n = groups.length; i < n; ++i) {
        groups[i] = [groups[i], getRenderParams];
      }

      return _this;
    }

    createClass(LinesMode, [{
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }, {
      key: "calcAtomRadius",
      value: function calcAtomRadius() {
        return this.opts.atom;
      }
    }, {
      key: "getAromaticOffset",
      value: function getAromaticOffset() {
        return this.opts.offsarom;
      }
    }, {
      key: "getAromaticArcChunks",
      value: function getAromaticArcChunks() {
        return this.opts.chunkarom;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }]);

    return LinesMode;
  }(Mode);

  defineProperty(LinesMode, "id", 'LN');

  LinesMode.prototype.id = 'LN';
  LinesMode.prototype.name = 'Lines';
  LinesMode.prototype.shortName = 'Lines';
  LinesMode.prototype.depGroups = ['ALoopsLines', 'BondsLines', 'OrphanedAtomsCrosses'];

  function _createSuper$14(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$15(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$15() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var LicoriceMode = /*#__PURE__*/function (_Mode) {
    inherits(LicoriceMode, _Mode);

    var _super = _createSuper$14(LicoriceMode);

    function LicoriceMode() {
      classCallCheck(this, LicoriceMode);

      return _super.apply(this, arguments);
    }

    createClass(LicoriceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(_atom) {
        return this.opts.bond;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return LicoriceMode;
  }(Mode);

  defineProperty(LicoriceMode, "id", 'LC');

  LicoriceMode.prototype.id = 'LC';
  LicoriceMode.prototype.name = 'Licorice';
  LicoriceMode.prototype.shortName = 'Licorice';
  LicoriceMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$15(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$16(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$16() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BallsAndSticksMode = /*#__PURE__*/function (_Mode) {
    inherits(BallsAndSticksMode, _Mode);

    var _super = _createSuper$15(BallsAndSticksMode);

    function BallsAndSticksMode() {
      classCallCheck(this, BallsAndSticksMode);

      return _super.apply(this, arguments);
    }

    createClass(BallsAndSticksMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius * this.opts.atom;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return BallsAndSticksMode;
  }(Mode);

  defineProperty(BallsAndSticksMode, "id", 'BS');

  BallsAndSticksMode.prototype.id = 'BS';
  BallsAndSticksMode.prototype.name = 'Balls and Sticks';
  BallsAndSticksMode.prototype.shortName = 'Balls';
  BallsAndSticksMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$16(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$17(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$17() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VanDerWaalsMode = /*#__PURE__*/function (_Mode) {
    inherits(VanDerWaalsMode, _Mode);

    var _super = _createSuper$16(VanDerWaalsMode);

    function VanDerWaalsMode() {
      classCallCheck(this, VanDerWaalsMode);

      return _super.apply(this, arguments);
    }

    createClass(VanDerWaalsMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }]);

    return VanDerWaalsMode;
  }(Mode);

  defineProperty(VanDerWaalsMode, "id", 'VW');

  VanDerWaalsMode.prototype.id = 'VW';
  VanDerWaalsMode.prototype.name = 'Van der Waals';
  VanDerWaalsMode.prototype.shortName = 'VDW';
  VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres'];

  function _createSuper$17(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$18(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$18() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TraceMode = /*#__PURE__*/function (_Mode) {
    inherits(TraceMode, _Mode);

    var _super = _createSuper$17(TraceMode);

    function TraceMode() {
      classCallCheck(this, TraceMode);

      return _super.apply(this, arguments);
    }

    createClass(TraceMode, [{
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.radius;
      }
    }]);

    return TraceMode;
  }(Mode);

  defineProperty(TraceMode, "id", 'TR');

  TraceMode.prototype.id = 'TR';
  TraceMode.prototype.name = 'Trace';
  TraceMode.prototype.shortName = 'Trace';
  TraceMode.prototype.depGroups = ['TraceChains'];

  function _createSuper$18(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$19(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$19() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TubeMode = /*#__PURE__*/function (_Mode) {
    inherits(TubeMode, _Mode);

    var _super = _createSuper$18(TubeMode);

    function TubeMode() {
      classCallCheck(this, TubeMode);

      return _super.apply(this, arguments);
    }

    createClass(TubeMode, [{
      key: "getResidueRadius",
      value: function getResidueRadius(_residue) {
        return this.TUBE_RADIUS;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var rad = this.opts.radius;
        this.TUBE_RADIUS = new THREE.Vector2(rad, rad);
        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return TubeMode;
  }(Mode);

  defineProperty(TubeMode, "id", 'TU');

  TubeMode.prototype.id = 'TU';
  TubeMode.prototype.name = 'Tube';
  TubeMode.prototype.shortName = 'Tube';
  TubeMode.prototype.depGroups = ['CartoonChains'];

  function _createSuper$19(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1a(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CartoonMode = /*#__PURE__*/function (_Mode) {
    inherits(CartoonMode, _Mode);

    var _super = _createSuper$19(CartoonMode);

    function CartoonMode(opts) {
      var _this;

      classCallCheck(this, CartoonMode);

      _this = _super.call(this, opts); // cache for secondary structure options

      _this.secCache = {};
      return _this;
    }

    createClass(CartoonMode, [{
      key: "getResidueStartRadius",
      value: function getResidueStartRadius(residue) {
        var second = residue.getSecondary();

        if (!second || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return secOpts.start;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueEndRadius",
      value: function getResidueEndRadius(residue) {
        var second = residue.getSecondary();

        if (second === null || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return this.ARROW_END;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueRadius",
      value: function getResidueRadius(residue, val) {
        var startRad = this.getResidueStartRadius(residue);

        if (val === 0) {
          return startRad;
        }

        var endRad = this.getResidueEndRadius(residue);

        if (val === 2) {
          return endRad;
        }

        return startRad.clone().lerp(endRad, val / 2.0);
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius(_res) {
        return this.opts.radius;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var tubeRad = this.opts.radius;
        var secHeight = this.opts.depth;
        this.TUBE_RADIUS = new THREE.Vector2(tubeRad, tubeRad);
        this.ARROW_END = new THREE.Vector2(secHeight, tubeRad);
        var secCache = {};
        var secData = this.opts.ss;
        /* eslint-disable guard-for-in */

        for (var prop in secData) {
          secCache[prop] = {
            center: new THREE.Vector2(secHeight, secData[prop].width),
            start: new THREE.Vector2(secHeight, secData[prop].arrow)
          };
        }

        this.secCache = secCache;
        /* eslint-enable guard-for-in */

        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return CartoonMode;
  }(Mode);

  defineProperty(CartoonMode, "id", 'CA');

  CartoonMode.prototype.id = 'CA';
  CartoonMode.prototype.name = 'Cartoon';
  CartoonMode.prototype.shortName = 'Cartoon';
  CartoonMode.prototype.depGroups = ['CartoonChains', 'NucleicSpheres', 'NucleicCylinders'];

  function _createSuper$1a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1b(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$1 = chem.selectors;

  function getRenderParams$1() {
    return {
      wireframe: this.opts.wireframe,
      zClip: this.opts.zClip
    };
  }

  var SurfaceMode = /*#__PURE__*/function (_Mode) {
    inherits(SurfaceMode, _Mode);

    var _super = _createSuper$1a(SurfaceMode);

    function SurfaceMode(opts) {
      var _this;

      classCallCheck(this, SurfaceMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits

      var surfaces = _this.surfaceNames;
      var groups = _this.depGroups;

      for (var i = 0, n = surfaces.length; i < n; ++i) {
        groups[groups.length] = [surfaces[i], getRenderParams$1];
      }

      return _this;
    }

    createClass(SurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getVisibilitySelector",
      value: function getVisibilitySelector() {
        var visibilitySelector = null;

        if (this.opts.subset !== '') {
          var res = selectors$1.parse(this.opts.subset);

          if (!res.error) {
            visibilitySelector = res.selector;
          }
        }

        return visibilitySelector;
      }
    }]);

    return SurfaceMode;
  }(Mode);

  SurfaceMode.prototype.isSurface = true;
  SurfaceMode.prototype.surfaceNames = [];

  function _createSuper$1b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1c(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var QuickSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(QuickSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1b(QuickSurfaceMode);

    function QuickSurfaceMode() {
      classCallCheck(this, QuickSurfaceMode);

      return _super.apply(this, arguments);
    }

    createClass(QuickSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          useBeads: false,
          isoValue: this.opts.isoValue,
          gaussLim: this.opts.gaussLim[this.settings.now.resolution],
          radScale: this.opts.scale,
          gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return QuickSurfaceMode;
  }(SurfaceMode);

  defineProperty(QuickSurfaceMode, "id", 'QS');

  QuickSurfaceMode.prototype.id = 'QS';
  QuickSurfaceMode.prototype.name = 'Quick Surface';
  QuickSurfaceMode.prototype.shortName = 'Quick Surf';
  QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo'];

  function _createSuper$1c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1d(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(IsoSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1c(IsoSurfaceMode);

    function IsoSurfaceMode(excludeProbe, opts) {
      var _this;

      classCallCheck(this, IsoSurfaceMode);

      _this = _super.call(this, opts);
      _this._excludeProbe = excludeProbe;
      return _this;
    }

    createClass(IsoSurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
          radScale: this._radScale,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector(),
          probeRadius: this.opts.probeRadius,
          excludeProbe: this._excludeProbe
        };
      }
    }]);

    return IsoSurfaceMode;
  }(SurfaceMode);

  IsoSurfaceMode.prototype.id = 'SU';
  IsoSurfaceMode.prototype.name = 'Surface';
  IsoSurfaceMode.prototype.shortName = 'Surface';
  IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo'];
  IsoSurfaceMode.prototype._radScale = 1;
  IsoSurfaceMode.prototype._excludeProbe = false;

  function _createSuper$1d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1e(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSASMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    inherits(IsoSurfaceSASMode, _IsoSurfaceMode);

    var _super = _createSuper$1d(IsoSurfaceSASMode);

    function IsoSurfaceSASMode(opts) {
      classCallCheck(this, IsoSurfaceSASMode);

      return _super.call(this, false, opts);
    }

    return IsoSurfaceSASMode;
  }(IsoSurfaceMode);

  defineProperty(IsoSurfaceSASMode, "id", 'SA');

  IsoSurfaceSASMode.prototype.id = 'SA';
  IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
  IsoSurfaceSASMode.prototype.shortName = 'SAS';

  function _createSuper$1e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1f(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSESMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    inherits(IsoSurfaceSESMode, _IsoSurfaceMode);

    var _super = _createSuper$1e(IsoSurfaceSESMode);

    function IsoSurfaceSESMode(opts) {
      classCallCheck(this, IsoSurfaceSESMode);

      return _super.call(this, true, opts);
    }

    return IsoSurfaceSESMode;
  }(IsoSurfaceMode);

  defineProperty(IsoSurfaceSESMode, "id", 'SE');

  IsoSurfaceSESMode.prototype.id = 'SE';
  IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
  IsoSurfaceSESMode.prototype.shortName = 'SES';

  function _createSuper$1f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1g(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ContactSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(ContactSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1f(ContactSurfaceMode);

    function ContactSurfaceMode() {
      classCallCheck(this, ContactSurfaceMode);

      return _super.apply(this, arguments);
    }

    createClass(ContactSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          probeRadius: this.opts.probeRadius,
          radScale: this.opts.polyComplexity[this.settings.now.resolution],
          scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
          gridSpacing: 1.0 / this.opts.polyComplexity[this.settings.now.resolution],
          isoValue: this.opts.isoValue,
          probePositions: this.opts.probePositions,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return ContactSurfaceMode;
  }(SurfaceMode);

  defineProperty(ContactSurfaceMode, "id", 'CS');

  ContactSurfaceMode.prototype.id = 'CS';
  ContactSurfaceMode.prototype.name = 'Contact Surface';
  ContactSurfaceMode.prototype.shortName = 'Contact Surf';
  ContactSurfaceMode.prototype.isSurface = true;
  ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo'];

  function _createSuper$1g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1h(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TextMode = /*#__PURE__*/function (_Mode) {
    inherits(TextMode, _Mode);

    var _super = _createSuper$1g(TextMode);

    function TextMode() {
      classCallCheck(this, TextMode);

      return _super.apply(this, arguments);
    }

    createClass(TextMode, [{
      key: "getTemplateOptions",
      value: function getTemplateOptions() {
        return this.opts.template;
      }
    }, {
      key: "getLabelOpts",
      value: function getLabelOpts() {
        return ___default['default'].merge(this.opts, {
          colors: true,
          adjustColor: true,
          transparent: true
        });
      }
    }]);

    return TextMode;
  }(Mode);

  defineProperty(TextMode, "id", 'TX');

  TextMode.prototype.id = 'TX';
  TextMode.prototype.name = 'Text mode';
  TextMode.prototype.shortName = 'Text';
  TextMode.prototype.depGroups = ['TextLabelsGeo'];

  var modes = new EntityList([LinesMode, LicoriceMode, BallsAndSticksMode, VanDerWaalsMode, TraceMode, TubeMode, CartoonMode, QuickSurfaceMode, IsoSurfaceSASMode, IsoSurfaceSESMode, ContactSurfaceMode, TextMode]);

  function clamp(x, a, b) {
    return x <= b ? x < 0 ? 0 : x : b;
  }

  function lerpColor(c1, c2, alpha) {
    var beta = 1 - alpha;
    var r1 = c1 >> 16 & 0xff;
    var g1 = c1 >> 8 & 0xff;
    var b1 = c1 & 0xff;
    var r2 = c2 >> 16 & 0xff;
    var g2 = c2 >> 8 & 0xff;
    var b2 = c2 & 0xff;
    var r = beta * r1 + alpha * r2;
    var g = beta * g1 + alpha * g2;
    var b = beta * b1 + alpha * b2;
    return r << 16 | g << 8 | b;
  }

  var Palette = /*#__PURE__*/function () {
    function Palette(name, id) {
      classCallCheck(this, Palette);

      this.name = name || 'Custom';
      this.id = id || 'CP';
    }

    createClass(Palette, [{
      key: "getElementColor",
      value: function getElementColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.elementColors[name];
        return color === undefined && !asIs ? this.defaultElementColor : color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.residueColors[name];
        return color === undefined && !asIs ? this.defaultResidueColor : color;
      }
    }, {
      key: "getChainColor",
      value: function getChainColor(name) {
        var chain = name.charCodeAt(0);
        chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1F) % this.chainColors.length;
        return this.chainColors[chain];
      }
    }, {
      key: "getSecondaryColor",
      value: function getSecondaryColor(type) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.secondaryColors[type];
        return color === undefined && !asIs ? this.defaultSecondaryColor : color;
      }
    }, {
      key: "getSequentialColor",
      value: function getSequentialColor(index) {
        var colors = this.colors;
        var len = colors.length;
        return index < 0 ? colors[index % len + len] : colors[index % len];
      }
    }, {
      key: "getGradientColor",
      value: function getGradientColor(value, gradientName) {
        var gradient = this.gradients[gradientName];

        if (!gradient) {
          return this.defaultNamedColor;
        }

        var count = gradient.length;
        var index = value * (count - 1);
        var left = Math.floor(index);
        var right = clamp(left + 1, 0, count - 1);
        left = clamp(left, 0, count - 1);
        return lerpColor(gradient[left], gradient[right], index - left);
      }
    }, {
      key: "getNamedColor",
      value: function getNamedColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.namedColors[name];
        return color === undefined && !asIs ? this.defaultNamedColor : color;
      }
    }]);

    return Palette;
  }();

  ___default['default'].assign(Palette.prototype, {
    colors: [0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0x808080],
    minRangeColor: 0x000000,
    midRangeColor: 0x7F7F7F,
    maxRangeColor: 0xFFFFFF,
    defaultElementColor: 0xFFFFFF,
    elementColors: {},
    defaultResidueColor: 0xFFFFFF,
    residueColors: {},
    chainColors: [0xFFFFFF],
    defaultSecondaryColor: 0xFFFFFF,
    secondaryColors: {},
    defaultGradientColor: 0x000000,
    defaultNamedColor: 0xFFFFFF,
    namedColorsArray: [
    /* eslint-disable no-multi-spaces */
    ['indianred', 0xcd5c5c], ['lightcoral', 0xf08080], ['salmon', 0xfa8072], ['darksalmon', 0xe9967a], ['lightsalmon', 0xffa07a], ['crimson', 0xdc143c], ['red', 0xff0000], ['firebrick', 0xb22222], ['darkred', 0x8b0000], ['pink', 0xffc0cb], ['lightpink', 0xffb6c1], ['hotpink', 0xff69b4], ['deeppink', 0xff1493], ['mediumvioletred', 0xc71585], ['palevioletred', 0xdb7093], ['coral', 0xff7f50], ['tomato', 0xff6347], ['orangered', 0xff4500], ['darkorange', 0xff8c00], ['orange', 0xffa500], ['gold', 0xffd700], ['yellow', 0xffff00], ['lightyellow', 0xffffe0], ['lemonchiffon', 0xfffacd], ['lightgoldenrodyellow', 0xfafad2], ['papayawhip', 0xffefd5], ['moccasin', 0xffe4b5], ['peachpuff', 0xffdab9], ['palegoldenrod', 0xeee8aa], ['khaki', 0xf0e68c], ['darkkhaki', 0xbdb76b], ['lavender', 0xe6e6fa], ['thistle', 0xd8bfd8], ['plum', 0xdda0dd], ['violet', 0xee82ee], ['orchid', 0xda70d6], ['fuchsia', 0xff00ff], ['magenta', 0xff00ff], ['mediumorchid', 0xba55d3], ['mediumpurple', 0x9370db], ['rebeccapurple', 0x663399], ['blueviolet', 0x8a2be2], ['darkviolet', 0x9400d3], ['darkorchid', 0x9932cc], ['darkmagenta', 0x8b008b], ['purple', 0x800080], ['indigo', 0x4b0082], ['slateblue', 0x6a5acd], ['mediumslateblue', 0x7b68ee], ['darkslateblue', 0x483d8b], ['greenyellow', 0xadff2f], ['chartreuse', 0x7fff00], ['lawngreen', 0x7cfc00], ['lime', 0x00ff00], ['limegreen', 0x32cd32], ['palegreen', 0x98fb98], ['lightgreen', 0x90ee90], ['mediumspringgreen', 0x00fa9a], ['springgreen', 0x00ff7f], ['mediumseagreen', 0x3cb371], ['seagreen', 0x2e8b57], ['forestgreen', 0x228b22], ['green', 0x008000], ['darkgreen', 0x006400], ['yellowgreen', 0x9acd32], ['olivedrab', 0x6b8e23], ['olive', 0x808000], ['darkolivegreen', 0x556b2f], ['mediumaquamarine', 0x66cdaa], ['darkseagreen', 0x8fbc8f], ['lightseagreen', 0x20b2aa], ['darkcyan', 0x008b8b], ['teal', 0x008080], ['aqua', 0x00ffff], ['cyan', 0x00ffff], ['lightcyan', 0xe0ffff], ['paleturquoise', 0xafeeee], ['aquamarine', 0x7fffd4], ['turquoise', 0x40e0d0], ['mediumturquoise', 0x48d1cc], ['darkturquoise', 0x00ced1], ['cadetblue', 0x5f9ea0], ['steelblue', 0x4682b4], ['lightsteelblue', 0xb0c4de], ['powderblue', 0xb0e0e6], ['lightblue', 0xadd8e6], ['skyblue', 0x87ceeb], ['lightskyblue', 0x87cefa], ['deepskyblue', 0x00bfff], ['dodgerblue', 0x1e90ff], ['cornflowerblue', 0x6495ed], ['royalblue', 0x4169e1], ['blue', 0x0000ff], ['mediumblue', 0x0000cd], ['darkblue', 0x00008b], ['navy', 0x000080], ['midnightblue', 0x191970], ['cornsilk', 0xfff8dc], ['blanchedalmond', 0xffebcd], ['bisque', 0xffe4c4], ['navajowhite', 0xffdead], ['wheat', 0xf5deb3], ['burlywood', 0xdeb887], ['tan', 0xd2b48c], ['rosybrown', 0xbc8f8f], ['sandybrown', 0xf4a460], ['goldenrod', 0xdaa520], ['darkgoldenrod', 0xb8860b], ['peru', 0xcd853f], ['chocolate', 0xd2691e], ['saddlebrown', 0x8b4513], ['sienna', 0xa0522d], ['brown', 0xa52a2a], ['maroon', 0x800000], ['white', 0xffffff], ['snow', 0xfffafa], ['honeydew', 0xf0fff0], ['mintcream', 0xf5fffa], ['azure', 0xf0ffff], ['aliceblue', 0xf0f8ff], ['ghostwhite', 0xf8f8ff], ['whitesmoke', 0xf5f5f5], ['seashell', 0xfff5ee], ['beige', 0xf5f5dc], ['oldlace', 0xfdf5e6], ['floralwhite', 0xfffaf0], ['ivory', 0xfffff0], ['antiquewhite', 0xfaebd7], ['linen', 0xfaf0e6], ['lavenderblush', 0xfff0f5], ['mistyrose', 0xffe4e1], ['gainsboro', 0xdcdcdc], ['lightgray', 0xd3d3d3], ['silver', 0xc0c0c0], ['darkgray', 0xa9a9a9], ['gray', 0x808080], ['dimgray', 0x696969], ['lightslategray', 0x778899], ['slategray', 0x708090], ['darkslategray', 0x2f4f4f], ['black', 0x000000]
    /* eslint-enable no-multi-spaces */
    ],
    namedColors: {},

    /* eslint-enable no-magic-numbers */
    gradients: {
      rainbow: [0x0000ff, // blue
      0x00ffff, // cyan
      0x00ff00, // green
      0xffff00, // yellow
      0xff0000 // red
      ],
      temp: [0x0000ff, // blue
      0x007fff, // light-blue
      0xffffff, // white
      0xff7f00, // orange
      0xff0000 // red
      ],
      hot: [0xffffff, // white
      0xff7f00, // orange
      0xff0000 // red
      ],
      cold: [0xffffff, // white
      0x007fff, // light-blue
      0x0000ff // blue
      ],
      'blue-red': [0x0000ff, // blue
      0xffffff, // white
      0xff0000 // red
      ],
      reds: [0xffffff, // white
      0xff0000 // red
      ],
      blues: [0xffffff, // white
      0x0000ff // blue
      ]
    }
  });

  var _Palette$prototype = Palette.prototype,
      namedColorsArray = _Palette$prototype.namedColorsArray,
      namedColors = _Palette$prototype.namedColors;

  for (var i = 0, length = namedColorsArray.length; i < length; ++i) {
    var _namedColorsArray$i = slicedToArray(namedColorsArray[i], 2),
        name = _namedColorsArray$i[0],
        value = _namedColorsArray$i[1];

    namedColors[name] = value;
  }

  var palette = new Palette('CPK', 'CP'); // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    C: 0x202020,
    N: 0x2060FF,
    O: 0xEE2010,
    F: 0x00FF00,
    P: 0x8020FF,
    S: 0xFFFF00,
    CL: 0x00BB00,
    FE: 0xD0D0D0,
    CO: 0xD0D0D0,
    NI: 0xD0D0D0,
    CU: 0xD0D0D0,
    BR: 0x008800,
    I: 0x005500
    /* eslint-enable no-magic-numbers */

  };

  var _palette$secondaryCol;
  var palette$1 = new Palette('Jmol', 'JM');
  palette$1.colors = [
  /* eslint-disable no-magic-numbers */
  0x0000FF, // blue
  0x0055FF, //
  0x00ABFF, //
  0x00FFFF, // cyan
  0x00FFAB, //
  0x00FF55, //
  0x00FF00, // green
  0x55FF00, //
  0xABFF00, //
  0xFFFF00, // yellow
  0xFFAB00, //
  0xFF5500, //
  0xFF0000, // red
  0xFF0055, //
  0xFF00AB, //
  0xFF00FF, // magenta
  0xAB00FF, //
  0x5500FF //

  /* eslint-enable no-magic-numbers */
  ]; // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette$1.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    D: 0xFFFFC0,
    T: 0xFFFFA0,
    HE: 0xD9FFFF,
    LI: 0xCC80FF,
    BE: 0xC2FF00,
    B: 0xFFB5B5,
    C: 0x909090,
    N: 0x3050F8,
    O: 0xFF0D0D,
    F: 0x90E050,
    NE: 0xB3E3F5,
    NA: 0xAB5CF2,
    MG: 0x8AFF00,
    AL: 0xBFA6A6,
    SI: 0xF0C8A0,
    P: 0xFF8000,
    S: 0xFFFF30,
    CL: 0x1FF01F,
    AR: 0x80D1E3,
    K: 0x8F40D4,
    CA: 0x3DFF00,
    SC: 0xE6E6E6,
    TI: 0xBFC2C7,
    V: 0xA6A6AB,
    CR: 0x8A99C7,
    MN: 0x9C7AC7,
    FE: 0xE06633,
    CO: 0xF090A0,
    NI: 0x50D050,
    CU: 0xC88033,
    ZN: 0x7D80B0,
    GA: 0xC28F8F,
    GE: 0x668F8F,
    AS: 0xBD80E3,
    SE: 0xFFA100,
    BR: 0xA62929,
    KR: 0x5CB8D1,
    RB: 0x702EB0,
    SR: 0x00FF00,
    Y: 0x94FFFF,
    ZR: 0x94E0E0,
    NB: 0x73C2C9,
    MO: 0x54B5B5,
    TC: 0x3B9E9E,
    RU: 0x248F8F,
    RH: 0x0A7D8C,
    PD: 0x006985,
    AG: 0xC0C0C0,
    CD: 0xFFD98F,
    IN: 0xA67573,
    SN: 0x668080,
    SB: 0x9E63B5,
    TE: 0xD47A00,
    I: 0x940094,
    XE: 0x429EB0,
    CS: 0x57178F,
    BA: 0x00C900,
    LA: 0x70D4FF,
    CE: 0xFFFFC7,
    PR: 0xD9FFC7,
    ND: 0xC7FFC7,
    PM: 0xA3FFC7,
    SM: 0x8FFFC7,
    EU: 0x61FFC7,
    GD: 0x45FFC7,
    TB: 0x30FFC7,
    DY: 0x1FFFC7,
    HO: 0x00FF9C,
    ER: 0x00E675,
    TM: 0x00D452,
    YB: 0x00BF38,
    LU: 0x00AB24,
    HF: 0x4DC2FF,
    TA: 0x4DA6FF,
    W: 0x2194D6,
    RE: 0x267DAB,
    OS: 0x266696,
    IR: 0x175487,
    PT: 0xD0D0E0,
    AU: 0xFFD123,
    HG: 0xB8B8D0,
    TL: 0xA6544D,
    PB: 0x575961,
    BI: 0x9E4FB5,
    PO: 0xAB5C00,
    AT: 0x754F45,
    RN: 0x428296,
    FR: 0x420066,
    RA: 0x007D00,
    AC: 0x70ABFA,
    TH: 0x00BAFF,
    PA: 0x00A1FF,
    U: 0x008FFF,
    NP: 0x0080FF,
    PU: 0x006BFF,
    AM: 0x545CF2,
    CM: 0x785CE3,
    BK: 0x8A4FE3,
    CF: 0xA136D4,
    ES: 0xB31FD4,
    FM: 0xB31FBA,
    MD: 0xB30DA6,
    NO: 0xBD0D87,
    LR: 0xC70066,
    RF: 0xCC0059,
    DB: 0xD1004F,
    SG: 0xD90045,
    BH: 0xE00038,
    HS: 0xE6002E,
    MT: 0xEB0026
    /* eslint-enable no-magic-numbers */

  };
  palette$1.defaultResidueColor = 0xBEA06E; // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

  palette$1.residueColors = {
    /* eslint-disable no-magic-numbers */
    ALA: 0xC8C8C8,
    ARG: 0x145AFF,
    ASN: 0x00DCDC,
    ASP: 0xE60A0A,
    CYS: 0xE6E600,
    GLN: 0x00DCDC,
    GLU: 0xE60A0A,
    GLY: 0xEBEBEB,
    HIS: 0x8282D2,
    ILE: 0x0F820F,
    LEU: 0x0F820F,
    LYS: 0x145AFF,
    MET: 0xE6E600,
    PHE: 0x3232AA,
    PRO: 0xDC9682,
    SER: 0xFA9600,
    THR: 0xFA9600,
    TRP: 0xB45AB4,
    TYR: 0x3232AA,
    VAL: 0x0F820F,
    A: 0xA0A0FF,
    C: 0xFF8C4B,
    G: 0xFF7070,
    I: 0x80FFFF,
    T: 0xA0FFA0,
    U: 0xFF8080,
    DA: 0xA0A0FF,
    DC: 0xFF8C4B,
    DG: 0xFF7070,
    DI: 0x80FFFF,
    DT: 0xA0FFA0,
    DU: 0xFF8080,
    '+A': 0xA0A0FF,
    '+C': 0xFF8C4B,
    '+G': 0xFF7070,
    '+I': 0x80FFFF,
    '+T': 0xA0FFA0,
    '+U': 0xFF8080
    /* eslint-enable no-magic-numbers */

  };
  palette$1.chainColors = [// ' '->0 'A'->1, 'B'->2
  0xFFffffff, // ' ' & '0' white
  //
  0xFFC0D0FF, // skyblue
  0xFFB0FFB0, // pastel green
  0xFFFFC0C8, // pink
  0xFFFFFF80, // pastel yellow
  0xFFFFC0FF, // pastel magenta
  0xFFB0F0F0, // pastel cyan
  0xFFFFD070, // pastel gold
  0xFFF08080, // lightcoral
  0xFFF5DEB3, // wheat
  0xFF00BFFF, // deepskyblue
  0xFFCD5C5C, // indianred
  0xFF66CDAA, // mediumaquamarine
  0xFF9ACD32, // yellowgreen
  0xFFEE82EE, // violet
  0xFF00CED1, // darkturquoise
  0xFF00FF7F, // springgreen
  0xFF3CB371, // mediumseagreen
  0xFF00008B, // darkblue
  0xFFBDB76B, // darkkhaki
  0xFF006400, // darkgreen
  0xFF800000, // maroon
  0xFF808000, // olive
  0xFF800080, // purple
  0xFF008080, // teal
  0xFFB8860B, // darkgoldenrod
  0xFFB22222 // firebrick
  ];
  var StructuralElementType$3 = StructuralElement.Type;
  palette$1.secondaryColors = (_palette$secondaryCol = {}, defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_ALPHA, 0xFF0080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_PI, 0x600080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_310, 0xA00080), defineProperty(_palette$secondaryCol, StructuralElementType$3.STRAND, 0xFFC800), defineProperty(_palette$secondaryCol, StructuralElementType$3.TURN, 0x6080FF), defineProperty(_palette$secondaryCol, "dna", 0xAE00FE), defineProperty(_palette$secondaryCol, "rna", 0xFD0162), _palette$secondaryCol);

  var _palette$secondaryCol$1;
  var palette$2 = new Palette('VMD', 'VM');
  palette$2.colors = [
  /* eslint-disable no-magic-numbers */
  0x0000FF, // blue
  0xFF0000, // red
  0x606060, // gray
  0xFF8000, // orange
  0xFFFF00, // yellow
  0x808033, // tan
  0x999999, // silver
  0x00FF00, // green
  0xFFFFFF, // white
  0xFF9999, // pink
  0x40C0C0, // cyan
  0xA600A6, // purple
  0x80E666, // lime
  0xE666B3, // mauve
  0x804D00, // ochre
  0x8080C0 // ice blue

  /* eslint-enable no-magic-numbers */
  ];
  palette$2.defaultElementColor = 0x804D00; // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette$2.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    C: 0x40BFBF,
    N: 0x0000FF,
    O: 0xFF0000,
    P: 0x808033,
    S: 0xFFFF00
    /* eslint-enable no-magic-numbers */

  };
  palette$2.defaultResidueColor = 0x40C0C0; // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

  palette$2.residueColors = {
    /* eslint-disable no-magic-numbers */
    ALA: 0x0000FF,
    ARG: 0xFFFFFF,
    ASN: 0x808033,
    ASP: 0xFF0000,
    CYS: 0xFFFF00,
    GLN: 0xFF8000,
    GLU: 0xFF9999,
    GLY: 0xFFFFFF,
    HIS: 0x40C0C0,
    ILE: 0x00FF00,
    LEU: 0xFF9999,
    LYS: 0x40C0C0,
    MET: 0xFFFF00,
    PHE: 0xA600A6,
    PRO: 0x804C00,
    SER: 0xFFFF00,
    THR: 0xE666B3,
    TRP: 0x999999,
    TYR: 0x00FF00,
    VAL: 0x808033,
    A: 0x0000FF,
    C: 0xFF8000,
    G: 0xFFFF00,
    T: 0xA600A6,
    U: 0x00FF00,
    DA: 0x0000FF,
    DC: 0xFF8000,
    DG: 0xFFFF00,
    DT: 0xA600A6,
    DU: 0x00FF00,
    '+A': 0x0000FF,
    '+C': 0xFF8000,
    '+G': 0xFFFF00,
    '+T': 0xA600A6,
    '+U': 0x00FF00,
    WAT: 0x40C0C0,
    H2O: 0x40C0C0,
    HOH: 0x40C0C0
    /* eslint-enable no-magic-numbers */

  };
  palette$2.chainColors = [0xFFFFFF].concat(palette$2.colors);
  var StructuralElementType$4 = StructuralElement.Type;
  palette$2.secondaryColors = (_palette$secondaryCol$1 = {}, defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_ALPHA, 0xA600A6), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_310, 0x0000FF), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_PI, 0xFF0000), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.STRAND, 0xFFFF00), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.BRIDGE, 0x808033), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.TURN, 0x40C0C0), _palette$secondaryCol$1);

  var palettes = new EntityList([palette, palette$1, palette$2]);

  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
   *
   * @exports Colorer
   * @this Colorer
   * @abstract
   * @constructor
   * @classdesc Basic class for all available coloring algorithms used for building and displaying molecule geometry.
   */

  var Colorer = /*#__PURE__*/function () {
    function Colorer(opts) {
      classCallCheck(this, Colorer);

      if (this.constructor === Colorer) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Colorer options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.opts = ___default['default'].merge(utils.deriveDeep(settings.now.colorers[this.id], true), opts);
      /**
       * Palette in use.
       * @type {Palette}
       */

      this.palette = palettes.first;
    }
    /**
     * Get Colorer identification, probably with options.
     * @returns {string|Array} Colorer identifier string ({@link Colorer#id}) or two-element array containing both colorer
     *   identifier and options ({@link Colorer#opts}).
     * Options are returned if they were changed during or after colorer creation.
     */


    createClass(Colorer, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, settings.now.colorers[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }]);

    return Colorer;
  }();
  /**
   * Colorer identifier.
   * @type {string}
   */


  Colorer.prototype.id = '__';

  function _createSuper$1h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1i(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Element
   *
   * @exports ElementColorer
   * @augments Colorer
   * @constructor
   * @classdesc Coloring algorithm based on chemical element.
   */

  var ElementColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ElementColorer, _Colorer);

    var _super = _createSuper$1h(ElementColorer);

    function ElementColorer() {
      classCallCheck(this, ElementColorer);

      return _super.apply(this, arguments);
    }

    createClass(ElementColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var type = atom.element.name;

        if (type === 'C' && this.opts.carbon >= 0) {
          return this.opts.carbon;
        }

        return this.palette.getElementColor(type);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ElementColorer;
  }(Colorer);

  defineProperty(ElementColorer, "id", 'EL');

  ElementColorer.prototype.id = 'EL';
  ElementColorer.prototype.name = 'Element';
  ElementColorer.prototype.shortName = 'Element';

  function _createSuper$1i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1j(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Coloring algorithm based on residue type.
   *
   * @see ResidueType
   *
   * @exports ResidueTypeColorer
   * @constructor
   */

  var ResidueTypeColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ResidueTypeColorer, _Colorer);

    var _super = _createSuper$1i(ResidueTypeColorer);

    function ResidueTypeColorer() {
      classCallCheck(this, ResidueTypeColorer);

      return _super.apply(this, arguments);
    }

    createClass(ResidueTypeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getResidueColor(residue._type._name);
      }
    }]);

    return ResidueTypeColorer;
  }(Colorer);

  defineProperty(ResidueTypeColorer, "id", 'RT');

  ResidueTypeColorer.prototype.id = 'RT';
  ResidueTypeColorer.prototype.name = 'Residue Type';
  ResidueTypeColorer.prototype.shortName = 'Residue';

  function _createSuper$1j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1k(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SequenceColorer = /*#__PURE__*/function (_Colorer) {
    inherits(SequenceColorer, _Colorer);

    var _super = _createSuper$1j(SequenceColorer);

    function SequenceColorer() {
      classCallCheck(this, SequenceColorer);

      return _super.apply(this, arguments);
    }

    createClass(SequenceColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var chain = residue._chain;

        if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
          return this.palette.defaultNamedColor;
        }

        var min = chain.minSequence;
        var max = chain.maxSequence > min ? chain.maxSequence : min + 1;
        return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
      }
    }]);

    return SequenceColorer;
  }(Colorer);

  defineProperty(SequenceColorer, "id", 'SQ');

  SequenceColorer.prototype.id = 'SQ';
  SequenceColorer.prototype.name = 'Sequence';
  SequenceColorer.prototype.shortName = 'Sequence';

  function _createSuper$1k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1l(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ChainColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ChainColorer, _Colorer);

    var _super = _createSuper$1k(ChainColorer);

    function ChainColorer() {
      classCallCheck(this, ChainColorer);

      return _super.apply(this, arguments);
    }

    createClass(ChainColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getChainColor(residue.getChain()._name);
      }
    }]);

    return ChainColorer;
  }(Colorer);

  defineProperty(ChainColorer, "id", 'CH');

  ChainColorer.prototype.id = 'CH';
  ChainColorer.prototype.name = 'Chain';
  ChainColorer.prototype.shortName = 'Chain';

  function _createSuper$1l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1m(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SecondaryStructureColorer = /*#__PURE__*/function (_Colorer) {
    inherits(SecondaryStructureColorer, _Colorer);

    var _super = _createSuper$1l(SecondaryStructureColorer);

    function SecondaryStructureColorer() {
      classCallCheck(this, SecondaryStructureColorer);

      return _super.apply(this, arguments);
    }

    createClass(SecondaryStructureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        if (residue._type.flags & ResidueType.Flags.DNA) {
          return this.palette.getSecondaryColor('dna');
        }

        if (residue._type.flags & ResidueType.Flags.RNA) {
          return this.palette.getSecondaryColor('rna');
        }

        var secondary = residue.getSecondary();

        if (secondary) {
          var color = this.palette.getSecondaryColor(secondary.type, true);

          if (color === undefined) {
            color = this.palette.getSecondaryColor(secondary.generic);
          }

          return color;
        }

        return this.palette.defaultSecondaryColor;
      }
    }]);

    return SecondaryStructureColorer;
  }(Colorer);

  defineProperty(SecondaryStructureColorer, "id", 'SS');

  SecondaryStructureColorer.prototype.id = 'SS';
  SecondaryStructureColorer.prototype.name = 'Secondary Structure';
  SecondaryStructureColorer.prototype.shortName = 'Structure';

  function _createSuper$1m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1n(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var UniformColorer = /*#__PURE__*/function (_Colorer) {
    inherits(UniformColorer, _Colorer);

    var _super = _createSuper$1m(UniformColorer);

    function UniformColorer() {
      classCallCheck(this, UniformColorer);

      return _super.apply(this, arguments);
    }

    createClass(UniformColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(_atom, _complex) {
        return this.opts.color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return UniformColorer;
  }(Colorer);

  defineProperty(UniformColorer, "id", 'UN');

  UniformColorer.prototype.id = 'UN';
  UniformColorer.prototype.name = 'Uniform';
  UniformColorer.prototype.shortName = 'Uniform';

  function _createSuper$1n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1o(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @exports ConditionalColorer
   * @augments Colorer
   * @constructor
   * @classdesc Bicolor coloring algorithm based on a selector string used as a condition.
   */

  var ConditionalColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ConditionalColorer, _Colorer);

    var _super = _createSuper$1n(ConditionalColorer);

    function ConditionalColorer(opts) {
      var _this;

      classCallCheck(this, ConditionalColorer);

      _this = _super.call(this, opts);
      var parsed = selectors.parse(_this.opts.subset);
      _this._subsetCached = parsed.error ? selectors.none() : parsed.selector;
      return _this;
    }

    createClass(ConditionalColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var subset = this._subsetCached;
        var atoms = residue._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (!subset.includesAtom(atoms[i])) {
            return this.opts.baseColor;
          }
        }

        return this.opts.color;
      }
    }]);

    return ConditionalColorer;
  }(Colorer);

  defineProperty(ConditionalColorer, "id", 'CO');

  ConditionalColorer.prototype.id = 'CO';
  ConditionalColorer.prototype.name = 'Conditional';
  ConditionalColorer.prototype.shortName = 'Conditional';

  function _createSuper$1o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1p(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ConformationColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ConformationColorer, _Colorer);

    var _super = _createSuper$1o(ConformationColorer);

    function ConformationColorer() {
      classCallCheck(this, ConformationColorer);

      return _super.apply(this, arguments);
    }

    createClass(ConformationColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this.palette.getChainColor(String.fromCharCode(atom.location));
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ConformationColorer;
  }(Colorer);

  defineProperty(ConformationColorer, "id", 'CF');

  ConformationColorer.prototype.id = 'CF';
  ConformationColorer.prototype.name = 'Conformation';
  ConformationColorer.prototype.shortName = 'Conformation';

  function _createSuper$1p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Temperature
   *
   * @exports TemperatureColorer
   * @augments Colorer
   * @constructor
   * @classdesc Coloring algorithm based on temperature of chemical element.
   */

  var TemperatureColorer = /*#__PURE__*/function (_Colorer) {
    inherits(TemperatureColorer, _Colorer);

    var _super = _createSuper$1p(TemperatureColorer);

    function TemperatureColorer() {
      classCallCheck(this, TemperatureColorer);

      return _super.apply(this, arguments);
    }

    createClass(TemperatureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        var factor = 1;

        if (atom.temperature && opts) {
          if (opts.min === opts.max) {
            factor = atom.temperature > opts.max ? 1 : 0;
          } else {
            factor = (atom.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;

        if (!opts) {
          return this.palette.defaultGradientColor;
        }

        if (residue.temperature) {
          var factor = 0;

          if (opts.min === opts.max) {
            factor = residue.temperature > opts.max ? 1 : 0;
          } else {
            factor = (residue.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }]);

    return TemperatureColorer;
  }(Colorer);

  defineProperty(TemperatureColorer, "id", 'TM');

  TemperatureColorer.prototype.id = 'TM'; // [T]e[M]perature

  TemperatureColorer.prototype.name = 'Temperature';
  TemperatureColorer.prototype.shortName = 'Temperature';

  function _createSuper$1q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1r(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Occupancy
   *
   * @exports OccupancyColorer
   * @augments Occupancy
   * @constructor
   * @classdesc Coloring algorithm based on occupancy of chemical element.
   */

  var OccupancyColorer = /*#__PURE__*/function (_Colorer) {
    inherits(OccupancyColorer, _Colorer);

    var _super = _createSuper$1q(OccupancyColorer);

    function OccupancyColorer() {
      classCallCheck(this, OccupancyColorer);

      return _super.apply(this, arguments);
    }

    createClass(OccupancyColorer, [{
      key: "_getColorByOccupancy",
      value: function _getColorByOccupancy(occupancy, opts) {
        if (occupancy !== undefined) {
          var factor = 1 - occupancy;
          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(atom.occupancy, opts);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(residue.occupancy, opts);
      }
    }]);

    return OccupancyColorer;
  }(Colorer);

  defineProperty(OccupancyColorer, "id", 'OC');

  OccupancyColorer.prototype.id = 'OC'; // [OC]cupancy

  OccupancyColorer.prototype.name = 'Occupancy';
  OccupancyColorer.prototype.shortName = 'Occupancy';

  function _createSuper$1r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1s(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var HydrophobicityColorer = /*#__PURE__*/function (_Colorer) {
    inherits(HydrophobicityColorer, _Colorer);

    var _super = _createSuper$1r(HydrophobicityColorer);

    function HydrophobicityColorer() {
      classCallCheck(this, HydrophobicityColorer);

      return _super.apply(this, arguments);
    }

    createClass(HydrophobicityColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var color = this.palette.defaultResidueColor;

        if (residue._type.hydrophobicity !== undefined) {
          // Kyte Doolitle hydro [-4.5,4.5]->[0.1]
          var min = -4.5;
          var max = 4.5;
          color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
        }

        return color;
      }
    }]);

    return HydrophobicityColorer;
  }(Colorer);

  defineProperty(HydrophobicityColorer, "id", 'HY');

  HydrophobicityColorer.prototype.id = 'HY';
  HydrophobicityColorer.prototype.name = 'Hydrophobicity';
  HydrophobicityColorer.prototype.shortName = 'Hydrophobicity';

  function _createSuper$1s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1t(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var MoleculeColorer = /*#__PURE__*/function (_Colorer) {
    inherits(MoleculeColorer, _Colorer);

    var _super = _createSuper$1s(MoleculeColorer);

    function MoleculeColorer() {
      classCallCheck(this, MoleculeColorer);

      return _super.apply(this, arguments);
    }

    createClass(MoleculeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var molecule = residue._molecule;

        var count = _complex.getMoleculeCount();

        if (count > 1) {
          return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
        }

        return this.palette.getGradientColor(0, this.opts.gradient);
      }
    }]);

    return MoleculeColorer;
  }(Colorer);

  defineProperty(MoleculeColorer, "id", 'MO');

  MoleculeColorer.prototype.id = 'MO';
  MoleculeColorer.prototype.name = 'Molecule';
  MoleculeColorer.prototype.shortName = 'Molecule';

  function _createSuper$1t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1u(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function scaleColor(c, factor) {
    var r1 = c >> 16 & 0xff;
    var g1 = c >> 8 & 0xff;
    var b1 = c & 0xff;
    var r = factor * r1;
    var g = factor * g1;
    var b = factor * b1;
    return r << 16 | g << 8 | b;
  }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @exports CarbonColorer
   * @augments Colorer
   * @constructor
   * @classdesc Bicolor coloring algorithm based on selection carbon atoms.
   */


  var CarbonColorer = /*#__PURE__*/function (_Colorer) {
    inherits(CarbonColorer, _Colorer);

    var _super = _createSuper$1t(CarbonColorer);

    function CarbonColorer() {
      classCallCheck(this, CarbonColorer);

      return _super.apply(this, arguments);
    }

    createClass(CarbonColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var colorCarbon = this.opts.color;
        var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
        return atom.flags & Atom.Flags.CARBON ? colorCarbon : colorNotCarbon;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return CarbonColorer;
  }(Colorer);

  defineProperty(CarbonColorer, "id", 'CB');

  CarbonColorer.prototype.id = 'CB';
  CarbonColorer.prototype.name = 'Carbon';
  CarbonColorer.prototype.shortName = 'Carbon';

  var colorers = new EntityList([ElementColorer, ResidueTypeColorer, SequenceColorer, ChainColorer, SecondaryStructureColorer, UniformColorer, ConditionalColorer, ConformationColorer, TemperatureColorer, OccupancyColorer, HydrophobicityColorer, MoleculeColorer, CarbonColorer]);

  function neutralColor(intensity) {
    return new THREE.Color(intensity, intensity, intensity);
  }

  var materialList = [{
    id: 'DF',
    name: 'Diffuse',
    shortName: 'Diffuse',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'SF',
    name: 'Soft Plastic',
    shortName: 'Soft',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.1),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'PL',
    name: 'Glossy Plastic',
    shortName: 'Glossy',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.28),
      shininess: 100,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'ME',
    name: 'Metal',
    shortName: 'Metal',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.55),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TR',
    name: 'Transparent',
    shortName: 'Transparent',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'GL',
    name: 'Glass',
    shortName: 'Glass',
    uberOptions: {
      diffuse: neutralColor(0.50),
      specular: neutralColor(0.65),
      shininess: 100,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'BA',
    name: 'Backdrop',
    shortName: 'Backdrop',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: false,
      depthWrite: false,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TN',
    name: 'Toon',
    shortName: 'Toon',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: true
    }
  }, {
    id: 'FL',
    name: 'Flat',
    shortName: 'Flat',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 0,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: true,
      depthWrite: true,
      transparent: false
    }
  }];
  var materials = new EntityList(materialList);

  /**
   * Utils functions which is worked with meshes
   *
   * functions for doing something with all/specified meshes
   * functions for traversihg tree and create auxiliary meshes for transparency/shadowmaps...
   * functions for calculating data connected with meshes
   */

  function _gatherObjects(root, meshTypes) {
    var meshes = [];
    root.traverse(function (object) {
      for (var i = 0; i < meshTypes.length; i++) {
        if (object instanceof meshTypes[i]) {
          meshes[meshes.length] = object;
          break;
        }
      }
    });
    return meshes;
  } // new mesh with the same geometry and specified material values and layer


  function createDerivativeMesh(mesh, values, layer) {
    var material = mesh.material.createInstance();
    material.setValues(values);
    var newMesh = new mesh.constructor(mesh.geometry, material);
    newMesh.material.needsUpdate = true;
    newMesh.applyMatrix4(mesh.matrix);
    newMesh.layers.set(layer);
    return newMesh;
  }

  function traverseMeshes(root, meshTypes, func) {
    var meshes = _gatherObjects(root, meshTypes);

    for (var i = 0, n = meshes.length; i < n; ++i) {
      var mesh = meshes[i];

      if (!mesh.parent) {
        continue;
      }

      func(mesh);
    }
  }

  function applyTransformsToMeshes(root, mtc) {
    var mtcCount = mtc.length;

    if (mtcCount < 1) {
      return;
    }

    var meshTypes = [THREE.Mesh, THREE.LineSegments, THREE.Line];
    traverseMeshes(root, meshTypes, function (mesh) {
      mesh.applyMatrix4(mtc[0]);

      for (var j = 1; j < mtcCount; ++j) {
        var newMesh = new mesh.constructor(mesh.geometry, mesh.material);
        mesh.parent.add(newMesh);
        newMesh.applyMatrix4(mtc[j]);
      }
    });
  }

  var processTransparentMaterial = function () {
    var matValues = {
      prepassTransparancy: true,
      fakeOpacity: false,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        mesh.material.setValues({
          prepassTransparancy: false,
          fakeOpacity: false
        });
        mesh.material.needsUpdate = true;
        mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
        var prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
        mesh.parent.add(prepassTranspMesh);
      });
    };
  }();

  var processColFromPosMaterial = function () {
    var matValues = {
      colorFromPos: true,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false,
      overrideColor: false,
      fogTransparent: false,
      attrColor: false,
      attrColor2: false,
      attrAlphaColor: false,
      fakeOpacity: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        var colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
        mesh.parent.add(colFromPosMesh);
      });
    };
  }();

  var createShadowmapMaterial = function () {
    var matValues = {
      colorFromDepth: true,
      orthoCam: true,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        if (!mesh.receiveShadow && mesh.material.shadowmap) {
          // remove shadow from non-receivers
          mesh.material.setValues({
            shadowmap: false
          });
        }

        if (!mesh.material.lights) {
          // skip creating shadowmap meshes for materials without lighting
          return;
        }

        if (!mesh.castShadow) {
          // skip creating shadowmap meshes for non-casters
          return;
        }

        if (!gfxutils.belongToSelectLayers(mesh)) {
          // skip creating shadowmap meshes for selection layer
          return;
        }

        var shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
        shadowmapMesh.isShadowmapMesh = true;
        mesh.parent.add(shadowmapMesh);
      });
    };
  }();

  function removeShadowmapMaterial(root, material) {
    if (!(material instanceof UberMaterial)) {
      return;
    }

    traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
      if (mesh.isShadowmapMesh) {
        mesh.parent.remove(mesh);
      }
    });
  }

  function forEachMeshInGroup(group, process) {
    function processObj(object) {
      if (object instanceof THREE.Mesh) {
        process(object);
      }

      for (var i = 0, l = object.children.length; i < l; i++) {
        processObj(object.children[i]);
      }
    }

    processObj(group);
  }

  function _countMeshTriangles(mesh) {
    var geom = mesh.geometry;

    if (geom instanceof THREE.InstancedBufferGeometry) {
      var attribs = geom.attributes;

      for (var property in attribs) {
        if (attribs.hasOwnProperty(property) && attribs[property] instanceof THREE.InstancedBufferAttribute) {
          var currAttr = attribs[property];
          var indexSize = geom.index ? geom.index.array.length / 3 : 0;
          return indexSize * currAttr.array.length / currAttr.itemSize;
        }
      }

      return 0;
    }

    if (geom instanceof THREE.BufferGeometry) {
      return geom.index ? geom.index.array.length / 3 : 0;
    }

    return geom.faces ? geom.faces.length : 0;
  }

  function countTriangles(group) {
    var totalCount = 0;
    forEachMeshInGroup(group, function (mesh) {
      totalCount += _countMeshTriangles(mesh);
    });
    return totalCount;
  }

  var meshutils = {
    applyTransformsToMeshes: applyTransformsToMeshes,
    processTransparentMaterial: processTransparentMaterial,
    processColFromPosMaterial: processColFromPosMaterial,
    createShadowmapMaterial: createShadowmapMaterial,
    removeShadowmapMaterial: removeShadowmapMaterial,
    forEachMeshInGroup: forEachMeshInGroup,
    countTriangles: countTriangles
  };

  var selectors$2 = chem.selectors;

  var Representation = /*#__PURE__*/function () {
    function Representation(index, mode, colorer, selector) {
      classCallCheck(this, Representation);

      var startMaterialValues = {
        clipPlane: settings.now.draft.clipPlane,
        fogTransparent: settings.now.bg.transparent,
        shadowmap: settings.now.shadow.on,
        shadowmapType: settings.now.shadow.type
      };
      this.index = index;
      this.mode = mode;
      this.colorer = colorer;
      this.selector = selector;
      this.selectorString = '';
      this.count = 0;
      this.material = new UberMaterial();
      this.material.setValues(startMaterialValues);
      this.material.setUberOptions({
        fogAlpha: settings.now.fogAlpha
      });
      this.materialPreset = materials.first;
      this.needsRebuild = true;
      this.visible = true; // apply mode params & preset

      this.setMode(mode);
    }

    createClass(Representation, [{
      key: "markAtoms",
      value: function markAtoms(complex) {
        this.count = complex.markAtoms(this.selector, 1 << this.index);
        this.needsRebuild = true;
        return this.count;
      }
    }, {
      key: "unmarkAtoms",
      value: function unmarkAtoms(complex) {
        complex.clearAtomBits(1 << this.index);
        this.count = 0;
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        this.mode = mode;
      }
    }, {
      key: "setMaterialPreset",
      value: function setMaterialPreset(preset) {
        this.materialPreset = preset;
        this.material.setUberOptions(preset.uberOptions);
        this.material.setValues(preset.values);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.geo = null;
        this.selectionGeo = null;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex) {
        this.reset();
        this.needsRebuild = false;

        if (settings.now.ao) {
          this.material.setValues({
            normalsToGBuffer: settings.now.ao
          });
        }

        this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);

        if (this.material.uberOptions.opacity < 0.99 && settings.now.transparency === 'prepass') {
          meshutils.processTransparentMaterial(this.geo, this.material);
        }

        this.geo.visible = this.visible;
        gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
        meshutils.processColFromPosMaterial(this.geo, this.material);

        if (settings.now.shadow.on) {
          meshutils.createShadowmapMaterial(this.geo, this.material);
        }

        return this.geo;
      }
    }, {
      key: "buildSelectionGeometry",
      value: function buildSelectionGeometry(mask) {
        var sg = null;

        if (this.geo && 'getSubset' in this.geo) {
          var meshes = this.geo.getSubset(mask);

          if (meshes && meshes.length > 0) {
            sg = new THREE.Group();
            sg.matrixAutoUpdate = false;
            sg.matrix = this.geo.matrix;

            for (var j = 0; j < meshes.length; j++) {
              var m = meshes[j];
              sg.add(m);
            }
          }
        }

        if (sg) {
          sg.visible = this.visible;
        }

        this.selectionGeo = sg;
        return this.selectionGeo;
      }
      /**
       * Create object that represents difference between current and another rep
       * anotherRep could be undefined. In this case everything is reported.
       */

    }, {
      key: "compare",
      value: function compare(repSettings) {
        var diff = {};
        var selStr = String(this.selector);

        if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
          diff.selector = selStr;
        }

        var modeDiff = this.mode.identify();

        if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
          diff.mode = modeDiff;
        }

        var colorerDiff = this.colorer.identify();

        if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
          diff.colorer = colorerDiff;
        }

        if (!repSettings || this.materialPreset.id !== repSettings.material) {
          diff.material = this.materialPreset.id;
        }

        return diff;
      }
      /**
       * Change representation. Write fields what was changed into new object, return it.
       */

    }, {
      key: "change",
      value: function change(repSettings, complex, mode, color) {
        var diff = {}; // modify selector

        if (repSettings.selector) {
          var newSelectorObject = selectors$2.parse(repSettings.selector).selector;
          var newSelector = String(newSelectorObject);

          if (this.selectorString !== newSelector) {
            diff.selector = newSelector;
            this.selectorString = newSelector;
            this.selector = newSelectorObject;
            this.markAtoms(complex);
          }
        } // modify mode


        if (repSettings.mode) {
          var newMode = repSettings.mode;

          if (!___default['default'].isEqual(this.mode.identify(), newMode)) {
            diff.mode = newMode;
            this.setMode(mode);
          }
        } // modify colorer


        if (repSettings.colorer) {
          var newColorer = repSettings.colorer;

          if (!___default['default'].isEqual(this.colorer.identify(), newColorer)) {
            diff.colorer = newColorer;
            this.colorer = color;
          }
        } // modify material


        if (repSettings.material) {
          var newMaterial = repSettings.material;

          if (!___default['default'].isEqual(this.materialPreset.id, newMaterial)) {
            diff.material = newMaterial;
            this.setMaterialPreset(materials.get(repSettings.material));
          }
        }

        return diff;
      }
    }, {
      key: "show",
      value: function show(visible) {
        this.visible = visible;

        if (this.geo) {
          this.geo.visible = visible;
        }

        if (this.selectionGeo) {
          this.selectionGeo.visible = visible;
        }
      }
    }]);

    return Representation;
  }();

  function _createSuper$1u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1v(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _traverseComponentGroups(root, component, callback) {
    var children = root.children;

    if (!children) {
      return;
    }

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];

      if (child._component === component) {
        callback(child);
      }

      if (child instanceof gfxutils.RCGroup) {
        _traverseComponentGroups(child, component, callback);
      }
    }
  }

  function ComplexEditor() {}

  var ComplexComponentEditor = /*#__PURE__*/function (_ComplexEditor) {
    inherits(ComplexComponentEditor, _ComplexEditor);

    var _super = _createSuper$1u(ComplexComponentEditor);

    function ComplexComponentEditor(complexVisual) {
      var _this;

      classCallCheck(this, ComplexComponentEditor);

      _this = _super.call(this);
      _this._complexVisual = complexVisual;
      _this._inProgress = false;
      return _this;
    }

    createClass(ComplexComponentEditor, [{
      key: "begin",
      value: function begin() {
        var complex = this._complexVisual.getComplex(); // init component matrices


        this._componentTransforms = [];

        for (var i = 0; i < complex._components.length; ++i) {
          var component = complex._components[i];
          this._componentTransforms[component._index] = new THREE.Object3D();
        }

        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var complex = this._complexVisual.getComplex();

        for (var i = 0; i < complex._components.length; ++i) {
          this._bakeComponentTransform(complex._components[i]);
        }

        complex.onAtomPositionChanged();

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE.Vector3(0, 0, 0)
        };
        var visual = this._complexVisual;
        var component = visual.getSelectedComponent();

        if (component === null) {
          return res;
        }

        var selection = this._complexVisual.getSelectionGeo();

        var selectionMask = 1 << visual.getSelectionBit();
        var i;
        var j;
        var reprNode;
        var geo; // find all geo nodes for this component

        _traverseComponentGroups(visual, component, function (child) {
          res.objects.push(child);
        }); // find all selection nodes for this component


        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component') && geo._component === component) {
              res.objects.push(geo);
            }
          }
        } // add dummy object that stores component transformation


        res.objects.push(this._componentTransforms[component._index]);
        var bbmin = new THREE.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var bbmax = new THREE.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        component.forEachResidue(function (residue) {
          var atoms = residue._atoms;

          for (j = 0; j < atoms.length; ++j) {
            if (atoms[j].mask & selectionMask) {
              bbmin.min(atoms[j].position);
              bbmax.max(atoms[j].position);
            }
          }
        });
        res.pivot.lerpVectors(bbmin, bbmax, 0.5);
        return res;
      }
    }, {
      key: "_bakeComponentTransform",
      value: function _bakeComponentTransform(component) {
        var t = this._componentTransforms[component._index];

        if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {
          t.updateMatrix();
          component.forEachResidue(function (residue) {
            var atoms = residue._atoms;

            for (var j = 0; j < atoms.length; ++j) {
              atoms[j].position.applyMatrix4(t.matrix);
            }
          });
        }
      }
    }, {
      key: "_resetComponentTransform",
      value: function _resetComponentTransform() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var i;
        var j;
        var reprNode;
        var geo;

        for (i = 0; i < this._componentTransforms.length; ++i) {
          geo = this._componentTransforms[i];
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        } // reset all geo nodes


        for (i = 0; i < visual.children.length; ++i) {
          reprNode = visual.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        } // reset all selection nodes


        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        }
      }
    }]);

    return ComplexComponentEditor;
  }(ComplexEditor);

  var ComplexFragmentEditor = /*#__PURE__*/function (_ComplexEditor2) {
    inherits(ComplexFragmentEditor, _ComplexEditor2);

    var _super2 = _createSuper$1u(ComplexFragmentEditor);

    function ComplexFragmentEditor(complexVisual) {
      var _this2;

      classCallCheck(this, ComplexFragmentEditor);

      _this2 = _super2.call(this);
      _this2._complexVisual = complexVisual;
      _this2._inProgress = false;
      return _this2;
    }

    createClass(ComplexFragmentEditor, [{
      key: "begin",
      value: function begin() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var atoms = this._getSelectionBorderAtoms();

        if (atoms.length < 1 || atoms.length > 2) {
          logger.error('Can only edit fragments with one or two bound atoms.');
          return false;
        }

        this._fragmentBoundAtoms = atoms;
        var selectionMask = 1 << visual.getSelectionBit(); // hide selected fragment in main model

        visual.disableSubset(selectionMask, true); // hide selection geo in main model

        for (var k = 0; k < selection.children.length; ++k) {
          selection.children[k].visible = false;
        } // create visible fragment representation to rotate


        var pivotPos = atoms[0].position.clone();

        if (atoms.length === 2) {
          pivotPos.lerp(atoms[1].position, 0.5);
        }

        this._fragmentGeo = new THREE.Group();
        visual.add(this._fragmentGeo);

        this._fragmentGeo.position.copy(pivotPos);

        this._fragmentSelectionGeo = new THREE.Group();
        selection.add(this._fragmentSelectionGeo);

        this._fragmentSelectionGeo.position.copy(pivotPos);

        var offset = pivotPos.clone();
        offset.negate();

        for (var i = 0; i < visual.children.length; ++i) {
          var g = visual.children[i];

          if (!('getSubset' in g)) {
            continue;
          }

          var vg = new THREE.Group();

          this._fragmentGeo.add(vg);

          var sg = new THREE.Group();

          this._fragmentSelectionGeo.add(sg);

          var meshes = g.getSubset(selectionMask, true);

          for (var j = 0; j < meshes.length; j++) {
            var m = meshes[j];
            vg.add(m);
            m.position.copy(offset);
          }

          var smeshes = g.getSubset(selectionMask, true);

          for (var h = 0; h < smeshes.length; h++) {
            var sm = smeshes[h];
            sg.add(sm);
            sm.position.copy(offset);
          }
        }

        gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;
        var selectionBit = visual.getSelectionBit();
        var p = this._fragmentGeo.position;

        var m = this._fragmentGeo.matrix.clone();

        m.multiply(new THREE.Matrix4().makeTranslation(-p.x, -p.y, -p.z));

        this._bakeAtomTransform(m, 1 << selectionBit); // show selected fragment in main model


        visual.enableSubset(1 << selectionBit, true);
        visual.getComplex().onAtomPositionChanged();
        visual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        this._fragmentGeo.parent.remove(this._fragmentGeo); // show selected fragment in main model


        visual.enableSubset(1 << visual.getSelectionBit(), true); // show selection geo in main model (+ remove fragment selection geo)

        for (var i = 0; i < selection.children.length; ++i) {
          var node = selection.children[i];

          if (node.visible) {
            selection.remove(node);
          } else {
            node.visible = true;
          }
        }

        visual.finalizeEdit();
      }
    }, {
      key: "isFreeRotationAllowed",
      value: function isFreeRotationAllowed() {
        return this._fragmentBoundAtoms.length < 2;
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE.Vector3(0, 0, 0)
        };
        res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
        var boundAtoms = this._fragmentBoundAtoms;

        if (boundAtoms.length === 1) {
          if (boundAtoms[0].bonds.length === 1) {
            // single external bond allows rotation about bond axis
            var bond = boundAtoms[0].bonds[0];
            res.axis = new THREE.Vector3().subVectors(bond._right.position, bond._left.position);
            res.axis.normalize();
            res.axis.transformDirection(this._complexVisual.matrixWorld);
          }
        } else if (boundAtoms.length === 2) {
          // two bound atoms allow rotation only about axis running through their centers
          res.axis = new THREE.Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
          res.axis.normalize();
          res.axis.transformDirection(this._complexVisual.matrixWorld);
        }

        return res;
      }
    }, {
      key: "_getSelectionBorderAtoms",
      value: function _getSelectionBorderAtoms() {
        var complex = this._complexVisual.getComplex();

        var selectionMask = 1 << this._complexVisual.getSelectionBit();

        var atomHash = {};
        complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              atomHash[bond._left.index] = 1;
            }
          } else if (bond._right.mask & selectionMask) {
            atomHash[bond._right.index] = 1;
          }
        });
        var atoms = [];
        var keys = Object.keys(atomHash);

        for (var i = 0, n = keys.length; i < n; ++i) {
          var idx = keys[i];
          atoms.push(complex._atoms[idx]);
        }

        return atoms;
      }
    }, {
      key: "_bakeAtomTransform",
      value: function _bakeAtomTransform(matrix, mask) {
        this._complexVisual.getComplex().forEachAtom(function (atom) {
          if (atom.mask & mask) {
            atom.position.applyMatrix4(matrix);
          }
        });
      }
    }]);

    return ComplexFragmentEditor;
  }(ComplexEditor);

  var ComplexVisualEdit = {
    ComponentEditor: ComplexComponentEditor,
    FragmentEditor: ComplexFragmentEditor
  };

  function _createSuper$1v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1w(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$3 = chem.selectors;

  function lookupAndCreate(entityList, specs) {
    if (!Array.isArray(specs)) {
      specs = [specs];
    }

    var _specs = specs,
        _specs2 = slicedToArray(_specs, 2),
        id = _specs2[0],
        opts = _specs2[1];

    var Entity = entityList.get(id) || entityList.first;
    return new Entity(opts);
  }

  var ComplexVisual = /*#__PURE__*/function (_Visual) {
    inherits(ComplexVisual, _Visual);

    var _super = _createSuper$1v(ComplexVisual);

    function ComplexVisual(name, dataSource) {
      var _this;

      classCallCheck(this, ComplexVisual);

      _this = _super.call(this, name, dataSource);
      _this._complex = dataSource;
      /** @type {Representation[]} */

      _this._reprList = [];
      /** @type {?Representation} */

      _this._repr = null;
      _this._reprListChanged = true;
      _this._selectionBit = 0;
      _this._reprUsedBits = 0;
      _this._selectionCount = 0;
      _this._selectionGeometry = new THREE.Group();
      return _this;
    }

    createClass(ComplexVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._complex.getBoundaries();
      }
    }, {
      key: "release",
      value: function release() {
        if (this._selectionGeometry.parent) {
          this._selectionGeometry.remove(this._selectionGeometry);
        }

        Visual.prototype.release.call(this);
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getSelectionCount",
      value: function getSelectionCount() {
        return this._selectionCount;
      }
    }, {
      key: "getSelectionGeo",
      value: function getSelectionGeo() {
        return this._selectionGeometry;
      }
    }, {
      key: "getSelectionBit",
      value: function getSelectionBit() {
        return this._selectionBit;
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        return this._editor;
      }
    }, {
      key: "resetReps",
      value: function resetReps(reps) {
        // Create all necessary representations
        if (this._complex) {
          this._complex.clearAtomBits(~0);
        }

        this._reprListChanged = true;
        this._reprUsedBits = 0;
        this._reprList.length = reps.length;

        for (var i = 0, n = reps.length; i < n; ++i) {
          var rep = reps[i];
          var selector = void 0;
          var selectorString = void 0;

          if (typeof rep.selector === 'string') {
            selectorString = rep.selector;

            var _selectors$parse = selectors$3.parse(selectorString);

            selector = _selectors$parse.selector;
          } else if (typeof rep.selector === 'undefined') {
            selectorString = settings.now.presets["default"][0].selector;

            var _selectors$parse2 = selectors$3.parse(selectorString);

            selector = _selectors$parse2.selector;
          } else {
            selector = rep.selector;
            selectorString = selector.toString();
          }

          var mode = lookupAndCreate(modes, rep.mode);
          var colorer = lookupAndCreate(colorers, rep.colorer);
          var material = materials.get(rep.material) || materials.first;
          this._reprList[i] = new Representation(i, mode, colorer, selector);

          this._reprList[i].setMaterialPreset(material);

          this._reprList[i].selectorString = selectorString;

          if (this._complex) {
            this._complex.markAtoms(selector, 1 << i);
          }

          this._reprUsedBits |= 1 << i;
        }

        this._repr = reps.length > 0 ? this._reprList[0] : null;
        this._selectionBit = reps.length;
        this._reprUsedBits |= 1 << this._selectionBit; // selection uses one bit

        this._selectionCount = 0;

        if (this._complex) {
          this._complex.update();
        }
      }
      /**
       * Get number of representations created so far.
       * @returns {number} Number of reps.
       */

    }, {
      key: "repCount",
      value: function repCount() {
        return this._reprList.length;
      }
      /**
       * Get or set the current representation index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @returns {number} The current index.
       */

    }, {
      key: "repCurrent",
      value: function repCurrent(index) {
        if (index >= 0 && index < this._reprList.length) {
          this._repr = this._reprList[index];
        } else {
          index = this._reprList.indexOf(this._repr);
        }

        return index;
      }
      /**
       * Get or set representation by index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @param {object=} rep - Optional representation description.
       * @param {string=} rep.selector - Selector string.
       * @param {string=} rep.mode - Mode id.
       * @param {string=} rep.colorer - Colorer id.
       * @param {string=} rep.material - Material id.
       * @returns {Object} {desc, index, status} field desc contains rep description, index - index of correspondent rep,
       * status - one of three strings: 'created', 'changed', ''. 'created' means new rep was created during this function,
       * 'changed' - rep was changed during this function. '' - something else.
       */

    }, {
      key: "rep",
      value: function rep(index, _rep) {
        // if index is missing then it is the current
        if (!_rep && (index === undefined || index instanceof Object)) {
          _rep = index;
          index = this.repCurrent();
        } // fail if out of bounds


        if (index < 0 || index > this._reprList.length) {
          logger.error("Rep ".concat(index, " does not exist!"));
          return null;
        } // a special case of adding just after the end


        if (index === this._reprList.length) {
          var res = this.repAdd(_rep);
          logger.warn("Rep ".concat(index, " does not exist! New representation was created."));
          return {
            desc: res.desc,
            index: index,
            status: 'created'
          };
        } // gather description


        var target = this._reprList[index];
        var desc = {
          selector: target.selectorString,
          mode: target.mode.identify(),
          colorer: target.colorer.identify(),
          material: target.materialPreset.id
        }; // modification is requested

        if (_rep) {
          // modify
          var diff = target.change(_rep, this._complex, lookupAndCreate(modes, _rep.mode), lookupAndCreate(colorers, _rep.colorer)); // something was changed

          if (!___default['default'].isEmpty(diff)) {
            target.needsRebuild = true;

            for (var key in diff) {
              if (diff.hasOwnProperty(key)) {
                desc[key] = diff[key];
                logger.debug("rep[".concat(index, "].").concat(key, " changed to ").concat(diff[key]));
              }
            } // safety trick: lower resolution for surface modes


            if (diff.mode && target.mode.isSurface && (settings.now.resolution === 'ultra' || settings.now.resolution === 'high')) {
              logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
              settings.set('resolution', 'medium');
            }

            return {
              desc: desc,
              index: index,
              status: 'changed'
            };
          }
        }

        return {
          desc: desc,
          index: index,
          status: ''
        };
      }
      /**
       * Get representation (not just description) by index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @returns {?object} Representation.
       */

    }, {
      key: "repGet",
      value: function repGet(index) {
        // if index is missing then it is the current
        if (index === undefined || index instanceof Object) {
          index = this.repCurrent();
        } // fail if out of bounds


        if (index < 0 || index >= this._reprList.length) {
          return null;
        }

        return this._reprList[index];
      }
    }, {
      key: "_getFreeReprIdx",
      value: function _getFreeReprIdx() {
        var bits = this._reprUsedBits;

        for (var i = 0; i <= ComplexVisual.NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
          if ((bits & 1) === 0) {
            return i;
          }
        }

        return -1;
      }
      /**
       * Add new representation.
       * @param {object=} rep - Representation description.
       * @returns {Object} {desc, index} field desc contains added rep description, index - index of this rep.
       */

    }, {
      key: "repAdd",
      value: function repAdd(rep) {
        if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
          return null;
        }

        var newSelectionBit = this._getFreeReprIdx();

        if (newSelectionBit < 0) {
          return null; // no more slots for representations
        }

        var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit); // Fill in default values

        var def = settings.now.presets["default"][0];

        var desc = ___default['default'].merge({
          selector: def.selector,
          mode: def.mode,
          colorer: def.colorer,
          material: def.material
        }, rep);

        var selector = typeof desc.selector === 'string' ? selectors$3.parse(desc.selector).selector : desc.selector;
        var target = new Representation(this._selectionBit, lookupAndCreate(modes, desc.mode), lookupAndCreate(colorers, desc.colorer), selector);
        target.selectorString = selector.toString();
        target.setMaterialPreset(materials.get(desc.material));
        target.markAtoms(this._complex);

        this._reprList.push(target); // change selection bit


        this._selectionBit = newSelectionBit;
        this._reprUsedBits |= 1 << this._selectionBit; // restore selection using new selection bit

        this._complex.markAtoms(originalSelection, 1 << this._selectionBit);

        return {
          desc: desc,
          index: this._reprList.length - 1
        };
      }
      /**
       * Remove representation.
       * @param {number=} index - Zero-based representation index.
       */

    }, {
      key: "repRemove",
      value: function repRemove(index) {
        if (index === undefined) {
          index = this.repCurrent();
        } // catch out of bounds case


        var count = this._reprList.length;

        if (index < 0 || index >= count || count <= 1) {
          // do not allow to remove the single rep
          return;
        }

        var target = this._reprList[index];
        target.unmarkAtoms(this._complex);
        this._reprUsedBits &= ~(1 << target.index);

        this._reprList.splice(index, 1); // update current rep


        if (target === this._repr) {
          --count;
          index = index < count ? index : count - 1;
          this._repr = this._reprList[index];
        }

        this._reprListChanged = true;
      }
      /**
       * Hide representation.
       * @param {number} index - Zero-based representation index.
       * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
       */

    }, {
      key: "repHide",
      value: function repHide(index, hide) {
        if (hide === undefined) {
          hide = true;
        } // fail if out of bounds


        if (index < 0 || index >= this._reprList.length) {
          return;
        }

        var target = this._reprList[index];
        target.show(!hide);
      }
      /**
       * Select atoms with selector
       * @param {Selector} selector - selector
       * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
       */

    }, {
      key: "select",
      value: function select(selector, append) {
        if (append) {
          this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
        } else {
          this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
        }

        this._complex.updateStructuresMask();

        this.rebuildSelectionGeometry();
      }
    }, {
      key: "resetSelectionMask",
      value: function resetSelectionMask() {
        if (this._selectionCount !== 0) {
          this._selectionCount = 0;

          if (this._complex) {
            this._complex.clearAtomBits(1 << this._selectionBit);
          }
        }
      }
    }, {
      key: "updateSelectionMask",
      value: function updateSelectionMask(pickedObj) {
        var self = this;
        var atom = pickedObj.atom;
        var residue = pickedObj.residue,
            chain = pickedObj.chain,
            molecule = pickedObj.molecule;
        var setMask = 1 << this._selectionBit;
        var clearMask = ~setMask;

        if (atom) {
          residue = atom.residue;
          chain = residue._chain;
          molecule = residue._molecule;

          if (atom.mask & setMask) {
            atom.mask &= clearMask;
            residue._mask &= clearMask;
            chain._mask &= clearMask;

            if (molecule) {
              molecule.mask &= clearMask;
            }

            this._selectionCount--;
          } else {
            atom.mask |= setMask;
            this._selectionCount++; // select residue if all atoms in it are selected

            residue.collectMask(); // select chain and molecule if all residues in it are selected

            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (residue) {
          chain = residue._chain;
          molecule = residue._molecule;

          if (residue._mask & setMask) {
            residue._mask &= clearMask;
            chain._mask &= clearMask;
            residue.forEachAtom(function (a) {
              if (a.mask & setMask) {
                a.mask &= clearMask;
                self._selectionCount--;
              }
            });
          } else {
            residue._mask |= setMask;
            residue.forEachAtom(function (a) {
              if (!(a.mask & setMask)) {
                a.mask |= setMask;
                self._selectionCount++;
              }
            }); // select chain and molecule if all residues in it are selected

            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (chain || molecule) {
          var obj = chain || molecule;

          if (obj._mask & setMask) {
            obj._mask &= clearMask;
            obj.forEachResidue(function (r) {
              if (r._mask & setMask) {
                r._mask &= clearMask;
                r.forEachAtom(function (a) {
                  if (a.mask & setMask) {
                    a.mask &= clearMask;
                    self._selectionCount--;
                  }
                });
                r._mask &= clearMask;
              }
            });
          } else {
            obj._mask |= setMask;
            obj.forEachResidue(function (r) {
              if (!(r._mask & setMask)) {
                r._mask |= setMask;
                r.forEachAtom(function (a) {
                  if (!(a.mask & setMask)) {
                    a.mask |= setMask;
                    self._selectionCount++;
                  }
                });
                var otherObj = chain ? r.getMolecule() : r.getChain();

                if (otherObj) {
                  otherObj.collectMask();
                }
              }
            });
          }
        } else {
          this.resetSelectionMask();
        }
      }
    }, {
      key: "expandSelection",
      value: function expandSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31; // mark atoms to add

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._right.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._left.mask |= tmpMask;
          }
        }); // select marked atoms


        var deselectionMask = ~tmpMask;

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask = atom.mask & deselectionMask | selectionMask;
            ++self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "shrinkSelection",
      value: function shrinkSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31; // mark atoms neighbouring to unselected ones

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._left.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._right.mask |= tmpMask;
          }
        }); // mark hanging atoms


        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask && atom.bonds.length === 1) {
            atom.mask |= tmpMask;
          }
        }); // deselect marked atoms


        var deselectionMask = ~(selectionMask | tmpMask);

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask &= deselectionMask;
            --self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "getSelectedComponent",
      value: function getSelectedComponent() {
        var selectionMask = 1 << this._selectionBit;
        var component = null;
        var multiple = false; // find which component is selected (exclusively)

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask) {
            if (component === null) {
              component = atom.residue._component;
            } else if (component !== atom.residue._component) {
              multiple = true;
            }
          }
        });

        return multiple ? null : component;
      }
    }, {
      key: "getSelectionCenter",
      value: function getSelectionCenter(center, includesAtom, selRule) {
        center.set(0.0, 0.0, 0.0);
        var count = 0;

        this._complex.forEachAtom(function (atom) {
          if (includesAtom(atom, selRule)) {
            center.add(atom.position);
            count++;
          }
        });

        if (count === 0) {
          return false;
        }

        center.divideScalar(count);
        center.applyMatrix4(this.matrix);
        return true;
      }
    }, {
      key: "needsRebuild",
      value: function needsRebuild() {
        if (this._reprListChanged) {
          return true;
        }

        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          var repr = reprList[i];

          if (repr.needsRebuild) {
            return true;
          }
        }

        return false;
      }
      /**
       * Rebuild molecule geometry asynchronously.
       */

    }, {
      key: "rebuild",
      value: function rebuild() {
        var self = this; // Destroy current geometry

        gfxutils.clearTree(this);
        return new Promise(function (resolve) {
          // Nothing to do?
          var complex = self._complex;

          if (!complex) {
            resolve();
            return;
          }

          var errorOccured = false;
          setTimeout(function () {
            console.time('build');
            var reprList = self._reprList;
            var palette = palettes.get(settings.now.palette) || palettes.first;
            var hasGeometry = false;

            for (var i = 0, n = reprList.length; i < n; ++i) {
              var repr = reprList[i];
              repr.colorer.palette = palette;

              if (repr.needsRebuild) {
                repr.reset();

                try {
                  repr.buildGeometry(complex);
                } catch (e) {
                  if (e instanceof utils.OutOfMemoryError) {
                    repr.needsRebuild = false;
                    repr.reset();
                    logger.error("Not enough memory to build geometry for representation ".concat(repr.index + 1));
                    errorOccured = true;
                  } else {
                    throw e;
                  }
                }
              }

              hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);

              if (repr.geo) {
                self.add(repr.geo);
              }
            }

            self._reprListChanged = false;
            console.timeEnd('build');
            resolve();
          }, 10);
        });
      }
    }, {
      key: "setNeedsRebuild",
      value: function setNeedsRebuild() {
        // invalidate all representations
        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          reprList[i].needsRebuild = true;
        }
      }
    }, {
      key: "rebuildSelectionGeometry",
      value: function rebuildSelectionGeometry() {
        var mask = 1 << this._selectionBit;
        gfxutils.clearTree(this._selectionGeometry);

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var repr = this._reprList[i];
          var sg = repr.buildSelectionGeometry(mask);

          if (!sg) {
            continue;
          }

          this._selectionGeometry.add(sg);

          for (var j = 0; j < sg.children.length; j++) {
            var m = sg.children[j]; // copy component transform (that's not applied yet)
            // TODO make this code obsolete, accessing editor is bad

            if (this._editor && this._editor._componentTransforms) {
              var t = this._editor._componentTransforms[m._component._index];

              if (t) {
                m.position.copy(t.position);
                m.quaternion.copy(t.quaternion);
              }
            }
          }

          gfxutils.applySelectionMaterial(sg);
        }
      }
    }, {
      key: "_buildSelectorFromSortedLists",
      value: function _buildSelectorFromSortedLists(atoms, residues, chains) {
        var complex = this._complex;

        function optimizeList(list) {
          var result = [];
          var k = 0;
          var first = NaN;
          var last = NaN;

          for (var i = 0, n = list.length; i < n; ++i) {
            var value = list[i];

            if (value === last + 1) {
              last = value;
            } else {
              if (!Number.isNaN(first)) {
                result[k++] = new selectors$3.Range(first, last);
              }

              first = last = value;
            }
          }

          if (!Number.isNaN(first)) {
            result[k] = new selectors$3.Range(first, last);
          }

          return result;
        }

        var expression = null;

        if (chains.length === complex._chains.length) {
          expression = selectors$3.all();
        } else {
          var selector;

          if (chains.length > 0) {
            selector = selectors$3.chain(chains);
            expression = expression ? selectors$3.or(expression, selector) : selector; // NOSONAR
          }

          if (Object.keys(residues).length > 0) {
            for (var ch in residues) {
              if (residues.hasOwnProperty(ch)) {
                selector = selectors$3.and(selectors$3.chain(ch), selectors$3.residx(optimizeList(residues[ch])));
                expression = expression ? selectors$3.or(expression, selector) : selector;
              }
            }
          }

          if (atoms.length > 0) {
            selector = selectors$3.serial(optimizeList(atoms));
            expression = expression ? selectors$3.or(expression, selector) : selector;
          }

          if (!expression) {
            expression = selectors$3.none();
          }
        }

        return expression;
      }
    }, {
      key: "buildSelectorFromMask",
      value: function buildSelectorFromMask(mask) {
        var complex = this._complex;
        var chains = [];
        var residues = {};
        var atoms = [];
        complex.forEachChain(function (chain) {
          if (chain._mask & mask) {
            chains.push(chain._name);
          }
        });
        complex.forEachResidue(function (residue) {
          if (residue._mask & mask && !(residue._chain._mask & mask)) {
            var c = residue._chain._name;

            if (!(c in residues)) {
              residues[c] = [residue._index];
            } else {
              residues[c].push(residue._index);
            }
          }
        });
        complex.forEachAtom(function (atom) {
          if (atom.mask & mask && !(atom.residue._mask & mask)) {
            atoms.push(atom.serial);
          }
        });
        return this._buildSelectorFromSortedLists(atoms, residues, chains);
      }
    }, {
      key: "forSelectedResidues",
      value: function forSelectedResidues(process) {
        var selectionMask = 1 << this._selectionBit;

        this._complex.forEachResidue(function (residue) {
          if (residue._mask & selectionMask) {
            process(residue);
          }
        });
      }
    }, {
      key: "beginComponentEdit",
      value: function beginComponentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.ComponentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      }
    }, {
      key: "beginFragmentEdit",
      value: function beginFragmentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.FragmentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      } // should only be called by editors

    }, {
      key: "finalizeEdit",
      value: function finalizeEdit() {
        this._editor = null;
      }
    }, {
      key: "setMaterialValues",
      value: function setMaterialValues(values) {
        var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setValues(values);

          if (needTraverse) {
            rep.geo.traverse(function (object) {
              if (object instanceof THREE.Mesh) {
                object.material.setValues(values);

                if (process !== undefined) {
                  process(object);
                }

                object.material.needsUpdate = true;
              }
            });
          }
        }
      }
    }, {
      key: "setUberOptions",
      value: function setUberOptions(values) {
        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setUberOptions(values);
        }
      }
      /**
       * Build selector that contains all atoms within given distance from group of atoms
       * @param {Selector} selector - selector describing source group of atoms
       * @param {number} radius - distance
       * @returns {Selector} selector describing result group of atoms
       */

    }, {
      key: "within",
      value: function within(selector, radius) {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return false;
        } // mark atoms of the group as selected


        var selectionMask = 1 << this._selectionBit;

        this._complex.markAtoms(selector, selectionMask); // mark all atoms within distance as selected


        if (vw) {
          vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), function (atom) {
            atom.mask |= selectionMask;
          });
        } // update selection count


        this._selectionCount = this._complex.countAtomsByMask(selectionMask); // update secondary structure mask

        this._complex.updateStructuresMask();

        return this.buildSelectorFromMask(selectionMask);
      }
    }]);

    return ComplexVisual;
  }(Visual); // 32 bits = 30 bits for reps + 1 for selection + 1 for selection expansion


  ComplexVisual.NUM_REPRESENTATION_BITS = 30;

  var vertexVolumeFaces = "varying vec3 pos;\n\nvoid main() {\n  // we're assuming local position is in [-0.5, 0.5]\n  // we need to offset it to be represented in RGB\n  pos = position.xyz + 0.5;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";

  var fragmentVolumeFaces = "varying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(pos, 0.5);\n}";

  var vertexVolume = "varying vec4 screenSpacePos;\n\nvoid main() {\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = screenSpacePos;\n}";

  var fragmentVolume = "uniform mat4 projectionMatrix;\n\n// 3D volume texture\nuniform vec3 volumeDim;    // volume dimensions, pixels\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\n\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\n\nuniform vec3 _isoLevel0;\nuniform float _flipV;\nuniform sampler2D _BFLeft;\nuniform sampler2D _BFRight;\nuniform sampler2D _FFLeft;\nuniform sampler2D _FFRight;\nuniform sampler2D _WFFLeft;\nuniform sampler2D _WFFRight;\n\nvarying vec4 screenSpacePos;\n\n#define NO_COLOR vec4(0., 0., 0., 0.)\n\nvec4 sample3DTexture(vec3 texCoord) {\n  // a pair of Z slices is determined by nearest slice border\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\n\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\n\n  // calculate coords in tile texture for both slices\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\n\n  // bilinear filtering\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\n  return mix(colorSlice1, colorSlice2, weightSlice2);\n}\n\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\n  vec3 textCoord = boxCoord;\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\n\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\n    return NO_COLOR;\n\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\n\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\n    return NO_COLOR;\n\n  return sample3DTexture(textCoord);\n}\n\nfloat CalcColor(vec3 iter, vec3 dir) {\n  float d = 1. / 128.;\n  vec3 dx = vec3(d, 0.0, 0.0);\n  vec3 dy = vec3(0.0, d, 0.0);\n  vec3 dz = vec3(0.0, 0.0, d);\n\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\n  vec3 coordInc = mix(\n    vec3(\n      sample3DTextureInclined(iter + dx).x,\n      sample3DTextureInclined(iter + dy).x,\n      sample3DTextureInclined(iter + dz).x\n    ),\n    vec3(0. ,0. , 0.),\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\n  );\n\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\n  vec3 coordDec = mix(\n    vec3(0. ,0. , 0.),\n    vec3(\n      sample3DTextureInclined(iter - dx).x,\n      sample3DTextureInclined(iter - dy).x,\n      sample3DTextureInclined(iter - dz).x\n    ),\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\n  );\n\n  vec3 N = normalize(coordInc - coordDec);\n  float dif = max(0.0, dot(N, dir));\n  return dif;\n}\n\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\n  for (int i = 0; i < 5; i++) {\n    vec3 iterator = 0.5 * (left + right);\n    float vol = sample3DTextureInclined(iterator).r;\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\n      right = iterator;\n    else\n      left = iterator;\n  }\n  return 0.5 * (left + right);\n}\n\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\n  for (int j = 0; j < 5; j++) {\n    vec3 iterator = 0.5 * (left + right);\n    float vol = sample3DTextureInclined(iterator).r;\n    if (vol < tr)\n      right = iterator;\n    else\n      left = iterator;\n  }\n  return 0.5 * (left + right);\n}\n\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\n  vec3 step = stepSize * dir, iterator = start, left, right;\n  vec4 acc = NO_COLOR;\n\n  for (int i = 0; i < STEPS_COUNT; i++) {\n    iterator = iterator + step;\n    vol = sample3DTextureInclined(iterator).r;\n    if (length(iterator - back) <= stepSize || (vol > tr))\n      break;\n  }\n\n  if (vol > tr)\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\n\n  return acc;\n}\n\nfloat easeOut(float x0, float x1, float x) {\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\n  return 1.0 - (1.0 - t) * (1.0 - t);\n}\n\nfloat easeIn(float x0, float x1, float x) {\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\n  return t * t;\n}\n\nvec3 GetColSimple(float vol) {\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\n}\n\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\n  vec4 acc = NO_COLOR, iso;\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\n  vec3 step, col, colOld, right;\n  float tr0 = _isoLevel0.x;\n  float dif, r, kd, finish;\n  int count = 0, stopMol = 0;\n\n  for (int k = 0; k < 3; k++) {\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\n    kd = 140. * tr0 * stepSize;\n    r = 1. - kd;\n    step = stepSize * dir;\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\n      break;\n    iterator = iso.xyz;\n    dif = 1.;// CalcColor(iterator, dir);\n    colOld = GetColSimple(tr0);\n    curStepSize = stepSize;\n    for (int i = 0; i < STEPS_COUNT; i++) {\n      iterator = iterator + step;\n      molD = length(iterator - start);\n      vol = sample3DTextureInclined(iterator).r;\n      finish = distance(iterator, back) - stepSize;\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\n        break;\n      alpha = (1. - r);\n      col = GetColSimple(vol);\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\n      vec3 colMid = GetColSimple(vol);\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\n      colOld = col;\n    } // for i\n\n    if (finish < 0.0 || sumAlpha > 0.97)\n      break;\n\n    if (molD > molDist) {\n      curStepSize = stepSize - (molD - molDist);\n      right = iterator - (molD - molDist) * dir;\n      vol = sample3DTextureInclined(right).r;\n    } else {\n      vec3 left = iterator - step;\n      right = CorrectIso(left, iterator, tr0);\n      curStepSize = distance(left, right);\n      vol = tr0;\n    }\n\n    alpha = (1. - r) * curStepSize / stepSize;\n    dif = 1.;// CalcColor(right, dir);\n    col = GetColSimple(vol);\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\n    vec3 colMid = GetColSimple(vol);\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\n\n    if (molD > molDist)\n      break;\n  } // for k\n  acc.rgb = 1. * sumColor / sumAlpha;\n  acc.a = sumAlpha;\n  return acc;\n}\n\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\n  float stepSize = 1.0 / float(STEPS_COUNT);\n  float len = length(back - start);\n  vec3 step = stepSize * dir;\n  vec3 iterator = start;\n  float acc = 0.0;\n\n  for (int i = 0; i < STEPS_COUNT; i++) {\n    if (float(i) * stepSize > len)\n      break;\n    iterator = iterator + step;\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\n  }\n\n  return vec4(1.,1.,1., acc);\n}\n\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\n  vec4 col = NO_COLOR;\n\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\n    float dif =  CalcColor(tst.xyz, dir);\n    dif = 0.9 * dif * dif;\n    col = vec4(dif, dif, dif, 1);\n  }\n  return col;\n}\n\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\n  return sample3DTexture(start);\n}\n\nvoid main() {\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\n\n  if (_flipV > 0.0) {\n    tc.y = 1.0 - tc.y;\n  }\n\n  vec3 start;\n  vec3 back;\n  vec3 molBack;\n  if (projectionMatrix[0][2] < 0.0) {\n    start = texture2D(_FFLeft, tc.xy).xyz;\n    back = texture2D(_BFLeft, tc.xy).xyz;\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\n  } else {\n    start = texture2D(_FFRight, tc.xy).xyz;\n    back = texture2D(_BFRight, tc.xy).xyz;\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\n  }\n\n  vec3 dir = normalize(back - start);\n\n  float molDist = 2.0;\n  if (length(molBack) > 0.001) {\n    molDist = distance(start, molBack);\n  }\n\n  #ifdef ISO_MODE\n    gl_FragColor = IsoRender(start, back, molDist, dir);\n  #else\n    gl_FragColor = VolRender(start, back, molDist, dir);\n  #endif\n}\n";

  var vertexFarPlane = "varying vec4 volPos;\nuniform float aspectRatio;\nuniform float farZ;\nuniform float tanHalfFOV;\nuniform mat4  matWorld2Volume;\n\nvoid main() {\n  // rescale plane to fill in the whole far plane area seen from camera\n  vec3 pos = position.xyz;\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\n  pos.y = pos.y * tanHalfFOV * farZ;\n  // common transformation\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  // calc pos in volume CS\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\n  // we're assuming local position is in [-0.5, 0.5]\n  // we need to offset it to be represented in RGB\n  volPos = volPos + 0.5;\n  volPos.w = 0.5;\n}\n";

  var fragmentFarPlane = "varying vec4 volPos;\n\nvoid main() {\n  gl_FragColor = volPos;\n}";

  function _createSuper$1w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1x(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var volumeUniforms = THREE.UniformsUtils.merge([{
    volumeDim: {
      type: 'v3',
      value: new THREE.Vector3(512, 512, 512)
    },
    tileTex: {
      type: 't',
      value: null
    },
    tileTexSize: {
      type: 'v2',
      value: new THREE.Vector2(512, 512)
    },
    tileStride: {
      type: 'v2',
      value: new THREE.Vector2(512, 512)
    },
    boxAngles: {
      type: 'v3',
      value: new THREE.Vector3(1, 1, 1)
    },
    delta: {
      type: 'v3',
      value: new THREE.Vector3(0, 0, 0)
    },
    _isoLevel0: {
      type: 'v2',
      value: new THREE.Vector3(0.5, 0.75, 1.0)
    },
    _flipV: {
      type: 'f',
      value: 0.0
    },
    _BFLeft: {
      type: 't',
      value: null
    },
    _BFRight: {
      type: 't',
      value: null
    },
    _FFLeft: {
      type: 't',
      value: null
    },
    _FFRight: {
      type: 't',
      value: null
    },
    _WFFLeft: {
      type: 't',
      value: null
    },
    _WFFRight: {
      type: 't',
      value: null
    }
  }]);

  function overrideUniforms(params, defUniforms) {
    var uniforms = THREE.UniformsUtils.clone(defUniforms);

    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p];
      }
    }

    return uniforms;
  }

  function facesPosMaterialParams(params, sideType) {
    return {
      uniforms: overrideUniforms(params, {}),
      vertexShader: vertexVolumeFaces,
      fragmentShader: fragmentVolumeFaces,
      transparent: false,
      depthTest: false,
      depthWrite: false,
      side: sideType
    };
  }

  var BackFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {
    inherits(BackFacePosMaterial, _THREE$ShaderMaterial);

    var _super = _createSuper$1w(BackFacePosMaterial);

    function BackFacePosMaterial(params) {
      classCallCheck(this, BackFacePosMaterial);

      var backFaceParams = facesPosMaterialParams(params, THREE.BackSide);
      return _super.call(this, backFaceParams);
    }

    return BackFacePosMaterial;
  }(THREE.ShaderMaterial);

  var ShaderParams = function ShaderParams(params, uniforms, vertexShader, fragmentShader) {
    classCallCheck(this, ShaderParams);

    this.uniforms = overrideUniforms(params, uniforms);
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.transparent = false;
    this.depthTest = false;
    this.depthWrite = false;
    this.side = THREE.FrontSide;
  };

  var BackFacePosMaterialFarPlane = /*#__PURE__*/function (_THREE$ShaderMaterial2) {
    inherits(BackFacePosMaterialFarPlane, _THREE$ShaderMaterial2);

    var _super2 = _createSuper$1w(BackFacePosMaterialFarPlane);

    function BackFacePosMaterialFarPlane(params) {
      classCallCheck(this, BackFacePosMaterialFarPlane);

      var matUniforms = THREE.UniformsUtils.merge([{
        aspectRatio: {
          type: 'f',
          value: 0.0
        },
        farZ: {
          type: 'f',
          value: 0.0
        },
        tanHalfFOV: {
          type: 'f',
          value: 0.0
        },
        matWorld2Volume: {
          type: '4fv',
          value: new THREE.Matrix4()
        }
      }]);
      var shaderParams = new ShaderParams(params, matUniforms, vertexFarPlane, fragmentFarPlane);
      return _super2.call(this, shaderParams);
    }

    return BackFacePosMaterialFarPlane;
  }(THREE.ShaderMaterial);

  var FrontFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial3) {
    inherits(FrontFacePosMaterial, _THREE$ShaderMaterial3);

    var _super3 = _createSuper$1w(FrontFacePosMaterial);

    function FrontFacePosMaterial(params) {
      classCallCheck(this, FrontFacePosMaterial);

      var frontFaceParams = facesPosMaterialParams(params, THREE.FrontSide);
      return _super3.call(this, frontFaceParams);
    }

    return FrontFacePosMaterial;
  }(THREE.ShaderMaterial);

  var VolumeMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial4) {
    inherits(VolumeMaterial, _THREE$ShaderMaterial4);

    var _super4 = _createSuper$1w(VolumeMaterial);

    function VolumeMaterial(params) {
      var _this;

      classCallCheck(this, VolumeMaterial);

      var shaderParams = new ShaderParams(params, volumeUniforms, vertexVolume, fragmentVolume);
      shaderParams.transparent = true;
      shaderParams.depthTest = true;
      _this = _super4.call(this, shaderParams);

      _this.updateDefines();

      return _this;
    }

    createClass(VolumeMaterial, [{
      key: "updateDefines",
      value: function updateDefines() {
        this.defines = {
          ISO_MODE: settings.now.modes.VD.isoMode,
          STEPS_COUNT: settings.now.modes.VD.polyComplexity[settings.now.resolution] * 100
        };
        this.needsUpdate = true;
      }
    }]);

    return VolumeMaterial;
  }(THREE.ShaderMaterial);

  var VolumeMaterial$1 = {
    BackFacePosMaterial: BackFacePosMaterial,
    BackFacePosMaterialFarPlane: BackFacePosMaterialFarPlane,
    FrontFacePosMaterial: FrontFacePosMaterial,
    VolumeMaterial: VolumeMaterial
  };

  function _createSuper$1x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeMesh = /*#__PURE__*/function (_THREE$Mesh) {
    inherits(VolumeMesh, _THREE$Mesh);

    var _super = _createSuper$1x(VolumeMesh);

    // data for noise filter
    function VolumeMesh() {
      var _this;

      classCallCheck(this, VolumeMesh);

      var geo = new THREE.BufferGeometry();
      _this = _super.call(this, geo);

      defineProperty(assertThisInitialized(_this), "volumeInfo", {});

      _this.clipPlane = new THREE.Plane();
      var size = new THREE.Vector3(0.5, 0.5, 0.5);
      _this.size = size;
      _this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
      _this.faces = [{
        indices: [],
        norm: new THREE.Vector3(0, 0, -1)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 0, 1)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, -1, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 1, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(-1, 0, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(1, 0, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 0, 0)
      }];
      _this.vertices = [new THREE.Vector3(-size.x, -size.y, -size.z), new THREE.Vector3(-size.x, size.y, -size.z), new THREE.Vector3(size.x, -size.y, -size.z), new THREE.Vector3(size.x, size.y, -size.z), new THREE.Vector3(-size.x, -size.y, size.z), new THREE.Vector3(-size.x, size.y, size.z), new THREE.Vector3(size.x, -size.y, size.z), new THREE.Vector3(size.x, size.y, size.z), new THREE.Vector3(0.0, 0.0, 0.0), // Placeholder for section
      new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0)];
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(_this.vertices.length * 3), 3));
      _this.name = 'VolumeMesh';
      return _this;
    }

    createClass(VolumeMesh, [{
      key: "_updateVertices",
      value: function _updateVertices() {
        // Algorithm:
        // 1. Get plane parameters
        // 2. Compute culling flags for all vertices
        // 3. If intersection occurs => compute from 3 to 6 intersection points
        var corners = VolumeMesh._corners;
        var edges = VolumeMesh._edges;
        var edgeIntersections = VolumeMesh._edgeIntersections;
        var i;
        var norm = this.clipPlane.normal;
        var D = this.clipPlane.constant;
        var vert = this.vertices;
        var size = this.size;
        var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
        var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        var curEdge = new THREE.Vector3();
        var curEdgeInter = null;

        function CheckX() {
          if (norm.x === 0) return 0;
          var x = -(norm.dot(curEdge) + D) / norm.x;

          if (-size.x <= x && x <= size.x) {
            curEdgeInter.set(x, curEdge.y, curEdge.z);
            if (x === size.x) return 2;
            if (x === -size.x) return -2;
            return 1;
          }

          return 0;
        }

        function CheckY() {
          if (norm.y === 0) return 0;
          var y = -(norm.dot(curEdge) + D) / norm.y;

          if (-size.y <= y && y <= size.y) {
            curEdgeInter.set(curEdge.x, y, curEdge.z);
            if (y === size.y) return 2;
            if (y === -size.y) return -2;
            return 1;
          }

          return 0;
        }

        function CheckZ() {
          if (norm.z === 0) return 0;
          var z = -(norm.dot(curEdge) + D) / norm.z;

          if (-size.z <= z && z <= size.z) {
            curEdgeInter.set(curEdge.x, curEdge.y, z);
            if (z === size.z) return 2;
            if (z === -size.z) return -2;
            return 1;
          }

          return 0;
        } // for each edge


        for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
          var curEdgeSource = edges[curEdgeIdx];
          curEdgeInter = edgeIntersections[curEdgeIdx];
          curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
          curEdge.multiply(size); // calculate intersection point

          var flag = 0;
          if (curEdgeSource[2] === 0) flag = CheckX();
          if (curEdgeSource[3] === 0) flag = CheckY();
          if (curEdgeSource[4] === 0) flag = CheckZ(); // mark corresponding corner (if plane cuts through one)

          if (flag === -2) {
            cornerMark[curEdgeSource[0]] = 1;
          } else if (flag === 2) {
            cornerMark[curEdgeSource[1]] = 1;
          } else if (flag === 0) {
            // edge is not intersected by the plane (doesn't produce a vertex)
            edgeMark[curEdgeIdx] = 0;
          }
        }

        var face = {
          indices: [],
          norm: norm.clone().negate()
        };
        var nextVertex = 8; // for each marked corner

        for (i = 0; i < 8; ++i) {
          if (cornerMark[i] === 1) {
            // add corner as vertex to the face
            vert[nextVertex].set(corners[i][0], corners[i][1], corners[i][2]).multiply(size);
            face.indices.push(nextVertex++); // skip adjacent edges

            edgeMark[corners[i][3]] = 0;
            edgeMark[corners[i][4]] = 0;
            edgeMark[corners[i][5]] = 0;
          }
        } // for each edge that has internal intersection


        for (i = 0; i < 12; ++i) {
          if (edgeMark[i] === 1) {
            // add intersection point as vertex to the face
            vert[nextVertex].copy(edgeIntersections[i]);
            face.indices.push(nextVertex++);
          }
        }

        this.faces[6] = face;
        var diff = new THREE.Vector3();
        var coplanarPoint = new THREE.Vector3();
        this.clipPlane.coplanarPoint(coplanarPoint);

        for (i = 0; i < vert.length; ++i) {
          this.cullFlag[i] = false;

          if (i < 8) {
            // corners should be culled by clipping plane
            diff.subVectors(vert[i], coplanarPoint);
            this.cullFlag[i] = norm.dot(diff) >= 0.0;
          } else if (i < 8 + face.indices.length) {
            // cross section vertices don't get culled
            this.cullFlag[i] = true;
          }
        } // write data to vertex buffer


        var positions = this.geometry.getAttribute('position');
        var idx = 0;

        for (i = 0; i < vert.length; ++i) {
          positions.array[idx++] = vert[i].x;
          positions.array[idx++] = vert[i].y;
          positions.array[idx++] = vert[i].z;
        }

        positions.needsUpdate = true;
      }
    }, {
      key: "_collectVertices",
      value: function _collectVertices(face, filter) {
        var i;
        var vert = this.vertices;
        face.indices = [];

        for (i = 0; i < vert.length; ++i) {
          if (this.cullFlag[i] && filter(vert[i])) {
            face.indices.push(i);
          }
        }
      }
    }, {
      key: "_sortIndices",
      value: function _sortIndices(face, right) {
        var i;
        var j;
        var vert = this.vertices;
        var angle = [];
        var dir = new THREE.Vector3();

        for (i = 1; i < face.indices.length; ++i) {
          dir.subVectors(vert[face.indices[i]], vert[face.indices[0]]);
          dir.normalize();
          dir.cross(right);
          dir.negate();
          angle[i] = face.norm.dot(dir);
        } // Exchange sort


        for (i = 1; i < face.indices.length - 1; ++i) {
          for (j = i + 1; j < face.indices.length; ++j) {
            if (angle[j] < angle[i]) {
              // swap
              var t = angle[i];
              angle[i] = angle[j];
              angle[j] = t;
              t = face.indices[i];
              face.indices[i] = face.indices[j];
              face.indices[j] = t;
            }
          }
        }
      }
    }, {
      key: "_updateIndices",
      value: function _updateIndices() {
        // Algorithm:
        // 1. Get plane vertices (from 3 to 6 vertices)
        // 2. Get "right" vector in plane
        // 3. Sort vertices using Graham-like method
        // 4. Create indices
        var i;
        var faceIdx;
        var face;
        var vert = this.vertices;
        var size = this.size;

        this._collectVertices(this.faces[0], function (vertex) {
          return vertex.z === -size.z;
        });

        this._collectVertices(this.faces[1], function (vertex) {
          return vertex.z === size.z;
        });

        this._collectVertices(this.faces[2], function (vertex) {
          return vertex.y === -size.y;
        });

        this._collectVertices(this.faces[3], function (vertex) {
          return vertex.y === size.y;
        });

        this._collectVertices(this.faces[4], function (vertex) {
          return vertex.x === -size.x;
        });

        this._collectVertices(this.faces[5], function (vertex) {
          return vertex.x === size.x;
        });

        var vCenter = new THREE.Vector3();
        var vRight = new THREE.Vector3();
        var vDir = new THREE.Vector3();

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];
          if (face.indices.length === 0) continue;
          vCenter.set(0, 0, 0);

          for (i = 0; i < face.indices.length; ++i) {
            vCenter.add(vert[face.indices[i]]);
          }

          vCenter.multiplyScalar(1.0 / face.indices.length);
          vRight.subVectors(vert[face.indices[0]], vCenter);
          vRight.normalize();
          var rightProj = [];

          for (i = 0; i < face.indices.length; ++i) {
            vDir.subVectors(vert[face.indices[i]], vCenter);
            rightProj[i] = vDir.dot(vRight);
          }

          for (i = 1; i < face.indices.length; ++i) {
            if (rightProj[i] < rightProj[0]) {
              // swap
              var t = rightProj[0];
              rightProj[0] = rightProj[i];
              rightProj[i] = t;

              var _face$indices = slicedToArray(face.indices, 1);

              t = _face$indices[0];
              face.indices[0] = face.indices[i];
              face.indices[i] = t;
            }
          }

          this._sortIndices(face, vRight);
        }

        var numIndices = 0;

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          if (face.indices.length >= 3) {
            numIndices += 3 * (face.indices.length - 2);
          }
        }

        var offset = 0;
        var indices = new Uint16Array(numIndices);

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          for (i = 0; i < face.indices.length - 2; ++i) {
            indices[offset] = face.indices[0]; // eslint-disable-line prefer-destructuring

            indices[offset + 1] = face.indices[i + 1];
            indices[offset + 2] = face.indices[i + 2];
            offset += 3;
          }
        }

        this.geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      }
    }, {
      key: "setDataSource",
      value: function setDataSource(dataSource) {
        var vm = new VolumeMaterial$1.VolumeMaterial();
        var dim = dataSource.getDimensions();
        var stride = dataSource.getTiledTextureStride();
        var texture = dataSource.buildTiledTexture();
        var bbox = dataSource.getBox();
        vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
        vm.uniforms.tileTex.value = texture;
        vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
        vm.uniforms.tileStride.value.set(stride[0], stride[1]);
        Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
        var volInfo = this.volumeInfo;
        vm.uniforms.delta.value.copy(volInfo.delta);
        vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
        this.material = vm;
        bbox.getSize(this.scale);
        bbox.getCenter(this.position);
      }
    }, {
      key: "_updateIsoLevel",
      value: function _updateIsoLevel() {
        var _settings$now$modes$V = settings.now.modes.VD,
            kSigma = _settings$now$modes$V.kSigma,
            kSigmaMed = _settings$now$modes$V.kSigmaMed,
            kSigmaMax = _settings$now$modes$V.kSigmaMax;
        var volInfo = this.volumeInfo;
        var mean = volInfo.dmean - volInfo.dmin;
        var span = volInfo.dmax - volInfo.dmin;

        var level = function level(k) {
          return (mean + k * volInfo.sd) / span;
        };

        this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
      }
    }, {
      key: "rebuild",
      value: function rebuild(camera) {
        var nearClipPlaneOffset = VolumeMesh._nearClipPlaneOffset;
        var pos = VolumeMesh._pos;
        var norm = VolumeMesh._norm;
        var norm4D = VolumeMesh._norm4D;
        var matrixWorldToLocal = VolumeMesh._matrixWorldToLocal;
        var clipPlane = VolumeMesh._clipPlane;

        this._updateIsoLevel(); // get clip plane in local space


        camera.getWorldDirection(norm);
        camera.getWorldPosition(pos);
        pos.addScaledVector(norm, camera.near + nearClipPlaneOffset); // transform pos to local CS

        matrixWorldToLocal.copy(this.matrixWorld).invert();
        pos.applyMatrix4(matrixWorldToLocal); // transform norm to local CS

        norm4D.set(norm.x, norm.y, norm.z, 0.0); // NOTE: use homogeneous norm for proper transformation

        norm4D.applyMatrix4(matrixWorldToLocal);
        norm.copy(norm4D);
        norm.normalize();
        clipPlane.setFromNormalAndCoplanarPoint(norm, pos);

        if (!this.clipPlane.equals(clipPlane)) {
          this.clipPlane = clipPlane.clone();

          this._updateVertices();

          this._updateIndices();
        }
      }
    }]);

    return VolumeMesh;
  }(THREE.Mesh);

  defineProperty(VolumeMesh, "_corners", [// x, y, z, edge1, edge2, edge3
  [-1, -1, -1, 0, 4, 8], [1, -1, -1, 0, 5, 9], [1, 1, -1, 1, 5, 10], [-1, 1, -1, 1, 4, 11], [-1, -1, 1, 2, 6, 8], [1, -1, 1, 2, 7, 9], [1, 1, 1, 3, 7, 10], [-1, 1, 1, 3, 6, 11]]);

  defineProperty(VolumeMesh, "_edges", [// corner1, corner2, center_x, center_y, center_z
  [0, 1, 0, -1, -1], [2, 3, 0, 1, -1], [4, 5, 0, -1, 1], [6, 7, 0, 1, 1], [0, 3, -1, 0, -1], [1, 2, 1, 0, -1], [4, 7, -1, 0, 1], [5, 6, 1, 0, 1], [0, 4, -1, -1, 0], [1, 5, 1, -1, 0], [2, 6, -1, 1, 0], [3, 7, 1, 1, 0]]);

  defineProperty(VolumeMesh, "_edgeIntersections", function () {
    var edgeIntersections = [];

    for (var j = 0; j < 12; ++j) {
      edgeIntersections.push(new THREE.Vector3());
    }

    return edgeIntersections;
  }());

  defineProperty(VolumeMesh, "_nearClipPlaneOffset", 0.2);

  defineProperty(VolumeMesh, "_pos", new THREE.Vector3());

  defineProperty(VolumeMesh, "_norm", new THREE.Vector3());

  defineProperty(VolumeMesh, "_norm4D", new THREE.Vector4());

  defineProperty(VolumeMesh, "_matrixWorldToLocal", new THREE.Matrix4());

  defineProperty(VolumeMesh, "_clipPlane", new THREE.Plane());

  function _flattenArray(input) {
    var n = input.length;
    var output = new Float32Array(n * 3);

    for (var i = 0; i < n; ++i) {
      var j = 3 * i;
      var v = input[i];
      output[j] = v.x;
      output[j + 1] = v.y;
      output[j + 2] = v.z;
    }

    return output;
  }

  var VolumeBounds = /*#__PURE__*/function () {
    function VolumeBounds(bBox, volInfo) {
      classCallCheck(this, VolumeBounds);

      var delta = volInfo.delta; // {x: XY, y : XZ, z: YZ}

      var obtuseAngle = volInfo.obtuseAngle; // 1 - obtuse, 0 - acute

      var bSize = new THREE.Vector3();
      bBox.getSize(bSize);
      bSize.multiplyScalar(0.5);

      var offsetVert = this._getBaseVertices(delta, obtuseAngle);

      var geometry = new THREE.BufferGeometry();
      var vertices = [];

      for (var i = 0; i < 4; i++) {
        vertices.push(offsetVert[i].clone().multiply(bSize));
        vertices.push(offsetVert[(i + 1) % 4].clone().multiply(bSize));
      }

      var translation = new THREE.Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);

      for (var _i = 0; _i < 8; _i++) {
        vertices.push(vertices[_i].clone().add(translation));
      }

      for (var _i2 = 0; _i2 < 4; _i2++) {
        vertices.push(vertices[_i2 * 2].clone());
        vertices.push(vertices[_i2 * 2 + 8].clone());
      }

      var center = new THREE.Vector3();
      bBox.getCenter(center);
      vertices.forEach(function (vertex) {
        return vertex.add(center);
      }); // pivot shift

      var flatVertices = _flattenArray(vertices);

      geometry.setAttribute('position', new THREE.BufferAttribute(flatVertices, 3));
      this._lines = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({
        color: 0xFFFFFF
      }));

      this._lines.layers.set(gfxutils.LAYERS.VOLUME);
    } // Set one edge (4 points) of frame, from which with parallel transfer  the rest of the frame points can be obtained


    createClass(VolumeBounds, [{
      key: "_getBaseVertices",
      value: function _getBaseVertices(delta, obtuseAngle) {
        var projTable = VolumeBounds._projectionTable;

        var proj = function proj(index, inv) {
          // tricky function to take account of projections: their position(related to box) and sign
          var currDelta = delta[projTable[index][0]];
          var angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]]; // inv = 1: alpha; inv = -1: 1 - alpha

          return angleValue * currDelta;
        };

        var offsetVert = [new THREE.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', 1)), -1 + 2 * proj('YZ', 1), -1), new THREE.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', 1)), -1 + 2 * proj('YZ', -1), 1), new THREE.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', -1)), 1 - 2 * proj('YZ', 1), 1), new THREE.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', -1)), 1 - 2 * proj('YZ', -1), -1)];
        return offsetVert;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._lines;
      }
    }]);

    return VolumeBounds;
  }();

  defineProperty(VolumeBounds, "_projectionTable", {
    // corresponds between (origin axes and angles between them) and between saving vector coordinates
    XY: ['x', 2],
    XZ: ['y', 1],
    YZ: ['z', 0]
  });

  // cube. In cut place of cube there is no correct data in BFTexture and volume rendering integral is calculated
  // with errors.
  // Far plane cuts the cube in case of large volume scale (zoom), because farplane doesn't change

  var VolumeFarPlane = /*#__PURE__*/function () {
    // create plane with unit corners coords (for future rescale in vshader according to camera properties)
    function VolumeFarPlane(volume, width, height) {
      classCallCheck(this, VolumeFarPlane);

      var planeGeo = this._initPlaneGeo(width, height);

      var mat = new VolumeMaterial$1.BackFacePosMaterialFarPlane();
      this._plane = new meshes.Mesh(planeGeo, mat);
      this._plane.frustumCulled = false;
      this._plane.doubleSided = true;
      var matWorldToVolume = new THREE.Matrix4();

      this._plane._onBeforeRender = function (_renderer, _scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!volume || !material) {
          return;
        } // count point in world at farplane place


        var planeCamPos = new THREE.Vector4(0, 0, -(camera.far - 0.1), 1);
        planeCamPos.applyMatrix4(camera.matrixWorld); // recalc matrices to make plane be placed as farplane in the World relative to camera

        this.matrix.identity();
        this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
        this.matrixWorld.copy(this.matrix);
        this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix); // build worldToVolume matrix to transform plane into volumeCS (volumeCS coords are written to BackFaceTexture)

        var volumeMatrix = volume.matrixWorld;
        matWorldToVolume.copy(volumeMatrix).invert(); // update material props

        material.uniforms.aspectRatio.value = camera.aspect;
        material.uniforms.farZ.value = camera.far;
        material.uniforms.tanHalfFOV.value = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov);
        material.uniforms.matWorld2Volume.value = matWorldToVolume;
      }; // set it to special layer to draw only into BFTexture


      this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
    }

    createClass(VolumeFarPlane, [{
      key: "_initPlaneGeo",
      value: function _initPlaneGeo(width, height) {
        var planeGeo = new THREE.BufferGeometry();
        width = width || 1;
        height = height || 1;
        var vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
        planeGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
        return planeGeo;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._plane;
      }
    }]);

    return VolumeFarPlane;
  }();

  function _createSuper$1y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeVisual = /*#__PURE__*/function (_Visual) {
    inherits(VolumeVisual, _Visual);

    var _super = _createSuper$1y(VolumeVisual);

    function VolumeVisual(name, dataSource) {
      var _this;

      classCallCheck(this, VolumeVisual);

      _this = _super.call(this, name, dataSource);
      _this._mesh = new VolumeMesh();

      _this._mesh.setDataSource(dataSource);

      _this.add(_this._mesh);

      _this._frame = new VolumeBounds(_this.getBoundaries().boundingBox, _this._mesh.volumeInfo);

      _this.add(_this._frame.getMesh());

      _this.showFrame(settings.now.modes.VD.frame);

      _this._farPlane = new VolumeFarPlane(_this._mesh, 2, 2);

      _this.add(_this._farPlane.getMesh());

      return _this;
    }

    createClass(VolumeVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        var box = this._dataSource.getBox();

        var sphere = new THREE.Sphere();
        box.getBoundingSphere(sphere);
        return {
          boundingBox: box,
          boundingSphere: sphere
        };
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._mesh;
      }
    }, {
      key: "showFrame",
      value: function showFrame(needShow) {
        this._frame.getMesh().material.visible = needShow;
      }
    }]);

    return VolumeVisual;
  }(Visual);

  function _createSuper$1z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1A(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available loaders.
   * @extends EntityList
   */

  var LoaderList = /*#__PURE__*/function (_EntityList) {
    inherits(LoaderList, _EntityList);

    var _super = _createSuper$1z(LoaderList);

    /**
     * Create a list of loaders.
     * The loaders are indexed by supported source types (`.types` property of a Loader
     * subclass).
     * The loaders can be retrieved later by matching against specs (see {@link LoaderList#find}).
     *
     * @param {!Array<function(new:Loader)>=} someLoaders A list of {@link Loader} subclasses to
     *   automatically register at creation time.
     * @see LoaderList#register
     */
    function LoaderList() {
      var someLoaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, LoaderList);

      return _super.call(this, someLoaders, ['types']);
    }
    /**
     * Find a suitable loader for a source type.
     *
     * @param {Object} specs Loader specifications.
     * @param {string=} specs.type Supported source type.
     * @param {*=} specs.source Source to load from.
     */


    createClass(LoaderList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.type) {
          list = this._dict.types[specs.type.toLowerCase()] || [];
        } else if (specs.source) {
          return this._list.filter(function (SomeLoader) {
            return SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source);
          });
        }

        return toConsumableArray(list);
      }
    }]);

    return LoaderList;
  }(EntityList);

  function _createSuper$1A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1B(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var Loader = /*#__PURE__*/function (_EventDispatcher) {
    inherits(Loader, _EventDispatcher);

    var _super = _createSuper$1A(Loader);

    function Loader(source, options) {
      var _this;

      classCallCheck(this, Loader);

      _this = _super.call(this);
      _this._source = source;
      _this._options = options || {};
      _this._abort = false;
      _this._agent = null;
      return _this;
    }

    createClass(Loader, [{
      key: "load",
      value: function load() {
        return Promise.reject(new Error('Loading from this source is not implemented'));
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;

        if (this._agent) {
          this._agent.abort();
        }
      }
    }], [{
      key: "extractName",
      value: function extractName(_source) {
        return undefined;
      }
    }]);

    return Loader;
  }(EventDispatcher);
  makeContextDependent(Loader.prototype);

  function _createSuper$1B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1C(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FileLoader = /*#__PURE__*/function (_Loader) {
    inherits(FileLoader, _Loader);

    var _super = _createSuper$1B(FileLoader);

    function FileLoader(source, options) {
      var _this;

      classCallCheck(this, FileLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    createClass(FileLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var blob = _this2._source;
          var reader = _this2._agent = new FileReader();
          reader.addEventListener('load', function () {
            resolve(reader.result);
          });
          reader.addEventListener('error', function () {
            reject(reader.error);
          });
          reader.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          reader.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });

          if (_this2._binary) {
            reader.readAsArrayBuffer(blob);
          } else {
            reader.readAsText(blob);
          }
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return File && source instanceof File || Blob && source instanceof Blob;
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        return source && source.name;
      }
    }]);

    return FileLoader;
  }(Loader);
  FileLoader.types = ['file', 'blob'];

  function _createSuper$1C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1D(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var urlStartRegexp = /^(https?|ftp):\/\//i;

  var XHRLoader = /*#__PURE__*/function (_Loader) {
    inherits(XHRLoader, _Loader);

    var _super = _createSuper$1C(XHRLoader);

    function XHRLoader(source, options) {
      var _this;

      classCallCheck(this, XHRLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    createClass(XHRLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var url = _this2._source;
          var request = _this2._agent = new XMLHttpRequest();
          request.addEventListener('load', function () {
            if (request.status === 200) {
              resolve(request.response);
            } else {
              reject(new Error("HTTP ".concat(request.status, " while fetching ").concat(url)));
            }
          });
          request.addEventListener('error', function () {
            reject(new Error('HTTP request failed'));
          });
          request.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          request.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });
          request.open('GET', url);

          if (_this2._binary) {
            request.responseType = 'arraybuffer';
          } else {
            request.responseType = 'text';
          }

          request.send();
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return ___default['default'].isString(source) && urlStartRegexp.test(source);
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        if (source) {
          var last = (source.indexOf('?') + 1 || source.lastIndexOf('#') + 1 || source.length + 1) - 1;
          return source.slice(source.lastIndexOf('/', last) + 1, last);
        }

        return undefined;
      }
    }]);

    return XHRLoader;
  }(Loader);
  XHRLoader.types = ['url'];

  function _createSuper$1D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1E(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ImmediateLoader = /*#__PURE__*/function (_Loader) {
    inherits(ImmediateLoader, _Loader);

    var _super = _createSuper$1D(ImmediateLoader);

    function ImmediateLoader() {
      classCallCheck(this, ImmediateLoader);

      return _super.apply(this, arguments);
    }

    createClass(ImmediateLoader, [{
      key: "load",
      value: function load() {
        var _this = this;

        return new Promise(function (resolve) {
          if (_this._abort) {
            throw new Error('Loading aborted');
          }

          resolve(_this._source);
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(_source) {
        return false;
      }
    }]);

    return ImmediateLoader;
  }(Loader);
  ImmediateLoader.types = ['immediate'];

  var loaders = new LoaderList([// note: order might be important
  FileLoader, XHRLoader, ImmediateLoader]);

  function _createSuper$1E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1F(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available parsers.
   * @extends EntityList
   */

  var ParserList = /*#__PURE__*/function (_EntityList) {
    inherits(ParserList, _EntityList);

    var _super = _createSuper$1E(ParserList);

    /**
     * Create a list of parsers.
     * The parsers are indexed by supported data formats and file extensions (`.formats` and
     * `.extensions` properties of a Parser subclass).
     * The parsers can be retrieved later by matching against specs (see {@link ParsrerList#find}).
     *
     * @param {!Array<function(new:Parser)>=} someParsers A list of {@link Parser} subclasses to
     *   automatically register at creation time.
     * @see ParserList#register
     */
    function ParserList() {
      var someParsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, ParserList);

      return _super.call(this, someParsers, ['formats', 'extensions']);
    }
    /**
     * Find a suitable parser for data.
     *
     * @param {Object} specs Parser specifications.
     * @param {string=} specs.format Supported data format.
     * @param {string=} specs.ext Supported filename extension.
     * @param {*=} specs.data Data to parse.
     */


    createClass(ParserList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        } else if (specs.ext) {
          list = this._dict.extensions[specs.ext.toLowerCase()] || [];
        } // autodetect only if no format is forced


        if (list.length === 0 && !specs.format && specs.data) {
          return this._list.filter(function (SomeParser) {
            return SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data);
          });
        }

        return toConsumableArray(list);
      }
    }]);

    return ParserList;
  }(EntityList);

  var Parser = /*#__PURE__*/function () {
    function Parser(data, options) {
      classCallCheck(this, Parser);

      this._data = data;
      this._options = options || {};
      this._abort = false;
    }

    createClass(Parser, [{
      key: "parseSync",
      value: function parseSync() {
        throw new Error('Parsing this type of data is not implemented');
      }
    }, {
      key: "parse",
      value: function parse() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Parsing aborted'));
              }

              return resolve(_this.parseSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      } // only for volume Parsers

    }, {
      key: "getModel",
      value: function getModel() {
        this.model._parseHeader(this._data);

        return this.model;
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Parser;
  }();
  makeContextDependent(Parser.prototype);

  /**
   * Parser helper for PDB tag "REMARK 290".
   *
   * @exports Remark290
   * @constructor
   */

  var Remark290 = /*#__PURE__*/function () {
    function Remark290() {
      classCallCheck(this, Remark290);

      /** @type {THREE.Matrix4[]} */
      this.matrices = [];
      /** @type {?THREE.Matrix4} */

      this._matrix = null;
      /** @type {number} */

      this._matrixIndex = -1;
    }
    /**
     * Parse a single line of a stream.
     * @param {PDBStream} stream - stream to parse
     */


    createClass(Remark290, [{
      key: "parse",
      value: function parse(stream) {
        /** @type {?THREE.Matrix4} */
        var matrix = this._matrix;

        if (stream.readString(12, 18) === '  SMTRY') {
          var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2

          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            // TODO: assert(matrixIndex === this.matrices.length + 1);
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE.Matrix4();
            this.matrices[this.matrices.length] = matrix;
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        }
      }
    }]);

    return Remark290;
  }();

  Remark290.prototype.id = 290;

  var Assembly$1 = chem.Assembly;
  /**
   * Parser helper for PDB tag "REMARK 350".
   *
   * @exports Remark350
   * @constructor
   */

  var Remark350 = /*#__PURE__*/function () {
    function Remark350(complex) {
      classCallCheck(this, Remark350);

      /** @type {Complex} */
      this._complex = complex;
      /** @type {Assembly[]} */

      this.assemblies = [];
      /** @type {?Assembly} */

      this._assembly = null;
      /** @type {?THREE.Matrix4} */

      this._matrix = null;
      /** @type {number} */

      this._matrixIndex = -1;
    }
    /**
     * Parse a single line of a stream.
     * @param {PDBStream} stream - stream to parse
     */


    createClass(Remark350, [{
      key: "parse",
      value: function parse(stream) {
        /** @type {?Assembly} */
        var assembly = this._assembly;
        /** @type {?THREE.Matrix4} */

        var matrix = this._matrix;

        if (assembly && stream.readString(12, 18) === '  BIOMT') {
          var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2

          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            // TODO: assert(matrixIndex === assembly.matrices.length + 1);
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE.Matrix4();
            assembly.addMatrix(matrix);
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
          var entries = stream.readString(42, 80).split(',');

          for (var i = 0, n = entries.length; i < n; ++i) {
            var chain = entries[i].trim();

            if (chain.length > 0) {
              assembly.addChain(chain);
            }
          }
        } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
          // assert molIndex === this.assemblies.length + 1
          this._matrix = null;
          this._matrixIndex = -1;
          this._assembly = assembly = new Assembly$1(this._complex);
          this.assemblies.push(assembly);
        }
      }
    }]);

    return Remark350;
  }();

  Remark350.prototype.id = 350;

  /** Helper class for stream-like reading input files. */
  var PDBStream = /*#__PURE__*/function () {
    /**
     * Create a stream
     * @param {String} data Input data
     */
    function PDBStream(data) {
      classCallCheck(this, PDBStream);

      /** @type String */
      this._data = data; // Input file

      /** @type Number */

      this._start = 0; // Starting position of line

      /** @type Number */

      this._nextCR = -1; // Position of next CR (0x0D)

      /** @type Number */

      this._nextLF = -1; // Position of next LF (0x0A)

      /** @type Number */

      this._next = -1; // End position of line

      /** @type Number */

      this._end = data.length; // End of data

      this.next();
    }
    /**
     * Reading next line.
     * @returns {String} Next line in data (ending with LF or CR)
     */


    createClass(PDBStream, [{
      key: "readLine",
      value: function readLine() {
        return this._data.slice(this._start, this._next);
      }
      /**
       * Reading character from position.
       * @param {Number} pos - Position in current line.
       * @returns {String} Character from position
       */

    }, {
      key: "readChar",
      value: function readChar(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data[pos] : ' ';
      }
      /**
       * Reading character code from position.
       * @param {Number} pos - Position in current line.
       * @returns {Number} Character code from position
       */

    }, {
      key: "readCharCode",
      value: function readCharCode(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data.charCodeAt(pos) : 32;
      }
      /**
       * Reading string from begin to end points.
       * For a reason unknown, numbering assumed not to start from 0, but from 1.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {String} String from begin to end
       */

    }, {
      key: "readString",
      value: function readString(begin, end) {
        var from = this._start + begin - 1;
        var to = this._start + end;
        return this._data.slice(from, to < this._next ? to : this._next);
      }
      /**
       * Reading integer from begin to end points.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {Number} Integer from begin to end
       */

    }, {
      key: "readInt",
      value: function readInt(begin, end) {
        return parseInt(this.readString(begin, end), 10);
      }
      /**
       * Reading float from begin to end points.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {Number} Float from begin to end
       */

    }, {
      key: "readFloat",
      value: function readFloat(begin, end) {
        return parseFloat(this.readString(begin, end));
      }
      /**
       * Checking for end of data.
       * @returns {boolean} True if data is ended, false otherwise
       */

    }, {
      key: "end",
      value: function end() {
        return this._start >= this._end;
      }
      /**
       * Procedure to re-arrange current pointers in data.
       */

    }, {
      key: "next",
      value: function next() {
        var start = this._next + 1;
        this._start = start < this._end ? start : this._end; // support CR, LF, CR+LF line endings
        // do not support LF+CR, CR+CR+LF, and other strange combinations

        if (this._start > this._nextCR) {
          this._nextCR = (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1;
        }

        if (this._start > this._nextLF) {
          this._nextLF = (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1;
        }

        this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
      }
    }]);

    return PDBStream;
  }();

  function _createSuper$1F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1G(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$1 = chem.Complex,
      Element$2 = chem.Element,
      Helix$1 = chem.Helix,
      Sheet$1 = chem.Sheet,
      Strand$1 = chem.Strand,
      Bond$1 = chem.Bond,
      Molecule$1 = chem.Molecule;
  var TAG_LENGTH = 6;

  function nameToElement(name) {
    // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    //
    // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
    //
    // Atom names start with element symbols right-justified in columns 13-14
    // as permitted by the length of the name. For example, the symbol FE for
    // iron appears in columns 13-14, whereas the symbol C for carbon appears
    // in column 14 (see Misaligned Atom Names). If an atom name has four
    // characters, however, it must start in column 13 even if the element
    // symbol is a single character (for example, see Hydrogen Atoms).
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  } // the most frequently used beginnings; although HEADER is mandatory, it is often missing in handmade files


  var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
  var remarkParsers = {
    // NOTE: please forget the idea to build the method name in runtime, it can be obfuscated.
    290: Remark290,
    350: Remark350
  };

  var PDBParser = /*#__PURE__*/function (_Parser) {
    inherits(PDBParser, _Parser);

    var _super = _createSuper$1F(PDBParser);

    function PDBParser(data, options) {
      var _this;

      classCallCheck(this, PDBParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._sheet = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._compaundFound = false;
      _this._biomoleculeFound = false;
      _this._allowedChainsIDs = null;
      _this._lastMolId = -1;
      _this._remarks = {};
      _this._remark = null;
      _this._molecules = [];
      _this._molecule = null;
      _this._compndCurrToken = '';
      _this._options.fileType = 'pdb';
      return _this;
    }

    createClass(PDBParser, [{
      key: "_finalize",
      value: function _finalize() {
        this._fixBondsArray();

        this._fixChains(); // keep crystallographic symmetry transformations


        var remark290 = this._remarks[290];
        this._complex.symmetry = ___default['default'].isUndefined(remark290) ? [] : remark290.matrices; // add loaded biological assemblies

        var remark350 = this._remarks[350];
        this._complex.units = this._complex.units.concat(___default['default'].isUndefined(remark350) ? [] : remark350.assemblies); // add loaded macromolecules

        this._finalizeMolecules(); // create secondary structure etc.


        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // get chains from complex
        var chainDict = {};
        var i;
        var chains = this._complex._chains;

        for (i = 0; i < chains.length; ++i) {
          var chainObj = chains[i];
          var chainName = chainObj._name;
          chainDict[chainName] = chainObj;
        } // aggregate residues from chains


        for (i = 0; i < this._molecules.length; i++) {
          var m = this._molecules[i];
          var residues = [];

          for (var j = 0; j < m._chains.length; j++) {
            var name = m._chains[j];
            var chain = chainDict[name];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$1(this._complex, m._name, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_fixChains",
      value: function _fixChains() {
        var idChainMap = {};
        var complex = this._complex; // prepare

        for (var i = 0; i < complex._chains.length; i++) {
          var chain = complex._chains[i];
          idChainMap[chain._name.charCodeAt(0)] = chain;
        }
      } // FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.

    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseATOM",
      value: function _parseATOM(stream) {
        if (this._modelId !== 1) {
          return;
        }
        /* eslint-disable no-magic-numbers */


        var het = stream.readCharCode(1) === 0x48; // field names according to wwPDB Format
        // NOTE: Chimera allows (nonstandard) use of columns 6-11 for the integer atom serial number in ATOM records.

        var serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
        var name = stream.readString(13, 16);
        var altLoc = stream.readChar(17);
        var resName = stream.readString(18, 20).trim();
        var chainID = stream.readChar(22);
        var resSeq = stream.readInt(23, 26);
        var iCode = stream.readChar(27);
        var x = stream.readFloat(31, 38);
        var y = stream.readFloat(39, 46);
        var z = stream.readFloat(47, 54);
        var occupancy = stream.readFloat(55, 60);
        var tempFactor = stream.readFloat(61, 66);
        var element = stream.readString(77, 78).trim() || nameToElement(name);
        var charge = stream.readInt(79, 80) || 0;
        /* eslint-enable no-magic-numbers */
        // skip waters (there may be lots of them)

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return;
          }
        } // PDB uses positional system for atom names. It helps derive element type from the name
        // but names may include extra spaces. From this point on we don't need those spaces anymore.


        name = name.trim();
        var type = Element$2.getByName(element);
        var role = Element$2.Role[name]; // FIXME: Maybe should use type as additional index (" CA " vs. "CA  ")
        // NOTE: Residues of a particular chain are not required to be listed next to each other.
        // https://github.com/biasmv/pv/commit/7319b898b7473ba380c26699e3b028b2b1a7e1a1

        var chain = this._chain;

        if (!chain || chain.getName() !== chainID) {
          this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
          this._residue = null;
        }

        var residue = this._residue;

        if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
          this._residue = residue = chain.addResidue(resName, resSeq, iCode);
        }

        var xyz = new THREE.Vector3(x, y, z);
        residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
      }
    }, {
      key: "_parseENDMDL",
      value: function _parseENDMDL() {
        this._modelId += 1;
      }
    }, {
      key: "_parseCONECT",
      value: function _parseCONECT(stream) {
        /* eslint-disable no-magic-numbers */
        var serial0 = stream.readInt(7, 11);
        var serial1 = stream.readInt(12, 16);
        var serial2 = stream.readInt(17, 21);
        var serial3 = stream.readInt(22, 26);
        var serial4 = stream.readInt(27, 31);
        /* eslint-enable no-magic-numbers */

        var complex = this._complex; // Keep bonds ordered by atom serial

        if (serial1 && serial1 > serial0) {
          complex.addBond(serial0, serial1, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial2 && serial2 > serial0) {
          complex.addBond(serial0, serial2, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial3 && serial3 > serial0) {
          complex.addBond(serial0, serial3, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial4 && serial4 > serial0) {
          complex.addBond(serial0, serial4, 0, Bond$1.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseCOMPND",
      value: function _parseCOMPND(stream) {
        /* eslint-disable no-magic-numbers */
        var str = stream.readString(11, 80);
        var tokenIdx = str.indexOf(':');
        this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
        /* eslint-enable no-magic-numbers */
        // start reading new molecule

        if (this._compndCurrToken === 'MOL_ID') {
          this._molecule = {
            _index: '',
            _chains: []
          };
          this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(';')), 10);

          this._molecules.push(this._molecule); // parse molecule name

        } else if (this._compndCurrToken === 'MOLECULE' && this._molecule != null) {
          this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(';')).trim(); // parse molecule chains
        } else if (this._compndCurrToken === 'CHAIN' && this._molecule != null) {
          var chainStr = str.substring(tokenIdx + 1, 80).trim();
          var lastChar = chainStr[chainStr.length - 1];

          if (lastChar === ';' || lastChar === ',') {
            chainStr = chainStr.slice(0, -1);
          }

          chainStr = chainStr.replace(/\s+/g, '');
          var chains = chainStr.split(',');
          this._molecule._chains = this._molecule._chains.concat(chains);
        }
      }
    }, {
      key: "_parseREMARK",
      value: function _parseREMARK(stream) {
        /* eslint-disable no-magic-numbers */
        var remarkNum = stream.readInt(8, 10);
        /* eslint-enable no-magic-numbers */
        // create remark parser if needed

        var remark = this._remarks[remarkNum];

        if (___default['default'].isUndefined(remark)) {
          var RemarkParser = remarkParsers[remarkNum];

          if (___default['default'].isFunction(RemarkParser)) {
            this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
          }
        } // delegate parsing


        if (!___default['default'].isUndefined(remark)) {
          remark.parse(stream);
        }
      }
    }, {
      key: "_parseHELIX",
      value: function _parseHELIX(stream) {
        var _this2 = this;

        /* eslint-disable no-magic-numbers */
        var fields = [20, 22, 32, 34];
        /* eslint-enable no-magic-numbers */

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this2._complex.addHelix(obj);

          _this2._complex.structures.push(obj);
        });
      }
    }, {
      key: "_parseSHEET",
      value: function _parseSHEET(stream) {
        var _this3 = this;

        /* eslint-disable no-magic-numbers */
        var fields = [22, 23, 33, 34];
        /* eslint-enable no-magic-numbers */

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this3._complex.addSheet(obj);
        });
      }
    }, {
      key: "_parseSTRUCTURE",
      value: function _parseSTRUCTURE(stream, pars, adder) {
        var startId = 0;
        var startIndex = 1;
        var endId = 2;
        var endIndex = 3; // identify fields: debugging and stuff

        /* eslint-disable no-magic-numbers */

        var codeOfS = 0x53;
        var serialNumber = stream.readInt(8, 10);
        var structureName = stream.readString(12, 14).trim(); // FIXME: LString(3) forbids trim()

        var comment = stream.readString(41, 70).trim();
        var helLength = stream.readInt(72, 76);
        var helixClass = stream.readInt(39, 40);
        var shWidth = stream.readInt(15, 16);
        var shCur = stream.readInt(42, 45);
        var shPrev = stream.readInt(57, 60);
        /* eslint-enable no-magic-numbers */
        // file fields

        var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
        var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
        var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
        var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
        var startICode = 0;

        if (iCodeStr.length > 0) {
          startICode = iCodeStr.charCodeAt(0);
        }

        var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
        iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
        var endICode = 0;

        if (iCodeStr.length > 0) {
          endICode = iCodeStr.charCodeAt(0);
        }

        var obj;
        var cs = this._sheet;

        if (stream.readCharCode(1) === codeOfS) {
          if (cs !== null && cs.getName() !== structureName) {
            cs = null;
            this._sheet = null;
          }

          if (cs === null) {
            this._sheet = obj = new Sheet$1(structureName, shWidth);
            adder(obj);
          } else {
            obj = cs;
          }

          var strand = new Strand$1(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
          obj.addStrand(strand);

          this._complex.structures.push(strand);
        } else {
          obj = new Helix$1(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
          adder(obj);
        }
      }
    }, {
      key: "_parseHEADER",
      value: function _parseHEADER(stream) {
        var metadata = this._complex.metadata;
        metadata.classification = stream.readString(11, 50).trim();
        metadata.date = stream.readString(51, 59).trim();
        var id = stream.readString(63, 66).trim();
        metadata.id = id;

        if (id) {
          this._complex.name = id;
        }

        metadata.format = 'pdb';
      }
    }, {
      key: "_parseTITLE",
      value: function _parseTITLE(stream) {
        var metadata = this._complex.metadata;
        metadata.title = metadata.title || [];
        var line = stream.readInt(9, 10) || 1;
        metadata.title[line - 1] = stream.readString(11, 80).trim();
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var stream = new PDBStream(this._data);
        var result = this._complex = new Complex$1(); // parse PDB line by line

        while (!stream.end()) {
          var tag = stream.readString(1, TAG_LENGTH);
          var func = PDBParser.tagParsers[tag];

          if (___default['default'].isFunction(func)) {
            func.call(this, stream);
          }

          stream.next();
        } // Resolve indices and serials to objects


        this._finalize(); // cleanup


        this._serialAtomMap = null;
        this._sheet = null;
        this._residue = null;
        this._chain = null;
        this._complex = null;

        if (result.getAtomCount() === 0) {
          throw new Error('The data does not contain valid atoms');
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && pdbStartRegexp.test(data);
      }
    }]);

    return PDBParser;
  }(Parser);

  defineProperty(PDBParser, "tagParsers", {
    HEADER: PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    HETATM: PDBParser.prototype._parseATOM,
    ENDMDL: PDBParser.prototype._parseENDMDL,
    CONECT: PDBParser.prototype._parseCONECT,
    COMPND: PDBParser.prototype._parseCOMPND,
    REMARK: PDBParser.prototype._parseREMARK,
    // 'SOURCE': PDBParser.prototype._parseSOURCE,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET,
    // nonstandard extension to allow range 100,000 - 999,999
    'ATOM 1': PDBParser.prototype._parseATOM,
    'ATOM 2': PDBParser.prototype._parseATOM,
    'ATOM 3': PDBParser.prototype._parseATOM,
    'ATOM 4': PDBParser.prototype._parseATOM,
    'ATOM 5': PDBParser.prototype._parseATOM,
    'ATOM 6': PDBParser.prototype._parseATOM,
    'ATOM 7': PDBParser.prototype._parseATOM,
    'ATOM 8': PDBParser.prototype._parseATOM,
    'ATOM 9': PDBParser.prototype._parseATOM
  });

  PDBParser.formats = ['pdb'];
  PDBParser.extensions = ['.pdb', '.ent'];

  function _createSuper$1G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1H(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$2 = chem.Complex,
      Element$3 = chem.Element,
      SGroup$1 = chem.SGroup,
      Bond$2 = chem.Bond;
  var cOrderCharCodes = {
    A: 0,
    S: 1,
    D: 2,
    T: 3
  };
  var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;

  var CMLParser = /*#__PURE__*/function (_Parser) {
    inherits(CMLParser, _Parser);

    var _super = _createSuper$1G(CMLParser);

    function CMLParser(data, options) {
      var _this;

      classCallCheck(this, CMLParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._residue = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._lastMolId = -1;
      _this._readOnlyOneMolecule = false;
      _this._options.fileType = 'cml';
      return _this;
    }

    createClass(CMLParser, [{
      key: "_rebuidBondIndexes",
      value: function _rebuidBondIndexes(atoms, bonds) {
        var count = atoms.length;

        for (var i = 0; i < count; i++) {
          var atomId = atoms[i].id;
          var countBonds = bonds.length;

          for (var j = 0; j < countBonds; j++) {
            var idxs = bonds[j].atomRefs2.split(' ');

            if (idxs[0] === atomId) {
              bonds[j].start = i;
            }

            if (idxs[1] === atomId) {
              bonds[j].end = i;
            }
          }
        }
      }
    }, {
      key: "_createSGroup",
      value: function _createSGroup(molecule, moleculeArr) {
        var newGroup = new SGroup$1(molecule.id, molecule.fieldData, new THREE.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);

        if (molecule.placement === 'Relative') {
          newGroup._center = new THREE.Vector3(0, 0, 0);
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
          newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
          newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
        }

        moleculeArr.push(newGroup);
      }
    }, {
      key: "_extractSGroup",
      value: function _extractSGroup(molecule, moleculeArr) {
        if (!Array.isArray(moleculeArr)) {
          moleculeArr = [];
        }

        if (molecule) {
          if (Array.isArray(molecule)) {
            var count = molecule.length;

            for (var i = 0; i < count; i++) {
              if (molecule[i].molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
              }

              this._createSGroup(molecule[i], moleculeArr);
            }
          } else {
            if (molecule.molecule) {
              if (molecule.molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
              }
            }

            this._createSGroup(molecule, moleculeArr);
          }
        }

        return moleculeArr;
      }
    }, {
      key: "_extractSGroups",
      value: function _extractSGroups(molecule, atoms) {
        var moleculeArr = this._extractSGroup(molecule);

        var count = atoms.length;
        var i;
        var j;

        for (i = 0; i < count; i++) {
          var atomId = atoms[i].id;

          for (j = 0; j < moleculeArr.length; j++) {
            var firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];

            if (firstAtomRef === atomId) {
              if (!atoms[i].sgroupRef) {
                atoms[i].sgroupRef = [];
              }

              atoms[i].sgroupRef.push(moleculeArr[j]);
            }
          }
        } // build sGroups centers


        var atomMap = {}; // sgrpmap cache

        var mapEntry = null;
        var nLimon = 100000000;
        var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);

        function cycleFuncInner(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            moleculeArr[j]._atoms.push(mapEntry.a);
          }
        }

        function cycleFunc(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
            bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
            cycleFuncInner(e);
          }
        }

        for (i = 0; i < atoms.length; i++) {
          atomMap[atoms[i].id] = {};
          atomMap[atoms[i].id].x = atoms[i].x2;

          if (atoms[i].x3) {
            atomMap[atoms[i].id].x = atoms[i].x3;
          }

          atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
          atomMap[atoms[i].id].y = atoms[i].y2;

          if (atoms[i].y3) {
            atomMap[atoms[i].id].y = atoms[i].y3;
          }

          atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
          atomMap[atoms[i].id].z = '0.0';

          if (atoms[i].z3) {
            atomMap[atoms[i].id].z = atoms[i].z3;
          }

          atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
          atomMap[atoms[i].id].a = atoms[i];
        }

        var atomsRef;

        for (j = 0; j < moleculeArr.length; j++) {
          if (moleculeArr[j]._center !== null) {
            bLow.set(nLimon, nLimon, nLimon);
            bHight.set(-nLimon, -nLimon, -nLimon);
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFunc);

            moleculeArr[j]._center.addVectors(bLow, bHight);

            moleculeArr[j]._center.multiplyScalar(0.5);
          } else {
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFuncInner);
          }
        }

        atomMap = null;
      }
    }, {
      key: "_traverseData",
      value: function _traverseData(dom) {
        function isArray(o) {
          return Object.prototype.toString.apply(o) === '[object Array]';
        }

        function parseNode(xmlNode, result) {
          if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
            return;
          }

          var jsonNode = {};
          jsonNode.xmlNode = xmlNode;
          var existing = result[xmlNode.nodeName];

          if (existing) {
            if (!isArray(existing)) {
              result[xmlNode.nodeName] = [existing, jsonNode];
            } else {
              result[xmlNode.nodeName].push(jsonNode);
            }
          } else {
            result[xmlNode.nodeName] = jsonNode;
          }

          var length;
          var i;

          if (xmlNode.attributes) {
            length = xmlNode.attributes.length;

            for (i = 0; i < length; i++) {
              var attribute = xmlNode.attributes[i];
              jsonNode[attribute.nodeName] = attribute.nodeValue;
            }
          }

          length = xmlNode.childNodes.length;

          for (i = 0; i < length; i++) {
            parseNode(xmlNode.childNodes[i], jsonNode);
          }
        }

        var result = {};

        if (dom.childNodes.length) {
          parseNode(dom.childNodes[0], result);
        }

        return result;
      }
    }, {
      key: "_findSuitableMolecule",
      value: function _findSuitableMolecule(data, molSet) {
        for (var key in data) {
          if (key === 'xmlNode') {
            continue;
          } else if (key === 'molecule') {
            if (data.molecule) {
              if (data.molecule.atomArray && data.molecule.atomArray.atom) {
                molSet.push(data);
              }

              if (Array.isArray(data.molecule)) {
                for (var i = 0; i < data.molecule.length; i++) {
                  if (data.molecule[i].atomArray && data.molecule[i].atomArray.atom) {
                    molSet.push({
                      molecule: data.molecule[i]
                    });
                  }
                }
              }
            }
          } else if (data[key] && data[key] !== null && _typeof_1(data[key]) === 'object') {
            this._findSuitableMolecule(data[key], molSet);
          }
        }
      }
    }, {
      key: "_selectComponents",
      value: function _selectComponents(text) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(text, 'application/xml');

        var traversedData = this._traverseData(doc);

        var rawData;
        var self = this;

        function prepareComponentCompound(data) {
          var atoms = [];

          if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
            if (!Array.isArray(data.molecule.atomArray.atom)) {
              atoms.push(data.molecule.atomArray.atom);
            } else {
              atoms = data.molecule.atomArray.atom;
            }
          } else if (!data.molecule) {
            var ret = {};
            ret.atomLabels = null;
            ret.labelsCount = 1;
            return ret;
          }

          if (data.molecule.molecule) {
            self._extractSGroups(data.molecule.molecule, atoms);
          }

          var atom;
          var count = atoms.length;

          for (var i = 0; i < count; i++) {
            atom = atoms[i];
            atom.edges = [];
          }

          var localBond = [];

          if (data.molecule.bondArray && data.molecule.bondArray.bond) {
            if (!Array.isArray(data.molecule.bondArray.bond)) {
              localBond.push(data.molecule.bondArray.bond);
            } else {
              localBond = data.molecule.bondArray.bond;
            }
          }

          var bond;
          count = localBond.length;

          self._rebuidBondIndexes(atoms, localBond);

          function addCurrBond(index) {
            bond = localBond[index];
            atom = atoms[bond.start];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.end);
            atom = atoms[bond.end];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.start);
            return true;
          }

          for (var _i = 0; _i < count; _i++) {
            if (!addCurrBond(_i)) {
              // ignore invalid bond
              continue;
            }

            var orderAttr = bond.xmlNode.getAttribute('order');
            var tc = parseInt(orderAttr, 10); // the default bond order is unknown

            localBond[_i].order = 0;
            localBond[_i].type = Bond$2.BondType.UNKNOWN;

            if (tc > 1) {
              localBond[_i].order = tc;
            } else {
              // another option - bond order is a string
              var order = cOrderCharCodes[orderAttr];

              if (order !== undefined) {
                localBond[_i].order = order;

                if (orderAttr === 'A') {
                  localBond[_i].type = Bond$2.BondType.AROMATIC;
                }
              }
            }
          }

          count = atoms.length;

          for (var _i2 = 0; _i2 < count; _i2++) {
            atom = atoms[_i2];
            atom.edges.sort();
          }

          var labels = self._breadWidthSearch(atoms, 0); // for now


          var retStruct = {};
          retStruct.atoms = atoms;
          retStruct.bonds = localBond;
          retStruct.labels = labels.atomLabels;
          retStruct.count = Math.min(1, labels.labelsCount); // for now

          retStruct.curr = -1;
          retStruct.originalCML = doc;
          return retStruct;
        }

        if (traversedData.cml) {
          rawData = traversedData.cml;
        } else {
          rawData = traversedData;
        }

        var retData = [];
        var filteredData = [];

        this._findSuitableMolecule(rawData, filteredData);

        if (this._readOnlyOneMolecule && filteredData.length > 1) {
          filteredData.splice(1, filteredData.length - 1);
        }

        filteredData.forEach(function (d) {
          var rd = prepareComponentCompound(d);

          if (rd.atoms.length > 0) {
            retData.push(rd);
          }
        });
        return retData;
      }
    }, {
      key: "_packLabel",
      value: function _packLabel(compId, molId) {
        var shift = 16;
        return (molId << shift) + compId;
      }
    }, {
      key: "_unpackLabel",
      value: function _unpackLabel(l) {
        var shift = 16;
        var mask = (1 << shift) - 1;
        return {
          molId: l >>> shift,
          compId: l & mask
        };
      }
    }, {
      key: "_breadWidthSearch",
      value: function _breadWidthSearch(atoms, molID) {
        var atomLabels = new Array(atoms.length);
        var id;

        for (id = 0; id < atomLabels.length; id++) {
          atomLabels[id] = this._packLabel(0, molID);
        }

        var breadthQueue = [];
        var componentID = 0;
        var labeledAtoms = atoms.length;

        while (labeledAtoms > 0) {
          componentID++;
          var startID = -1;

          for (id = 0; id < atomLabels.length; id++) {
            if (this._unpackLabel(atomLabels[id]).compId === 0) {
              startID = id;
              break;
            }
          }

          if (startID < 0) {
            break;
          } // Bread first search


          breadthQueue.push(atoms[startID]);
          atomLabels[startID] = this._packLabel(componentID, molID);
          labeledAtoms--;

          while (breadthQueue.length > 0) {
            var curr = breadthQueue.shift();

            if (!curr) {
              continue;
            }

            for (var i = 0; i < curr.edges.length; i++) {
              if (atomLabels[curr.edges[i]] !== componentID) {
                breadthQueue.push(atoms[curr.edges[i]]);
                atomLabels[curr.edges[i]] = componentID;
                labeledAtoms--;
              }
            }
          }
        }

        var ret = {};
        ret.atomLabels = atomLabels;
        ret.labelsCount = componentID;
        return ret;
      }
    }, {
      key: "_parseBond",
      value: function _parseBond(eAtom, mainAtom, order, type) {
        if (eAtom >= 0) {
          var h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];

          this._complex.addBond(h[0], h[1], order, type, true);
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseSet",
      value: function _parseSet(varData) {
        var complex = this._complex = new Complex$2();
        var data = varData;
        var currentLabel = data.curr;
        var atoms = data.atoms,
            labels = data.labels;
        var atom = null;
        var i;
        var j;
        var count = atoms.length;

        function addFunc(a) {
          a.xmlNodeRef = atom;

          if (atom.x2) {
            atom.x3 = atom.x2;
            delete atom.x2;
          }

          if (atom.y2) {
            atom.y3 = atom.y2;
            delete atom.y2;
          }

          if (!atom.z3) {
            atom.z3 = '0.0';
          }

          atom.complexAtom = a;
        }

        var chains = {}; // parse atoms in label order

        var reorder = [];

        for (i = 0; i < count; i++) {
          reorder.push(i);
        }

        reorder.sort(function (a, b) {
          return labels[a] - labels[b];
        });

        for (i = 0; i < count; i++) {
          var atomCharge = 0;
          var lLabel = labels[reorder[i]];

          if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[reorder[i]];
            var atomFullNameStruct = atom.elementType;

            if (atom.sgroupRef) {
              var countRef = atom.sgroupRef.length;

              for (var k = 0; k < countRef; ++k) {
                complex._sgroups.push(atom.sgroupRef[k]);
              }
            }

            if (atom.x3 || atom.x2) {
              var currAtomComp = this._unpackLabel(lLabel).compId; // use ' ' by default instead of synthetic creation of chain names


              var chainID = ' '; //= String.fromCharCode('A'.charCodeAt(0) + currAtomComp);

              var resSeq = currAtomComp;
              var iCode = ' ';
              var strLabel = currAtomComp.toString();

              if (strLabel.length === 1) {
                strLabel = "0".concat(strLabel);
              }

              var resName = "N".concat(strLabel);
              var chain = chains[chainID];

              if (!chain || chain.getName() !== chainID) {
                chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
                this._residue = null;
              }

              var residue = this._residue;

              if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
                this._residue = residue = chain.addResidue(resName, resSeq, iCode);
              } // _x, _y, _z, mname, mindex, atomNameFull, atomName, chainID, serial, isHet, atlLocInd, atomNameToTypeF


              var xyz = null;

              if (atom.x3) {
                xyz = new THREE.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
              } else if (atom.x2) {
                xyz = new THREE.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
              }

              var element = Element$3.ByName[atom.elementType.toUpperCase()];

              if (!element) {
                element = JSON.parse(JSON.stringify(Element$3.ByName[Object.keys(Element$3.ByName)[Object.keys(Element$3.ByName).length - 1]]));
                element.number += 1;
                element.name = atom.elementType.toUpperCase();
                element.fullName = 'Unknown';
                Element$3.ByName[atom.elementType.toUpperCase()] = element;
              }

              var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
              var added = residue.addAtom(atomFullNameStruct, element, xyz, Element$3.Role.SG, true, atomSerial, ' ', 1.0, 0.0, atomCharge);

              if (atom.hydrogenCount) {
                added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
              }

              if (atom.mrvValence) {
                added.valence = parseInt(atom.mrvValence, 10);
              }

              addFunc(added);
            }
          }
        }

        chains = null; // NOSONAR

        for (i = 0; i < data.bonds.length; i++) {
          var cb = data.bonds[i];

          if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[cb.start];

            if (!atom || !atoms[cb.end]) {
              continue; // skip invalid
            }

            this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
          }
        }

        for (i = 0; i < this._complex.getSGroupCount(); i++) {
          var sGrp = this._complex.getSGroups()[i];

          for (j = 0; j < sGrp._atoms.length; j++) {
            sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
          }
        }

        for (i = 0; i < count; i++) {
          if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[i];
            atom.complexAtom = null;
            delete atom.complexAtom;
          }
        }

        this._complex.originalCML = data.originalCML;

        this._fixBondsArray();

        complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
        this._serialAtomMap = null;
        this._complex = null;
        return complex;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var complexes = [];
        var self = this;

        var moleculaSet = this._selectComponents(this._data);

        moleculaSet.forEach(function (molSet) {
          molSet.curr = 2;

          if (molSet.count === 0) {
            molSet.count = 1;
          }

          for (var i = 0; i < molSet.count; i++) {
            molSet.curr = i + 1;
            complexes.push(self._parseSet(molSet, false));
          }
        });
        var totalAtomsParsed = 0;
        complexes.forEach(function (c) {
          totalAtomsParsed += c.getAtomCount();
        });

        if (totalAtomsParsed <= 0) {
          throw new Error('The data does not contain valid atoms');
        }

        if (complexes.length > 1) {
          var joinedComplex = new Complex$2();
          joinedComplex.joinComplexes(complexes);
          joinedComplex.originalCML = complexes[0].originalCML;
          return joinedComplex;
        }

        if (complexes.length === 1) {
          return complexes[0];
        }

        return new Complex$2();
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && cmlStartRegexp.test(data);
      }
    }]);

    return CMLParser;
  }(Parser);

  CMLParser.formats = ['cml'];
  CMLParser.extensions = ['.cml'];

  var mmtf = createCommonjsModule(function (module, exports) {
  !function(r,t){t(exports);}(commonjsGlobal,function(r){function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else {if(!(1114112>o))throw new Error("bad codepoint "+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else {if(!(1114112>i))throw new Error("bad codepoint "+i);t+=4;}}return t}function e(r,i,o){var a=typeof r;if("string"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if("number"===a){if(!isFinite(r))throw new Error("Number not finite: "+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error("Number too small -0x"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if("boolean"===a)return i.setUint8(o,r?195:194),1;if("object"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else {var d=Object.keys(r);u=d.length;}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var v=d[l];f+=e(v,i,o+f),f+=e(r[v],i,o+f);}return f}throw new Error("Unknown type "+a)}function i(r){var t=typeof r;if("string"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if("number"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error("Number too small -0x"+r.toString(16).substr(1))}if("boolean"===t||null===r)return 1;if("object"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a]);}else {var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s]);}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error("Array or object too long 0x"+e.toString(16))}throw new Error("Unknown type "+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function v(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function g(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i);}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u);}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e;}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:a+=u===e||u===i?2:u>0?Math.ceil(u/e):Math.ceil(u/i);}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f;}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return [n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=v(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n]);}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o();}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join("")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error("Unknown type 0x"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return g(t);case 5:return s(t);case 6:return p(g(t),new Uint8Array(n));case 7:return p(g(t));case 8:return A(g(t));case 9:return M(g(t),g(e)[0]);case 10:return O(l(t),g(e)[0]);case 11:return y(l(t),g(e)[0]);case 12:return N(l(t),g(e)[0]);case 13:return N(f(t),g(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o);}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,v=t.onAtom,g=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k});}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z});}for(u=0;q>u;++u){if(v){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),v({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R});}m+=1;}if(g){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)g({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]});}y+=1;}h+=1;}if(p=U+1,U=m-1,g&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&g({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null});}L+=1;}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r);}catch(t){e(t);}}var o=new XMLHttpRequest;o.addEventListener("load",i,!0),o.addEventListener("error",e,!0),o.responseType="arraybuffer",o.open("GET",t+r.toUpperCase()),o.send();}function $(r,t,n){Z(r,or,t,n);}function _(r,t,n){Z(r,ar,t,n);}var rr=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],tr=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],nr=rr.concat(tr),er="v1.1.0dev",ir="//mmtf.rcsb.org/v1.0/",or=ir+"full/",ar=ir+"reduced/";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X;});
  });

  function _createSuper$1H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1I(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$3 = chem.Complex,
      Chain$1 = chem.Chain,
      Atom$1 = chem.Atom,
      Element$4 = chem.Element,
      Helix$2 = chem.Helix,
      Sheet$2 = chem.Sheet,
      Strand$2 = chem.Strand,
      Bond$3 = chem.Bond,
      Assembly$2 = chem.Assembly,
      Molecule$2 = chem.Molecule;

  var ArrayComparator = /*#__PURE__*/function () {
    function ArrayComparator(original) {
      classCallCheck(this, ArrayComparator);

      this._original = Array.from(original);

      this._original.sort();

      this._sum = 0;

      for (var i = 0; i < this._original.length; ++i) {
        this._sum += this._original[i];
      }
    }

    createClass(ArrayComparator, [{
      key: "compare",
      value: function compare(candidate) {
        var len = candidate.length;

        if (len !== this._original.length) {
          return false;
        }

        var sum = 0;
        var i;

        for (i = 0; i < len; ++i) {
          sum += candidate[i];
        }

        if (sum !== this._sum) {
          return false;
        }

        var sorted = Array.from(candidate);
        sorted.sort();

        for (i = 0; i < len; ++i) {
          if (sorted[i] !== this._original[i]) {
            return false;
          }
        }

        return true;
      }
    }]);

    return ArrayComparator;
  }();

  ArrayComparator.prototype.constructor = ArrayComparator;
  var StructuralElementType$5 = StructuralElement.Type; // see https://github.com/rcsb/mmtf-javascript/blob/master/src/mmtf-traverse.js

  var secStructToType = [StructuralElementType$5.HELIX_PI, // 0
  StructuralElementType$5.BEND, // 1
  StructuralElementType$5.HELIX_ALPHA, // 2
  StructuralElementType$5.STRAND, // 3
  StructuralElementType$5.HELIX_310, // 4
  StructuralElementType$5.BRIDGE, // 5
  StructuralElementType$5.TURN, // 6
  StructuralElementType$5.COIL // 7
  ];

  function getFirstByte(buf) {
    var bytes = new Uint8Array(buf, 0, 1);
    return bytes[0];
  }

  var MMTFParser = /*#__PURE__*/function (_Parser) {
    inherits(MMTFParser, _Parser);

    var _super = _createSuper$1H(MMTFParser);

    function MMTFParser(data, options) {
      var _this;

      classCallCheck(this, MMTFParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'mmtf';
      return _this;
    }

    createClass(MMTFParser, [{
      key: "_onModel",
      value: function _onModel(_modelData) {}
    }, {
      key: "_onChain",
      value: function _onChain(chainData) {
        if (chainData.modelIndex !== 0) {
          return;
        }

        var chain = new Chain$1(this._complex, chainData.chainName);
        this._complex._chains[chainData.chainIndex] = chain;
        chain._index = chainData.chainIndex;
      }
    }, {
      key: "_onGroup",
      value: function _onGroup(groupData) {
        if (groupData.modelIndex !== 0) {
          return;
        }

        if (this.settings.now.nowater) {
          // skip water
          if (groupData.groupName === 'HOH' || groupData.groupName === 'WAT') {
            return;
          }
        }

        var chain = this._complex._chains[groupData.chainIndex];
        var icode = !groupData.insCode.charCodeAt(0) ? '' : groupData.insCode;
        var residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
        residue._index = groupData.groupIndex;

        this._updateSecStructure(this._complex, residue, groupData);
      }
    }, {
      key: "_onAtom",
      value: function _onAtom(atomData) {
        if (atomData.modelIndex !== 0) {
          return;
        }

        var altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc;
        var atom = new Atom$1(atomData.groupIndex, // we store residue index here to replace it later with actual reference
        atomData.atomName, Element$4.getByName(atomData.element.toUpperCase()), new THREE.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord), Element$4.Role[atomData.atomName], false, // hetero atoms will be marked later
        atomData.atomId, altLoc, atomData.occupancy, atomData.bFactor, atomData.formalCharge);
        this._complex._atoms[atomData.atomIndex] = atom;
        atom.index = atomData.atomIndex;
        this._serialAtomMap[atomData.atomId] = atom;
      }
    }, {
      key: "_onBond",
      value: function _onBond(bondData) {
        var right = Math.max(bondData.atomIndex1, bondData.atomIndex2);

        if (right >= this._complex._atoms.length) {
          return;
        }

        var left = Math.min(bondData.atomIndex1, bondData.atomIndex2);

        this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, Bond$3.BondType.UNKNOWN, true);
      }
    }, {
      key: "_updateSecStructure",
      value: function _updateSecStructure(complex, residue, groupData) {
        var helixClasses = [3, -1, 1, -1, 5];

        if (!___default['default'].isUndefined(groupData) && groupData.secStruct === this._ssType) {
          residue._secondary = this._ssStruct;

          if (this._ssStruct) {
            this._ssStruct.term = residue;
          }

          return;
        }

        if (!___default['default'].isUndefined(groupData)) {
          // start new secondary structure
          var type = secStructToType[groupData.secStruct];
          this._ssType = groupData.secStruct;
          this._ssStart = residue;
          var struct = null;

          switch (this._ssType) {
            case -1: // undefined

            case 7:
              // coil
              break;

            case 0: // pi helix

            case 2: // alpha helix

            case 4:
              // 3-10 helix
              struct = new Helix$2(helixClasses[this._ssType], residue, residue, 0, '', '', 0);

              complex._helices.push(struct);

              break;

            case 3:
              {
                // extended
                var sheet = new Sheet$2('', 0);

                complex._sheets.push(sheet);

                struct = new Strand$2(sheet, residue, residue, 0, null, null);
                break;
              }

            default:
              if (type !== undefined) {
                struct = new StructuralElement(type, residue, residue);
              }

              break;
          }

          this._ssStruct = struct;
          residue._secondary = struct;

          if (struct) {
            complex.structures.push(struct);
          }
        }
      }
    }, {
      key: "_updateMolecules",
      value: function _updateMolecules(mmtfData) {
        var entities = mmtfData.entityList;

        if (!entities) {
          return;
        }

        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < entities.length; i++) {
          var entity = entities[i];
          var chains = entity.chainIndexList;
          var residues = [];

          for (var j = 0; j < chains.length; j++) {
            var chainIndex = chains[j]; // skip chains in models other than the first one

            if (chainIndex >= chainsInModel0) {
              continue;
            }

            var chain = this._complex._chains[chainIndex];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$2(this._complex, entity.description, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      } // populate complex with chains, residues and atoms

    }, {
      key: "_traverse",
      value: function _traverse(mmtfData) {
        var self = this; // get metadata

        var metadata = this._complex.metadata;
        metadata.id = mmtfData.structureId;
        metadata.title = [];
        metadata.title[0] = mmtfData.title;
        metadata.date = mmtfData.releaseDate;
        metadata.format = 'mmtf'; // create event callback functions

        var eventCallbacks = {
          onModel: function onModel(modelData) {
            self._onModel(modelData);
          },
          onChain: function onChain(chainData) {
            self._onChain(chainData);
          },
          onGroup: function onGroup(groupData) {
            self._onGroup(groupData);
          },
          onAtom: function onAtom(atomData) {
            self._onAtom(atomData);
          },
          onBond: function onBond(bondData) {
            self._onBond(bondData);
          }
        }; // temporary variables used during traversal to track secondary structures

        this._ssType = -1;
        this._ssStruct = null;
        this._ssStart = null; // traverse the structure and listen to the events

        mmtf.traverse(mmtfData, eventCallbacks);

        this._updateSecStructure(this._complex);

        this._updateMolecules(mmtfData);
      } // During traversal atoms and residues don't come sequentially
      // so a residue for certain atom can be unavailable. Thus we
      // store residue index in atom.
      // This function being called after traversal replaces the index
      // with actual reference, and also populates atom lists in residues.

    }, {
      key: "_linkAtomsToResidues",
      value: function _linkAtomsToResidues() {
        for (var i = 0; i < this._complex._atoms.length; ++i) {
          var atom = this._complex._atoms[i];
          var residue = this._complex._residues[atom.residue];
          atom.residue = residue;

          residue._atoms.push(atom);
        }
      }
    }, {
      key: "_findSynonymousChains",
      value: function _findSynonymousChains() {
        var named = {};

        for (var i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!named.hasOwnProperty(name)) {
            named[name] = [];
          }

          named[name].push(chain._index);
        }

        return named;
      } // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.

    }, {
      key: "_parseAssemblyInfo",
      value: function _parseAssemblyInfo(mmtfData) {
        var i;
        var j;
        var k;
        var assemblies = [];
        var logger = this.logger;

        for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
          var baInfo = mmtfData.bioAssemblyList[i];

          if (baInfo.transformList.length === 0) {
            continue;
          }

          var chains = baInfo.transformList[0].chainIndexList;
          var chainListCheck = new ArrayComparator(chains); // build list of chain names

          var chainNames = {};

          for (j = 0; j < chains.length; ++j) {
            chainNames[this._complex._chains[chains[j]].getName()] = 1;
          } // all chains with the same name should belong to assembly if one of them belongs


          var allChains = [];
          var name = void 0;

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              // just concat arrays -- there should be no duplicates
              Array.prototype.push.apply(allChains, this._chainsByName[name]);
            }
          }

          if (!chainListCheck.compare(allChains)) {
            // assembly is missing some of the chains
            logger.debug('MMTF: Assembly is missing some of the synonymous chains. Skipping...');
          }

          var a = new Assembly$2(this._complex); // add chains to assembly

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              a.addChain(name);
            }
          } // add unique matrices to assembly


          a.addMatrix(new THREE.Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());

          for (j = 1; j < baInfo.transformList.length; ++j) {
            var transform = baInfo.transformList[j];

            if (!chainListCheck.compare(transform.chainIndexList)) {
              // list of chains for this transform doesn't match that for other transforms
              // this is illegal in our structure
              logger.debug('MMTF: Chain lists differ for different transforms in one assembly. Skipping...');
              continue;
            }

            var m = new THREE.Matrix4().fromArray(transform.matrix).transpose(); // check if matrix is already in the list

            for (k = 0; k < a.matrices.length; ++k) {
              if (a.matrices[k].equals(m)) {
                break;
              }
            }

            if (k === a.matrices.length) {
              a.addMatrix(m);
            }
          }

          a.finalize();
          assemblies.push(a);
        }

        return assemblies;
      } // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.

    }, {
      key: "_markHeteroAtoms",
      value: function _markHeteroAtoms(mmtfData) {
        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < mmtfData.entityList.length; ++i) {
          var entity = mmtfData.entityList[i];

          if (entity.type !== 'polymer') {
            for (var j = 0; j < entity.chainIndexList.length; ++j) {
              var chainIndex = entity.chainIndexList[j]; // skip chains in models other than the first one

              if (chainIndex >= chainsInModel0) {
                continue;
              }

              var chain = this._complex._chains[chainIndex];

              for (var k = 0; k < chain._residues.length; ++k) {
                var res = chain._residues[k];

                for (var m = 0; m < res._atoms.length; ++m) {
                  res._atoms[m].het = true;
                }
              }
            }
          }
        }
      } // joins chains with the same name into single chain

    }, {
      key: "_joinSynonymousChains",
      value: function _joinSynonymousChains() {
        var i;
        var j;
        var primaryChainsArray = [];
        var primaryChainsHash = {}; // join chains

        for (i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!primaryChainsHash.hasOwnProperty(name)) {
            // new name -- this is a primary chain
            primaryChainsHash[name] = chain;
            chain._index = primaryChainsArray.length; // update index as this array will later replace original chain list

            primaryChainsArray.push(chain);
            continue;
          } // this chain should be joined with the primary chain of the same name


          var primary = primaryChainsHash[name];

          for (j = 0; j < chain._residues.length; ++j) {
            var residue = chain._residues[j];

            primary._residues.push(residue);

            residue._chain = primary;
          }
        } // replace chains list with one containing only primary chains
        // dropping references to all chains but primary


        this._complex._chains = primaryChainsArray;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var mmtfData = mmtf.decode(this._data);
        this._complex = new Complex$3();
        this._serialAtomMap = {}; // filled during traversal

        this._traverse(mmtfData);

        this._linkAtomsToResidues();

        this._markHeteroAtoms(mmtfData);

        this._chainsByName = this._findSynonymousChains();
        Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));

        this._joinSynonymousChains();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        return this._complex;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        // check if it's binary MessagePack format containing a map (dictionary)
        // see https://github.com/msgpack/msgpack/blob/master/spec.md
        return ___default['default'].isArrayBuffer(data) && (getFirstByte(data) | 1) === 0xDF;
      }
    }]);

    return MMTFParser;
  }(Parser);

  MMTFParser.formats = ['mmtf'];
  MMTFParser.extensions = ['.mmtf'];
  MMTFParser.binary = true;

  function _createSuper$1I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1J(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ParsingError = /*#__PURE__*/function (_Error) {
    inherits(ParsingError, _Error);

    var _super = _createSuper$1I(ParsingError);

    function ParsingError(message, line, column) {
      var _this;

      classCallCheck(this, ParsingError);

      _this = _super.call(this, "data:".concat(line, ":").concat(column, ": ").concat(message));

      if (Error.captureStackTrace) {
        Error.captureStackTrace(assertThisInitialized(_this), ParsingError);
      }

      _this.name = 'ParsingError';
      _this.parseLine = line;
      _this.parseColumn = column;
      return _this;
    }

    return ParsingError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function _isWhitespace(ch) {
    return ch === 32 || ch === 10 || ch === 13 || ch === 9;
  }

  function _inlineIndexOf(ch0, str, idx) {
    var len = str.length;
    var ch = -1;

    while (idx < len) {
      ch = str.charCodeAt(idx);

      if (ch === ch0 || ch === 10) {
        break;
      }

      ++idx;
    }

    return ch === ch0 ? idx : -1;
  }

  function readCIF(source) {
    var i = 0;
    var j = 0;
    var n = source.length;
    var code = NaN;
    var newline = true;
    var line = 1;
    var column = 1;
    var begin;
    var state = 0; // 0 - start, 1 - block, 2 - item, 3 - loop, 4 - values, 5 - value

    var result = {};
    var block = {};
    var keys = [];
    var keysCount = 0;
    var key = '';
    var values = [];
    var valuesCount = 0;
    var value;

    function _parseValue() {
      var val;

      if ((code === 46 || code === 63) && (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))) {
        // '.' or '?' .....
        // it's a missing value
        ++column;
        ++i;
        return undefined;
      }

      if (newline && code === 59) {
        // ';' ......................................................................
        // parse multi-line string
        j = i;
        var lines = 0;

        do {
          j = _inlineIndexOf(10, source, j + 1); // '\n'

          if (j === -1) {
            throw new ParsingError('Unterminated text block found', line, column);
          }

          ++lines;
        } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);

        val = source.substring(i + 1, j).replace(/\r/g, '');
        i = j + 2;
        line += lines;
        column = 1;
        newline = false;
        return val;
      }

      if (code === 39 || code === 34) {
        // ''' or '"' ...........................................................
        // parse quoted string
        j = i;

        do {
          j = _inlineIndexOf(code, source, j + 1);

          if (j === -1) {
            throw new ParsingError('Unterminated quoted string found', line, column);
          }
        } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));

        val = source.substring(i + 1, j);
        column += j - i + 1;
        i = j + 1;
        return val;
      } // ......................................................................................................
      // parse until the first whitespace


      j = i;

      while (j < n && !_isWhitespace(source.charCodeAt(j))) {
        ++j;
      }

      val = source.substring(i, j);
      column += j - i;
      i = j; // try to convert to a number

      var num = Number(val);

      if (!Number.isNaN(num)) {
        return num;
      } // or leave as an unquoted string


      return val;
    }

    function _storeKey(tag) {
      keys[keysCount++] = tag;
    }

    function _storeValue(val) {
      var keyIndex = valuesCount % keysCount;
      values[keyIndex].push(val);
      ++valuesCount;
      return val;
    }

    while (i <= n) {
      code = source.charCodeAt(i); // 'NaN' in place of '<eof>'

      if (code === 13) ; else if (code === 10) {
        // '\n' ................................................................................
        // take note of new lines
        newline = true;
        ++line;
        column = 1;
      } else {
        // process inline characters
        if (code === 32 || code === 9) ; else if (code === 35) {
          // '#' ...............................................................................
          // skip the comment until before the end of the line
          i = _inlineIndexOf(10, source, i + 1); // '\n'

          if (i === -1) {
            break;
          } else {
            continue; // don't forget to process the new line
          }
        } else if (state === 0) {
          // start =============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            j = i + 5;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // add new data block
              result[source.substring(begin, i)] = block = {};
              state = 1; // block

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Data block name missing', line, column);
            }
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            break;
          } else {
            // ..................................................................................................
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 1) {
          // block =============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            state = 0; // start

            continue; // parse again in a different state
          } else if (code === 95) {
            // '_' .............................................................................
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // start new item
              key = source.substring(begin, i);
              state = 2; // item

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            // 'loop_' ...
            i += 5;
            column += 5;

            if (i < n && !_isWhitespace(source.charCodeAt(i))) {
              throw new ParsingError("Unexpected character in state ".concat(state), line, column);
            } else {
              // start new loop
              keys = [];
              keysCount = 0;
              values = [];
              valuesCount = 0;
              state = 3; // loop

              continue; // don't forget to process the whitespace
            }
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            break;
          } else {
            // ..................................................................................................
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 2) {
          // item ==============================================================================
          if (Number.isNaN(code)) {
            break;
          }

          value = _parseValue();

          ___default['default'].set(block, key, value);

          state = 1; // block

          continue;
        } else if (state === 3) {
          // loop ==============================================================================
          if (code === 95) {
            // '_' ....................................................................................
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // add new key
              _storeKey(source.substring(begin, i));

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else {
            // ..................................................................................................
            if (keysCount > 0) {
              for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
                value = [];
                values[keyIndex] = value;

                ___default['default'].set(block, keys[keyIndex], value);
              }

              state = 4;
              continue; // parse again in a different state
            }

            throw new ParsingError('Data tags are missing inside a loop', line, column);
          }
        } else if (state === 4) {
          // values ============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            state = 0; // start
          } else if (code === 95) {
            // '_' .............................................................................
            state = 1; // block
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            // 'loop_' ...
            state = 1; // block
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            state = 0;
          } else {
            // ..................................................................................................
            _storeValue(_parseValue());
          }

          continue; // parse again in a different state
        } else {
          // ====================================================================================================
          throw new ParsingError("Unexpected internal state ".concat(state), line, column);
        }

        newline = false;
        ++column;
      }

      ++i;
    }

    if (state === 2) {
      // item
      throw new ParsingError("Unexpected end of file in state ".concat(state), line, column);
    }

    return result;
  }

  function _createSuper$1J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1K(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$4 = chem.Complex,
      Element$5 = chem.Element,
      Helix$3 = chem.Helix,
      Sheet$3 = chem.Sheet,
      Strand$3 = chem.Strand,
      Assembly$3 = chem.Assembly,
      Molecule$3 = chem.Molecule;
  var cRequiredAtomFields = ['auth_seq_id', 'Cartn_x', 'Cartn_y', 'Cartn_z', 'label_atom_id'];
  var cSecondaryCoding = {
    helx: 'helix',
    turn: 'turn',
    strn: 'strand'
  };

  function getTypeFromId(string) {
    var typeId = /[A-Za-z]+/.exec(string);

    if (!typeId) {
      return null;
    }

    return cSecondaryCoding[typeId[0].toLowerCase()];
  }
  /**
   * Make valid object an array
   * @param arrayLikeObject
   * @return {array, object} array or object
   */


  function arrize(arrayLikeObject) {
    if (arrayLikeObject === null || arrayLikeObject === undefined || ___default['default'].isArray(arrayLikeObject)) {
      return arrayLikeObject;
    }

    return [arrayLikeObject];
  }

  function nameToElement$1(name) {
    // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    //
    // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
    //
    // Atom names start with element symbols right-justified in columns 13-14
    // as permitted by the length of the name. For example, the symbol FE for
    // iron appears in columns 13-14, whereas the symbol C for carbon appears
    // in column 14 (see Misaligned Atom Names). If an atom name has four
    // characters, however, it must start in column 13 even if the element
    // symbol is a single character (for example, see Hydrogen Atoms).
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  }

  var AtomDataError = /*#__PURE__*/function (_Error) {
    inherits(AtomDataError, _Error);

    var _super = _createSuper$1J(AtomDataError);

    function AtomDataError(message) {
      var _this;

      classCallCheck(this, AtomDataError);

      _this = _super.call(this);
      _this.name = 'AtomDataError';
      _this.message = message;
      return _this;
    }

    return AtomDataError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function _getOperations(operList) {
    if (!operList) {
      return null;
    }

    var idc = arrize(operList.id);
    var matrix = operList.matrix,
        vector = operList.vector;

    if (!idc || !matrix || !vector) {
      return null;
    }

    var ops = [];

    for (var i = 0, n = idc.length; i < n; ++i) {
      var mtx = new THREE.Matrix4();
      var elements = mtx.elements;

      for (var row = 0; row < 3; ++row) {
        var matrixData = matrix[row + 1];
        elements[row] = arrize(matrixData[1])[i];
        elements[row + 4] = arrize(matrixData[2])[i];
        elements[row + 8] = arrize(matrixData[3])[i];
        elements[row + 12] = arrize(vector[row + 1])[i];
      }

      ops[idc[i]] = mtx;
    }

    return ops;
  }

  function _extractOperations(assemblyGen, opsDict) {
    assemblyGen = ___default['default'].isString(assemblyGen) ? assemblyGen : "".concat(assemblyGen);
    var l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '');
    var groupStr = l.split('!');
    var gps = [];

    for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
      var gr = groupStr[grIdx].split(',');
      var gp = [];
      var idx = 0;

      for (var i = 0, n = gr.length; i < n; ++i) {
        var s = gr[i];

        if (s.includes('-')) {
          var es = s.split('-');
          var j = parseInt(es[0], 10);
          var m = parseInt(es[1], 10);

          for (; j <= m; ++j) {
            gp[idx++] = opsDict[j];
          }
        } else {
          gp[idx++] = opsDict[s];
        }
      }

      gps.push(gp);
    } // traverse all groups from the end of array and make all mults


    var matrices = [];
    var cnt = 0;

    function traverse(level, mtx) {
      for (var ii = 0, nn = gps[level].length; ii < nn; ++ii) {
        var newMtx = mtx ? mtx.clone() : new THREE.Matrix4();
        newMtx.multiplyMatrices(gps[level][ii], newMtx);

        if (level === 0) {
          matrices[cnt++] = newMtx;
        } else {
          traverse(level - 1, newMtx);
        }
      }
    }

    traverse(gps.length - 1);
    return matrices;
  }

  var CIFParser = /*#__PURE__*/function (_Parser) {
    inherits(CIFParser, _Parser);

    var _super2 = _createSuper$1J(CIFParser);

    function CIFParser(data, options) {
      var _this2;

      classCallCheck(this, CIFParser);

      _this2 = _super2.call(this, data, options);
      _this2.asymDict = {};
      _this2.molecules = [];
      _this2._options.fileType = 'cif';
      return _this2;
    }

    createClass(CIFParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing CIF file..');
        var data = readCIF(this._data);
        return this._toComplex(data);
      }
      /**
       * Convert intermediate structure into our valid Complex object
       * @param cifData intermediate CIF object
       * @returns {Complex} complex
       * @private
       */

    }, {
      key: "_toComplex",
      value: function _toComplex(cifData) {
        var complex = new Complex$4();
        var complexData = cifData[Object.keys(cifData)[0]];

        this._extractAtoms(complex, complexData);

        this._extractSecondary(complex, complexData);

        this._extractAssemblies(complex, complexData);

        this._extractMolecules(complex, complexData);

        this._extractMetadata(complex, complexData);

        complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing
        });
        return complex;
      }
      /**
       * Extract metadata
       * @param complex structure to fill
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractMetadata",
      value: function _extractMetadata(complex, complexData) {
        var metadata = complex.metadata;
        metadata.id = complexData.entry.id;
        metadata.classification = complexData.struct_keywords.pdbx_keywords;
        var databaserev = complexData.database_PDB_rev;
        metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : '';
        metadata.format = 'cif';
        metadata.title = [];
        metadata.title[0] = complexData.struct.title;
      }
      /**
       * Extract molecules information from CIF structure (should be called strictly after _extractAtoms)
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractMolecules",
      value: function _extractMolecules(complex, complexData) {
        var molData = complexData.entity;
        var names = arrize(molData.pdbx_description);
        var count = names.length;
        var i; // molecules names from cif

        for (i = 0; i < count; i++) {
          if (this.molecules[i]) {
            // molecule was created during atoms processing
            this.molecules[i].name = names[i];
          } else {
            // molecule wasn't created, because there is no atom which is contained
            this.molecules[i] = {
              name: names[i],
              residues: []
            };
          }
        } // reorganize molecules for complex and check chains


        var molecules = complex.getMolecules();

        for (i = 0; i < count; i++) {
          var molecule = this.molecules[i];
          molecules[i] = new Molecule$3(complex, molecule.name, i + 1);
          molecules[i].residues = molecule.residues;
        }
      }
      /**
       * Extract atom information from CIF structure and fill complex
       * @param {Complex} complex
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var atomData = complexData.atom_site;

        if (!atomData) {
          throw new AtomDataError('CIF parsing error: atom_site is not specified!');
        }

        for (var f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
          if (!atomData[cRequiredAtomFields[f]]) {
            throw new AtomDataError("CIF parsing error: requires field ".concat(cRequiredAtomFields[f], " not found!"));
          }
        }

        var asymDict = this.asymDict; // required fields

        var resIdc = arrize(atomData.auth_seq_id);
        var x = arrize(atomData.Cartn_x);
        var y = arrize(atomData.Cartn_y);
        var z = arrize(atomData.Cartn_z);
        var names = arrize(atomData.label_atom_id);
        var count = names.length; // optional fields

        var group = arrize(atomData.group_PDB) || [];
        var chainIdc = arrize(atomData.auth_asym_id) || [];
        var chainLabelIdc = arrize(atomData.label_asym_id) || [];
        var serials = arrize(atomData.id) || [];
        var iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
        var resNames = arrize(atomData.label_comp_id) || [];
        var elements = arrize(atomData.type_symbol) || [];
        var tempFactors = arrize(atomData.B_iso_or_equiv) || [];
        var occupancies = arrize(atomData.occupancy) || [];
        var charges = arrize(atomData.pdbx_formal_charge) || [];
        var altLocs = arrize(atomData.label_alt_id) || [];
        var models = arrize(atomData.pdbx_PDB_model_num) || [];
        var molecules = arrize(atomData.label_entity_id) || [];
        var chain = null;
        var residue = null;

        for (var i = 0; i < count; ++i) {
          var model = models[i] || 1;

          if (model !== 1) {
            continue;
          }

          var chainID = String(chainIdc[i] || ' ');

          if (!chain || chain.getName() !== chainID) {
            chain = complex.getChain(chainID) || complex.addChain(chainID);
          }

          asymDict[String(chainLabelIdc[i] || ' ')] = chainID;
          var resSeq = resIdc[i];
          var iCode = String(iCodes[i] || ' ');
          var resName = String(resNames[i] || '');

          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            residue = chain.addResidue(resName, resSeq, iCode); // store residue in appropriate molecule

            var moleculeIdx = molecules[i] - 1;
            var entity = this.molecules[moleculeIdx];

            if (!entity) {
              // create new molecule if it hasn't been created
              this.molecules[moleculeIdx] = {
                name: '',
                residues: []
              };
              entity = this.molecules[moleculeIdx];
            }

            entity.residues.push(residue);
          }

          var name = names[i];
          var element = elements[i] || nameToElement$1(name);
          var type = Element$5.getByName(element);
          var role = Element$5.Role[name.trim()];
          var xyz = new THREE.Vector3(x[i], y[i], z[i]);
          var het = group[i] === 'HETATM' || false;
          var serial = serials[i] || i;
          var tempFactor = tempFactors[i] || 0.0;
          var occupancy = occupancies[i] || 0.0;
          var altLoc = String(altLocs[i] || '');
          var charge = charges[i] || 0;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }
      }
      /**
       * Extracts secondary structure information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex - complex to fill
       * @param complexData - CIF complex data
       * @private
       */

    }, {
      key: "_extractSecondary",
      value: function _extractSecondary(complex, complexData) {
        if (complexData.struct_conf) {
          this._extractConfs(complex, complexData.struct_conf);
        }

        if (complexData.struct_sheet_range) {
          this._extractSheets(complex, complexData.struct_sheet_range);
        }
      }
      /**
       * Extracts sheets information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex
       * @param sheetData
       * @private
       */

    }, {
      key: "_extractSheets",
      value: function _extractSheets(complex, sheetData) {
        var asymDict = this.asymDict;

        if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
          return;
        } // Strand(sheet, start, end, sense, cur, prev)


        var sheets = complex._sheets;

        function getSheet(name) {
          var n = sheets.length;

          for (var i = 0; i < n; ++i) {
            if (sheets[i]._name === name) {
              return sheets[i];
            }
          }

          sheets[n] = new Sheet$3(name, 0);
          return sheets[n];
        }

        var sheetNames = arrize(sheetData.sheet_id);
        var strandNames = arrize(sheetData.id);
        var starts = arrize(sheetData.beg_auth_seq_id);
        var ends = arrize(sheetData.end_auth_seq_id);
        var chains = arrize(sheetData.beg_label_asym_id);
        var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
        var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];

        for (var i = 0, n = strandNames.length; i < n; ++i) {
          var chain = complex.getChain(asymDict[chains[i]]);
          var sheet = getSheet(sheetNames[i]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode); // TODO think about last condition

          if (!start || !end) {
            continue;
          }

          var strand = new Strand$3(sheet, start[0], end[0], 0, null, null);
          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = strand;
          }

          sheet.addStrand(strand);
          complex.structures.push(strand);
        }
      }
      /**
       * Extracts helix/turn/strand(?) information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex
       * @param helicesData
       * @private
       */

    }, {
      key: "_extractConfs",
      value: function _extractConfs(complex, helicesData) {
        var asymDict = this.asymDict;

        if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
          return;
        }

        var types = arrize(helicesData.conf_type_id);
        var starts = arrize(helicesData.beg_auth_seq_id);
        var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
        var ends = arrize(helicesData.end_auth_seq_id);
        var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
        var comments = arrize(helicesData.details) || [];
        var lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
        var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
        var names = arrize(helicesData.id) || [];
        var chains = arrize(helicesData.beg_label_asym_id);

        for (var i = 0, n = types.length; i < n; ++i) {
          var type = getTypeFromId(types[i]);

          if (!type) {
            continue;
          }

          var name = names[i] || types[i];
          var chain = complex.getChain(asymDict[chains[i]]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode); // TODO think about last condition

          if (!start || !end) {
            continue;
          }

          var comment = comments[i] || '';
          var length = lengths[i] || 0;
          var helixClass = helixClasses[i] || ' ';
          var struct = void 0;

          if (type === 'helix') {
            var idx = complex._helices.length;
            struct = new Helix$3(helixClass, start[0], end[0], idx, name, comment, length);
            complex.addHelix(struct);
            complex.structures.push(struct);
          } else if (type === 'turn') {
            struct = new StructuralElement(StructuralElement.Type.TURN, start[0], end[0]);
            complex.structures.push(struct);
          } else {
            struct = null;
          }

          if (!struct) {
            continue;
          }

          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = struct;
          }
        }
      }
      /**
       * Extract biological assemblies information from CIF structure and fill complex
       * @param {Complex} complex
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractAssemblies",
      value: function _extractAssemblies(complex, complexData) {
        var asymDict = this.asymDict;
        var asmGen = complexData.pdbx_struct_assembly_gen;

        if (!asmGen) {
          return;
        }

        var asmIdx = arrize(asmGen.assembly_id);
        var asmOper = arrize(asmGen.oper_expression);
        var asmList = arrize(asmGen.asym_id_list);

        if (!asmIdx || !asmOper || !asmList) {
          return;
        }

        var operList = _getOperations(complexData.pdbx_struct_oper_list);

        if (!operList) {
          return;
        }

        for (var i = 0, n = asmIdx.length; i < n; ++i) {
          var asm = new Assembly$3(complex);

          var assemblyOps = _extractOperations(asmOper[i], operList);

          var entries = asmList[i].split(',');

          for (var ii = 0, nn = entries.length; ii < nn; ++ii) {
            var chain = entries[ii].trim();

            if (chain.length > 0) {
              asm.addChain(asymDict[chain]);
            }
          }

          asm.matrices = assemblyOps;
          complex.units.push(asm);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && /^\s*data_/i.test(data);
      }
    }]);

    return CIFParser;
  }(Parser);

  CIFParser.formats = ['cif', 'mmcif'];
  CIFParser.extensions = ['.cif', '.mmcif'];

  var valueType = {
    singular: 0,
    vector: 1,
    array: 2,
    buffer: 3
  };

  var VolumeModel = /*#__PURE__*/function () {
    function VolumeModel() {
      classCallCheck(this, VolumeModel);

      defineProperty(this, "_xyz2crs", []);

      defineProperty(this, "_origin", new THREE.Vector3(0, 0, 0));

      this._header = {};
      this._boxSize = new THREE.Vector3();
      this._boxStart = new THREE.Vector3();
      this._header.delta = {};
      this._header.extent = [];
      this._header.nstart = [];
      this._header.grid = [];
      this._header.crs2xyz = [];
      this._header.cellDims = new THREE.Vector3();
      this._header.angles = [];
      this._header.origin = new THREE.Vector3(0, 0, 0);
      this._header.dmin = 0;
      this._header.dmean = 0;
      this._header.dmax = 0;
    }

    createClass(VolumeModel, [{
      key: "_typedCheck",
      value: function _typedCheck() {
        if (___default['default'].isTypedArray(this._buff)) {
          this._buff = this._buff.buffer;
        } else if (!___default['default'].isArrayBuffer(this._buff)) {
          throw new TypeError('Expected ArrayBuffer or TypedArray');
        }
      }
    }, {
      key: "_fillHeader",
      value: function _fillHeader(headerFormat, arrays) {
        for (var key in headerFormat) {
          if (headerFormat.hasOwnProperty(key)) {
            switch (headerFormat[key][0]) {
              case valueType.singular:
                this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
                break;

              case valueType.array:
                this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.vector:
                this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.buffer:
                this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
                break;
            }
          }
        }
      }
    }, {
      key: "_parseVector",
      value: function _parseVector(vector, arr, pos) {
        var _ref = [arr[pos], arr[pos + 1], arr[pos + 2]];
        vector.x = _ref[0];
        vector.y = _ref[1];
        vector.z = _ref[2];
      }
    }, {
      key: "_parseArray",
      value: function _parseArray(vector, arr, pos) {
        vector[0] = arr[pos];
        vector[1] = arr[pos + 1];
        vector[2] = arr[pos + 2];
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {}
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {}
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {}
    }, {
      key: "_getAxis",
      value: function _getAxis() {
        var header = this._header;
        var xScale = header.cellDims.x / header.grid[0];
        var yScale = header.cellDims.y / header.grid[1];
        var zScale = header.cellDims.z / header.grid[2];

        var _header$angles = slicedToArray(header.angles, 3),
            alpha = _header$angles[0],
            beta = _header$angles[1],
            gamma = _header$angles[2];

        var z1 = Math.cos(beta);
        var z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
        var z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
        var xaxis = new THREE.Vector3(xScale, 0, 0);
        var yaxis = new THREE.Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
        var zaxis = new THREE.Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
        return [xaxis, yaxis, zaxis];
      }
    }, {
      key: "_getXYZdim",
      value: function _getXYZdim() {
        return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
      }
    }, {
      key: "_getVolumeInfo",
      value: function _getVolumeInfo() {
        var volInfo = ___default['default'].pick(this._header, ['dmean', 'dmin', 'dmax', 'sd', 'delta']);

        volInfo.obtuseAngle = this._header.angles.map(function (angle) {
          return Number(angle >= Math.PI / 2);
        });
        return volInfo;
      }
    }, {
      key: "_setBoxParams",
      value: function _setBoxParams(xaxis, yaxis, zaxis) {
        var _this = this;

        // if axes are not orthogonal, the origins might not match with box coordinates - need to make shift
        var shiftX = 0;
        var shiftY = 0;

        var _this$_header$angles = slicedToArray(this._header.angles, 3),
            alpha = _this$_header$angles[0],
            beta = _this$_header$angles[1],
            gamma = _this$_header$angles[2];

        if (gamma >= Math.PI / 2) {
          shiftX += Math.abs(yaxis.x);
        }

        if (beta >= Math.PI / 2) {
          shiftX += Math.abs(zaxis.x);
        }

        if (alpha >= Math.PI / 2) {
          shiftY += Math.abs(zaxis.y);
        }

        this._boxStart = new THREE.Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
        this._boxSize = new THREE.Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));

        var delta = function delta(axe, proj) {
          return Math.abs(axe[proj]) / _this._boxSize[proj];
        };

        this._header.delta.x = delta(yaxis, 'x');
        this._header.delta.y = delta(zaxis, 'x');
        this._header.delta.z = delta(zaxis, 'y');
      }
    }, {
      key: "_getXYZbox",
      value: function _getXYZbox() {
        return new THREE.Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {}
    }, {
      key: "parse",
      value: function parse(data) {
        this._parseHeader(data);

        this._setOrigins();

        return new Volume(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
      }
    }]);

    return VolumeModel;
  }();

  function _createSuper$1K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1L(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var CCP4Header = {
    extent: [valueType.array, 'u32', 0],
    type: [valueType.singular, 'u32', 3],
    nstart: [valueType.array, 'i32', 4],
    grid: [valueType.array, 'u32', 7],
    cellDims: [valueType.vector, 'f32', 10],
    angles: [valueType.array, 'f32', 13],
    crs2xyz: [valueType.array, 'i32', 16],
    dmin: [valueType.singular, 'f32', 19],
    dmax: [valueType.singular, 'f32', 20],
    dmean: [valueType.singular, 'f32', 21],
    ispg: [valueType.singular, 'u32', 22],
    nsymbt: [valueType.singular, 'u32', 23],
    lksflg: [valueType.singular, 'u32', 24],
    customData: [valueType.buffer, 'buffer', 25, 9],
    origin: [valueType.vector, 'f32', 34],
    map: [valueType.buffer, 'buffer', 52, 1],
    machine: [valueType.singular, 'u32', 53],
    sd: [valueType.singular, 'f32', 54],
    nlabel: [valueType.singular, 'f32', 55],
    label: [valueType.buffer, 'buffer', 56, 200]
  };

  var Ccp4Model = /*#__PURE__*/function (_VolumeModel) {
    inherits(Ccp4Model, _VolumeModel);

    var _super = _createSuper$1K(Ccp4Model);

    function Ccp4Model() {
      classCallCheck(this, Ccp4Model);

      return _super.apply(this, arguments);
    }

    createClass(Ccp4Model, [{
      key: "_parseHeader",
      // read header (http://www.ccp4.ac.uk/html/maplib.html)
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.u32 = new Uint32Array(this._buff, 0, 56);
        arrays.i32 = new Int32Array(this._buff, 0, 56);
        arrays.f32 = new Float32Array(this._buff, 0, 56);
        arrays.buffer = this._buff;
        var header = this._header;

        this._fillHeader(CCP4Header, arrays); // calculate non-orthogonal unit cell coordinates


        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0;
        });
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        var header = this._header;

        if (header.cellDims.x === 0.0 && header.cellDims.y === 0.0 && header.cellDims.z === 0.0) {
          header.cellDims.set(1.0, 1.0, 1.0);
        } // Apply header conversion
        // Mapping between CCP4 column, row, section and VMD x, y, z.


        var crs2xyz = this._header.crs2xyz;

        if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
          crs2xyz[0] = 1;
          crs2xyz[1] = 2;
          crs2xyz[2] = 3;
        }

        var xyz2crs = this._xyz2crs;
        xyz2crs[crs2xyz[0] - 1] = 0; // column

        xyz2crs[crs2xyz[1] - 1] = 1; // row

        xyz2crs[crs2xyz[2] - 1] = 2; // section
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        var header = this._header;
        var xyz2crs = this._xyz2crs; // Handle both MRC-2000 and older format maps

        if (header.origin.x === 0.0 && header.origin.y === 0.0 && header.origin.z === 0.0) {
          this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);

          this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);

          this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
        } else {
          this._origin = header.origin; // Use ORIGIN records rather than old n[xyz]start records
          //   http://www2.mrc-lmb.cam.ac.uk/image2000.html
          // XXX the ORIGIN field is only used by the EM community, and
          // has undefined meaning for non-orthogonal maps and/or non-cubic voxels, etc.
        }

        xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
        yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
        zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);

        if (header.type === 2) {
          this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
        } else {
          throw new Error("CCP4: Unsupported format ".concat(header.type));
        }

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var data = this._data;
        var xyz2crs = this._xyz2crs;
        var xyzData = new Float32Array(data.length);

        var dim = this._getXYZdim();

        var xSize = dim[0];
        var ySize = dim[1];
        var crsIdx = 0;
        var coord = [];
        var x;
        var y;
        var z;

        for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
          // Site
          for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
            // Row
            for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
              // Column
              x = coord[xyz2crs[0]];
              y = coord[xyz2crs[1]];
              z = coord[xyz2crs[2]];
              xyzData[x + xSize * (y + ySize * z)] = data[crsIdx];
            }
          }
        }

        return xyzData;
      }
    }]);

    return Ccp4Model;
  }(VolumeModel);

  var CCP4Parser = /*#__PURE__*/function (_Parser) {
    inherits(CCP4Parser, _Parser);

    var _super2 = _createSuper$1K(CCP4Parser);

    function CCP4Parser(data, options) {
      var _this;

      classCallCheck(this, CCP4Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'ccp4';
      _this.model = new Ccp4Model();
      return _this;
    }

    createClass(CCP4Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false; // Autodetection is not implemented yet
      }
    }]);

    return CCP4Parser;
  }(Parser);

  CCP4Parser.formats = ['ccp4'];
  CCP4Parser.extensions = ['.ccp4', '.map', '.mrc'];
  CCP4Parser.binary = true;

  function _createSuper$1L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1M(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$5 = chem.Complex,
      Element$6 = chem.Element,
      Molecule$4 = chem.Molecule;

  var XYZParser = /*#__PURE__*/function (_Parser) {
    inherits(XYZParser, _Parser);

    var _super = _createSuper$1L(XYZParser);

    function XYZParser(data, options) {
      var _this;

      classCallCheck(this, XYZParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._atomsInf = null;
      _this._options.fileType = 'xyz';
      _this._fileName = options.name;
      return _this;
    }

    createClass(XYZParser, [{
      key: "_parseToAtomsInf",
      value: function _parseToAtomsInf(source) {
        var endnAtoms = source.indexOf('\n');
        var nAtoms = parseInt(source.substring(0, endnAtoms), 10);
        var endComment = source.indexOf('\n', endnAtoms + 1);
        var comment = source.slice(endnAtoms + 1, endComment).trim();

        if (comment.length === 0) {
          comment = this._fileName;
        }

        var startAtomsInf = endComment + source.substring(endComment).search(/\S/);
        this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);

        if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
          this._complex.error = {
            message: 'wrong number of atoms'
          };
          return;
        }

        this._complex.metadata.format = 'xyz';
        this._complex.name = comment;
      }
    }, {
      key: "_parseAtomsInf",
      value: function _parseAtomsInf() {
        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;

        var chain = this._complex.addChain('A');

        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0; i < this._atomsInf.length - 1; i++) {
          var words = this._atomsInf[i].split(/[\s,]+/);

          if (words.length !== 4) {
            this._complex.error = {
              message: 'missed parameters'
            };
            break;
          }

          var serial = i + 1;
          var name = words[0];
          var xyz = new THREE.Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
          var type = Element$6.getByName(name);
          var role = undefined;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }

        var molecule = new Molecule$4(this._complex, this._complex.name, 1);
        molecule.residues = residue;
        this._complex._molecules[0] = molecule;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$5();

        this._parseToAtomsInf(this._data);

        this._parseAtomsInf();

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        this._complex = null;
        this._atomsInf = null;

        if (result.error) {
          throw new Error(result.error.message);
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
      }
    }]);

    return XYZParser;
  }(Parser);

  defineProperty(XYZParser, "formats", ['xyz']);

  defineProperty(XYZParser, "extensions", ['.xyz']);

  function _createSuper$1M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1N(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$6 = chem.Complex,
      Element$7 = chem.Element;

  var PubChemParser = /*#__PURE__*/function (_Parser) {
    inherits(PubChemParser, _Parser);

    var _super = _createSuper$1M(PubChemParser);

    function PubChemParser(data, options) {
      var _this;

      classCallCheck(this, PubChemParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'pubchem+json';
      return _this;
    }

    createClass(PubChemParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing PubChem JSON file...');
        return this._toComplex(JSON.parse(this._data));
      }
    }, {
      key: "_toComplex",
      value: function _toComplex(jsonData) {
        var complex = new Complex$6();
        var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];

        if (complexData) {
          this._extractAtoms(complex, complexData);

          complex.finalize({
            needAutoBonding: false,
            detectAromaticLoops: this.settings.now.aromatic,
            enableEditing: this.settings.now.editing
          });
        }

        return complex;
      }
    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var aids = complexData.atoms && complexData.atoms.aid;
        var elements = aids && complexData.atoms.element;

        if (!elements || aids.length !== elements.length) {
          throw new Error('Unable to parse atom elements');
        }

        elements = ___default['default'].fromPairs(___default['default'].zip(aids, elements));
        var atoms = {};
        var coords = complexData.coords && complexData.coords[0];
        var model = coords && coords.conformers && coords.conformers[0];
        var xs = model && model.x;
        var ys = model && model.y;
        var zs = model && model.z || [];
        aids = coords && coords.aid;

        if (!aids || !xs || !ys) {
          throw new Error('Coordinates are not found in the file');
        }

        var chain = complex.addChain(' ');
        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0, n = aids.length; i < n; ++i) {
          var aid = aids[i];
          var element = Element$7.ByAtomicNumber[elements[aid]];
          var xyz = new THREE.Vector3(xs[i], ys[i], zs[i] || 0.0);
          atoms[aid] = residue.addAtom(element.name, element, xyz, undefined, true, aid, ' ', 1.0, 0.0, 0);
        }

        var aids1 = complexData.bonds && complexData.bonds.aid1;
        var aids2 = complexData.bonds && complexData.bonds.aid2;
        var orders = complexData.bonds && complexData.bonds.order || [];

        if (!aids1 || !aids2 || aids1.length !== aids2.length) {
          return;
        }

        for (var j = 0, m = aids1.length; j < m; ++j) {
          complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && data[0] === '{';
      }
    }]);

    return PubChemParser;
  }(Parser);

  PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc'];
  PubChemParser.extensions = ['.json'];

  var SDFStream = /*#__PURE__*/function () {
    function SDFStream(data) {
      classCallCheck(this, SDFStream);

      this._strings = data.split(/\r?\n|\r/);
      this._currentStart = 0;
      this._currentStringIndx = 0;
    }

    createClass(SDFStream, [{
      key: "setStart",
      value: function setStart(start) {
        if (start >= this._strings.length) {
          this._currentStart = this._strings.length - 1;
          this._currentStringIndx = this._strings.length - 1;
        } else {
          this._currentStart = start;
          this._currentStringIndx = start;
        }
      }
    }, {
      key: "getNextString",
      value: function getNextString() {
        return this._strings[++this._currentStringIndx];
      }
    }, {
      key: "getCurrentString",
      value: function getCurrentString() {
        return this._strings[this._currentStringIndx];
      }
    }, {
      key: "getStringFromStart",
      value: function getStringFromStart(numb) {
        this._currentStringIndx = this._currentStart + numb;
        return this._strings[this._currentStart + numb];
      }
    }, {
      key: "findNextDataItem",
      value: function findNextDataItem() {
        var curStr = this.getNextString();
        var res = false;

        while (!___default['default'].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          if (curStr.match(/>\s+<(.*)>/)) {
            res = true;
            break;
          }

          curStr = this.getNextString();
        }

        return res;
      }
    }, {
      key: "findNextCompoundStart",
      value: function findNextCompoundStart() {
        var curStr = this.getCurrentString();

        while (!___default['default'].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          curStr = this.getNextString();
        }

        this.setStart(++this._currentStringIndx);
        return this.probablyHaveDataToParse();
      }
    }, {
      key: "probablyHaveDataToParse",
      value: function probablyHaveDataToParse() {
        return this._currentStringIndx < this._strings.length - 2;
      }
    }]);

    return SDFStream;
  }();

  function _createSuper$1N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1O(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$7 = chem.Complex,
      Element$8 = chem.Element,
      Bond$4 = chem.Bond,
      Molecule$5 = chem.Molecule;
  var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
  var orderMap = [0, 1, 2, 3, 1, 1, 1, 2];
  var typeMap = [Bond$4.BondType.UNKNOWN, // 0 - error
  Bond$4.BondType.COVALENT, // 1 - single
  Bond$4.BondType.COVALENT, // 2 - double
  Bond$4.BondType.COVALENT, // 3 - triple
  Bond$4.BondType.AROMATIC, // 4 - aromatic
  Bond$4.BondType.UNKNOWN, // 5 - single or double
  Bond$4.BondType.AROMATIC, // 6 - single or aromatic
  Bond$4.BondType.AROMATIC // 7 - double or aromatic
  // 8 - any
  // 9 - coordination
  // 10 - hydrogen
  ];
  var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
  var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
  var fileFormat = {
    SDF: 'sdf',
    MOL: 'mol'
  };
  var possibleNameTags = ['PUBCHEM_IUPAC_TRADITIONAL_NAME', /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
  var possibleIDTags = ['PUBCHEM_COMPOUND_CID', 'id', 'ID', /.*CID/, /.*ID/, /.*id/];
  var possibleTitleTags = ['msg', 'MSG', 'message', 'title', 'description', 'desc'];
  var tagsNames = ['name', 'id', 'title'];
  var tags = {
    name: possibleNameTags,
    id: possibleIDTags,
    title: possibleTitleTags
  };

  function buildChainID(index) {
    if (!index) {
      return 'A';
    }

    var codes = [];

    while (index) {
      codes.push(65 + index % 26);
      index = Math.trunc(index / 26);
    }

    if (codes.length > 1) {
      codes.reverse();
      codes[0] -= 1;
    }

    return String.fromCharCode.apply(String, codes);
  }

  var SDFParser = /*#__PURE__*/function (_Parser) {
    inherits(SDFParser, _Parser);

    var _super = _createSuper$1N(SDFParser);

    function SDFParser(data, options) {
      var _this;

      classCallCheck(this, SDFParser);

      _this = _super.call(this, data, options);
      _this._format = 'sdf';
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._molecules = null;
      _this._metadata = {};
      _this._metadata.molecules = [];
      _this._currentMolProps = {};
      _this._compoundIndx = -1;
      _this._assemblies = [];
      _this._atomsParsed = 0;
      _this._atomsIndexes = [];
      return _this;
    }

    createClass(SDFParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && sdfAndMolRegexp.test(data);
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(stream) {
        var molecule = {};
        molecule.name = stream.getStringFromStart(0);
        var date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
        molecule.date = date.toString() || '';
        molecule.title = stream.getStringFromStart(2);

        this._metadata.molecules.push(molecule);
      }
    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(stream, atomsNum) {
        var curStr;
        var serial = this._atomsParsed; // each molecule = chain\residue

        var chainID = buildChainID(this._compoundIndx);
        var resName = 'UNK';
        var resSeq = 1;
        this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
        this._residue = this._chain.addResidue(resName, resSeq, ' ');

        for (var i = 0; i < atomsNum; i++) {
          curStr = stream.getNextString();
          serial++;
          var x = parseFloat(curStr.substr(0, 10));
          var y = parseFloat(curStr.substr(10, 10));
          var z = parseFloat(curStr.substr(20, 10));
          var charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
          var xyz = new THREE.Vector3(x, y, z);
          var name = curStr.substr(31, 3).trim().toUpperCase();
          var type = Element$8.getByName(name);

          if (!this._atomsIndexes[name]) {
            this._atomsIndexes[name] = 0;
          }

          this._atomsIndexes[name] += 1;
          name += this._atomsIndexes[name]; // every atom need to have unique name.

          this._residue.addAtom(name, type, xyz, undefined, true, serial, ' ', 1.0, 0.0, charge);
        }
      }
    }, {
      key: "_parseBonds",
      value: function _parseBonds(stream, bondsNum) {
        var curStr;

        for (var i = 0; i < bondsNum; i++) {
          curStr = stream.getNextString();

          var atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;

          var atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;

          var bondType = parseInt(curStr.substr(6, 3), 10);

          if (atom1 > atom2) {
            var _ref = [atom2, atom1];
            atom1 = _ref[0];
            atom2 = _ref[1];
          }

          this._complex.addBond(atom1, atom2, orderMap[bondType] || 1, typeMap[bondType] || Bond$4.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseMOL",
      value: function _parseMOL(stream) {
        this._compoundIndx++;

        this._parseHeader(stream);

        var countsLine = stream.getStringFromStart(3);
        var atomsNum = parseInt(countsLine.substr(0, 3), 10);
        var bondsNum = parseInt(countsLine.substr(3, 3), 10);

        this._parseAtoms(stream, atomsNum);

        this._parseBonds(stream, bondsNum);

        this._atomsParsed += atomsNum;
        this._metadata.molecules[this._compoundIndx]._residues = [];

        this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
      }
    }, {
      key: "_parseDataItem",
      value: function _parseDataItem(stream) {
        var tag = stream.getCurrentString();
        var data = [];
        var curStr = stream.getNextString(); // read data

        while (curStr.trim() !== '') {
          data.push(curStr);
          curStr = stream.getNextString();
        }

        if (data.length === 1) {
          var _data = data;

          var _data2 = slicedToArray(_data, 1);

          data = _data2[0];
        }

        this._currentMolProps[tag.replace(/[<>]/g, '').trim()] = data;
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(stream) {
        this._parseMOL(stream); // parse data items block


        if (this._format === fileFormat.SDF) {
          this._currentMolProps = {};

          while (stream.findNextDataItem()) {
            this._parseDataItem(stream);
          }

          if (Object.keys(this._currentMolProps).length !== 0) {
            var molecule = this._metadata.molecules[this._compoundIndx];
            molecule.props = this._currentMolProps;

            this._tryToUpdateMoleculeData(molecule);
          }
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;
        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            console.log('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_buildAssemblies",
      value: function _buildAssemblies() {
        var chains = this._complex._chains;

        if (chains.length === 1) {
          return this._assemblies;
        }

        for (var i = 0; i < chains.length; i++) {
          var assembly = new Assembly(this._complex);
          var matrix = new THREE.Matrix4();
          assembly.addMatrix(matrix);
          assembly.addChain(chains[i]._name);

          this._assemblies.push(assembly);
        }

        return this._assemblies;
      }
    }, {
      key: "_buildMolecules",
      value: function _buildMolecules() {
        this._complex._molecules = [];
        var molecules = this._metadata.molecules;

        for (var i = 0; i < molecules.length; i++) {
          var molecule = new Molecule$5(this._complex, molecules[i].name, i + 1);
          molecule.residues = molecules[i]._residues;
          this._complex._molecules[i] = molecule;
        }

        return this._complex._molecules;
      }
    }, {
      key: "_searchTag",
      value: function _searchTag(tag, props) {
        for (var i = 0; i < props.length; i++) {
          if (tag instanceof RegExp && tag.test(props[i].tag) || tag === props[i].tag) {
            return props[i].data;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToFind",
      value: function _tryToFind(tagsList, props) {
        for (var j = 0; j < tagsList.length; j++) {
          var res = this._searchTag(tagsList[j], props);

          if (res) {
            return res;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToUpdateMoleculeData",
      value: function _tryToUpdateMoleculeData(molecule) {
        var res = false;

        for (var i = 0; i < tagsNames.length; i++) {
          var tagPossibleNames = tags[tagsNames[i]];

          var data = this._tryToFind(tagPossibleNames, molecule.props);

          if (data) {
            molecule[tagsNames[i]] = data;
            res = true;
          }
        }

        molecule.name = molecule.name || molecule.id;

        if (molecule.name.match(/^\d+$/)) {
          molecule.name = "CID: ".concat(molecule.name);
        }

        return res;
      }
    }, {
      key: "_finalizeMetadata",
      value: function _finalizeMetadata() {
        var molecules = this._metadata.molecules;
        var metadata = this._complex.metadata;
        var complex = this._complex;

        if (molecules.length === 1) {
          complex.name = molecules[0].name;
          metadata.title = molecules[0].title;
          metadata.date = molecules[0].date;
          metadata.properties = molecules[0].props;
        } else if (molecules.length > 1) {
          metadata.molecules = [];

          for (var i = 0; i < molecules.length; i++) {
            metadata.molecules.push({
              name: molecules[i].name,
              date: molecules[i].date,
              title: molecules[i].title,
              properties: molecules[i].props
            });
          }
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var serialAtomMap = this._serialAtomMap = {};
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        this._complex._finalizeBonds();

        this._fixBondsArray();

        this._finalizeMetadata();

        this._buildAssemblies();

        this._complex.units = this._complex.units.concat(this._assemblies);

        this._buildMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: false,
          enableEditing: false,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "defineFormat",
      value: function defineFormat(data) {
        var format;

        if (sdfRegExp.test(data)) {
          format = fileFormat.SDF;
        } else {
          format = fileFormat.MOL;
        }

        return format;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$7();
        var stream = new SDFStream(this._data);
        this._format = this.defineFormat(this._data);
        result.metadata.format = this._format;

        do {
          this._parseCompound(stream);
        } while (stream.findNextCompoundStart());

        this._finalize();

        return result;
      }
    }]);

    return SDFParser;
  }(Parser);
  SDFParser.formats = ['mol', 'sdf'];
  SDFParser.extensions = ['.mol', '.sdf'];

  function _createSuper$1O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1P(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var DSN6Header = {
    nstart: [valueType.array, 'i16', 0],
    extent: [valueType.array, 'i16', 3],
    grid: [valueType.array, 'i16', 6],
    cellDims: [valueType.vector, 'i16', 9],
    angles: [valueType.array, 'i16', 12],
    div: [valueType.singular, 'i16', 15],
    adder: [valueType.singular, 'i16', 16],
    scaleFactor: [valueType.singular, 'i16', 17]
  };

  var DSN6Model = /*#__PURE__*/function (_VolumeModel) {
    inherits(DSN6Model, _VolumeModel);

    var _super = _createSuper$1O(DSN6Model);

    function DSN6Model() {
      classCallCheck(this, DSN6Model);

      return _super.apply(this, arguments);
    }

    createClass(DSN6Model, [{
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.i16 = new Int16Array(this._buff); // check and reverse if big endian

        if (arrays.i16[18] !== 100) {
          for (var i = 0, n = arrays.i16.length; i < n; ++i) {
            var val = arrays.i16[i];
            arrays.i16[i] = (val & 0xff) << 8 | val >> 8 & 0xff;
          }
        }

        if (arrays.i16[18] !== 100) {
          throw new Error('DSN6: Incorrect format ');
        }

        var header = this._header;

        this._fillHeader(DSN6Header, arrays);

        header.cellDims.multiplyScalar(1.0 / header.scaleFactor);
        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0 / header.scaleFactor;
        });
        header.div /= 100;
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        this._xyz2crs[0] = 0;
        this._xyz2crs[1] = 1;
        this._xyz2crs[2] = 2;
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var header = this._header;

        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        this._origin.addScaledVector(xaxis, header.nstart[0]);

        this._origin.addScaledVector(yaxis, header.nstart[1]);

        this._origin.addScaledVector(zaxis, header.nstart[2]);

        xaxis.multiplyScalar(header.extent[0]);
        yaxis.multiplyScalar(header.extent[1]);
        zaxis.multiplyScalar(header.extent[2]);

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_pointCalculate",
      value: function _pointCalculate(xyzData, byteBuffer, z, y, x, pos, i) {
        var header = this._header;

        if (x < header.extent[0] && y < header.extent[1] && z < header.extent[2]) {
          var idx = x + header.extent[0] * (y + header.extent[1] * z);
          xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
          ++pos.counter;
        } else {
          pos.counter += 8 - i;
          return false;
        }

        return true;
      }
    }, {
      key: "_blockCalculate",
      value: function _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
        for (var k = 0; k < 8; ++k) {
          var z = 8 * zBlock + k;

          for (var j = 0; j < 8; ++j) {
            var y = 8 * yBlock + j;
            var inRange = true;
            var i = 0;

            while (inRange && i < 8) {
              var x = 8 * xBlock + i;
              inRange = this._pointCalculate(xyzData, byteBuffer, z, y, x, pos, i);
              i++;
            }
          }
        }
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var byteBuffer = new Uint8Array(this._buff);
        var xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
        var blocks = new THREE.Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
        var pos = {};
        pos.counter = 512;

        for (var zBlock = 0; zBlock < blocks.z; ++zBlock) {
          for (var yBlock = 0; yBlock < blocks.y; ++yBlock) {
            for (var xBlock = 0; xBlock < blocks.x; ++xBlock) {
              this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
            }
          }
        }

        this._calculateInfoParams(xyzData);

        return xyzData;
      }
    }, {
      key: "_calculateInfoParams",
      value: function _calculateInfoParams(xyzData) {
        this._header.dmean /= xyzData.length;
        var dispersion = 0;
        var minDensity = xyzData[0];
        var maxDensity = xyzData[0];

        for (var j = 0; j < xyzData.length; j++) {
          dispersion += Math.pow(this._header.dmean - xyzData[j], 2);

          if (xyzData[j] < minDensity) {
            minDensity = xyzData[j];
          }

          if (xyzData[j] > maxDensity) {
            maxDensity = xyzData[j];
          }
        }

        this._header.sd = Math.sqrt(dispersion / xyzData.length);
        this._header.dmax = maxDensity;
        this._header.dmin = minDensity;
      }
    }]);

    return DSN6Model;
  }(VolumeModel);

  var DSN6Parser = /*#__PURE__*/function (_Parser) {
    inherits(DSN6Parser, _Parser);

    var _super2 = _createSuper$1O(DSN6Parser);

    function DSN6Parser(data, options) {
      var _this;

      classCallCheck(this, DSN6Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'dsn6';
      _this.model = new DSN6Model();
      return _this;
    }

    createClass(DSN6Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canParse",
      value: function canParse(data, options) {
        if (!data) {
          return false;
        }

        return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'dsn6');
      }
    }, {
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false;
      }
    }]);

    return DSN6Parser;
  }(Parser);

  DSN6Parser.formats = ['dsn6'];
  DSN6Parser.extensions = ['.dsn6', '.omap'];
  DSN6Parser.binary = true;

  function _createSuper$1P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Little helper class for GRO Parser usage.
   * @extends PDBStream
   */

  var GROReader = /*#__PURE__*/function (_PDBStream) {
    inherits(GROReader, _PDBStream);

    var _super = _createSuper$1P(GROReader);

    function GROReader(data) {
      var _this;

      classCallCheck(this, GROReader);

      _this = _super.call(this, data);
      /** @type Number */

      _this._next = -1; // End position of line

      _this.next();

      return _this;
    }
    /**
     * Getting end of string.
     * @returns {Number} Pointer to end of string
     */


    createClass(GROReader, [{
      key: "getNext",
      value: function getNext() {
        return this._next;
      }
    }]);

    return GROReader;
  }(PDBStream);

  function _createSuper$1Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1R(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$8 = chem.Complex,
      Element$9 = chem.Element,
      Molecule$6 = chem.Molecule;
  /**
   * Gromos87 file format parser.
   * @extends Parser
   */

  var GROParser = /*#__PURE__*/function (_Parser) {
    inherits(GROParser, _Parser);

    var _super = _createSuper$1Q(GROParser);

    /**
     * Create parser for .gro file format
     *
     * @param {String} data Input file
     * @param {String} options Input options (optional field)
     */
    function GROParser(data, options) {
      var _this;

      classCallCheck(this, GROParser);

      _this = _super.call(this, data, options);
      /** @type Date */

      _this._time = null; // Time in ps, optional field for animations

      /** @type Number */

      _this._numAtoms = null; // Number of atoms in complex

      /** @type Number */

      _this._residueNumber = null; // Number of exact residue

      /** @type String */

      _this._residueName = ''; // Scientific name of exact residue

      /** @type String */

      _this._atomName = ''; // Scientific name of exact atom

      /** @type Number */

      _this._atomNumber = null; // Sorted number of exact atom

      /** @type Array */

      _this._atomPosition = []; // Array which contains x, y, z position of exact atom

      /** @type Array */

      _this._atomVelocity = []; // Array which contains x, y, z velocity of exact atom (optional)

      /** @type Complex */

      _this._complex = null; // Complex structure for unified molecule representation

      /** @type Vector3 */

      _this._molecules = []; // Molecules array

      /** @type Molecule */

      _this._molecule = null; // Single molecule

      /** @type String */

      _this._options.filetype = 'gro'; // Extension of data file.

      return _this;
    }
    /**
     * General check for possibility of parsing.
     * @param {String} data - Input file
     * @returns {boolean} true if this file is in ascii, false otherwise
     */


    createClass(GROParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
      }
      /**
       * Parsing title of molecule complex.
       * NOTE: that names are ESTIMATES, there is no strict rules in Gromos87 standard for first line in input file.
       * @param {GROReader} line - Line containing title and time.
       */

    }, {
      key: "_parseTitle",
      value: function _parseTitle(line) {
        var metadata = this._complex.metadata;
        metadata.id = line.readLine().trim();
        metadata.name = metadata.id.slice(metadata.id.lastIndexOf('\\') + 1, metadata.id.lastIndexOf('.'));
        metadata.format = 'gro';
      }
      /**
       * Parsing line containing number of atoms information.
       * @param {GROReader} line - Line containing number of atoms.
       */

    }, {
      key: "_parseNumberOfAtoms",
      value: function _parseNumberOfAtoms(line) {
        this._numAtoms = line.readInt(0, line.getNext());

        if (Number.isNaN(this._numAtoms)) {
          throw new Error('Line 2 is not representing atom number. Consider checking input file');
        }
      }
      /**
       * Parsing line containing information about residues, atoms etc. Also information about box vectors.
       * Format of atoms MUST (by Gromos87 standard) be this: (note that numbering starts not from 0, but from 1!)
       * ResidueNumber[1 - 5]  ResidueName[6 - 10] AtomName[11 - 15] AtomNumber[16 - 20] Position[21 - 45] Velocity[46 - 69]
       * @param {GROReader} line - Line containing information about atom.
       */

    }, {
      key: "_parseAtom",
      value: function _parseAtom(line) {
        this._residueNumber = line.readInt(1, 5);
        this._residueName = line.readString(6, 10).trim();
        this._atomName = line.readString(11, 15).trim();
        this._atomNumber = line.readInt(16, 20);
        var positionX = line.readFloat(21, 28) * 10;
        var positionY = line.readFloat(29, 36) * 10;
        var positionZ = line.readFloat(37, 45) * 10;

        if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
          this._complex.error = {
            message: "Atom position is invalid in \"".concat(line.readLine(), "\"")
          };
          return;
        }
        /* const velocityX = line.readFloat(46, 53);
        const velocityY = line.readFloat(54, 61);
        const velocityZ = line.readFloat(62, 69); */

        /* Adding residue and atom to complex structure */


        var type = Element$9.getByName(this._atomName[0]);
        /* MAGIC 0. REASONS: This name is something like "CA", where
        C - is an element an A is something else. But what about Calcium? */

        if (type.fullName === 'Unknown') {
          this._complex.error = {
            message: "".concat(this._atomName[0], " hasn't been recognised as an atom name.")
          };
          return;
        }

        var role = Element$9.Role[this._atomName];
        /* Firstly, create a dummy chain */

        var chain = this._chain;

        if (!chain) {
          this._chain = chain = this._complex.addChain('A');
        }
        /* Secondly, add residue to that chain */


        var residue = this._residue;

        if (!residue || residue.getSequence() !== this._residueNumber) {
          this._residue = residue = chain.addResidue(this._residueName, this._residueNumber, ' ');
        }
        /* Lastly, add atom to that residue */


        this._atomPosition = new THREE.Vector3(positionX, positionY, positionZ);
        /* Adding default constants to correct atom addition process */

        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;
        residue.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
      }
      /**
       * Some finalizing procedures. In '.gro' file format there is only 1 chain and 1 molecule.
       */

    }, {
      key: "_finalize",
      value: function _finalize() {
        var molecule = new Molecule$6(this._complex, this._complex.metadata.name, 1); // aggregate residues from chain

        molecule.residues = this._chain._residues;
        molecule._chains = this._chain;
        this._complex._molecules[0] = molecule;

        this._molecules.push(molecule);

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
      /**
       * Main parsing procedure.
       * @returns {Complex} Complex structure for visualizing.
       */

    }, {
      key: "parseSync",
      value: function parseSync() {
        /* Create "Complex" variable */
        var result = this._complex = new Complex$8();
        /* Parse input file line-by-line */

        var reader = new GROReader(this._data);
        var counter = 0;
        /* Simple counter regarding to format of .gro file */

        /* First two lines - technical information, other lines - Atoms */

        this._parseTitle(reader);

        reader.next();

        this._parseNumberOfAtoms(reader);

        reader.next();

        for (counter = 0; counter < this._numAtoms; ++counter) {
          if (!reader.end()) {
            this._parseAtom(reader);

            reader.next();
          } else break;
        }
        /* If number of atoms in second line is less then actual atoms in file */


        if (counter < this._numAtoms) {
          this._complex.error = {
            message: 'File ended unexpectedly.'
          };
        }
        /* Catch errors occurred in parsing process */


        if (result.error) {
          throw new Error(result.error.message);
        }
        /* Finalizing data */


        this._finalize();
        /* Cleaning up */


        this._atomPosition = null;
        this._complex = null;
        this._molecules = null;
        this._molecule = null;
        /* Return resulting Complex variable */

        return result;
      }
    }]);

    return GROParser;
  }(Parser);

  GROParser.formats = ['gro'];
  GROParser.extensions = ['.gro'];

  function _createSuper$1R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1S(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$9 = chem.Complex,
      Element$a = chem.Element,
      Bond$5 = chem.Bond,
      Molecule$7 = chem.Molecule;
  var orderMap$1 = {
    un: 0,
    1: 1,
    2: 2,
    3: 3,
    ar: 1,
    am: 1,
    nc: 0,
    du: 1
  };
  var typeMap$1 = {
    un: Bond$5.BondType.UNKNOWN,
    // unknown (cannot be determined from the parameter tables)
    1: Bond$5.BondType.COVALENT,
    // single
    2: Bond$5.BondType.COVALENT,
    // double
    3: Bond$5.BondType.COVALENT,
    // triple
    ar: Bond$5.BondType.AROMATIC,
    // aromatic
    am: Bond$5.BondType.COVALENT,
    // amide
    nc: Bond$5.BondType.UNKNOWN,
    // not connected
    du: Bond$5.BondType.COVALENT // dummy

  };
  var resNumberRegex = /\d+$/;
  var spacesRegex = /\s+/;

  function splitToFields(str) {
    return str.trim().split(spacesRegex);
  }
  /* There is no jsdoc documentation because of eslint corrections:
   * not all Parser methods are implemented
   */


  var MOL2Parser = /*#__PURE__*/function (_Parser) {
    inherits(MOL2Parser, _Parser);

    var _super = _createSuper$1R(MOL2Parser);

    function MOL2Parser(data, options) {
      var _this;

      classCallCheck(this, MOL2Parser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._compoundIndx = -1;
      _this._molecules = [];
      _this._molecule = null;
      _this._currPosIdx = 0;
      _this._currStartIdx = 0;
      _this._serialAtomMap = {};
      _this._options.fileType = 'mol2';
      return _this;
    }

    createClass(MOL2Parser, [{
      key: "_parseRawStrings",
      value: function _parseRawStrings(data) {
        return data.split(/\r?\n|\r/);
      }
    }, {
      key: "_toStringFromStart",
      value: function _toStringFromStart(numb, MOL2Data) {
        var newPosIdx = this._currStartIdx + numb;
        this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
      }
    }, {
      key: "_toHeaderString",
      value: function _toHeaderString(header, MOL2Data) {
        this._toStringFromStart(0, MOL2Data);

        while (this._currPosIdx < MOL2Data.length) {
          if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header))) {
            return;
          }

          this._currPosIdx++;
        }

        this._toStringFromStart(0, MOL2Data);
      }
    }, {
      key: "_toStringFromHeader",
      value: function _toStringFromHeader(header, numb, MOL2Data) {
        this._toHeaderString(header, MOL2Data);

        var newPosIdx = this._currPosIdx + numb;

        if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header)) && newPosIdx < MOL2Data.length) {
          this._currPosIdx = newPosIdx;
        }
      }
    }, {
      key: "_setStart",
      value: function _setStart(startPos, MOL2Data) {
        if (startPos >= MOL2Data.length) {
          this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
        } else {
          this._currStartIdx = this._currPosIdx = startPos;
        }
      }
    }, {
      key: "_probablyHaveDataToParse",
      value: function _probablyHaveDataToParse(MOL2Data) {
        return this._currPosIdx < MOL2Data.length - 2;
      }
    }, {
      key: "_findNextCompoundStart",
      value: function _findNextCompoundStart(MOL2Data) {
        while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== '@<TRIPOS>MOLECULE>') {
          this._currPosIdx++;
        }

        this._setStart(++this._currPosIdx, MOL2Data);

        return this._probablyHaveDataToParse(MOL2Data);
      }
    }, {
      key: "_parseMolecule",
      value: function _parseMolecule(MOL2Data) {
        this._toHeaderString('MOLECULE', MOL2Data);

        var metadata = this._complex.metadata;
        metadata.name = MOL2Data[++this._currPosIdx];
        metadata.format = 'mol2';
        this._molecule = {
          _index: '',
          _chains: []
        };
        this._molecule._index = this._compoundIndx + 1;

        this._molecules.push(this._molecule);
      }
      /* Atom format description:
       * atomId atomName x y z element [resSeq [resName [charge [statusBit]]]]
       * statusBits is the internal SYBYL status bits associated with the atom.
       * These should never be set by the user.
       * Source: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf
       */

    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(atomsNum, MOL2Data) {
        this._toHeaderString('ATOM', MOL2Data);

        for (var i = 0; i < atomsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 6) {
            throw new Error('MOL2 parsing error: Not enough information to create atom!');
          }

          var atomId = parseInt(parsedStr[0], 10);
          var atomName = parsedStr[1];
          var x = parseFloat(parsedStr[2]);
          var y = parseFloat(parsedStr[3]);
          var z = parseFloat(parsedStr[4]);
          var element = parsedStr[5].split('.')[0].toUpperCase();
          var charge = 0;

          if (parsedStr.length >= 9) {
            charge = parseFloat(parsedStr[8]) || 0.0;
          }

          var chain = this._chain;

          if (!chain) {
            // .mol2 may contain information about multiple molecules, but they can't be visualized
            // at the same time now. There is no need to create different chain IDs then.
            this._chain = chain = this._complex.getChain('A') || this._complex.addChain('A');
            this._residue = null;
          }

          if (!this._setResidue(parsedStr)) {
            continue;
          } // These fields are not listed in mol2 format. Set them default.
          // Atoms and het atoms doesn't differ in .mol2,
          // but het atoms have special residues. It can be used in next updates


          var het = false;
          var altLoc = ' ';
          var occupancy = 1.0;
          var tempFactor = 0.0;
          var type = Element$a.getByName(element);
          var role = Element$a.Role[atomName];
          var xyz = new THREE.Vector3(x, y, z);

          this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
        }
      }
    }, {
      key: "_setResidue",
      value: function _setResidue(parsedStr) {
        var resSeq = 1;
        var resName = 'UNK'; // The same meaning has '<0>' in some mol2 files

        if (parsedStr.length >= 7) {
          resSeq = parseInt(parsedStr[6], 10);
        }

        if (parsedStr.length >= 8 && parsedStr[7] !== '<0>') {
          resName = parsedStr[7].replace(resNumberRegex, '');
        }

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return false;
          }
        }

        var residue = this._residue;
        var chain = this._chain;

        if (!residue || residue.getSequence() !== resSeq) {
          this._residue = chain.addResidue(resName, resSeq, 'A');
        }

        return true;
      }
      /* Bond format description
       * bondId originAtomId targetAtomId bondType [statusBits]
       */

    }, {
      key: "_parseBonds",
      value: function _parseBonds(bondsNum, MOL2Data) {
        this._toHeaderString('BOND', MOL2Data);

        for (var i = 0; i < bondsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 3) {
            throw new Error('MOL2 parsing error: Missing information about bonds!');
          }

          var originAtomId = parseInt(parsedStr[1], 10);
          var targetAtomId = parseInt(parsedStr[2], 10);
          var bondType = parsedStr[3];

          if (originAtomId > targetAtomId) {
            var _ref = [targetAtomId, originAtomId];
            originAtomId = _ref[0];
            targetAtomId = _ref[1];
          }

          this._complex.addBond(originAtomId, targetAtomId, orderMap$1[bondType] || 0, typeMap$1[bondType] || Bond$5.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_fixSerialAtoms",
      value: function _fixSerialAtoms() {
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          this._serialAtomMap[atom.serial] = atom;
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;

        if (Object.keys(serialAtomMap).length === 0) {
          throw new Error('MOL2 parsing error: Missing atom information!');
        }

        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];
          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // Get chain from complex
        var chain = this._complex._chains[0];
        this._complex._molecules = []; // Aggregate residues from chains
        // (to be precise from the chain 'A')

        for (var i = 0; i < this._molecules.length; i++) {
          var currMolecule = this._molecules[i];
          var molResidues = chain._residues;
          var molecule = new Molecule$7(this._complex, currMolecule._name, i + 1);
          molecule.residues = molResidues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._complex._finalizeBonds();

        this._fixSerialAtoms();

        this._fixBondsArray();

        this._finalizeMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(MOL2Data) {
        this._compoundIndx++;

        this._parseMolecule(MOL2Data); // Ignoring comments and everything before @<TRIPOS>MOLECULE block


        this._toStringFromHeader('MOLECULE', 2, MOL2Data);

        var parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);

        var atomsNum = parsedStr[0];
        var bondsNum = parsedStr[1];

        this._parseAtoms(atomsNum, MOL2Data);

        this._parseBonds(bondsNum, MOL2Data);
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$9();

        var MOL2Data = this._parseRawStrings(this._data);

        do {
          this._parseCompound(MOL2Data);
        } while (this._findNextCompoundStart(MOL2Data));

        this._finalize();

        return result;
      }
    }]);

    return MOL2Parser;
  }(Parser);

  MOL2Parser.formats = ['mol2'];
  MOL2Parser.extensions = ['.mol2', '.ml2', '.sy2'];

  var parsers = new ParserList([// note: order might be important
  PDBParser, CIFParser, MMTFParser, XYZParser, CMLParser, PubChemParser, SDFParser, CCP4Parser, DSN6Parser, GROParser, MOL2Parser]);

  function _createSuper$1S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1T(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available exporters.
   * @extends EntityList
   */

  var ExporterList = /*#__PURE__*/function (_EntityList) {
    inherits(ExporterList, _EntityList);

    var _super = _createSuper$1S(ExporterList);

    /**
     * Create a list of exporters.
     * The exporters are indexed by supported data formats (`.formats` and
     * `.extensions` properties of a Exporter subclass).
     * The Exporters can be retrieved later by matching against specs (see {@link ExporterList#find}).
     *
     * @param {!Array<function(new:Exporter)>=} someExporters A list of {@link Exporter} subclasses to
     *   automatically register at creation time.
     * @see ExporterList#register
     */
    function ExporterList() {
      var someExporters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, ExporterList);

      return _super.call(this, someExporters, ['formats']);
    }
    /**
     * Find a suitable exporter for data.
     *
     * @param {Object} specs Exporter specifications.
     * @param {string=} specs.format Supported data format.
     * @param {*=} specs.data Data to export.
     */


    createClass(ExporterList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        }

        return toConsumableArray(list);
      }
    }]);

    return ExporterList;
  }(EntityList);

  var Exporter = /*#__PURE__*/function () {
    function Exporter(source, options) {
      classCallCheck(this, Exporter);

      this._source = source;
      this._options = options || {};
      this._abort = false;
    }

    createClass(Exporter, [{
      key: "exportSync",
      value: function exportSync() {
        throw new Error('Exporting to this source is not implemented');
      }
    }, {
      key: "export",
      value: function _export() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Export aborted'));
              }

              return resolve(_this.exportSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Exporter;
  }();
  makeContextDependent(Exporter.prototype);

  var PDBResult = /*#__PURE__*/function () {
    function PDBResult() {
      classCallCheck(this, PDBResult);

      this._resultArray = [];
      this._currentStr = -1;
      this._tag = null;
      this._fixedNumeration = false;
      this._numeration = false;
      this._tagStrNum = 0;
    }

    createClass(PDBResult, [{
      key: "getResult",
      value: function getResult() {
        this.writeString('\n', 81, 81);
        return this._resultArray.join('');
      }
    }, {
      key: "_currentStrLength",
      value: function _currentStrLength() {
        var curStr = this._resultArray[this._currentStr];
        return curStr ? curStr.length : 0;
      } // numeration can be number or boolean
      // if numeration is number then just put this number to 8-10 pos in string
      // if numeration is boolean then increase number for all new strings

    }, {
      key: "newTag",
      value: function newTag(tag, numeration) {
        if (!tag) {
          this._tag = null;
        } else {
          this._tag = tag;
        }

        if (!___default['default'].isUndefined(numeration)) {
          if (___default['default'].isNumber(numeration)) {
            this._tagStrNum = numeration;
            this._numeration = true;
            this._fixedNumeration = true;
          } else if (___default['default'].isBoolean(numeration)) {
            this._tagStrNum = 0;
            this._numeration = numeration;
            this._fixedNumeration = false;
          }
        } else {
          this._numeration = false;
          this._fixedNumeration = false;
          this._tagStrNum = 0;
        }
      }
    }, {
      key: "newString",
      value: function newString(tag) {
        this.writeString('\n', 81, 81);
        this._currentStr++;

        this._resultArray.push('');

        if (tag) {
          this.writeString(tag, 1, 6);
        } else if (this._tag) {
          this.writeString(this._tag, 1, 6);
        }

        if (this._numeration) {
          if (!this._fixedNumeration) {
            this._tagStrNum++;
          }

          if (this._tagStrNum !== 1) {
            this.writeString(this._tagStrNum.toString(), 10, 8);
          }
        }
      }
    }, {
      key: "writeEntireString",
      value: function writeEntireString(string, maxStrPos, concat) {
        if (!maxStrPos) {
          maxStrPos = 81;
        }

        for (var j = 0; j < string.length; j++) {
          if (this._currentStrLength() === maxStrPos && j !== string.length - 1) {
            this.newString();

            if (concat) {
              // pretty hardcoddy
              this.writeString(concat.tag, concat.begin, concat.end);
            }
          }

          if (string[j] === '\n') {
            this.newString();
          } else {
            this.writeString(string[j]);
          }
        }
      }
    }, {
      key: "writeString",
      value: function writeString(string, begin, end) {
        var curStr = this._resultArray[this._currentStr];
        var str;
        var curStrLength = curStr ? curStr.length : 0;

        if (___default['default'].isUndefined(string)) {
          return;
        }

        if (!___default['default'].isNumber(begin)) {
          begin = curStrLength + 1;
        }

        if (!___default['default'].isNumber(end)) {
          end = curStrLength + string.length;
        }

        if (!___default['default'].isString(string)) {
          str = string.toString();
        } else {
          str = string;
        }

        var finish = begin < end ? end : begin;
        var start = begin < end ? begin : end;

        if (str.length > Math.abs(begin - end) + 1) {
          str = str.substr(0, Math.abs(begin - end + 1));
        } // spaces before start of new data


        if (start > curStrLength + 1) {
          this._resultArray[this._currentStr] += ' '.repeat(start - curStrLength - 1);
        } else if (start <= curStrLength) {
          var cStr = this._resultArray[this._currentStr];
          this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
        } // if reverse order
        // reverse order of end and begin means that user wants to align text right


        if (end < begin) {
          var len = begin - end + 1;
          str = ' '.repeat(len - str.length) + str;
        } // some hardcode fix for space between string numeration and data
        // (see pdb file format description)


        if (start === 11 && this._numeration && this._tagStrNum !== 1) {
          str = " ".concat(str);
        } // append new data to string


        this._resultArray[this._currentStr] += str;
        curStr = this._resultArray[this._currentStr];

        if (finish > curStr.length) {
          this._resultArray[this._currentStr] += ' '.repeat(finish - curStr.length);
        }
      }
    }, {
      key: "writeBondsArray",
      value: function writeBondsArray(bonds, atom) {
        var bondsArrays = this._getSubArrays(bonds, 4);

        for (var k = 0; k < bondsArrays.length; k++) {
          this.newString();
          this.writeString(atom.serial, 11, 7);

          for (var j = 0; j < bondsArrays[k].length; j++) {
            var serial = bondsArrays[k][j]._left.serial === atom.serial ? bondsArrays[k][j]._right.serial : bondsArrays[k][j]._left.serial;
            this.writeString(serial, 16 + 5 * j, 12 + 5 * j);
          }
        }
      }
    }, {
      key: "_getSubArrays",
      value: function _getSubArrays(arr, subArraySize) {
        var subArrays = [];

        for (var i = 0; i < arr.length; i += subArraySize) {
          subArrays.push(arr.slice(i, i + subArraySize));
        }

        return subArrays;
      } // function for writing matrix in Remark290 and Remark350 tags
      // (see pdb file description)

    }, {
      key: "writeMatrix",
      value: function writeMatrix(matrix, matrixIndx, tag) {
        for (var j = 0; j < 3; j++) {
          this.newString();
          this.writeString(tag, 14, 18);
          this.writeString((j + 1).toString(), 19, 19);
          this.writeString(matrixIndx.toString(), 23, 20);

          for (var k = 0; k < 3; k++) {
            var _numb = parseFloat(matrix.elements[j * 4 + k]).toFixed(6);

            this.writeString(_numb.toString(), 33 + k * 10, 24 + k * 10);
          }

          var numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5);
          this.writeString(numb.toString(), 68, 55);
        }
      }
    }, {
      key: "writeMatrices",
      value: function writeMatrices(matrices, string) {
        if (!matrices) {
          return;
        }

        var matrix = new THREE.Matrix4();

        for (var j = 0; j < matrices.length; j++) {
          matrix.copy(matrices[j]).transpose();
          this.writeMatrix(matrix, j + 1, string);
        }
      }
    }]);

    return PDBResult;
  }();

  function _createSuper$1T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1U(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var PDBExporter = /*#__PURE__*/function (_Exporter) {
    inherits(PDBExporter, _Exporter);

    var _super = _createSuper$1T(PDBExporter);

    function PDBExporter(source, options) {
      var _this;

      classCallCheck(this, PDBExporter);

      _this = _super.call(this, source, options);
      _this._tags = ['HEADER', 'TITLE', 'COMPND', 'REMARK', 'HELIX', 'SHEET', 'ATOM and HETATM', 'CONECT'];
      _this._result = null;
      _this._tagExtractors = {
        HEADER: _this._extractHEADER,
        TITLE: _this._extractTITLE,
        'ATOM and HETATM': _this._extractATOM,
        CONECT: _this._extractCONECT,
        COMPND: _this._extractCOMPND,
        REMARK: _this._extractREMARK,
        HELIX: _this._extractHELIX,
        SHEET: _this._extractSHEET
      };
      _this._stringForRemark350 = 'COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\n' + 'BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\n' + 'MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\n' + 'GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\n' + 'CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.';
      _this._stringForRemark290 = 'CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\n' + 'THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\n' + 'RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\n' + 'RELATED MOLECULES.';
      return _this;
    }

    createClass(PDBExporter, [{
      key: "exportSync",
      value: function exportSync() {
        var result = new PDBResult();

        if (!this._source) {
          return this._result;
        }

        for (var i = 0; i < this._tags.length; i++) {
          var tag = this._tags[i];
          var func = this._tagExtractors[tag];

          if (___default['default'].isFunction(func)) {
            func.call(this, result);
          }
        }

        this._result = result.getResult();
        return this._result;
      }
    }, {
      key: "_extractHEADER",
      value: function _extractHEADER(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;
        result.newTag('HEADER');
        result.newString();

        if (metadata.classification) {
          result.writeString(metadata.classification, 11, 50);
        }

        if (metadata.date) {
          result.writeString(metadata.date, 51, 59);
        }

        if (metadata.id) {
          result.writeString(metadata.id, 63, 66);
        }
      }
    }, {
      key: "_extractTITLE",
      value: function _extractTITLE(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;

        if (!metadata.title) {
          return;
        }

        result.newTag('TITLE', true);

        for (var i = 0; i < metadata.title.length; i++) {
          result.newString();
          result.writeString(metadata.title[i], 11, 80);
        }
      }
    }, {
      key: "_extractCONECT",
      value: function _extractCONECT(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;
        result.newTag('CONECT');

        for (var i = 0; i < atoms.length; i++) {
          var fixedBonds = atoms[i].bonds.filter(function (bond) {
            return bond._fixed;
          });

          if (fixedBonds.length !== 0) {
            result.writeBondsArray(fixedBonds.reverse(), atoms[i]);
          }
        }
      }
    }, {
      key: "_extractSHEET",
      value: function _extractSHEET(result) {
        if (!this._source._sheets) {
          return;
        }

        result.newTag('SHEET');
        var sheets = this._source._sheets;

        for (var i = 0; i < sheets.length; i++) {
          if (sheets[i]._strands) {
            var strands = sheets[i]._strands;

            for (var j = 0; j < strands.length; j++) {
              result.newString();
              result.writeString(j + 1, 10, 8);
              result.writeString(sheets[i]._name, 14, 12);
              result.writeString(strands.length, 16, 15);
              result.writeString(strands[j].init._type._name, 18, 20);
              result.writeString(strands[j].init._chain._name, 22, 22);
              result.writeString(strands[j].init._sequence, 26, 23);
              result.writeString(strands[j].init._icode, 27, 27);
              result.writeString(strands[j].term._type._name, 29, 31);
              result.writeString(strands[j].init._chain._name, 33, 33);
              result.writeString(strands[j].term._sequence, 37, 34);
              result.writeString(strands[j].term._icode, 38, 38);
              result.writeString(strands[j].sense, 40, 39);
            }
          }
        }
      }
    }, {
      key: "_extractHELIX",
      value: function _extractHELIX(result) {
        if (!this._source._helices) {
          return;
        }

        result.newTag('HELIX');
        var helices = this._source._helices;

        for (var i = 0; i < helices.length; i++) {
          var helix = helices[i];

          var helixClass = ___default['default'].invert(typeByPDBHelixClass);

          result.newString();
          result.writeString(helix.serial, 10, 8);
          result.writeString(helix.name, 14, 12);
          result.writeString(helix.init._type._name, 16, 18);
          result.writeString(helix.init._chain._name, 20, 20);
          result.writeString(helix.init._sequence, 25, 22);
          result.writeString(helix.init._icode, 26, 26);
          result.writeString(helix.term._type._name, 28, 30);
          result.writeString(helix.term._chain._name, 32, 32);
          result.writeString(helix.term._sequence, 37, 34);
          result.writeString(helix.term._icode, 38, 38);
          result.writeString(helixClass[helix.type], 40, 39);
          result.writeString(helix.comment, 41, 70);
          result.writeString(helix.length, 76, 72);
        }
      }
    }, {
      key: "_extractATOM",
      value: function _extractATOM(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var tag = atoms[i].het ? 'HETATM' : 'ATOM';
          result.newString(tag);
          var startIndx = atoms[i].element.name.length > 1 || atoms[i].name.length > 3 ? 13 : 14;
          result.writeString(atoms[i].serial, 11, 7);
          result.writeString(atoms[i].name, startIndx, 16);
          result.writeString(String.fromCharCode(atoms[i].location), 17, 17);
          result.writeString(atoms[i].residue._type._name, 20, 18);
          result.writeString(atoms[i].residue._chain._name, 22, 22);
          result.writeString(atoms[i].residue._sequence, 26, 23);
          result.writeString(atoms[i].residue._icode, 27, 27);
          result.writeString(atoms[i].position.x.toFixed(3), 38, 31);
          result.writeString(atoms[i].position.y.toFixed(3), 46, 39);
          result.writeString(atoms[i].position.z.toFixed(3), 54, 47);
          result.writeString(atoms[i].occupancy.toFixed(2), 60, 55);
          result.writeString(atoms[i].temperature.toFixed(2), 66, 61);
          result.writeString(atoms[i].element.name, 78, 77);

          if (atoms[i].charge) {
            result.writeString(atoms[i].charge, 79, 80);
          }
        }
      }
    }, {
      key: "_extractCOMPND",
      value: function _extractCOMPND(result) {
        if (!this._source._molecules) {
          return;
        }

        var molecules = this._source._molecules;
        result.newTag('COMPND', true);

        for (var i = 0; i < molecules.length; i++) {
          var chains = this._getMoleculeChains(molecules[i]);

          result.newString();
          result.writeString("MOL_ID: ".concat(molecules[i].index, ";"), 11, 80);
          result.newString();
          result.writeString("MOLECULE: ".concat(molecules[i].name, ";"), 11, 80);
          result.newString();
          result.writeString('CHAIN: ', 11, 18);
          var chainsString = "".concat(chains.join(', '), ";");
          result.writeEntireString(chainsString, 81);
        }
      }
    }, {
      key: "_extractREMARK",
      value: function _extractREMARK(result) {
        this._Remark290(result);

        this._Remark350(result);
      }
    }, {
      key: "_Remark290",
      value: function _Remark290(result) {
        if (!this._source.symmetry) {
          return;
        }

        if (this._source.symmetry.length !== 0) {
          var matrices = this._source.symmetry;
          result.newTag('REMARK', 290);
          result.newString();
          result.newString();
          result.writeEntireString(this._stringForRemark290);
          result.writeMatrices(matrices, 'SMTRY');
          result.newString();
          result.newString();
          result.writeString('REMARK: NULL', 11, 80);
        }
      }
    }, {
      key: "_Remark350",
      value: function _Remark350(result) {
        if (!this._source.units) {
          return;
        }

        var units = this._source.units;
        var biomolIndx = 0;
        result.newTag('REMARK', 350);
        result.newString();
        result.newString();
        result.writeEntireString(this._stringForRemark350);
        var assemblies = units.filter(function (unit) {
          return unit instanceof Assembly;
        });

        for (var i = 0; i < assemblies.length; i++) {
          result.newString();
          result.newString();
          biomolIndx++;
          result.writeString("BIOMOLECULE: ".concat(biomolIndx), 11, 80);
          var chains = assemblies[i].chains.join(', ');
          result.newString();
          result.writeString('APPLY THE FOLLOWING TO CHAINS: ');
          result.writeEntireString(chains, 69, {
            tag: 'AND CHAINS: ',
            begin: 31,
            end: 42
          });
          var matrices = assemblies[i].matrices;
          result.writeMatrices(matrices, 'BIOMT');
        }
      }
    }, {
      key: "_getMoleculeChains",
      value: function _getMoleculeChains(molecule) {
        function getChainName(residue) {
          return residue._chain._name;
        }

        var chainNames = molecule.residues.map(getChainName);
        return chainNames.filter(function (item, pos) {
          return chainNames.indexOf(item) === pos;
        });
      }
    }]);

    return PDBExporter;
  }(Exporter);
  PDBExporter.formats = ['pdb'];
  PDBExporter.SourceClass = Complex;

  var FBX_POS_SIZE = 3;
  var FBX_NORM_SIZE = 3;
  var FBX_COL_SIZE = 4;

  function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
  }

  function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
    dst[dstIdx + 3] = value;
  }

  var vector4 = new THREE.Vector4();

  function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
    vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w);
    vector4.applyMatrix4(opts.matrix);
    dst[dstIdx] = vector4.x;
    dst[dstIdx + 1] = vector4.y;
    dst[dstIdx + 2] = vector4.z;
  }

  function setSubArray(src, dst, count, copyFunctor, functorOpts) {
    if ((dst.array.length - dst.start) / dst.stride < count || (src.array.length - src.start) / src.stride < count) {
      return; // we've got no space
    }

    if (src.stride === dst.stride) {
      // stride is the same
      dst.array.set(src.array, dst.start);
    } else {
      var idx = dst.start;
      var arridx = src.start;

      for (var i = 0; i < count; ++i, idx += dst.stride, arridx += src.stride) {
        copyFunctor(src.array, arridx, dst.array, idx, functorOpts);
      }
    }
  }

  var FBXModel = /*#__PURE__*/function () {
    function FBXModel() {
      classCallCheck(this, FBXModel);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.lastPos = 0;
      this.lastNorm = 0;
      this.lastCol = 0;
      this.lastIdx = 0;
    }

    createClass(FBXModel, [{
      key: "init",
      value: function init(vertsCount, indsCount) {
        this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
        this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
        this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
        this.indices = new Int32Array(indsCount);
      }
    }, {
      key: "setPositions",
      value: function setPositions(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.positions,
          start: this.lastPos,
          stride: FBX_POS_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setTransformedPositions",
      value: function setTransformedPositions(array, start, count, stride, matrix) {
        var idx = this.lastPos;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 1
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_POS_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.positions, idx, opts);
        }

        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setNormals",
      value: function setNormals(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.normals,
          start: this.lastNorm,
          stride: FBX_NORM_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setTransformedNormals",
      value: function setTransformedNormals(array, start, count, stride, matrix) {
        var idx = this.lastNorm;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 0
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_NORM_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.normals, idx, opts);
        }

        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setColors",
      value: function setColors(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.colors,
          start: this.lastCol,
          stride: FBX_COL_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint4, 1);
        this.lastCol += count * FBX_COL_SIZE;
      }
    }, {
      key: "setIndices",
      value: function setIndices(array, start, count) {
        this.indices.set(array, this.lastIdx);
        this.lastIdx += count;
      }
    }, {
      key: "setShiftedIndices",
      value: function setShiftedIndices(array, count, shift) {
        var shifted = array.map(function (x) {
          return x + shift;
        });
        this.setIndices(shifted, 0, count);
      }
    }, {
      key: "getVerticesNumber",
      value: function getVerticesNumber() {
        return this.lastPos / FBX_POS_SIZE;
      }
    }, {
      key: "addInstance",
      value: function addInstance(matrix, geo) {
        // add indices at first to take old number of vertices for shift
        var currentCount = this.getVerticesNumber();
        this.setShiftedIndices(geo.indices, geo.indices.length, currentCount); // simply write vertices at empty space

        var size = geo.itemSize;
        this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
        this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
        this.setColors(geo.colors, 0, geo.vertsCount, size.color);
      }
    }]);

    return FBXModel;
  }();

  /** Base class for fbx geometry contains simply organized attributes: positions+normals+colors, indices. */
  var FBXGeometry = /*#__PURE__*/function () {
    /**
     * Create a base geo with necessary members.
     */
    function FBXGeometry() {
      classCallCheck(this, FBXGeometry);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.vertsCount = 0;
      this.itemSize = null;
    }
    /**
     * Initialize base geo storing items info from attributes.
     * @param {Object} geo - THREE.BufferGeometry.
     */


    createClass(FBXGeometry, [{
      key: "init",
      value: function init(geo, _info) {
        var attributes = geo.attributes; // save item size

        this.itemSize = {
          position: attributes.position.itemSize,
          normal: attributes.normal.itemSize,
          color: attributes.color.itemSize
        };
      }
    }]);

    return FBXGeometry;
  }();

  function _createSuper$1U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1V(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Fbx geometry, that copies positions+normals, indexes and creates colors filled with defined value.
   * @extends FBXGeometry
   */

  var FBX1CGeometry = /*#__PURE__*/function (_FBXGeometry) {
    inherits(FBX1CGeometry, _FBXGeometry);

    var _super = _createSuper$1U(FBX1CGeometry);

    function FBX1CGeometry() {
      classCallCheck(this, FBX1CGeometry);

      return _super.apply(this, arguments);
    }

    createClass(FBX1CGeometry, [{
      key: "init",

      /**
       * Initialize geo storing positions, normals, indices and create colors.
       * @param {Object} geo - THREE.BufferGeometry.
       */
      value: function init(geo, _info) {
        get(getPrototypeOf(FBX1CGeometry.prototype), "init", this).call(this, geo, _info);

        var _geo$attributes = geo.attributes,
            position = _geo$attributes.position,
            normal = _geo$attributes.normal,
            index = geo.index; // copy vertices attributes

        this.vertsCount = position.count;
        this.positions = position.array;
        this.normals = normal.array; // create color array

        this.colors = new Float32Array(this.vertsCount * this.itemSize.color); // indices

        this.indices = index.array;
      }
      /**
       * Set defined color for all items in color attribute
       * @param {Object} color - THREE.Color.
       */

    }, {
      key: "setColors",
      value: function setColors(color) {
        var offset = 0;

        for (var i = 0, l = this.colors.length, cl = this.itemSize.color; i < l; i += cl) {
          this.colors[offset++] = color.r;
          this.colors[offset++] = color.g;
          this.colors[offset++] = color.b;
        }
      }
    }]);

    return FBX1CGeometry;
  }(FBXGeometry);

  function _createSuper$1V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1W(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Fbx geometry, that copies positions+normals, indexes from cylinder  geometry and creates colors filled with two
   * defined values.
   * @extends FBXGeometry
   */

  var FBX2CCylinder = /*#__PURE__*/function (_FBXGeometry) {
    inherits(FBX2CCylinder, _FBXGeometry);

    var _super = _createSuper$1V(FBX2CCylinder);

    function FBX2CCylinder() {
      var _this;

      classCallCheck(this, FBX2CCylinder);

      _this = _super.call(this);
      _this._cutRawStart = 0;
      _this._cutRawEnd = 0;
      _this._facesPerSlice = 0;
      return _this;
    }
    /**
     * Initialize geo by creating new attributes, because we extend number of vertices to make cylinder two-colored.
     * Indices remain the same. We process open- end close-ended cylinders and consider cylinders od 2 segments
     * in height ONLY.
     * NOTE: cylinder consists of 2 height segments and stores parts in the order: tube, topCap, bottomCap
     * @param {Object} geo - THREE.BufferGeometry.
     * @param {Object} info - information needed for geo extend
     */


    createClass(FBX2CCylinder, [{
      key: "init",
      value: function init(geo, info) {
        get(getPrototypeOf(FBX2CCylinder.prototype), "init", this).call(this, geo, info);

        var position = geo.attributes.position,
            index = geo.index; // extend vertices arrays

        this.vertsCount = position.count + info.addPerCylinder;
        this._facesPerSlice = info.addPerCylinder;
        this.positions = new Float32Array(this.vertsCount * position.itemSize);
        this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
        this.colors = new Float32Array(this.vertsCount * this.itemSize.color);

        this._extendVertices(geo, info); // number of indices stays the same


        this.indices = new Uint32Array(index.count);

        this._extendIndices(geo, info);
      }
      /** Extend vertex attributes to have one more slice to make sharp middle startColor-endColor line. */

    }, {
      key: "_extendVertices",
      value: function _extendVertices(geo, info) {
        var position = geo.attributes.position;
        var normal = geo.attributes.normal;
        var geoParams = geo.getGeoParams();
        var cutRaw = 1; // we expect cylinders of 2 segments in height => so half segment = 1

        this._cutRawStart = cutRaw * geoParams.radialSegments;
        this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
        {
          // write first half of cylinder
          var temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
          this.positions.set(temp, 0);
          temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
          this.normals.set(temp, 0);
        }
        {
          // write second part of cylinder
          var _temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);

          this.positions.set(_temp, this._cutRawEnd * position.itemSize);
          _temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
          this.normals.set(_temp, this._cutRawEnd * normal.itemSize);
        }
      }
      /** Shift values of second part (+caps) indices by newly added vertices count. Number of faces remains the same. */

    }, {
      key: "_extendIndices",
      value: function _extendIndices(geo, info) {
        var index = geo.index;
        var indicesPerQuad = 6; // quad = 2 triangles => 6 indices

        var startToShift = info.addPerCylinder * indicesPerQuad;
        var shift = info.addPerCylinder;
        var shifted = index.array.slice(startToShift, index.count);
        shifted = shifted.map(function (x) {
          return x + shift;
        }); // shift only the endings

        this.indices.set(index.array, 0);
        this.indices.set(shifted, startToShift);
      }
      /**
       * Set defined colors: (first part + bottom cap), (second part + top cap)
       * @param {number} start - start color index
       * @param {number} end - start color index
       * @param {array} array - array of colors
       * @param {array} color - color value components
       */

    }, {
      key: "_setColorRange",
      value: function _setColorRange(start, end, array, color) {
        var colorSize = color.length;

        for (var i = start; i < end; i += colorSize) {
          array.set(color, i);
        }
      }
      /**
       * Set defined colors: (first part + bottom cap), (second part + top cap)
       * @param {Object} color1 - THREE.Color.
       * @param {Object} color2 - THREE.Color.
       */

    }, {
      key: "setColors",
      value: function setColors(color1, color2) {
        var colorSize = this.itemSize.color;
        var part1End = this._cutRawEnd * colorSize;
        var part2End = part1End * 2;

        this._setColorRange(0, part1End, this.colors, color1.toArray());

        this._setColorRange(part1End, part2End, this.colors, color2.toArray());

        if (part2End < this.colors.length) {
          // cylinder has caps, lets paint them
          var capSize = (this._facesPerSlice + 1) * colorSize;
          var cap1End = part2End + capSize;

          this._setColorRange(part2End, cap1End, this.colors, color2.toArray());

          var cap2End = cap1End + capSize; // should be equal to this.colors.length;

          this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
        }
      }
    }]);

    return FBX2CCylinder;
  }(FBXGeometry);

  var FBXInfoExtractor = /*#__PURE__*/function () {
    function FBXInfoExtractor() {
      classCallCheck(this, FBXInfoExtractor);

      this._materials = [];
      this._models = [];
    }

    createClass(FBXInfoExtractor, [{
      key: "process",
      value: function process(data) {
        this._extractModelsAndMaterials(data);

        var models = this._flattenModels();

        return {
          name: data.name,
          models: models,
          materials: this._materials
        };
      }
      /**
       * Extract fbx object information from ComplexVisual
       * @param {object} data - complexVisual to get geometry info from
       */

    }, {
      key: "_extractModelsAndMaterials",
      value: function _extractModelsAndMaterials(data) {
        var _this = this;

        var layersOfInterest = new THREE.Layers();
        layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
        layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
        data.traverse(function (object) {
          if (object instanceof THREE.Mesh && object.layers.test(layersOfInterest) && _this.checkExportAbility(object)) {
            if (object.geometry.type === 'InstancedBufferGeometry') {
              _this._collectInstancedGeoInfo(object);
            } else {
              _this._collectGeoInfo(object);
            }
          }
        });
      }
      /**
       * Reworking indices buffer, see https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/
       * basically, every triangle in Miew has been represented hat way (e.g.) : 0,1,7, but we must (for FBX) rework that
       * into: 0,1,-8.
       * @param {array} indices - belongs to [0, maxVertIndex]
       */

    }, {
      key: "_reworkIndices",
      value: function _reworkIndices(indices) {
        var faceSize = 3;

        for (var i = faceSize - 1; i < indices.length; i += faceSize) {
          indices[i] *= -1;
          indices[i]--;
        }
      }
      /**
       * Combine geometry from several models having the same material into one Model and finally prepare indices
        * @returns {array} models, combined by material id
       */

    }, {
      key: "_flattenModels",
      value: function _flattenModels() {
        var overallVertsCount = 0;

        function shift(x) {
          return x + overallVertsCount;
        }

        var combined = []; // flatten models geometry

        for (var i = 0, n = this._models.length; i < n; i++) {
          var models = this._models[i];
          var indices = [];
          var positions = [];
          var normals = [];
          var colors = []; // reorganize every attributes as array of arrays

          overallVertsCount = 0;

          for (var j = 0; j < models.length; j++) {
            var m = models[j];
            indices.push(m.indices.map(shift));
            overallVertsCount += m.getVerticesNumber();
            positions.push(m.positions);
            normals.push(m.normals);
            colors.push(m.colors);
          } // join all subarrays into one


          indices = utils.mergeTypedArraysUnsafe(indices);

          this._reworkIndices(indices);

          positions = utils.mergeTypedArraysUnsafe(positions);
          normals = utils.mergeTypedArraysUnsafe(normals);
          colors = utils.mergeTypedArraysUnsafe(colors);
          combined.push({
            indices: indices,
            positions: positions,
            normals: normals,
            colors: colors,
            verticesCount: overallVertsCount
          });
        }

        return combined;
      }
      /**
       * Check ability to export the kind of mesh.
       * @param {object} mesh - given mesh to check
       * @returns {boolean} result of check
       */

    }, {
      key: "checkExportAbility",
      value: function checkExportAbility(mesh) {
        // check mesh on not being empty
        if (mesh.geometry.attributes.position.count === 0) {
          return false;
        } // check type of mesh
        // if (mesh.geometry.isInstancedBufferGeometry && settings.now.zSprites) {


        if (mesh instanceof ZSpriteMesh) {
          logger.warn('Currently we cannot export \'sprites\' modes, like BS, WV, LC. Please turn of settings \'zSprites\' and try again');
          return false;
        }

        if (mesh instanceof ThickLineMesh) {
          logger.warn('Currently we cannot export Lines mode');
          return false;
        }

        return true;
      }
      /**
       * Save geometry info from common mesh, like Surface or Cartoon
       */

    }, {
      key: "_collectGeoInfo",
      value: function _collectGeoInfo(mesh) {
        var _mesh$geometry = mesh.geometry,
            _mesh$geometry$attrib = _mesh$geometry.attributes,
            position = _mesh$geometry$attrib.position,
            color = _mesh$geometry$attrib.color,
            normal = _mesh$geometry$attrib.normal,
            index = _mesh$geometry.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var vertCount = position.count;
        model.init(vertCount, index.count);

        if (matrix.isIdentity()) {
          model.setPositions(position.array, 0, vertCount, position.itemSize);
          model.setNormals(normal.array, 0, vertCount, normal.itemSize);
        } else {
          model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
          model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
        }

        model.setColors(color.array, 0, vertCount, color.itemSize);
        model.setIndices(index.array, 0, index.count);

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Collect instanced spheres geometry and materials.
       * @param {object} mesh - mesh with instanced spheres info
       */

    }, {
      key: "_collectSpheresInfo",
      value: function _collectSpheresInfo(mesh) {
        var _mesh$geometry2 = mesh.geometry,
            _mesh$geometry2$attri = _mesh$geometry2.attributes,
            position = _mesh$geometry2$attri.position,
            color = _mesh$geometry2$attri.color,
            index = _mesh$geometry2.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount, instCount * indsCount);
        var geo = new FBX1CGeometry();
        geo.init(mesh.geometry);
        var instMatrix = new THREE.Matrix4();
        var objMatrix = new THREE.Matrix4();
        var sphereColor = new THREE.Color();

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          // update colors in geometry
          var colorIdx = instanceIndex * color.itemSize;
          sphereColor.fromArray(color.array, colorIdx);
          geo.setColors(sphereColor); // add instance to the model

          this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Getting all instanced cylinders from given mesh.
       * Divide cylinder (add additional vertexes) for prettiness therefore algorithm is a bit complicated
       * @param {object} mesh - given mesh with instanced cylinders
       */

    }, {
      key: "_collectCylindersInfo",
      value: function _collectCylindersInfo(mesh) {
        var _mesh$geometry3 = mesh.geometry,
            _mesh$geometry3$attri = _mesh$geometry3.attributes,
            position = _mesh$geometry3$attri.position,
            color = _mesh$geometry3$attri.color,
            color2 = _mesh$geometry3$attri.color2,
            index = _mesh$geometry3.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var oneCCylinder = new FBX1CGeometry();
        oneCCylinder.init(mesh.geometry);

        var splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);

        var twoCCylinder = null;

        if (splittingInfo.needToSplit > 0) {
          twoCCylinder = new FBX2CCylinder();
          twoCCylinder.init(mesh.geometry, splittingInfo);
        }

        var additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
        var instMatrix = new THREE.Matrix4();
        var objMatrix = new THREE.Matrix4();
        var colorStart = new THREE.Color();
        var colorEnd = new THREE.Color();
        var geo = {};

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          // update colors in geometry
          var colorIdx = instanceIndex * color.itemSize;

          if (splittingInfo.is2Colored[instanceIndex]) {
            // .color2 contains starting color, and .color contains starting color (see uber.frag ATTR_COLOR2)
            colorStart.fromArray(color2.array, colorIdx);
            colorEnd.fromArray(color.array, colorIdx);

            if (twoCCylinder) {
              twoCCylinder.setColors(colorStart, colorEnd);
              geo = twoCCylinder;
            }
          } else {
            // has one color per cylinder
            colorStart.fromArray(color.array, colorIdx);
            oneCCylinder.setColors(colorStart);
            geo = oneCCylinder;
          } // add instance to the model


          this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Adding model to pool of models or extend existing ones
       * @param {object} model - model to add
       * @param {object} material - material to add
       */

    }, {
      key: "_addToPool",
      value: function _addToPool(model, material) {
        var materialIdx = this._checkExistingMaterial(material);

        if (materialIdx < 0) {
          // new model-material pair
          this._models.push([model]);

          this._materials.push(material);
        } else {
          // add model to existing model-material pair
          var models = this._models[materialIdx];
          models.push(model);
        }
      }
      /**
       * Checking if given material already was registered in materials pool (no need to create new one)
       * @param {object} material - given material
       * @returns {number} number of model-material pair
       */

    }, {
      key: "_checkExistingMaterial",
      value: function _checkExistingMaterial(material) {
        return ___default['default'].findIndex(this._materials, function (m) {
          return ___default['default'].isEqual(m, material);
        });
      }
    }, {
      key: "_gatherCylindersColoringInfo",
      value: function _gatherCylindersColoringInfo(geo) {
        var instCount = geo.instanceCount;
        var color1 = geo.attributes.color.array;
        var color2 = geo.attributes.color2.array;
        var stride = geo.attributes.color.itemSize;
        var is2Colored = new Array(instCount); // analyze color instance attributes

        var needToSplit = 0;
        var colIdx = 0;

        for (var i = 0; i < instCount; i++, colIdx += stride) {
          var differs = Math.abs(color1[colIdx] - color2[colIdx]) > 0.0000001 || // compare ending colors
          Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 0.0000001 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 0.0000001;
          is2Colored[i] = differs;
          needToSplit += differs; // count number of 2-colored cylinders
        } // calc number of vertices to add into 2-colored


        var geoParams = geo.getGeoParams();
        var addPerCylinder = geoParams.radialSegments;
        return {
          is2Colored: is2Colored,
          needToSplit: needToSplit,
          addPerCylinder: addPerCylinder
        };
      }
      /**
       * Collect instanced models and materials.
       * @param {object} mesh - given mesh with instanced something (spheres or cylinders)
       */

    }, {
      key: "_collectInstancedGeoInfo",
      value: function _collectInstancedGeoInfo(mesh) {
        if (mesh.geometry instanceof InstancedSpheresGeometry) {
          this._collectSpheresInfo(mesh);
        } else if (mesh.geometry instanceof Instanced2CCylindersGeometry) {
          this._collectCylindersInfo(mesh);
        }
      }
      /**
       * Collect Material info from given mesh.
       * @param {object} mesh - given mesh with material info
       * @returns {object} material
       */

    }, {
      key: "_collectMaterialInfo",
      value: function _collectMaterialInfo(mesh) {
        var uberOptions = mesh.material.uberOptions;
        return {
          diffuse: uberOptions.diffuse.toArray(),
          opacity: uberOptions.opacity,
          shininess: uberOptions.shininess,
          specular: uberOptions.specular.toArray()
        };
      }
    }, {
      key: "_getCylinderInstanceMatrix",
      value: function _getCylinderInstanceMatrix(geo, instIdx, matrix) {
        var matVector1 = geo.attributes.matVector1.array;
        var matVector2 = geo.attributes.matVector2.array;
        var matVector3 = geo.attributes.matVector3.array;
        var idxOffset = instIdx * 4; // used 4 because offset arrays are stored in quads

        matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
      }
    }, {
      key: "_getSphereInstanceMatrix",
      value: function _getSphereInstanceMatrix(geo, instIdx, matrix) {
        var offset = geo.attributes.offset;
        var idx = instIdx * offset.itemSize;
        var x = offset.array[idx];
        var y = offset.array[idx + 1];
        var z = offset.array[idx + 2];
        var scale = offset.array[idx + 3];
        matrix.set(scale, 0, 0, x, 0, scale, 0, y, 0, 0, scale, z, 0, 0, 0, 1);
      }
    }]);

    return FBXInfoExtractor;
  }();

  // Forming default definitions block
  var defaultDefinitions = "\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: \"Model\" {\n    Count: 1\n  }\n  ObjectType: \"Geometry\" {\n    Count: 1\n  }\n  ObjectType: \"Material\" {\n    Count: 1\n  }\n  ObjectType: \"Pose\" {\n    Count: 1\n  }\n  ObjectType: \"GlobalSettings\" {\n    Count: 1\n  }\n} "; // Default model properties

  var defaultProperties = "Properties60: {\n      Property: \"QuaternionInterpolate\", \"bool\", \"\",0\n      Property: \"Visibility\", \"Visibility\", \"A\",1\n      Property: \"Lcl Translation\", \"Lcl Translation\", \"A\",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: \"Lcl Rotation\", \"Lcl Rotation\", \"A\",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: \"Lcl Scaling\", \"Lcl Scaling\", \"A\",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: \"RotationOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationActive\", \"bool\", \"\",0\n      Property: \"TranslationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMinX\", \"bool\", \"\",0\n      Property: \"TranslationMinY\", \"bool\", \"\",0\n      Property: \"TranslationMinZ\", \"bool\", \"\",0\n      Property: \"TranslationMaxX\", \"bool\", \"\",0\n      Property: \"TranslationMaxY\", \"bool\", \"\",0\n      Property: \"TranslationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationOrder\", \"enum\", \"\",0\n      Property: \"RotationSpaceForLimitOnly\", \"bool\", \"\",0\n      Property: \"AxisLen\", \"double\", \"\",10\n      Property: \"PreRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"PostRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationActive\", \"bool\", \"\",0\n      Property: \"RotationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMinX\", \"bool\", \"\",0\n      Property: \"RotationMinY\", \"bool\", \"\",0\n      Property: \"RotationMinZ\", \"bool\", \"\",0\n      Property: \"RotationMaxX\", \"bool\", \"\",0\n      Property: \"RotationMaxY\", \"bool\", \"\",0\n      Property: \"RotationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationStiffnessX\", \"double\", \"\",0\n      Property: \"RotationStiffnessY\", \"double\", \"\",0\n      Property: \"RotationStiffnessZ\", \"double\", \"\",0\n      Property: \"MinDampRangeX\", \"double\", \"\",0\n      Property: \"MinDampRangeY\", \"double\", \"\",0\n      Property: \"MinDampRangeZ\", \"double\", \"\",0\n      Property: \"MaxDampRangeX\", \"double\", \"\",0\n      Property: \"MaxDampRangeY\", \"double\", \"\",0\n      Property: \"MaxDampRangeZ\", \"double\", \"\",0\n      Property: \"MinDampStrengthX\", \"double\", \"\",0\n      Property: \"MinDampStrengthY\", \"double\", \"\",0\n      Property: \"MinDampStrengthZ\", \"double\", \"\",0\n      Property: \"MaxDampStrengthX\", \"double\", \"\",0\n      Property: \"MaxDampStrengthY\", \"double\", \"\",0\n      Property: \"MaxDampStrengthZ\", \"double\", \"\",0\n      Property: \"PreferedAngleX\", \"double\", \"\",0\n      Property: \"PreferedAngleY\", \"double\", \"\",0\n      Property: \"PreferedAngleZ\", \"double\", \"\",0\n      Property: \"InheritType\", \"enum\", \"\",0\n      Property: \"ScalingActive\", \"bool\", \"\",0\n      Property: \"ScalingMin\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMax\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMinX\", \"bool\", \"\",0\n      Property: \"ScalingMinY\", \"bool\", \"\",0\n      Property: \"ScalingMinZ\", \"bool\", \"\",0\n      Property: \"ScalingMaxX\", \"bool\", \"\",0\n      Property: \"ScalingMaxY\", \"bool\", \"\",0\n      Property: \"ScalingMaxZ\", \"bool\", \"\",0\n      Property: \"GeometricTranslation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricScaling\", \"Vector3D\", \"\",1,1,1\n      Property: \"LookAtProperty\", \"object\", \"\"\n      Property: \"UpVectorProperty\", \"object\", \"\"\n      Property: \"Show\", \"bool\", \"\",1\n      Property: \"NegativePercentShapeSupport\", \"bool\", \"\",1\n      Property: \"DefaultAttributeIndex\", \"int\", \"\",0\n      Property: \"Color\", \"Color\", \"A+\",0,0,0\n      Property: \"Size\", \"double\", \"\",100\n      Property: \"Look\", \"enum\", \"\",1\n    }"; // Default materials layer

  var defaultMaterialLayer = "\n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: \"\"\n      MappingInformationType: \"AllSame\"\n      ReferenceInformationType: \"Direct\"\n      Materials: 0\n    }"; // Default layers block

  var defaultLayerBlock = "\n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: \"LayerElementNormal\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementColor\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementMaterial\"\n        TypedIndex: 0\n      }\n    }";
  /**
   * globalSettings info in output file.
   */

  var globalSettings = "GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: \"UpAxis\", \"int\", \"\",1\n      Property: \"UpAxisSign\", \"int\", \"\",1\n      Property: \"FrontAxis\", \"int\", \"\",2\n      Property: \"FrontAxisSign\", \"int\", \"\",1\n      Property: \"CoordAxis\", \"int\", \"\",0\n      Property: \"CoordAxisSign\", \"int\", \"\",1\n      Property: \"UnitScaleFactor\", \"double\", \"\",1\n    }\n  }";

  var FBXResult = /*#__PURE__*/function () {
    function FBXResult() {
      classCallCheck(this, FBXResult);

      this._resultArray = [];
      this._info = null;
    }

    createClass(FBXResult, [{
      key: "getResult",
      value: function getResult(info) {
        this._info = info;

        this._resultArray.push(this._writeHeader());

        this._resultArray.push(this._writeDefinitions());

        this._resultArray.push(this._writeObjects(info.models, info.materials));

        this._resultArray.push(this._writeRelations());

        this._resultArray.push(this._writeConnections()); // connections between models and materials)


        this._info = null;
        return this._resultArray.join('');
      }
      /**
       * Add FBXHeader info to output file.
       * Some fields are really confusing, but it seems that all listed fields are very informative
       */

    }, {
      key: "_writeHeader",
      value: function _writeHeader() {
        var FBXHeaderVersion = 1003; // 1003 is some number which appears to present in many 6.1 ASCII files

        var FBXVersion = 6100; // Mandatory and only supported version

        var date = new Date();
        var timeStampVersion = 1000;
        var creator = "Miew FBX Exporter v".concat(this._info.version); // Supposed to be an engine

        return "; FBX 6.1.0 project file\n; Created by ".concat(creator, " Copyright (c) 2015-2020 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: ").concat(FBXHeaderVersion, "\n  FBXVersion: ").concat(FBXVersion, "\n  CreationTimeStamp:  {\n    Version: ").concat(timeStampVersion, "\n    Year: ").concat(date.getFullYear(), "\n    Month: ").concat(date.getMonth() + 1, " \n    Day: ").concat(date.getDate(), "\n    Hour: ").concat(date.getHours(), "\n    Minute: ").concat(date.getMinutes(), "\n    Second: ").concat(date.getSeconds(), "\n    Millisecond: ").concat(date.getMilliseconds(), "\n  }\n  Creator: \"").concat(creator, "\"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: \"").concat(date, "\"\nCreator: \"").concat(creator, "\"  \n");
      }
      /**
       * Add Definitions info to output file.
       * Not exactly sure if this section is template section (as it is in 7.4+) or it should every time be like this
       */

    }, {
      key: "_writeDefinitions",
      value: function _writeDefinitions() {
        return "\n; Object definitions\n;------------------------------------------------------------------\n\n".concat(defaultDefinitions, "\n");
      }
      /**
       * Adding gathered information about Models to resulting string.
       * Reminder - there may be more then 1 model in scene, but we must place materials after ALL models.
       * @returns {string} string containing all models (vertices, indices, colors, normals etc)
       */

    }, {
      key: "_models",
      value: function _models() {
        var modelVersion = 232;
        var allModels = '';
        var models = this._info.models;

        for (var i = 0; i < models.length; ++i) {
          var model = models[i];
          var vertCount = model.verticesCount;
          allModels += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n    Version: ").concat(modelVersion, " \n    ").concat(defaultProperties, "\n    ").concat(this._verticesIndices(model.positions, model.indices), "\n    ").concat(this._normalLayer(model.normals), " \n    ").concat(this._colorLayer(model.colors, vertCount), " \n    ").concat(defaultMaterialLayer, "  \n    ").concat(defaultLayerBlock, "\n  }");
        }

        return allModels;
      }
      /**
       * Add Material info to result
       */

    }, {
      key: "_materials",
      value: function _materials() {
        var materialVersion = 102;
        var allMaterials = '';
        var materials = this._info.materials;

        for (var i = 0; i < materials.length; ++i) {
          var material = materials[i];
          allMaterials += "\n  Material: \"Material::".concat(this._info.name, "_").concat(i, "_default\", \"\" {\n    Version: ").concat(materialVersion, "\n    ShadingModel: \"lambert\"\n    MultiLayer: 0\n    ").concat(this._materialProperties(material), "\n  }");
        }

        return allMaterials;
      }
      /**
       * Add Objects info to output file.
       */

    }, {
      key: "_writeObjects",
      value: function _writeObjects() {
        return "\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  ".concat(this._models(), "\n  ").concat(this._materials(), "\n  ").concat(globalSettings, "\n}\n");
      }
      /**
       * Add Relations info to output file.
       */

    }, {
      key: "_writeRelations",
      value: function _writeRelations() {
        var modelsList = '';

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n  }");
        }

        var materialList = '';

        for (var _i = 0; _i < this._info.materials.length; ++_i) {
          materialList += "\n  Material: \"Material::".concat(this._info.name, "_").concat(_i, "_default\", \"\" {\n  }");
        }

        return "\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  ".concat(modelsList, "\n  Model: \"Model::Producer Perspective\", \"Camera\" {\n  }\n  Model: \"Model::Producer Top\", \"Camera\" {\n  }\n  Model: \"Model::Producer Bottom\", \"Camera\" {\n  }\n  Model: \"Model::Producer Front\", \"Camera\" {\n  }\n  Model: \"Model::Producer Back\", \"Camera\" {\n  }\n  Model: \"Model::Producer Right\", \"Camera\" {\n  }\n  Model: \"Model::Producer Left\", \"Camera\" {\n  }\n  Model: \"Model::Camera Switcher\", \"CameraSwitcher\" {\n  }\n  ").concat(materialList, "\n}");
      }
      /**
       * Add Connections info to output file.
       */

    }, {
      key: "_writeConnections",
      value: function _writeConnections() {
        var modelsList = '';
        var name = this._info.name;

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Connect: \"OO\", \"Model::".concat(name, "_").concat(i, "\", \"Model::Scene\"");
        }

        var materialList = '';

        for (var _i2 = 0; _i2 < this._info.materials.length; ++_i2) {
          materialList += "\n  Connect: \"OO\", \"Material::".concat(name, "_").concat(_i2, "_default\", \"Model::").concat(name, "_").concat(_i2, "\"");
        }

        return "\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  ".concat(modelsList, "\n  ").concat(materialList, "\n}");
      }
      /**
       * Write float array to string with limited precision
       * @param {Float32Array} array - array to be fixed
       * @returns {String} String with fixed floats
       */

    }, {
      key: "_floatArrayToString",
      value: function _floatArrayToString(array) {
        var str = [];

        for (var i = 0; i < array.length; ++i) {
          str[i] = array[i].toFixed(6);
        }

        return str.join(',');
      }
      /**
       * Adding color layer to resulting file
       * @param {Float32Array} colorArray attribute
       * @param {number} vertCount - number of vertices in the model
       * @returns {string} color layer info
       */

    }, {
      key: "_colorLayer",
      value: function _colorLayer(colorArray, vertCount) {
        var layerElementColorNumber = 0;
        var layerElementColorVersion = 101;
        var layerElementColorName = '';

        var colorsStr = this._floatArrayToString(colorArray); // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed
        // As said [..Array(...)] - fastest and easiest way to produce [0, 1, .....] array


        var colorIndices = toConsumableArray(Array(vertCount).keys());

        return "\n    LayerElementColor: ".concat(layerElementColorNumber, " {\n      Version: ").concat(layerElementColorVersion, "\n      Name: \"").concat(layerElementColorName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\"\n      Colors: ").concat(colorsStr, "\n      ColorIndex: ").concat(colorIndices, "\n    }");
      }
      /**
       * Adding normal layer to resulting file
       * @param {Float32Array} normalArray attribute
       * @returns {string} normal layer info
       */

    }, {
      key: "_normalLayer",
      value: function _normalLayer(normalArray) {
        var layerElementNormalNumber = 0;
        var layerElementNormalVersion = 101;
        var layerElementNormalName = '';

        var normalsStr = this._floatArrayToString(normalArray); // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed


        return "\n    LayerElementNormal: ".concat(layerElementNormalNumber, " {\n      Version: ").concat(layerElementNormalVersion, "\n      Name: \"").concat(layerElementNormalName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\" \n      Normals: ").concat(normalsStr, "\n    }");
      }
      /**
       * Adding vertices and indices to resulting string
       * @return {string} resulting string in FBX notation
       */

    }, {
      key: "_verticesIndices",
      value: function _verticesIndices(positions, indices) {
        var multiLayer = 0;
        var multiTake = 1;
        var shading = 'Y';
        var culling = 'CullingOff';
        var geometryVersion = 124;

        var vertStr = this._floatArrayToString(positions);
        /* About _correctArrayNotation: Float32Arrays will contains only Float32 numbers, which implies that it will be floating points with 17 numbers after point.
        * We cannot (and it's logically incorrect) save all this information, so we convert this Float32Array into Array-like object with numbers with only 6 numbers after point
        * Reminder - this is big memory loss (as we must save at one moment two arrays with similar information) */


        return "MultiLayer: ".concat(multiLayer, "\n    MultiTake: ").concat(multiTake, "\n    Shading: ").concat(shading, "\n    Culling: \"").concat(culling, "\"\n    Vertices: ").concat(vertStr, "\n    PolygonVertexIndex: ").concat(indices, "\n    GeometryVersion: ").concat(geometryVersion);
      }
      /**
       * Forming material properties block.
       * @param {Object} material - given material of model
       * @returns {String} material properties string
       */

    }, {
      key: "_materialProperties",
      value: function _materialProperties(material) {
        return "Properties60:  {\n      Property: \"ShadingModel\", \"KString\", \"\", \"Lambert\"\n      Property: \"MultiLayer\", \"bool\", \"\",0\n      Property: \"EmissiveColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"EmissiveFactor\", \"double\", \"\",0.0000\n      Property: \"AmbientColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"AmbientFactor\", \"double\", \"\",0.0000\n      Property: \"DiffuseColor\", \"ColorRGB\", \"\",".concat(material.diffuse, "\n      Property: \"DiffuseFactor\", \"double\", \"\",1.0000\n      Property: \"Bump\", \"Vector3D\", \"\",0,0,0\n      Property: \"TransparentColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"TransparencyFactor\", \"double\", \"\",0.0000\n      Property: \"SpecularColor\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"SpecularFactor\", \"double\", \"\",1.0000\n      Property: \"ShininessExponent\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"ReflectionColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"ReflectionFactor\", \"double\", \"\",1\n      Property: \"Ambient\", \"ColorRGB\", \"\",1,1,1\n      Property: \"Diffuse\", \"ColorRGB\", \"\",").concat(material.diffuse, "\n      Property: \"Specular\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"Shininess\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"Opacity\", \"double\", \"\",").concat(material.opacity, "\n      Property: \"Reflectivity\", \"double\", \"\",0\n    }");
      }
    }]);

    return FBXResult;
  }();

  function _createSuper$1W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1X(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FBXExporter = /*#__PURE__*/function (_Exporter) {
    inherits(FBXExporter, _Exporter);

    var _super = _createSuper$1W(FBXExporter);

    function FBXExporter(source, options) {
      var _this;

      classCallCheck(this, FBXExporter);

      _this = _super.call(this, source, options); // Data

      _this._data = source;
      _this._version = options.miewVersion || '0.0-UNSPECIFIED';
      _this._extractor = new FBXInfoExtractor();
      return _this;
    }
    /**
     * Entry point to exporter.
     */


    createClass(FBXExporter, [{
      key: "exportSync",
      value: function exportSync() {
        // Creating mandatory blocks
        var result = new FBXResult();

        if (!this._source) {
          return this._result;
        }

        var info = this._extractor.process(this._data);

        info.version = this._version;
        this._result = result.getResult(info);
        return this._result;
      }
    }]);

    return FBXExporter;
  }(Exporter);
  FBXExporter.formats = ['fbx'];
  FBXExporter.SourceClass = ComplexVisual;

  var exporters = new ExporterList([PDBExporter, FBXExporter]);

  var io = {
    loaders: loaders,
    parsers: parsers,
    exporters: exporters
  };

  var tempColor = new THREE.Color();

  var CSS2DRenderer = /*#__PURE__*/function () {
    function CSS2DRenderer() {
      classCallCheck(this, CSS2DRenderer);

      this._width = 0;
      this._height = 0;
      this._widthHalf = 0;
      this._heightHalf = 0;
      this._vector = new THREE.Vector3();
      this._viewMatrix = new THREE.Matrix4();
      this._projectionMatrix = new THREE.Matrix4();
      this._domElement = document.createElement('div');
      this._domElement.style.overflow = 'hidden';
      this._domElement.style.position = 'absolute';
      this._domElement.style.top = '0';
      this._domElement.style.zIndex = '0'; // start a new Stacking Context to enclose all z-ordered children

      this._domElement.style.pointerEvents = 'none';
    }

    createClass(CSS2DRenderer, [{
      key: "getElement",
      value: function getElement() {
        return this._domElement;
      }
    }, {
      key: "reset",
      value: function reset() {
        var myNode = this.getElement();

        while (myNode.firstChild) {
          myNode.removeChild(myNode.firstChild);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this._width = width;
        this._height = height;
        this._widthHalf = this._width / 2;
        this._heightHalf = this._height / 2;
        this._domElement.style.width = "".concat(width, "px");
        this._domElement.style.height = "".concat(height, "px");
      }
    }, {
      key: "_renderObject",
      value: function _renderObject(object, camera, scene) {
        function lerpColorAsHex(a, b, t) {
          tempColor.setHex(a);
          tempColor.lerp(b, t);
          return "#".concat(tempColor.getHexString());
        }

        function colorAsHex(a) {
          tempColor.setHex(a);
          return "#".concat(tempColor.getHexString());
        }

        if (object instanceof CSS2DObject) {
          this._vector.setFromMatrixPosition(object.matrixWorld);

          if (object.userData !== undefined && object.userData.offset !== undefined) {
            var localOffset = new THREE.Vector3(object.userData.offset.x, object.userData.offset.y, 0);

            this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
          }

          this._vector.applyMatrix4(this._viewMatrix);

          var visibility = this._vector.z > -camera.near ? 'hidden' : 'visible';
          var zIndex = 10000 * (camera.far - -this._vector.z) / (camera.far - camera.near);
          var element = object.getElement();

          if (typeof scene.fog === 'undefined') {
            element.style.color = colorAsHex(object.userData.color);

            if (object.userData.background !== 'transparent') {
              element.style.background = colorAsHex(object.userData.background);
            }
          } else {
            var fogFactor = THREE.MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
            element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);

            if (object.userData.background !== 'transparent') {
              element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
            }
          }

          this._vector.applyMatrix4(this._projectionMatrix);

          var style = "".concat(object.userData !== {} ? object.userData.translation : 'translate(-50%, -50%) ', "translate(").concat(this._vector.x * this._widthHalf + this._widthHalf, "px,").concat(-this._vector.y * this._heightHalf + this._heightHalf, "px)");
          element.style.visibility = visibility;
          element.style.WebkitTransform = style;
          element.style.MozTransform = style;
          element.style.oTransform = style;
          element.style.transform = style;
          element.style.zIndex = Number(zIndex).toFixed(0);

          if (element.parentNode !== this._domElement) {
            this._domElement.appendChild(element);
          }
        }

        for (var i = 0, l = object.children.length; i < l; i++) {
          this._renderObject(object.children[i], camera, scene);
        }
      }
    }, {
      key: "render",
      value: function render(scene, camera) {
        scene.updateMatrixWorld();

        if (camera.parent === null) {
          camera.updateMatrixWorld();
        }

        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

        this._viewMatrix.copy(camera.matrixWorldInverse);

        this._projectionMatrix.copy(camera.projectionMatrix);

        this._renderObject(scene, camera, scene);
      }
    }]);

    return CSS2DRenderer;
  }();

  var VK_LEFT = 37;
  var VK_UP = 38;
  var VK_RIGHT = 39;
  var VK_DOWN = 40;
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    TRANSLATE: 1,
    SCALE: 2,
    TRANSLATE_PIVOT: 3
  }; // pausing for this amount of time before releasing mouse button prevents inertial rotation (seconds)

  var FULL_STOP_THRESHOLD = 0.1;
  var quaternion = new THREE.Quaternion();
  var matrix4 = new THREE.Matrix4(); // pivot -- local offset of the rotation pivot point

  function ObjectHandler(objects, camera, pivot, options) {
    this.objects = objects;

    var _objects = slicedToArray(objects, 1);

    this.object = _objects[0];
    this.camera = camera;
    this.pivot = pivot;
    this.axis = new THREE.Vector3(0, 0, 1);
    this.options = options;
    this.lastRotation = {
      axis: new THREE.Vector3(),
      angle: 0.0
    };
  }

  ObjectHandler.prototype._rotate = function () {
    var p = new THREE.Vector3();
    var q = new THREE.Quaternion();
    var s = new THREE.Vector3();
    var m = new THREE.Matrix4();
    return function (quat) {
      var zeroPivot = this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0;
      m.copy(this.object.matrix);

      if (zeroPivot) {
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
      } else {
        m.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
        m.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
      }

      m.decompose(p, q, s); // update objects

      if (!zeroPivot) {
        for (var i = 0; i < this.objects.length; ++i) {
          this.objects[i].position.copy(p);
        }
      }

      for (var j = 0; j < this.objects.length; ++j) {
        this.objects[j].quaternion.copy(q);
        this.objects[j].updateMatrix();
      }
    };
  }();

  ObjectHandler.prototype.setObjects = function (objects) {
    this.objects = objects;

    var _objects2 = slicedToArray(objects, 1);

    this.object = _objects2[0];
  };

  ObjectHandler.prototype.rotate = function () {
    var rot = {
      axis: new THREE.Vector3(),
      angle: 0.0
    };
    return function (quat, mousePrevPos, mouseCurPos, aboutAxis) {
      this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
      quat.setFromAxisAngle(rot.axis, rot.angle);

      if (rot.angle) {
        this._rotate(quat);
      }

      this.lastRotation = rot;
    };
  }();

  ObjectHandler.prototype.translate = function () {
    var dir = new THREE.Vector3();
    var pivot = new THREE.Vector3();
    return function (delta) {
      // reverse-project viewport movement to view coords (compensate for screen aspect ratio)
      dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
      var dist = dir.length();
      dir.normalize(); // transform movement direction to object local coords

      dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert()); // visible translate distance shouldn't depend on camera-to-object distance

      pivot.copy(this.pivot);
      this.object.localToWorld(pivot);
      dist *= Math.abs(pivot.z - this.camera.position.z); // visible translate distance shouldn't depend on object scale

      dist /= this.object.matrixWorld.getMaxScaleOnAxis(); // all objects are translated similar to principal object
      // (we assume they all have identical pivot and scale)

      for (var i = 0; i < this.objects.length; ++i) {
        this.objects[i].translateOnAxis(dir, dist);
      }
    };
  }();

  ObjectHandler.prototype.update = function () {
    var axis = new THREE.Vector3();
    return function (timeSinceLastUpdate, timeSinceMove) {
      if (settings.now.autoRotation !== 0.0) {
        // auto-rotation with constant speed
        // if rotation axis is fixed or hasn't been defined yet
        if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0.0) {
          // use Y-axis (transformed to local object coords)
          axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
        } else {
          // use axis defined by last user rotation
          axis.copy(this.lastRotation.axis);
        }

        this._rotate(quaternion.setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));

        return true;
      }

      if (this.options.intertia && this.lastRotation.angle) {
        // inertial object rotation
        var angle = this.lastRotation.angle * Math.pow(1.0 - this.options.dynamicDampingFactor, 40.0 * timeSinceMove);

        if (Math.abs(angle) <= this.options.intertiaThreshold) {
          this.lastRotation.angle = 0.0;
        } else {
          this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));

          return true;
        }
      }

      return false;
    };
  }();

  ObjectHandler.prototype.stop = function () {
    this.lastRotation.angle = 0.0;
  }; // calculate (axis, angle) pair from mouse/touch movement


  ObjectHandler.prototype.mouse2rotation = function () {
    var center = new THREE.Vector3();
    var eye = new THREE.Vector3();
    var eyeDirection = new THREE.Vector3();
    var cameraUpDirection = new THREE.Vector3();
    var cameraSidewaysDirection = new THREE.Vector3();
    var moveDirection = new THREE.Vector3();
    var mouseDelta = new THREE.Vector2();
    return function (rot, mousePrev, mouseCur, aboutAxis) {
      if (aboutAxis) {
        rot.axis.copy(this.axis);
        rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);
        /* cool method that allows rotation around Z axis to be "tied" to mouse cursor
           res.axis.copy(this.axis);
           var pivot = this.pivot.clone();
          this.object.localToWorld(pivot);
          pivot.project(this.camera);
           var v1 = new THREE.Vector3(mousePrev.x, mousePrev.y, this.camera.position.z);
          v1.sub(pivot);
          var v2 = new THREE.Vector3(mouseCur.x, mouseCur.y, this.camera.position.z);
          v2.sub(pivot);
           v1.sub(res.axis.clone().multiplyScalar(v1.dot(res.axis)));
          v2.sub(res.axis.clone().multiplyScalar(v2.dot(res.axis)));
           var abs = v1.length() * v2.length();
          if (abs > 0) {
            res.angle = res.axis.dot(v1.cross(v2)) / abs;
          }
        */
      } else {
        mouseDelta.subVectors(mouseCur, mousePrev);
        var angle = mouseDelta.length();

        if (angle === 0.0) {
          return;
        }

        center.copy(this.pivot);
        this.object.localToWorld(center);
        eye.subVectors(this.camera.position, center);
        eyeDirection.copy(eye).normalize();
        cameraUpDirection.copy(this.camera.up).normalize();
        cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
        cameraUpDirection.setLength(mouseDelta.y);
        cameraSidewaysDirection.setLength(mouseDelta.x);
        moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
        rot.axis.crossVectors(moveDirection, eye);
        rot.angle = -angle * this.options.rotateFactor;
      }

      rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert()); // make sure angle is always positive (thus 'axis' defines both axis and direction of rotation)

      if (rot.angle < 0.0) {
        rot.axis.negate();
        rot.angle = -rot.angle;
      }
    };
  }();

  function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
    EventDispatcher.call(this);
    var self = this;
    this.object = object;
    this.objectPivot = objectPivot;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.getAltObj = getAltObj; // API

    this.enabled = true;
    this.hotkeysEnabled = true;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this.options = {
      rotateFactor: Math.PI,
      // full screen slide (along short side) would roughly mean 180 deg. rotation
      axisRotateFactor: 4 * Math.PI,
      // full screen slide (along short side) would roughly mean 720 deg. rotation
      intertia: true,
      dynamicDampingFactor: 0.1,
      intertiaThreshold: 1e-3
    }; // internals

    this._state = STATE.NONE;
    this._mousePrevPos = new THREE.Vector2();
    this._mouseCurPos = new THREE.Vector2();
    this._mainObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._altObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._affectedObj = this._mainObj;
    this._isAltObjFreeRotationAllowed = true;
    this._isTranslationAllowed = true;
    this._isKeysTranslatingObj = false;
    this._pressedKeys = [];
    this._clock = new Timer();

    this._clock.start();

    this._lastUpdateTime = this._clock.getElapsedTime(); // events

    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousewheel',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'DOMMouseScroll',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseout',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchmove',
      handler: function handler(e) {
        self.touchmove(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keydown',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keyup',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }, {
      obj: window,
      type: 'blur',
      handler: function handler() {
        self.resetKeys();
      }
    }, {
      obj: self.domElement,
      type: 'contextmenu',
      handler: function handler(e) {
        self.contextmenu(e);
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
    this.resetKeys(); // force an update at start

    this.update();
  } // methods


  ObjectControls.prototype = Object.create(EventDispatcher.prototype);
  ObjectControls.prototype.constructor = ObjectControls;

  ObjectControls.prototype.resetKeys = function () {
    this._pressedKeys[VK_LEFT] = false;
    this._pressedKeys[VK_UP] = false;
    this._pressedKeys[VK_RIGHT] = false;
    this._pressedKeys[VK_DOWN] = false;
  };

  ObjectControls.prototype.contextmenu = function (e) {
    e.stopPropagation();
    e.preventDefault();
  };

  ObjectControls.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  ObjectControls.prototype.enable = function (enable) {
    this.enabled = enable;
  };

  ObjectControls.prototype.enableHotkeys = function (enable) {
    this.hotkeysEnabled = enable;
  };

  ObjectControls.prototype.allowTranslation = function (allow) {
    this._isTranslationAllowed = allow;
  };

  ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
    this._isAltObjFreeRotationAllowed = allow;
  };

  ObjectControls.prototype.keysTranslateObj = function (on) {
    this._isKeysTranslatingObj = on;
  };

  ObjectControls.prototype.isEditingAltObj = function () {
    return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
  }; // convert page coords of mouse/touch to uniform coords with smaller side being [-0.5, 0.5]
  // (uniform coords keep direct proportion with screen distance travelled by mouse regardless of screen aspect ratio)


  ObjectControls.prototype.convertMouseToOnCircle = function (coords, pageX, pageY) {
    var screenSize = Math.min(this.screen.width, this.screen.height);

    if (screenSize === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
  }; // convert page coords of mouse/touch to viewport coords with both sides being [-1, 1]
  // (those are non-uniform coords affected by screen aspect ratio)


  ObjectControls.prototype.convertMouseToViewport = function (coords, pageX, pageY) {
    if (this.screen.width === 0 || this.screen.height === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set(2.0 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2.0 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
  };

  ObjectControls.prototype.stop = function () {
    this._mainObj.stop();

    this._altObj.stop();
  }; // rotate object based on latest mouse/touch movement


  ObjectControls.prototype.rotateByMouse = function () {
    var quat = new THREE.Quaternion();
    return function (aboutZAxis) {
      this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);

      this.dispatchEvent({
        type: 'change',
        action: 'rotate',
        quaternion: quat
      });
    };
  }(); // rotate object by specified quaternion


  ObjectControls.prototype.rotate = function (quat) {
    this.object.quaternion.multiply(quat);
    this.dispatchEvent({
      type: 'change',
      action: 'rotate',
      quaternion: quat
    });
  }; // get object's orientation


  ObjectControls.prototype.getOrientation = function () {
    return this.object.quaternion;
  }; // set object's orientation


  ObjectControls.prototype.setOrientation = function (quat) {
    this.object.quaternion.copy(quat);
  }; // translate object based on latest mouse/touch movement


  ObjectControls.prototype.translate = function () {
    var delta = new THREE.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);

      this._affectedObj.translate(delta);

      this.dispatchEvent({
        type: 'change',
        action: 'translate'
      });
    };
  }(); // get object scale


  ObjectControls.prototype.getScale = function () {
    return this.object.scale.x;
  }; // set uniform object scale


  ObjectControls.prototype.setScale = function (scale) {
    this.object.scale.set(scale, scale, scale);
  }; // scale object by factor (factor should be greater than zero)


  ObjectControls.prototype.scale = function (factor) {
    if (factor <= 0) {
      return;
    }

    this.setScale(this.object.scale.x * factor);
    this.dispatchEvent({
      type: 'change',
      action: 'zoom',
      factor: factor
    });
  };

  ObjectControls.prototype.update = function () {
    var shift = new THREE.Vector2();
    return function () {
      var curTime = this._clock.getElapsedTime();

      var timeSinceLastUpdate = curTime - this._lastUpdateTime; // update object handler

      if (this._state === STATE.NONE) {
        var timeSinceMove = curTime - this._lastMouseMoveTime;

        if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
          this.dispatchEvent({
            type: 'change',
            action: 'auto'
          });
        }
      } // apply arrow keys


      if (this._isKeysTranslatingObj) {
        var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
        var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);

        if (speedX !== 0.0 || speedY !== 0.0) {
          var delta = timeSinceLastUpdate; // update object translation

          var altObj = this.getAltObj();

          if (altObj.objects.length > 0) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }

            shift.set(delta * speedX, delta * speedY);

            this._altObj.translate(shift);

            this.dispatchEvent({
              type: 'change',
              action: 'translate'
            });
          }
        }
      }

      this._lastUpdateTime = curTime;
    };
  }();

  ObjectControls.prototype.reset = function () {
    this._state = STATE.NONE;
    this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
  }; // listeners


  ObjectControls.prototype.mousedown = function (event) {
    if (this.enabled === false || this._state !== STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (this._state === STATE.NONE) {
      if (event.button === 0) {
        this._affectedObj.stop(); // can edit only one object at a time


        var workWithAltObj = false;

        if (event.altKey) {
          var altObj = this.getAltObj();
          workWithAltObj = altObj.objects.length > 0;

          if (workWithAltObj) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }
          }
        }

        this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
        this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
      } else if (event.button === 2) {
        this._state = STATE.TRANSLATE_PIVOT;
      }
    }

    if (this._state === STATE.ROTATE) {
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }

    if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }
  };

  ObjectControls.prototype.mousemove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
        this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.TRANSLATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translate();
        break;

      case STATE.TRANSLATE_PIVOT:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translatePivotByMouse();
        break;
    }
  };

  ObjectControls.prototype.mousewheel = function (event) {
    if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
      return;
    }

    event.preventDefault();
    var delta = 0;

    if (event.wheelDelta) {
      // WebKit / Opera / Explorer 9
      delta = event.wheelDelta / 40;
    } else if (event.detail) {
      // Firefox
      delta = -event.detail / 3;
    }

    var factor = 1.0 + delta * 0.05;
    factor = Math.max(factor, 0.01);
    this.scale(factor);
  };

  ObjectControls.prototype.mouseup = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    this._state = STATE.NONE;

    if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
      this._affectedObj.stop();
    }
  };

  ObjectControls.prototype.touchstartend = function (event) {
    if (this.enabled === false) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {
      case 1:
        this._state = STATE.ROTATE;
        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);

        this._mousePrevPos.copy(this._mouseCurPos);

        break;

      case 2:
        {
          // prevent inertial rotation
          this._mainObj.stop();

          this._altObj.stop();

          this._state = STATE.SCALE;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
          this._scaleStart = this.object.scale.x;
          break;
        }

      default:
        this._state = STATE.NONE;
    }
  };

  ObjectControls.prototype.touchmove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
        this.rotateByMouse(false);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.SCALE:
        if (settings.now.zooming) {
          // update scale
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
          var newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
          var factor = newScale / this.object.scale.x;
          this.scale(factor);
        }

        break;
    }
  };

  ObjectControls.prototype.keydownup = function (event) {
    if (this.enabled === false || this.hotkeysEnabled === false) {
      return;
    }

    switch (event.keyCode) {
      case VK_LEFT:
      case VK_UP:
      case VK_RIGHT:
      case VK_DOWN:
        this._pressedKeys[event.keyCode] = event.type === 'keydown';
        event.preventDefault();
        event.stopPropagation();
        break;
    }
  };

  ObjectControls.prototype.getKeyBindObject = function () {
    return window.top;
  };

  ObjectControls.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  ObjectControls.prototype.translatePivotByMouse = function () {
    var delta = new THREE.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);
      this.translatePivotInWorld(settings.now.translationSpeed * delta.x, settings.now.translationSpeed * delta.y, 0);
    };
  }(); // Translate in WorldCS, translation is scaled with root scale matrix


  ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.applyMatrix4(this.object.matrixWorld);
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  }; // Translate in ModelCS, x, y, z are Ang


  ObjectControls.prototype.translatePivot = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  }; // Set pivot


  ObjectControls.prototype.setPivot = function (newPivot) {
    this.objectPivot.position.copy(newPivot);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  };

  function Picker(gfxObj, camera, domElement) {
    EventDispatcher.call(this);
    var self = this;
    this.gfxObj = gfxObj;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this._lastMousePos = new THREE.Vector2(0, 0);
    this._mouseTotalDist = 0.0;
    this._lastClickBeginTime = -1000.0;
    this._lastClickPos = new THREE.Vector2(0, 0);
    this._clickBeginTime = 0.0;
    this._clock = new Timer();

    this._clock.start();

    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstart(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchend(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
  }

  Picker.prototype = Object.create(EventDispatcher.prototype);
  Picker.prototype.constructor = Picker;

  Picker.prototype.reset = function () {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
  };

  Picker.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  Picker.prototype.pickObject = function (screenPos) {
    if (!this.gfxObj) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var gfxObj = this.gfxObj;
    var rayCaster = new THREE.Raycaster();
    rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
    rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
    var clipPlane = settings.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
    var fogFarPlane = settings.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
    var point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);

    if (!point) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var picked = {};

    if (point.residue || point.atom) {
      var residue = point.residue || point.atom.residue;

      if (settings.now.pick === 'chain') {
        picked = {
          chain: residue.getChain()
        };
      } else if (settings.now.pick === 'molecule') {
        picked = {
          molecule: residue.getMolecule()
        };
      } else if (point.residue || settings.now.pick === 'residue') {
        picked = {
          residue: residue
        };
      } else if (point.atom) {
        picked = {
          atom: point.atom
        };
      }
    }

    this.picked = picked;
    this.dispatchEvent({
      type: 'newpick',
      obj: picked
    });
  };

  Picker.prototype.getMouseInViewport = function (pageX, pageY) {
    return new THREE.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
  };

  Picker.prototype.mousedown = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
      this._mouseTotalDist = 0.0;
      this._clickBeginTime = this._clock.getElapsedTime();
    }
  };

  Picker.prototype.mousemove = function (event) {
    event.preventDefault();
    event.stopPropagation();
    var pos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist += pos.sub(this._lastMousePos).length();
  };

  Picker.prototype.mouseup = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      if (this._mouseTotalDist < 0.01) {
        var curTime = this._clock.getElapsedTime();

        var curPos = this.getMouseInViewport(event.pageX, event.pageY);
        var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;

        if (timeSinceLastClickBegin < 0.7) {
          var clickDist = new THREE.Vector2().subVectors(curPos, this._lastClickPos);

          if (clickDist.length() < 0.01) {
            // it's a double click
            this.dispatchEvent({
              type: 'dblclick',
              obj: this.picked
            });
            this._lastClickPos = curPos;
            this._lastClickBeginTime = -1000; // this click cannot serve as first click in double-click

            return;
          }
        }

        setTimeout(function () {
          self.pickObject(curPos);
        }, 0);
        this._lastClickPos = curPos;
        this._lastClickBeginTime = this._clickBeginTime;
      }
    }
  };

  Picker.prototype.touchstart = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 1) {
      this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
    }
  };

  Picker.prototype.touchend = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
      var dist = pos.sub(this._lastTouchdownPos).length();

      if (dist < 0.01) {
        setTimeout(function () {
          self.pickObject(self._lastTouchdownPos);
        }, 0);
      }
    }
  };

  Picker.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  var Axes = /*#__PURE__*/function () {
    function Axes(target, targetCamera) {
      classCallCheck(this, Axes);

      this._target = target;
      this._targetCamera = targetCamera;
      this._camera = new THREE.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
      this._object = new THREE.AxesHelper(1);
      this._scene = new THREE.Scene();

      this._scene.add(this._object);

      this._full = new THREE.Vector2();

      this._update();
    }

    createClass(Axes, [{
      key: "_update",
      value: function _update() {
        var fov = this._targetCamera.fov;
        var camera = this._camera;
        camera.aspect = this._targetCamera.aspect;
        camera.setMinimalFov(fov);
        camera.setDistanceToFit(1.0, fov);
        camera.updateProjectionMatrix();

        this._object.quaternion.copy(this._target.quaternion);
      }
    }, {
      key: "render",
      value: function render(renderer) {
        this._update();

        renderer.getSize(this._full);
        var width = this._full.width * 0.25;
        var height = this._full.height * 0.25;
        var autoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setViewport(0.0, 0.0, width, height);
        renderer.clear(false, true, false);
        renderer.render(this._scene, this._camera);
        renderer.setViewport(0, 0, this._full.width, this._full.height);
        renderer.autoClear = autoClear;
      }
    }]);

    return Axes;
  }();

  var cDataOffset = 12;
  var cFirstMask = 0x0FFFFF00;
  var cFirstShift = 8;
  var cSecMask1 = 0x000000FF;
  var cSecShift1 = 12;
  var cSecMask2 = 0xFFF00000;
  var cSecShift2 = 20;
  var cThirdMask = 0x000FFFFF;
  var cStrMask = 0xF0000000;
  var cStrShift = 28;
  var c219 = 1 << 19;
  var c220 = 1 << 20;
  var cHelixIdx = 1;
  var cSheetIdx = 2;
  var secTypes = ['helix', 'strand'];
  var cSecNames = ['fs', 'ps', 'ns', 'us'];

  function _createSecondary(strArray, complex) {
    var residues = complex._residues;
    var nRes = residues.length;
    var resid = new Uint8Array(nRes);
    var atoms = complex._atoms;

    for (var i = 0, n = strArray.length; i < n; ++i) {
      var atom = atoms[i];
      resid[atom.residue._index] = strArray[i];
    }

    var secondary = [];
    var rIdx = 0;

    while (rIdx < nRes) {
      if (resid[rIdx] !== 0) {
        var start = rIdx;
        var val = resid[rIdx];

        while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
          ++rIdx;
        }

        secondary.push({
          start: start,
          end: rIdx,
          type: secTypes[val - 1]
        });
      }

      ++rIdx;
    }

    return secondary;
  }

  function fromUInt20ToInt20(uint20) {
    return uint20 >= c219 ? uint20 - c220 : uint20;
  }

  var FrameInfo = /*#__PURE__*/function () {
    function FrameInfo(complex, payload, callbacks) {
      classCallCheck(this, FrameInfo);

      this._complex = complex;
      this._secondary = null;
      this.isLoading = false;
      this._framesRange = {
        start: 0,
        end: -1
      };
      this.frameIsReady = false;
      this._buffer = null;
      this._frameRequest = null;
      this._callbacks = callbacks;

      if (typeof payload === 'function') {
        this._framesRequestLength = 1;
        this._downloadDataFn = payload;
      } else {
        this.parseBinaryData(payload, true);
      }

      this.reset();
      this.setFrame(0);
    }

    createClass(FrameInfo, [{
      key: "_prepareBuffer",
      value: function _prepareBuffer(framesStart, framesEnd) {
        if (framesStart === undefined || framesStart === null) {
          framesStart = 0;
        }

        if (framesEnd === undefined || framesEnd === null) {
          framesEnd = framesStart + this._framesRequestLength;
        }

        if (this._framesCount !== undefined) {
          framesEnd = Math.min(this._framesCount - 1, framesEnd);
        }

        if (this._downloadDataFn) {
          var self = this;

          var onDone = function onDone(data) {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
              self._callbacks.onLoadStatusChanged();
            }

            self._buffer = {
              data: data,
              state: 'ready',
              start: framesStart,
              end: framesEnd
            };

            if (self._frameRequest !== null) {
              var idx = self._frameRequest;
              self._frameRequest = null;
              self.setFrame(idx);
            }
          };

          var onFail = function onFail() {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onError === 'function') {
              self._callbacks.onError('Streaming failed');
            }
          };

          if (!this._buffer) {
            this._buffer = {};
          }

          this._buffer.state = 'downloading';
          this.isLoading = true;

          if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
            self._callbacks.onLoadStatusChanged();
          }

          this._downloadDataFn({
            start: framesStart,
            end: framesEnd + 1
          }, onDone, onFail);
        }
      }
    }, {
      key: "_parseBuffer",
      value: function _parseBuffer() {
        if (this._buffer && this._buffer.state === 'ready') {
          this._framesRange = {
            start: this._buffer.start,
            end: this._buffer.end
          };
          this.parseBinaryData(this._buffer.data, false);

          var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;

          if (_bufferRequestStart >= this._framesCount) {
            _bufferRequestStart = 0;
          }

          this._buffer = {
            state: 'none'
          };

          this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);

          if (this._frameRequest !== null) {
            var idx = this._frameRequest;
            this._frameRequest = null;
            this.setFrame(idx);
          }
        }
      }
    }, {
      key: "parseBinaryData",
      value: function parseBinaryData(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var offset = 0;
        var atomsCount = dataView.getUint32(offset, true);
        offset += 4;
        var framesCount = dataView.getUint32(offset, true);
        this._framesCount = framesCount;
        this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
        offset += 4;
        this._atomsCount = atomsCount;
        var maxSize = 1024 * 1024; // 1 MB

        this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
        var chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;

        if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
          throw new Error();
        }

        var complex = this._complex;
        var timeStep = dataView.getUint32(offset, true);
        var iName = 0;

        while (timeStep > 1000 && iName < cSecNames.length - 1) {
          timeStep /= 1000;
          ++iName;
        }

        this._timeStep = "".concat(timeStep.toString(), " ").concat(cSecNames[iName]);
        offset += 4;
        var secondary = [];
        var posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
        var coordIdx = 0;
        var secondaryArr = new Int8Array(atomsCount);

        for (var j = 0; j < chunkedFramesCount; ++j) {
          for (var i = 0; i < atomsCount; ++i) {
            var hiWord = dataView.getUint32(offset, true);
            offset += 4;
            var loWord = dataView.getUint32(offset, true);
            offset += 4;
            var str = (loWord & cStrMask) >>> cStrShift;
            var x = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
            var y = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
            var z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
            secondaryArr[i] = 0;

            if (str > 0 && str < 4) {
              secondaryArr[i] = cHelixIdx;
            } else if (str === 4) {
              secondaryArr[i] = cSheetIdx;
            }

            posData[coordIdx++] = x / 100;
            posData[coordIdx++] = y / 100;
            posData[coordIdx++] = z / 100;
          }

          secondary.push(_createSecondary(secondaryArr, complex));
        }

        this._secondaryData = secondary;
        this._data = posData;
      }
    }, {
      key: "nextFrame",
      value: function nextFrame() {
        this.setFrame((this._currFrame + 1) % this._framesCount);
      }
    }, {
      key: "needsColorUpdate",
      value: function needsColorUpdate(colorer) {
        return colorer instanceof SecondaryStructureColorer;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(colorer, atom) {
        return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(colorer, residue) {
        return colorer.getResidueColor(this._residues[residue._index], this._complex);
      }
    }, {
      key: "_updateSecondary",
      value: function _updateSecondary() {
        var i;
        var myResidues = this._residues;
        var n = myResidues.length;

        for (i = 0; i < n; ++i) {
          myResidues[i]._secondary = null;
        }

        var sec = this._secondaryData[this._currFrame - this._framesRange.start];

        for (i = 0, n = sec.length; i < n; ++i) {
          var oldSec = sec[i];
          var start = oldSec.start,
              end = oldSec.end;
          var nSec = {
            _start: myResidues[start],
            _end: myResidues[end],
            type: oldSec.type,
            generic: oldSec.generic
          };

          for (var j = start; j <= end; ++j) {
            myResidues[j]._secondary = nSec;
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var compRes = this._complex._residues;
        var n = compRes.length;
        this._residues = new Array(n);
        var myResidues = this._residues;

        var getSec = function getSec() {
          return this._secondary;
        };

        for (var i = 0; i < n; ++i) {
          myResidues[i] = {
            _type: compRes[i]._type,
            _isValid: compRes[i]._isValid,
            _controlPoint: null,
            _wingVector: null,
            _secondary: null,
            getSecondary: getSec
          };
        }
      }
    }, {
      key: "setFrame",
      value: function setFrame(frameIdx) {
        this.frameIsReady = false;

        if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
          this._currFrame = frameIdx;
          this._cachedResidues = false;

          this._updateSecondary();

          this.frameIsReady = true;
        } else {
          this._frameRequest = frameIdx;

          if (!this._buffer) {
            this._prepareBuffer(frameIdx);
          } else {
            var self = this;

            switch (this._buffer.state) {
              case 'none':
                this._prepareBuffer(frameIdx);

                break;

              case 'ready':
                self._parseBuffer();

                break;
            }
          }
        }
      }
    }, {
      key: "disableEvents",
      value: function disableEvents() {
        this._callbacks = null;
      }
      /**
       * Returns link to atom pos vector, clone it if needed
       */

    }, {
      key: "getAtomPos",
      value: function getAtomPos(atomIdx) {
        var vec = FrameInfo._vec;
        var self = this;
        var data = self._data;
        var idx = (self._atomsCount * (self._currFrame - self._framesRange.start) + atomIdx) * 3;
        vec.set(data[idx], data[idx + 1], data[idx + 2]);
        return vec;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        if (this._cachedResidues) {
          return this._residues;
        }

        this._complex.updateToFrame(this);

        return this._residues;
      }
    }]);

    return FrameInfo;
  }();

  defineProperty(FrameInfo, "_vec", new THREE.Vector3());

  /**
   * Create new scene object.
   *
   * @param {array=} params - Object required params.
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
   *
   * @exports SceneObject
   * @this SceneObject
   * @abstract
   * @constructor
   * @classdesc Basic class for all scene objects that are not reps.
   */

  var SceneObject = /*#__PURE__*/function () {
    function SceneObject(params, opts) {
      classCallCheck(this, SceneObject);

      if (this.constructor === SceneObject) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Object's options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.params = params;
      this.opts = ___default['default'].merge(utils.deriveDeep(settings.now.objects[this.type], true), opts);
      this.needsRebuild = false;
      this._mesh = null;
      this.id = null;
    }
    /**
     * Get object identification, probably with options.
     *  @returns {Object} field type contains type information, params - object's formal parameters,
     * opts - changed options
     * Options are returned if they were changed during or after object creation.
     */


    createClass(SceneObject, [{
      key: "identify",
      value: function identify() {
        var result = {
          type: this.type,
          params: this.params
        };
        var diff = utils.objectsDiff(this.opts, settings.now.modes[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          result.opts = diff;
        }

        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        var paramsStr = "o=".concat(this.type, ",").concat(this.params.join(','));
        var optsStr = utils.compareOptionsWithDefaults(this.opts, settings.defaults.objects[this.type]);
        return paramsStr + optsStr;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this._mesh;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._mesh) {
          gfxutils.destroyObject(this._mesh);
        }
      }
    }]);

    return SceneObject;
  }();
  /**
   * Scene object identifier.
   * @type {string}
   */


  SceneObject.prototype.type = '__';

  function _createSuper$1X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var LinesObj = /*#__PURE__*/function (_SceneObject) {
    inherits(LinesObj, _SceneObject);

    var _super = _createSuper$1X(LinesObj);

    function LinesObj(params, opts) {
      var _this;

      classCallCheck(this, LinesObj);

      _this = _super.call(this, params, opts);

      if (params.length < 2) {
        throw new Error('Wrong number of argumets on line object creation!');
      }

      var _params = slicedToArray(params, 2);

      _this._id1 = _params[0];
      _this._id2 = _params[1];
      return _this;
    }

    createClass(LinesObj, [{
      key: "_getAtomFromName",
      value: function _getAtomFromName(complex, atomId) {
        var err = ' - Wrong atom format it must be \'#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME\' (e.g. \'A.38.CO1\')';
        var atom1 = complex.getAtomByFullname(atomId);

        if (!atom1) {
          throw new Error(atomId + err);
        }

        return atom1;
      }
    }, {
      key: "build",
      value: function build(complex) {
        var geom = new THREE.BufferGeometry();
        this._atom1 = this._getAtomFromName(complex, this._id1);
        this._atom2 = this._getAtomFromName(complex, this._id2);
        var p1 = this._atom1.position;
        var p2 = this._atom2.position;
        var vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeBoundingBox();
        this._line = new meshes.Line(geom, new UberMaterial({
          lights: false,
          overrideColor: true,
          dashedLine: true,
          fogTransparent: settings.now.bg.transparent
        }));

        this._line.computeLineDistances();

        this._line.material.setUberOptions({
          fixedColor: new THREE.Color(this.opts.color),
          dashedLineSize: this.opts.dashSize,
          dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
        });

        this._line.material.updateUniforms();

        this._line.raycast = function (_raycaster, _intersects) {};

        this._mesh = this._line;
        var transforms = complex.getTransforms();

        if (transforms.length > 0) {
          this._mesh = new THREE.Group();

          this._mesh.add(this._line);

          meshutils.applyTransformsToMeshes(this._mesh, transforms);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        if (!this._atom1 || !this._atom2 || !this._line) {
          return;
        }

        var geo = this._line.geometry;
        geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
        geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));

        this._line.computeLineDistances();

        geo.computeBoundingSphere();
        geo.verticesNeedUpdate = true;
      }
    }]);

    return LinesObj;
  }(SceneObject);

  LinesObj.prototype.constructor = LinesObj;
  LinesObj.prototype.type = 'line';

  var fragmentShader$1 = "precision highp float;\n\nuniform sampler2D srcTex;\nuniform vec2 srcTexSize;\nuniform vec2 thickness;\nvarying vec2 vUv;\n\n#ifdef DEPTH_OUTLINE\n  uniform sampler2D srcDepthTex; //depthTexture\n  uniform vec3 color;\n  uniform float threshold;\n#endif\n\nvoid main() {\n\n  vec2 pixelSize = thickness / srcTexSize;\n\n  #ifdef DEPTH_OUTLINE\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\n\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\n\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\n\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\n\n  #else\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\n\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\n\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\n    gl_FragColor = grad;\n  #endif\n}\n";

  function _createSuper$1Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var OutlineMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(OutlineMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1Y(OutlineMaterial);

    function OutlineMaterial(params) {
      var _this;

      classCallCheck(this, OutlineMaterial);

      // add depth outline
      _this = _super.call(this, params);
      var settings = {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcDepthTex: {
            type: 't',
            value: null
          },
          srcTexSize: {
            type: 'v2',
            value: new THREE.Vector2(512, 512)
          },
          color: {
            type: 'v3',
            value: null
          },
          threshold: {
            type: 'f',
            value: null
          },
          opacity: {
            type: 'f',
            value: 1.0
          },
          thickness: {
            type: 'v2',
            value: new THREE.Vector2(1, 1)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$1,
        transparent: true,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    createClass(OutlineMaterial, [{
      key: "copy",
      value: function copy(source) {
        get(getPrototypeOf(OutlineMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(OutlineMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.depth) {
          defines.DEPTH_OUTLINE = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return OutlineMaterial;
  }(THREE.RawShaderMaterial);

  OutlineMaterial.prototype.depth = false;

  var fragmentShader$2 = "precision highp float;\n\n// edge end finding algorithm parameters\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n// constants\nfloat fxaaQualityEdgeThreshold = 0.125;\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\nfloat fxaaQualitySubpix = 0.7; //0.65;\n// global params\nuniform sampler2D srcTex;\nuniform vec2 srcTexelSize;\nuniform vec3 bgColor;\n// from vs\nvarying vec2 vUv;\n//=====================================================================//\n// calc luminance from rgb\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\n                                                                           // for non-real scene rendering\n// texture sampling by pixel position(coords) and offset(in pixels)\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\n  #ifdef BG_TRANSPARENT\n    vec4 color = texture2D( tex, pos + off * res );\n    return mix(color.rgb, bgColor, 1.0 - color.a);\n  #else\n    return texture2D( tex, pos + off * res ).xyz;\n  #endif\n}\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\n  #ifdef BG_TRANSPARENT\n    vec4 color = texture2D( tex, pos );\n    return mix(color.rgb, bgColor, 1.0 - color.a);\n  #else\n    return texture2D( tex, pos).xyz;\n  #endif\n}\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\n  return texture2D( tex, pos);\n}\n\n//=====================================================================//\nvoid main() {\n  // renaming\n  vec2 posM = vUv;\n  // get luminance for neighbours\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\n  // find max and min luminance\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\n  // calc maximum non-edge range\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n  float range = rangeMax - rangeMin;\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n  // exit when luma contrast is small (is not edge)\n  if(range < rangeMaxClamped){\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\n    return;\n  }\n  float subpixRcpRange = 1.0/range;\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\n  // visibly, thus we decided to leave calculation here for better readability.\n  // calc other neighbours luminance\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\n/*--------------span calculation and subpix amount calulation-----------------*/\n  float lumaNS = lumaN + lumaS;\n  float lumaWE = lumaW + lumaE;\n  float subpixNSWE = lumaNS + lumaWE;\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n  float lumaNESE = lumaNE + lumaSE;\n  float lumaNWNE = lumaNW + lumaNE;\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n  float lumaNWSW = lumaNW + lumaSW;\n  float lumaSWSE = lumaSW + lumaSE;\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n  float edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------subpix amount calulation------------------------------*/\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\n  float lengthSign = srcTexelSize.x;\n  bool horzSpan = edgeHorz >= edgeVert;\n   // debug  code edge span visualization\n/*'  if (horzSpan)\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n  else\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  return;*/\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n  if(!horzSpan) lumaN = lumaW;\n  if(!horzSpan) lumaS = lumaE;\n  if(horzSpan) lengthSign = srcTexelSize.y;\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n  float gradientN = lumaN - lumaM;\n  float gradientS = lumaS - lumaM;\n  float lumaNN = lumaN + lumaM;\n  float lumaSS = lumaS + lumaM;\n  bool pairN = abs(gradientN) >= abs(gradientS);\n  float gradient = max(abs(gradientN), abs(gradientS));\n  if(pairN) lengthSign = -lengthSign;\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n/*--------------------------------------------------------------------------*/\n  vec2 posB;\n  posB = posM;\n  vec2 offNP;\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\n  if(!horzSpan) posB.x += lengthSign * 0.5;\n  if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n  vec2 posN;\n  posN = posB - offNP * FXAA_QUALITY_P0;\n  vec2 posP;\n  posP = posB + offNP * FXAA_QUALITY_P0;\n  float subpixD = ((-2.0)*subpixC) + 3.0;\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\n  float subpixE = subpixC * subpixC;\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\n/*--------------------------------------------------------------------------*/\n  if(!pairN) lumaNN = lumaSS;\n  float gradientScaled = gradient * 1.0/4.0;\n  float lumaMM = lumaM - lumaNN * 0.5;\n  float subpixF = subpixD * subpixE;\n  bool lumaMLTZero = lumaMM < 0.0;\n/*---------------------looped edge-end search-------------------------------*/\n  lumaEndN -= lumaNN * 0.5;\n  lumaEndP -= lumaNN * 0.5;\n  bool doneN = abs(lumaEndN) >= gradientScaled;\n  bool doneP = abs(lumaEndP) >= gradientScaled;\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\n  bool doneNP = (!doneN) || (!doneP);\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n  if(doneNP) {\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n    doneN = abs(lumaEndN) >= gradientScaled;\n    doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\n    doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 3)\n      if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 4)\n          if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 5)\n               if(doneNP) {\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                 doneN = abs(lumaEndN) >= gradientScaled;\n                 doneP = abs(lumaEndP) >= gradientScaled;\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\n                 doneNP = (!doneN) || (!doneP);\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                 #if (FXAA_QUALITY_PS > 6)\n                   if(doneNP) {\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                     doneN = abs(lumaEndN) >= gradientScaled;\n                     doneP = abs(lumaEndP) >= gradientScaled;\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\n                     doneNP = (!doneN) || (!doneP);\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                     #if (FXAA_QUALITY_PS > 7)\n                       if(doneNP) {\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                         doneN = abs(lumaEndN) >= gradientScaled;\n                         doneP = abs(lumaEndP) >= gradientScaled;\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\n                         doneNP = (!doneN) || (!doneP);\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n                       }\n                     #endif\n                   }\n                 #endif\n               }\n             #endif\n           }\n         #endif\n      }\n    #endif\n  }\n/*----------------calculate subpix offset due to edge ends-------------------*/\n  float dstN = posM.x - posN.x;\n  float dstP = posP.x - posM.x;\n  if(!horzSpan) dstN = posM.y - posN.y;\n  if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n  float spanLength = (dstP + dstN);\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n  float spanLengthRcp = 1.0 / spanLength;\n/*--------------------------------------------------------------------------*/\n  bool directionN = dstN < dstP;\n  float dst = min(dstN, dstP);\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\n  float subpixG = subpixF * subpixF;\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n  float subpixH = subpixG * fxaaQualitySubpix;\n/*-----------------calc texture offest using subpix-------------------------*/\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\n  float offset = pixelOffsetSubpix * lengthSign;\n  #ifdef BG_TRANSPARENT\n    // get original texel\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\n    // calc step to blended texel\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\n    // get neighboring texel\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\n    //  calc blend factor from offset\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\n    f = abs(f);\n    // calc alpha (special formula to emulate blending with bg)\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\n    // calc color (special formula to emulate blending with bg)\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\n  #else\n    if(!horzSpan) {\n       posM.x += offset;\n    } else {\n       posM.y += offset;\n    }\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\n  #endif\n  return;\n}\n";

  function _createSuper$1Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1_(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FXAAMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(FXAAMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1Z(FXAAMaterial);

    function FXAAMaterial(params) {
      var _this;

      classCallCheck(this, FXAAMaterial);

      _this = _super.call(this, params); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          bgColor: {
            type: 'c',
            value: new THREE.Color(0xffffff)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$2,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    createClass(FXAAMaterial, [{
      key: "copy",
      value: function copy(source) {
        get(getPrototypeOf(FXAAMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(FXAAMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.bgTransparent) {
          defines.BG_TRANSPARENT = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return FXAAMaterial;
  }(THREE.RawShaderMaterial);

  FXAAMaterial.prototype.bgTransparent = false;

  var fragmentShader$3 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 32\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\nuniform sampler2D noiseTexture;\nuniform vec2      noiseTexelSize;\nuniform sampler2D diffuseTexture;\nuniform sampler2D depthTexture;\nuniform sampler2D normalTexture;\nuniform vec2      srcTexelSize;\nuniform vec2      camNearFar;\nuniform mat4      projMatrix;\n\nuniform float aspectRatio;\nuniform float tanHalfFOV;\n\nuniform float kernelRadius;\nuniform float depthThreshold;\nuniform float factor;\n\nvarying vec2 vUv;\n\nfloat CalcViewZ(vec2 screenPos)\n{\n  float depth = texture2D(depthTexture, screenPos).x;\n  // [0, 1]->[-1, 1]\n  float clipedZ = 2.0 * depth - 1.0;\n  // see THREE.js camera.makeFrustum for projection details\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\n}\n\nvec3 ViewPosFromDepth(vec2 screenPos)\n{\n  vec3 viewPos;\n  viewPos.z = CalcViewZ(screenPos);\n  //[0, 1]->[-1, 1]\n  vec2 projPos = 2.0 * screenPos - 1.0;\n  // reconstruct viewposition in right-handed sc with z to viewer\n  viewPos.xy = vec2(\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\n                   );\n  return viewPos;\n}\n\nvoid main() {\n  vec3 viewPos = ViewPosFromDepth(vUv);\n  // remap coordinates to prevent noise exture rescale\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\n  vec4 normalData = texture2D(normalTexture, vUv);\n  // return for background fragments (their normals are zero vectors)\n  if (length(normalData.rgb) < EPSILON) {\n    // 0.0 in alpha component means that it is background fragment\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n  }\n  //[0, 1] -> [-1, 1]\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\n  // normalData.a store 1.0 if normal was build for frontfaced surface\n  // and 0.0 in other case\n  if (normalData.a < EPSILON) {\n    normal *= -1.0;\n  }\n  // get random vector for sampling sphere rotation\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\n  randN = normalize(randN);\n  // build TBN (randomly rotated around normal)\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\n  vec3 bitangent = cross(tangent, normal);\n  mat3 TBN = mat3(tangent, bitangent, normal);\n  // calc AO value\n  float AO = 0.0;\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\n    // rotate sampling kernel around normal\n    vec3 reflectedSample = TBN * samplesKernel[i];\n    // get sample\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\n\n    // project sample to screen to get sample's screen pos\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\n    // eye -> clip\n    SampleScrPos = projMatrix * SampleScrPos;\n    // normalize\n    SampleScrPos.xy /= SampleScrPos.w;\n    //[-1, 1] -> [0, 1]\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\n\n    // get view z for sample projected to the objct surface\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\n    // calc occlusion made by object surface at the sample\n    AO += step(samplePos.z, sampleDepth);\n  }\n  // calc result AO-map color\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\n  // write value to AO-map\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\n}\n";

  function _createSuper$1_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1$(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _samplesKernel$1 = [// hemisphere samples adopted to sphere
  new THREE.Vector3(0.295184, 0.077723, 0.068429), new THREE.Vector3(-0.271976, -0.365221, 0.838363), new THREE.Vector3(0.547713, 0.467576, 0.488515), new THREE.Vector3(0.662808, -0.031733, 0.584758), new THREE.Vector3(-0.025717, 0.218955, 0.657094), new THREE.Vector3(-0.310153, -0.365223, 0.370701), new THREE.Vector3(-0.101407, -0.006313, 0.747665), new THREE.Vector3(-0.769138, 0.360399, 0.086847), new THREE.Vector3(-0.271988, -0.275140, 0.905353), new THREE.Vector3(0.096740, -0.566901, 0.700151), new THREE.Vector3(0.562872, -0.735136, 0.094647), new THREE.Vector3(0.379877, 0.359278, 0.190061), new THREE.Vector3(0.519064, -0.023055, 0.405068), new THREE.Vector3(-0.301036, 0.114696, 0.088885), new THREE.Vector3(-0.282922, 0.598305, 0.487214), new THREE.Vector3(-0.181859, 0.251670, 0.679702), new THREE.Vector3(-0.191463, -0.635818, 0.512919), new THREE.Vector3(-0.293655, 0.427423, 0.078921), new THREE.Vector3(-0.267983, 0.680534, 0.132880), new THREE.Vector3(0.139611, 0.319637, 0.477439), new THREE.Vector3(-0.352086, 0.311040, 0.653913), new THREE.Vector3(0.321032, 0.805279, 0.487345), new THREE.Vector3(0.073516, 0.820734, 0.414183), new THREE.Vector3(-0.155324, 0.589983, 0.411460), new THREE.Vector3(0.335976, 0.170782, 0.527627), new THREE.Vector3(0.463460, -0.355658, 0.167689), new THREE.Vector3(0.222654, 0.596550, 0.769406), new THREE.Vector3(0.922138, -0.042070, 0.147555), new THREE.Vector3(-0.727050, -0.329192, 0.369826), new THREE.Vector3(-0.090731, 0.533820, 0.463767), new THREE.Vector3(-0.323457, -0.876559, 0.238524), new THREE.Vector3(-0.663277, -0.372384, 0.342856)];

  var AOMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1_(AOMaterial);

    function AOMaterial() {
      var _this;

      classCallCheck(this, AOMaterial);

      _this = _super.call(this); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          noiseTexture: {
            type: 't',
            value: noise.noiseTexture
          },
          noiseTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight)
          },
          diffuseTexture: {
            type: 't',
            value: null
          },
          normalTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          camNearFar: {
            type: 'v2',
            value: new THREE.Vector2(1.0, 10.0)
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          samplesKernel: {
            type: 'v3v',
            value: _samplesKernel$1
          },
          kernelRadius: {
            type: 'f',
            value: 1.0
          },
          depthThreshold: {
            type: 'f',
            value: 1.0
          },
          factor: {
            type: 'f',
            value: 1.0
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$3,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOMaterial;
  }(THREE.RawShaderMaterial);

  var fragmentShader$4 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 5\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\nuniform sampler2D aoMap;\nuniform sampler2D depthTexture;\nuniform vec2      srcTexelSize;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float x = vUv.x;\n  float y = vUv.y;\n  vec4 res = vec4(0.0);\n  res.a = texture2D(aoMap, vec2(x, y )).a;\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\n  if (res.a < EPSILON) {\n    gl_FragColor = res;\n    return;\n  }\n\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\n  float weightSum = 0.0;\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\n      continue;\n    }\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\n    float depth = texture2D(depthTexture, samplePos).x;\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\n    weightSum += weight;\n  }\n  res.rgb = res.rgb / weightSum;\n  gl_FragColor = res;\n}\n";

  function _createSuper$1$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$20(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$20() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOHorBlurMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOHorBlurMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1$(AOHorBlurMaterial);

    function AOHorBlurMaterial() {
      var _this;

      classCallCheck(this, AOHorBlurMaterial);

      _this = _super.call(this); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$4,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOHorBlurMaterial;
  }(THREE.RawShaderMaterial);

  var fragmentShader$5 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 5\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\nuniform sampler2D diffuseTexture;\nuniform sampler2D aoMap;\nuniform sampler2D depthTexture;\nuniform vec2      srcTexelSize;\n\nuniform mat4  projMatrix;\nuniform float aspectRatio;\nuniform float tanHalfFOV;\n\n#ifdef USE_FOG\n  uniform vec2 fogNearFar;\n  uniform vec4 fogColor;\n#endif\nvarying vec2 vUv;\n\nfloat CalcViewZ(vec2 screenPos)\n{\n  float depth = texture2D(depthTexture, screenPos).x;\n  // [0, 1]->[-1, 1]\n  float clipedZ = 2.0 * depth - 1.0;\n  // see THREE.js camera.makeFrustum for projection details\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\n}\n\nvec3 ViewPosFromDepth(vec2 screenPos)\n{\n  vec3 viewPos;\n  viewPos.z = CalcViewZ(screenPos);\n  //[0, 1]->[-1, 1]\n  vec2 projPos = 2.0 * screenPos - 1.0;\n  // reconstruct viewposition in right-handed sc with z to viewer\n  viewPos.xy = vec2(\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\n  projPos.y * tanHalfFOV * abs(viewPos.z)\n  );\n  return viewPos;\n}\n\nvoid main() {\n  vec3 viewPos = ViewPosFromDepth(vUv);\n  float x = vUv.x;\n  float y = vUv.y;\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\n  vec4 res = vec4(0.0);\n  res.a = texture2D(aoMap, vec2(x, y )).a;\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\n  if (res.a < EPSILON) {\n    gl_FragColor = color;\n    return;\n  }\n\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\n  float weightSum = 0.0;\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\n      continue;\n    }\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\n    float depth = texture2D(depthTexture, samplePos).x;\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\n    weightSum += weight;\n  }\n  res.rgb /= weightSum;\n\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\n    // Add fog to the result value\n    // Proper way to get an image with fog and ao requires formula:\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\n    // We have:  AO, fogFactor, fogColor,\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\n    //                                                                where molecule has been already drawn with fog)\n    // Transform:\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\n  #else\n    gl_FragColor.rgb = color.rgb * res.rgb;\n  #endif\n  gl_FragColor.a = color.a;\n}\n";

  function _createSuper$20(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$21(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$21() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets$1 = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOVertBlurWithBlendMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOVertBlurWithBlendMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$20(AOVertBlurWithBlendMaterial);

    function AOVertBlurWithBlendMaterial(params) {
      var _this;

      classCallCheck(this, AOVertBlurWithBlendMaterial);

      _this = _super.call(this, params); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          diffuseTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets$1
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          fogNearFar: {
            type: 'v2',
            value: new THREE.Vector2(100.0, 100.0)
          },
          fogColor: {
            type: 'v4',
            value: new THREE.Vector4(0.0, 0.5, 0.0, 1.0)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$5,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    createClass(AOVertBlurWithBlendMaterial, [{
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(AOVertBlurWithBlendMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.useFog) {
          defines.USE_FOG = 1;
        }

        if (this.fogTransparent) {
          defines.FOG_TRANSPARENT = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return AOVertBlurWithBlendMaterial;
  }(THREE.RawShaderMaterial);

  AOVertBlurWithBlendMaterial.prototype.useFog = true;
  AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;

  var fragmentShader$6 = "precision highp float;\n\nuniform sampler2D srcL;\nuniform sampler2D srcR;\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 l = texture2D(srcL, vUv);\n  vec4 r = texture2D(srcR, vUv);\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\n}\n";

  function _createSuper$21(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$22(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$22() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AnaglyphMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AnaglyphMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$21(AnaglyphMaterial);

    function AnaglyphMaterial() {
      var _this;

      classCallCheck(this, AnaglyphMaterial);

      _this = _super.call(this);
      var settings = {
        uniforms: {
          srcL: {
            type: 't',
            value: null
          },
          srcR: {
            type: 't',
            value: null
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$6,
        transparent: false,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    return AnaglyphMaterial;
  }(THREE.RawShaderMaterial);

  var View = /*#__PURE__*/function () {
    function View() {
      classCallCheck(this, View);

      this.position = new THREE.Vector3(0, 0, 0);
      this.scale = 1;
      this.orientation = new THREE.Quaternion(0, 0, 0, 1);
    }

    createClass(View, [{
      key: "set",
      value: function set(position, scale, orientation) {
        this.position = position;
        this.scale = scale;
        this.orientation = orientation;
      }
    }]);

    return View;
  }();

  var _transitionTime = 1.5; // in seconds

  var ViewInterpolator = /*#__PURE__*/function () {
    function ViewInterpolator() {
      classCallCheck(this, ViewInterpolator);
    }

    createClass(ViewInterpolator, [{
      key: "setup",
      value: function setup(startView, endView) {
        this._startTime = undefined;
        this._endTime = undefined;
        this._isPaused = false;
        this._srcView = startView;
        this._dstView = endView;
        this._isMoving = false;
      }
    }, {
      key: "isMoving",
      value: function isMoving() {
        return this._isMoving;
      }
    }, {
      key: "wasStarted",
      value: function wasStarted() {
        return typeof this._startTime !== 'undefined' && typeof this._endTime !== 'undefined';
      }
    }, {
      key: "start",
      value: function start() {
        this._startTime = Date.now();
        var transTime = settings.now.interpolateViews ? _transitionTime * 1000 : 0;
        this._endTime = this._startTime + transTime;
        this._isMoving = true;
      }
    }, {
      key: "getCurrentView",
      value: function getCurrentView() {
        if (typeof this._srcView === 'undefined' || typeof this._dstView === 'undefined' || !this._isMoving || !this.wasStarted()) {
          return {
            success: false
          };
        }

        var view = this.createView();
        var time = Date.now();

        if (time > this._endTime) {
          view = this._dstView;
          this.reset();
          return {
            success: true,
            view: view
          };
        }

        var factor = (time - this._startTime) / (this._endTime - this._startTime);
        view.position.copy(this._srcView.position);
        view.position.lerp(this._dstView.position, factor);
        view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
        view.orientation.copy(this._srcView.orientation);
        view.orientation.slerp(this._dstView.orientation, factor);
        return {
          success: true,
          view: view
        };
      }
    }, {
      key: "reset",
      value: function reset() {
        this._startTime = this._endTime = 0;
        this._isMoving = false;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (!this._isPaused) {
          this.setup(this.getCurrentView().view, this._dstView);
          this._isPaused = true;
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this._isPaused = false;
      }
    }, {
      key: "createView",
      value: function createView() {
        return new View();
      }
    }]);

    return ViewInterpolator;
  }();

  var MAX_COOKIE_LEN = 4000;
  var COUNT_SUFFIX = 'Cnt';

  function _chunkString(string, chunkLen) {
    var l = string.length;
    var chunks = [];

    for (var c = 0, lc = 0; lc < l; c++, lc += chunkLen) {
      chunks[c] = string.slice(lc, lc + chunkLen);
    }

    return chunks;
  }
  /**
   * Create new context dependent Cookie holder object.
   * @param context
   * @param {Object} opts - options
   * @param {string} opts.path - cookie path
   * @constructor
   */


  function Cookies(context, opts) {
    this.context = context;
    this._opts = ___default['default'].merge({
      path: '/'
    }, opts);
  }

  makeContextDependent(Cookies.prototype);
  /**
   * Remove cookie by the name.
   * @param key
   */

  Cookies.prototype.removeCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      this._removeSimpleCookie(key);

      return;
    }

    this._removeSimpleCookie(cntKey);

    cntVal = parseInt(cntVal, 10);

    for (var i = 0; i < cntVal; ++i) {
      this._removeSimpleCookie(key + i);
    }
  };
  /**
   * Set new cookie value. Automatically splits
   * values that are too large into multiple cookies.
   * @param key
   * @param value
   */


  Cookies.prototype.setCookie = function (key, value) {
    this.removeCookie(key);
    value = encodeURIComponent(value);

    var values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);

    var cntVal = values.length;

    if (cntVal === 1) {
      this._setSimpleCookie(key, value);

      return;
    }

    var cntKey = this._toCount(key);

    this._setSimpleCookie(cntKey, cntVal.toString());

    for (var i = 0; i < cntVal; ++i) {
      this._setSimpleCookie(key + i, values[i]);
    }
  };
  /**
   * Obtain the value of a compound cookie.
   * @param key
   */


  Cookies.prototype.getCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      return this._getSimpleCookie(key);
    }

    cntVal = parseInt(cntVal, 10);
    var value = [];

    for (var i = 0; i < cntVal; ++i) {
      value[i] = this._getSimpleCookie(key + i);
    }

    return value.join('');
  };

  Cookies.prototype._toCount = function (key) {
    return key + COUNT_SUFFIX;
  };

  Cookies.prototype._removeSimpleCookie = function (key) {
    document.cookie = "".concat(key, "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;");
  };

  Cookies.prototype._getExpirationDate = function () {
    var today = new Date();
    var EXP_PERIOD_YEARS = 10;
    today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
    return today;
  };

  Cookies.prototype._setSimpleCookie = function (key, value) {
    document.cookie = "".concat(key, "=").concat(value, ";expires=").concat(this._getExpirationDate().toUTCString(), ";path=").concat(this._opts.path);
  };

  Cookies.prototype._getSimpleCookie = function (key) {
    var matches = document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
    return matches ? decodeURIComponent(matches[1]) : '';
  };

  Cookies.prototype._exists = function (key) {
    return document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
  };

  /*
   * Toggling WebVR is done through button.click because of limitations on calling requestPresent in webVR:
   * VRDisplay::requestPresent should be called from user gesture:
   * https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestPresent
   */
  function createWebVRButton (webVRPoC) {
    function showEnterVR(button) {
      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'ENTER VR';
      var currentSession = null;

      function onSessionEnded()
      /* event */
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'ENTER VR';
        currentSession = null;
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        webVRPoC._gfx.renderer.xr.setReferenceSpaceType('local');

        webVRPoC._gfx.renderer.xr.setSession(session);

        button.textContent = 'EXIT VR';
        currentSession = session;
      }

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          // WebXR's requestReferenceSpace only works if the corresponding feature
          // was requested at session creation time. For simplicity, just ask for
          // the interesting ones as optional features, but be aware that the
          // requestReferenceSpace call will fail if it turns out to be unavailable.
          // ('local' is always available for immersive sessions and doesn't need to
          // be requested separately.)
          var sessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor']
          };
          navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
          webVRPoC.moveSceneBehindHeadset();
        } else {
          currentSession.end();
        }
      };
    }

    function showWebXRNotFound(button) {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.textContent = 'VR NOT FOUND';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'transparent';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      var button = document.createElement('button');
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
        return supported ? showEnterVR(button) : showWebXRNotFound(button);
      });
      return button;
    }

    var message = document.createElement('a');
    message.href = 'https://webvr.info';
    message.innerHTML = 'WEBXR NOT SUPPORTED';
    message.style.left = 'calc(50% - 90px)';
    message.style.width = '180px';
    message.style.textDecoration = 'none';
    stylizeElement(message);
    return message;
  }

  var WebVRPoC = /*#__PURE__*/function () {
    function WebVRPoC(onToggle) {
      classCallCheck(this, WebVRPoC);

      this._mainCamera = new THREE.PerspectiveCamera();
      this._button = null;
      this._onToggle = onToggle;
      this._molContainer = new gfxutils.RCGroup();
      this._user = new gfxutils.RCGroup();
      this._scalingPivot = new THREE.Object3D();

      this._user.add(this._scalingPivot);

      this._controller1 = null;
      this._controller2 = null;
      this._pressedGripsCounter = 0;
      this._distance = 0;
      this._gfx = null;
    }

    createClass(WebVRPoC, [{
      key: "startScalingByControllers",
      value: function startScalingByControllers() {
        // reset scale
        this._distance = this._controller1.position.distanceTo(this._controller2.position);
        gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);

        this._scalingPivot.scale.set(1, 1, 1);

        this._scalingPivot.updateMatrix();

        this._scalingPivot.updateMatrixWorld(); // link molecule to pivot


        this._scalingPivot.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "stopScalingByControllers",
      value: function stopScalingByControllers() {
        this._gfx.scene.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "handleGripsDown",
      value: function handleGripsDown(event) {
        this._pressedGripsCounter++;

        if (this._pressedGripsCounter === 2) {
          this.startScalingByControllers();
        } else if (this._pressedGripsCounter === 1) {
          event.target.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "handleGripsUp",
      value: function handleGripsUp(event) {
        this._pressedGripsCounter--;

        if (this._pressedGripsCounter === 1) {
          this.stopScalingByControllers(); // reattach molecule to other controller

          var anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
          anotherController.addSavingWorldTransform(this._molContainer);
        } else if (this._pressedGripsCounter === 0) {
          this._gfx.scene.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "enable",
      value: function enable(gfx) {
        if (!gfx) {
          logger.warn('WebVR couldn\'t be enabled, because gfx is not defined');
          return;
        }

        this._gfx = gfx;
        var renderer = gfx.renderer,
            camera = gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        }

        if (!camera) {
          throw new Error('No camera is available to toggle WebVR');
        } // enable xr in renderer


        renderer.xr.enabled = true; // add button for turning vr mode

        if (!this._button) {
          this._button = createWebVRButton(this);
          document.body.appendChild(this._button);
        } else {
          this._button.style.display = 'block';
        } // store fog setting


        this._mainFog = settings.now.fog;
        settings.set('fog', false);

        this._plugVRNodesIntoScene(gfx, renderer);

        this._setControllersListeners(); // make some Miew job


        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "_plugVRNodesIntoScene",
      value: function _plugVRNodesIntoScene(gfx, renderer) {
        // store common scene camera
        this._mainCamera.copy(gfx.camera); // add hierarchical structure for webVR into scene


        gfx.scene.add(this._user); // turn on webvr transformation

        gfx.scene.add(this._molContainer);

        this._molContainer.add(gfx.root);

        this._controller1 = renderer.xr.getController(0);
        this._controller2 = renderer.xr.getController(1);

        var mesh = this._createControllerMesh();

        this._controller1.add(mesh);

        this._controller2.add(mesh.clone());

        this._user.add(this._controller1);

        this._user.add(this._controller2);
      }
    }, {
      key: "_setControllersListeners",
      value: function _setControllersListeners() {
        var _this = this;

        this._controller1.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller1.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });
      }
    }, {
      key: "disable",
      value: function disable() {
        if (!this._gfx) {
          return;
        }

        var _this$_gfx = this._gfx,
            renderer = _this$_gfx.renderer,
            camera = _this$_gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        } // nullify webxr callback for animation frame


        renderer.setAnimationLoop(null);
        var session = renderer.xr.getSession();

        if (session) {
          session.end();
        }

        renderer.xr.enabled = false; // remove button of VR entering

        if (this._button) {
          this._button.style.display = 'none';
        } // restore fog param


        settings.set('fog', this._mainFog);

        this._unplugVRNodesFromScene(camera); // make some Miew job


        if (this._onToggle) {
          this._onToggle(false);
        }
      }
    }, {
      key: "_unplugVRNodesFromScene",
      value: function _unplugVRNodesFromScene(camera) {
        // restore common camera
        if (this._mainCamera && camera) {
          camera.copy(this._mainCamera);
        } // turn off webvr transformation


        var root = this._molContainer.children[0];

        if (root) {
          this._gfx.scene.add(root);
        }

        this._molContainer.parent.remove(this._molContainer);

        if (this._user) {
          this._gfx.scene.remove(this._user);
        } // free scene nodes


        this._molContainer = null;
        this._user = null;
        this._scalingPivot = null;
        this._user = null;
        this._controller1 = null;
        this._controller2 = null;
      }
    }, {
      key: "_createControllerMesh",
      value: function _createControllerMesh() {
        // visualize controllers with cylinders
        var geometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3);
        var material = new UberMaterial({
          lights: false,
          overrideColor: true
        });
        material.setUberOptions({
          fixedColor: new THREE.Color(0x4444ff)
        });
        material.updateUniforms();
        var cylinder = new THREE.Mesh(geometry, material);
        cylinder.rotateX(-Math.PI / 2);
        return cylinder;
      }
    }, {
      key: "updateMoleculeScale",
      value: function updateMoleculeScale() {
        if (!this._controller1 || !this._controller2) {
          return;
        }

        var self = this; // update molecule scaling by controllers

        if (self._pressedGripsCounter === 2) {
          // recalc scaling pivot
          gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position); // recalc scaler

          var dist = self._controller1.position.distanceTo(self._controller2.position);

          var scaler = dist / self._distance;

          self._scalingPivot.scale.multiplyScalar(scaler); // save cur distance for next frame


          self._distance = dist;
        }
      }
      /**
       * Reposition molecule right before the camera.
       * @note The proper way is to initiate headset in the place of common Miew's camera.
       * But threejs limitations on setting new XRReferenceSpace enforce the molecule repositioning
       * Hope, something will change.
       */

    }, {
      key: "moveSceneBehindHeadset",
      value: function moveSceneBehindHeadset() {
        var gfx = this._gfx;
        var camera = gfx.camera; // set container position in camera space

        var container = this._molContainer;
        container.matrix.identity();
        container.position.set(0, 0, -4.0);
        container.updateMatrix(); // update container world matrix

        container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix); // readd to scene

        gfx.scene.addSavingWorldTransform(container);

        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        var gfx = this._gfx;
        return gfx && gfx.renderer ? gfx.renderer.domElement : null;
      }
    }]);

    return WebVRPoC;
  }();

  var fragmentScreenQuadFromDistTex = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform vec3 aberration;\n\nvoid main() {\n  vec2 uv = vUv * 2.0 - 1.0;\n  \n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\n  gl_FragColor.a = 1.0;\n}";

  var selectors$4 = chem.selectors,
      Atom$2 = chem.Atom,
      Residue$1 = chem.Residue,
      Chain$2 = chem.Chain,
      Molecule$8 = chem.Molecule;
  var EDIT_MODE = {
    COMPLEX: 0,
    COMPONENT: 1,
    FRAGMENT: 2
  };
  var LOADER_NOT_FOUND = 'Could not find suitable loader for this source';
  var PARSER_NOT_FOUND = 'Could not find suitable parser for this source';
  var createElement$2 = utils.createElement;

  function updateFogRange(fog, center, radius) {
    fog.near = center - radius * settings.now.fogNearFactor;
    fog.far = center + radius * settings.now.fogFarFactor;
  }

  function removeExtension(fileName) {
    var dot = fileName.lastIndexOf('.');

    if (dot >= 0) {
      fileName = fileName.substr(0, dot);
    }

    return fileName;
  }

  function hasValidResidues(complex) {
    var hasValidRes = false;
    complex.forEachComponent(function (component) {
      component.forEachResidue(function (residue) {
        if (residue._isValid) {
          hasValidRes = true;
        }
      });
    });
    return hasValidRes;
  }

  function reportProgress(log, action, percent) {
    var TOTAL_PERCENT = 100;

    if (percent !== undefined) {
      log.debug("".concat(action, "... ").concat(Math.floor(percent * TOTAL_PERCENT), "%"));
    } else {
      log.debug("".concat(action, "..."));
    }
  }

  function chooseFogColor() {
    return settings.now.fogColorEnable ? settings.now.fogColor : settings.now.bg.color;
  } // ////////////////////////////////////////////////////////////////////////////

  /**
   * Main 3D Molecular Viewer class.
   *
   * @param {object} opts - Viewer options.
   * @param {HTMLElement=} opts.container - DOM element that serves as a viewer container.
   * @param {object=} opts.settings - An object with properties to override default settings.
   * @param {string=} opts.settingsCookie='settings' - The name of the cookie to save current settings to.
   * @param {string=} opts.cookiePath='/' - The path option for cookies. Defaults to root.
   *
   * @exports Miew
   * @constructor
   */


  function Miew(opts) {
    EventDispatcher.call(this);
    this._opts = ___default['default'].merge({
      settingsCookie: 'settings',
      cookiePath: '/'
    }, opts);
    /** @type {?object} */

    this._gfx = null;
    /** @type {ViewInterpolator} */

    this._interpolator = new ViewInterpolator();
    /** @type {HTMLElement} */

    this._container = opts && opts.container || document.getElementById('miew-container') || ___default['default'].head(document.getElementsByClassName('miew-container')) || document.body;
    /** @type {HTMLElement} */

    this._containerRoot = this._container;
    /** @type {boolean} */

    this._running = false;
    /** @type {boolean} */

    this._halting = false;
    /** @type {boolean} */

    this._building = false;
    /** @type {boolean} */

    this._needRender = true;
    /** @type {boolean} */

    this._hotKeysEnabled = true;
    /** @type {Settings} */

    this.settings = settings;
    var log = logger;
    log.console = false;
    log.level =  'info';
    /**
     * @type {Logger}
     * @example
     * miew.logger.addEventListener('message', function _onLogMessage(evt) {
     *   console.log(evt.message);
     * });
     */

    this.logger = log;
    this._cookies = new Cookies(this);
    this.restoreSettings();

    if (opts && opts.settings) {
      this.settings.set(opts.settings);
    }
    /** @type {?Spinner} */


    this._spinner = null;
    /** @type {JobHandle[]} */

    this._loading = [];
    /** @type {?number}
     * @deprecated until Animation system refactoring
     */

    this._animInterval = null;
    /** @type {object} */

    this._visuals = {};
    /** @type {?string} */

    this._curVisualName = null;
    /** @type {array} */

    this._objects = [];
    /** @type {object} */

    this._sourceWindow = null;
    this.reset();

    if (this._repr) {
      log.debug("Selected ".concat(this._repr.mode.name, " mode with ").concat(this._repr.colorer.name, " colorer."));
    }

    var self = this;
    Miew.registeredPlugins.forEach(function (plugin) {
      plugin.call(self);
    });

    this._initOnSettingsChanged();
  }

  Miew.prototype = Object.create(EventDispatcher.prototype);
  Miew.prototype.constructor = Miew;

  Miew.prototype.getMaxRepresentationCount = function () {
    return ComplexVisual.NUM_REPRESENTATION_BITS;
  };
  /**
   * Replace viewer container contents with a DOM element.
   * @param {HTMLElement} container - parent container.
   * @param {HTMLElement} element - DOM element to show.
   * @private
   */


  function _setContainerContents(container, element) {
    var parent = container;

    while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
    }

    parent.appendChild(element);
  }
  /**
   * Update Shadow Camera target position and frustum.
   * @private
   */


  Miew.prototype._updateShadowCamera = function () {
    var shadowMatrix = new THREE.Matrix4();
    var direction = new THREE.Vector3();
    var OBB = {
      center: new THREE.Vector3(),
      halfSize: new THREE.Vector3()
    };
    return function () {
      this._gfx.scene.updateMatrixWorld();

      for (var i = 0; i < this._gfx.scene.children.length; i++) {
        if (this._gfx.scene.children[i].type === 'DirectionalLight') {
          var light = this._gfx.scene.children[i];
          shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
          this.getOBB(shadowMatrix, OBB);
          direction.subVectors(light.target.position, light.position);
          light.position.subVectors(OBB.center, direction);
          light.target.position.copy(OBB.center);
          light.shadow.bias = 0.09;
          light.shadow.camera.bottom = -OBB.halfSize.y;
          light.shadow.camera.top = OBB.halfSize.y;
          light.shadow.camera.right = OBB.halfSize.x;
          light.shadow.camera.left = -OBB.halfSize.x;
          light.shadow.camera.near = direction.length() - OBB.halfSize.z;
          light.shadow.camera.far = direction.length() + OBB.halfSize.z;
          light.shadow.camera.updateProjectionMatrix();
        }
      }
    };
  }();
  /**
   * Initialize the viewer.
   * @returns {boolean} true on success.
   * @throws Forwards exception raised during initialization.
   * @see Miew#term
   */


  Miew.prototype.init = function () {
    var container = this._container;
    var elem = utils.createElement('div', {
      "class": 'miew-canvas'
    });

    _setContainerContents(container, elem);

    this._container = elem;
    var frag = document.createDocumentFragment();
    frag.appendChild(this._msgMode = createElement$2('div', {
      "class": 'mode-message overlay'
    }, createElement$2('p', {}, 'COMPONENT EDIT MODE')));
    frag.appendChild(this._msgAtomInfo = createElement$2('div', {
      "class": 'atom-info overlay'
    }, createElement$2('p', {}, '')));
    container.appendChild(frag);

    if (this._gfx !== null) {
      // block double init
      return true;
    }

    var self = this;

    this._showMessage('Viewer is being initialized...');

    try {
      this._initGfx();

      this._initListeners();

      this._spinner = new Spinner({
        lines: 13,
        length: 28,
        width: 14,
        radius: 42,
        color: '#fff',
        zIndex: 700
      });
      window.top.addEventListener('keydown', function (event) {
        self._onKeyDown(event);
      });
      window.top.addEventListener('keyup', function (event) {
        self._onKeyUp(event);
      });
      this._objectControls = new ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, function () {
        return self._getAltObj();
      });

      this._objectControls.addEventListener('change', function (e) {
        if (settings.now.shadow.on) {
          self._updateShadowCamera();
        } // route rotate, zoom, translate and translatePivot events to the external API


        switch (e.action) {
          case 'rotate':
            self.dispatchEvent({
              type: 'rotate',
              quaternion: e.quaternion
            });
            break;

          case 'zoom':
            self.dispatchEvent({
              type: 'zoom',
              factor: e.factor
            });
            break;

          default:
            self.dispatchEvent({
              type: e.action
            });
        }

        self.dispatchEvent({
          type: 'transform'
        });
        self._needRender = true;
      });

      var gfx = this._gfx;
      this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);

      this._picker.addEventListener('newpick', function (event) {
        self._onPick(event);
      });

      this._picker.addEventListener('dblclick', function (event) {
        self.center(event);
      });
    } catch (error) {
      if (error.name === 'TypeError' && error.message === 'Cannot read property \'getExtension\' of null') {
        this._showMessage('Could not create WebGL context.');
      } else if (error.message.search(/webgl/i) > 1) {
        this._showMessage(error.message);
      } else {
        this._showMessage('Viewer initialization failed.');

        throw error;
      }

      return false;
    } // automatically load default file


    var file = this._opts && this._opts.load;

    if (file) {
      var type = this._opts && this._opts.type;
      this.load(file, {
        fileType: type,
        keepRepsInfo: true
      });
    }

    return true;
  };
  /**
   * Terminate the viewer completely.
   * @see Miew#init
   */


  Miew.prototype.term = function () {
    this._showMessage('Viewer has been terminated.');

    this._loading.forEach(function (job) {
      job.cancel();
    });

    this._loading.length = 0;
    this.halt();
    this._gfx = null;
  };
  /**
   * Display message inside the viewer container, hiding WebGL canvas.
   * @param {string} msg - Message to show.
   * @private
   */


  Miew.prototype._showMessage = function (msg) {
    var element = document.createElement('div');
    element.setAttribute('class', 'miew-message');
    element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));

    _setContainerContents(this._container, element);
  };
  /**
   * Display WebGL canvas inside the viewer container, hiding any message shown.
   * @private
   */


  Miew.prototype._showCanvas = function () {
    _setContainerContents(this._container, this._gfx.renderer.domElement);
  };

  Miew.prototype._requestAnimationFrame = function (callback) {
    var xr = this._gfx.renderer.xr;

    if (xr && xr.enabled) {
      this._gfx.renderer.setAnimationLoop(callback);

      return;
    }

    requestAnimationFrame(callback);
  };

  function arezSpritesSupported(context) {
    return context.getExtension('EXT_frag_depth');
  }

  function isAOSupported(context) {
    return context.getExtension('WEBGL_depth_texture') && context.getExtension('WEBGL_draw_buffers');
  }
  /**
   * Initialize WebGL and set 3D scene up.
   * @private
   */


  Miew.prototype._initGfx = function () {
    var gfx = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
    var webGLOptions = {
      preserveDrawingBuffer: true,
      alpha: true,
      premultipliedAlpha: false
    };

    if (settings.now.antialias) {
      webGLOptions.antialias = true;
    }

    gfx.renderer2d = new CSS2DRenderer();
    gfx.renderer = new THREE.WebGL1Renderer(webGLOptions);
    gfx.renderer.shadowMap.enabled = settings.now.shadow.on;
    gfx.renderer.shadowMap.autoUpdate = false;
    gfx.renderer.shadowMap.type = THREE.PCFShadowMap;
    capabilities.init(gfx.renderer); // z-sprites and ambient occlusion possibility

    if (!arezSpritesSupported(gfx.renderer.getContext())) {
      settings.set('zSprites', false);
    }

    if (!isAOSupported(gfx.renderer.getContext())) {
      settings.set('ao', false);
    }

    gfx.renderer.autoClear = false;
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.clearColor();
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    gfx.camera = new THREE.PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.position.z = settings.now.camDistance;
    gfx.camera.updateProjectionMatrix();
    gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
    gfx.stereoCam = new THREE.StereoCamera();
    gfx.scene = new THREE.Scene();
    var color = chooseFogColor();
    gfx.scene.fog = new THREE.Fog(color, settings.now.camNear, settings.now.camFar);
    gfx.root = new gfxutils.RCGroup();
    gfx.scene.add(gfx.root);
    gfx.pivot = new gfxutils.RCGroup();
    gfx.root.add(gfx.pivot);
    gfx.selectionScene = new THREE.Scene();
    gfx.selectionRoot = new THREE.Group();
    gfx.selectionRoot.matrixAutoUpdate = false;
    gfx.selectionScene.add(gfx.selectionRoot);
    gfx.selectionPivot = new THREE.Group();
    gfx.selectionPivot.matrixAutoUpdate = false;
    gfx.selectionRoot.add(gfx.selectionPivot);
    var light12 = new THREE.DirectionalLight(0xffffff, 0.45);
    light12.position.set(0, 0.414, 1);
    light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    light12.castShadow = true;
    light12.shadow.bias = 0.09;
    light12.shadow.radius = settings.now.shadow.radius;
    light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
    var pixelRatio = gfx.renderer.getPixelRatio();
    var shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
    light12.shadow.mapSize.width = shadowMapSize;
    light12.shadow.mapSize.height = shadowMapSize;
    light12.target.position.set(0.0, 0.0, 0.0);
    gfx.scene.add(light12);
    gfx.scene.add(light12.target);
    var light3 = new THREE.AmbientLight(0x666666);
    light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    gfx.scene.add(light3); // add axes

    gfx.axes = new Axes(gfx.root, gfx.camera);
    var deviceWidth = gfx.width * pixelRatio;
    var deviceHeight = gfx.height * pixelRatio;
    gfx.offscreenBuf = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      depthBuffer: true
    });

    if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
      gfx.offscreenBuf.depthTexture = new THREE.DepthTexture();
      gfx.offscreenBuf.depthTexture.type = THREE.UnsignedShortType;
    }

    gfx.offscreenBuf2 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf3 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf4 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.volBFTex = gfx.offscreenBuf3;
    gfx.volFFTex = gfx.offscreenBuf4;
    gfx.volWFFTex = gfx.offscreenBuf; // use float textures for volume rendering if possible

    if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
      gfx.offscreenBuf5 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf6 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf7 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: true
      });
      gfx.volBFTex = gfx.offscreenBuf5;
      gfx.volFFTex = gfx.offscreenBuf6;
      gfx.volWFFTex = gfx.offscreenBuf7;
    } else {
      this.logger.warn('Device doesn\'t support OES_texture_float extension');
    }

    gfx.stereoBufL = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.stereoBufR = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    this._gfx = gfx;

    this._showCanvas();

    this._embedWebXR(settings.now.stereo === 'WEBVR');

    this._container.appendChild(gfx.renderer2d.getElement()); // add FPS counter


    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0';
    stats.domElement.style.bottom = '0';

    this._container.appendChild(stats.domElement);

    this._fps = stats;

    this._fps.show(settings.now.fps);
  };
  /**
   * Setup event listeners.
   * @private
   */


  Miew.prototype._initListeners = function () {
    var self = this;
    window.addEventListener('resize', function () {
      self._onResize();
    });
  };
  /**
   * Try to add numbers to the base name to make it unique among visuals
   * @private
   */


  Miew.prototype._makeUniqueVisualName = function (baseName) {
    if (!baseName) {
      return Math.random().toString();
    }

    var name = baseName;
    var suffix = 1;

    while (this._visuals.hasOwnProperty(name)) {
      name = "".concat(baseName, " (").concat(suffix.toString(), ")");
      suffix++;
    }

    return name;
  };
  /**
   * Add visual to the viewer
   * @private
   */


  Miew.prototype._addVisual = function (visual) {
    if (!visual) {
      return null;
    } // change visual name in order to make it unique


    var name = this._makeUniqueVisualName(visual.name);

    visual.name = name;
    this._visuals[name] = visual;

    this._gfx.pivot.add(visual);

    if (visual.getSelectionGeo) {
      this._gfx.selectionPivot.add(visual.getSelectionGeo());
    }

    return name;
  };
  /**
   * Remove visual from the viewer
   * @private
   */


  Miew.prototype._removeVisual = function (visual) {
    var name = '';
    var obj = null;

    if (visual instanceof Visual) {
      name = visual.name;
      obj = visual;
    } else if (typeof visual === 'string') {
      name = visual;
      obj = this._visuals[name];
    }

    if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
      return;
    }

    if (name === this._curVisualName) {
      this._curVisualName = undefined;
    }

    delete this._visuals[name];
    obj.release(); // removes nodes from scene

    this._needRender = true;
  };
  /**
   * Call specified function for each Visual
   * @private
   */


  Miew.prototype._forEachVisual = function (callback) {
    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        callback(this._visuals[name]);
      }
    }
  };
  /**
   * Release (destroy) all visuals in the scene
   * @private
   */


  Miew.prototype._releaseAllVisuals = function () {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        this._visuals[name].release();
      }
    }

    this._visuals = {};
  };
  /**
   * Call specified function for each ComplexVisual
   * @private
   */


  Miew.prototype._forEachComplexVisual = function (callback) {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof ComplexVisual) {
        callback(this._visuals[name]);
      }
    }
  };
  /**
   * Returns ComplexVisual with specified name, or current (if not found), or any, or null
   * @private
   */


  Miew.prototype._getComplexVisual = function (name) {
    name = name || this._curVisualName;
    var any = null;
    var named = null;

    this._forEachComplexVisual(function (visual) {
      any = visual;

      if (visual.name === name) {
        named = visual;
      }
    });

    return named || any;
  };
  /**
   * Returns first found VolumeVisual (no more than one should be present actually)
   * @private
   */


  Miew.prototype._getVolumeVisual = function () {
    var any = null;

    this._forEachVisual(function (visual) {
      if (visual instanceof VolumeVisual) {
        any = visual;
      }
    });

    return any;
  };
  /**
   * Returns ComplexVisual corresponding to specified complex
   * @private
   */


  Miew.prototype._getVisualForComplex = function (complex) {
    if (!complex) {
      return null;
    }

    var found = null;

    this._forEachComplexVisual(function (visual) {
      if (visual.getComplex() === complex) {
        found = visual;
      }
    });

    return found;
  };
  /*
     * Get a list of names of visuals currently shown by the viewer
     */


  Miew.prototype.getVisuals = function () {
    return Object.keys(this._visuals);
  };
  /*
     * Get complex visuals count
     */


  Miew.prototype.getComplexVisualsCount = function () {
    var count = 0;

    this._forEachComplexVisual(function () {
      return count++;
    });

    return count;
  };
  /*
     * Get current visual
     */


  Miew.prototype.getCurrentVisual = function () {
    return this._curVisualName;
  };
  /*
     * Set current visual.
     * All further operations will be performed on this visual (complex) if not stated otherwise.
     */


  Miew.prototype.setCurrentVisual = function (name) {
    if (!this._visuals[name]) {
      return;
    }

    this._curVisualName = name;
  };
  /**
   * Run the viewer, start processing update/render frames periodically.
   * Has no effect if already running.
   * @see Miew#halt
   */


  Miew.prototype.run = function () {
    var _this = this;

    if (!this._running) {
      this._running = true;

      if (this._halting) {
        this._halting = false;
        return;
      }

      this._objectControls.enable(true);

      this._interpolator.resume();

      this._requestAnimationFrame(function () {
        return _this._onTick();
      });
    }
  };
  /**
   * Request the viewer to stop.
   * Will be processed during the next frame.
   * @see Miew#run
   */


  Miew.prototype.halt = function () {
    if (this._running) {
      this._discardComponentEdit();

      this._discardFragmentEdit();

      this._objectControls.enable(false);

      this._interpolator.pause();

      this._halting = true;
    }
  };
  /**
   * Request the viewer to start / stop responsing
   * on hot keys.
   * @param enabled - start (true) or stop (false) response on hot keys.
   */


  Miew.prototype.enableHotKeys = function (enabled) {
    this._hotKeysEnabled = enabled;

    this._objectControls.enableHotkeys(enabled);
  };
  /**
   * Callback which processes window resize.
   * @private
   */


  Miew.prototype._onResize = function () {
    this._needRender = true;
    var gfx = this._gfx;
    gfx.width = this._container.clientWidth;
    gfx.height = this._container.clientHeight;
    gfx.camera.aspect = gfx.width / gfx.height;
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    this.dispatchEvent({
      type: 'resize'
    });
  };

  Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
    var gfx = this._gfx;
    stereo = stereo || 'NONE';
    var isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH';
    var multi = isAnaglyph ? 1 : 0.5;
    gfx.offscreenBuf.setSize(multi * width, height);
    gfx.offscreenBuf2.setSize(multi * width, height);
    gfx.offscreenBuf3.setSize(multi * width, height);
    gfx.offscreenBuf4.setSize(multi * width, height);

    if (gfx.offscreenBuf5) {
      gfx.offscreenBuf5.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf6) {
      gfx.offscreenBuf6.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf7) {
      gfx.offscreenBuf7.setSize(multi * width, height);
    }

    if (isAnaglyph) {
      gfx.stereoBufL.setSize(width, height);
      gfx.stereoBufR.setSize(width, height);
    }
  };
  /**
   * Callback which processes update/render frames.
   * @private
   */


  Miew.prototype._onTick = function () {
    var _this2 = this;

    if (this._halting) {
      this._running = false;
      this._halting = false;
      return;
    }

    this._fps.update();

    this._requestAnimationFrame(function () {
      return _this2._onTick();
    });

    this._onUpdate();

    if (this._needRender) {
      this._onRender();

      this._needRender = !settings.now.suspendRender || settings.now.stereo === 'WEBVR';
    }
  };

  Miew.prototype._getBSphereRadius = function () {
    // calculate radius that would include all visuals
    var radius = 0;

    this._forEachVisual(function (visual) {
      radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
    });

    return radius * this._objectControls.getScale();
  };
  /**
   * Calculate bounding box that would include all visuals and being axis aligned in world defined by
   * transformation matrix: matrix
   * @param {Matrix4} matrix - transformation matrix.
   * @param {object}  OBB           - calculating bounding box.
   * @param {Vector3} OBB.center    - OBB center.
   * @param {Vector3} OBB.halfSize  - half magnitude of OBB sizes.
   */


  Miew.prototype.getOBB = function () {
    var _bSphereForOneVisual = new THREE.Sphere();

    var _bBoxForOneVisual = new THREE.Box3();

    var _bBox = new THREE.Box3();

    var _invMatrix = new THREE.Matrix4();

    var _points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
    return function (matrix, OBB) {
      _bBox.makeEmpty();

      this._forEachVisual(function (visual) {
        _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);

        _bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);

        _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual);

        _bBox.union(_bBoxForOneVisual);
      });

      _bBox.getCenter(OBB.center);

      _invMatrix.copy(matrix).invert();

      OBB.center.applyMatrix4(_invMatrix);
      var min = _bBox.min;
      var max = _bBox.max;

      _points[0].set(min.x, min.y, min.z); // 000


      _points[1].set(max.x, min.y, min.z); // 100


      _points[2].set(min.x, max.y, min.z); // 010


      _points[3].set(min.x, min.y, max.z); // 001


      for (var i = 0, l = _points.length; i < l; i++) {
        _points[i].applyMatrix4(_invMatrix);
      }

      OBB.halfSize.set(Math.abs(_points[0].x - _points[1].x), Math.abs(_points[0].y - _points[2].y), Math.abs(_points[0].z - _points[3].z)).multiplyScalar(0.5);
    };
  }();

  Miew.prototype._updateFog = function () {
    var gfx = this._gfx;

    if (settings.now.fog) {
      if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
        var color = chooseFogColor();
        gfx.scene.fog = new THREE.Fog(color);

        this._setUberMaterialValues({
          fog: settings.now.fog
        });
      }

      updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
    } else if (gfx.scene.fog) {
      gfx.scene.fog = undefined;

      this._setUberMaterialValues({
        fog: settings.now.fog
      });
    }
  };

  Miew.prototype._onUpdate = function () {
    if (this.isScriptingCommandAvailable !== undefined && this.isScriptingCommandAvailable() && !this._building) {
      this.callNextCmd();
    }

    this._objectControls.update();

    this._forEachComplexVisual(function (visual) {
      visual.getComplex().update();
    });

    if (settings.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
      this.rebuild();
    }

    if (!this._loading.length && !this._building && !this._needRebuild()) {
      this._updateView();
    }

    this._updateFog();

    if (this._gfx.renderer.xr.enabled) {
      this.webVR.updateMoleculeScale();
    }
  };

  Miew.prototype._onRender = function () {
    var gfx = this._gfx; // update all matrices

    gfx.scene.updateMatrixWorld();
    gfx.camera.updateMatrixWorld();

    this._clipPlaneUpdateValue(this._getBSphereRadius());

    this._fogFarUpdateValue();

    gfx.renderer.setRenderTarget(null);
    gfx.renderer.clear();

    this._renderFrame(settings.now.stereo);
  };

  Miew.prototype._renderFrame = function () {
    var _anaglyphMat = new AnaglyphMaterial();

    var _size = new THREE.Vector2();

    return function (stereo) {
      var gfx = this._gfx;
      var renderer = gfx.renderer;
      renderer.getSize(_size);

      if (stereo !== 'NONE') {
        gfx.camera.focus = gfx.camera.position.z; // set focus to the center of the object

        gfx.stereoCam.aspect = 1.0; // in anaglyph mode we render full-size image for each eye
        // while in other stereo modes only half-size (two images on the screen)

        if (stereo === 'ANAGLYPH') {
          gfx.stereoCam.update(gfx.camera);
        } else {
          gfx.stereoCam.updateHalfSized(gfx.camera, settings.now.camFov);
        }
      } // resize offscreen buffers to match the target


      var pixelRatio = gfx.renderer.getPixelRatio();

      this._resizeOffscreenBuffers(_size.width * pixelRatio, _size.height * pixelRatio, stereo);

      this._renderShadowMap();

      switch (stereo) {
        case 'WEBVR':
        case 'NONE':
          this._renderScene(gfx.camera, false);

          break;

        case 'SIMPLE':
        case 'DISTORTED':
          renderer.setScissorTest(true);
          renderer.setScissor(0, 0, _size.width / 2, _size.height);
          renderer.setViewport(0, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED');

          renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height);
          renderer.setViewport(_size.width / 2, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED');

          renderer.setScissorTest(false);
          break;

        case 'ANAGLYPH':
          this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);

          this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);

          renderer.setRenderTarget(null);
          _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
          _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
          gfx.renderer.renderScreenQuad(_anaglyphMat);
          break;
      }

      gfx.renderer2d.render(gfx.scene, gfx.camera);

      if (settings.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
        gfx.axes.render(renderer);
      }
    };
  }();

  Miew.prototype._onBgColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx) {
      if (gfx.scene.fog) {
        gfx.scene.fog.color.set(color);
      }

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    }

    this._needRender = true;
  };

  Miew.prototype._onFogColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx && gfx.scene.fog) {
      gfx.scene.fog.color.set(color);
    }

    this._needRender = true;
  };

  Miew.prototype._setUberMaterialValues = function (values) {
    this._gfx.root.traverse(function (obj) {
      if ((obj instanceof THREE.Mesh || obj instanceof THREE.LineSegments || obj instanceof THREE.Line) && obj.material instanceof UberMaterial) {
        obj.material.setValues(values);
        obj.material.needsUpdate = true;
      }
    });
  };

  Miew.prototype._enableMRT = function (on, renderBuffer, textureBuffer) {
    var gfx = this._gfx;
    var gl = gfx.renderer.getContext();
    var ext = gl.getExtension('WEBGL_draw_buffers');
    var properties = gfx.renderer.properties;

    if (!on) {
      ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
      return;
    } // take extra texture from Texture Buffer


    gfx.renderer.setRenderTarget(textureBuffer);

    var tx8 = properties.get(textureBuffer.texture).__webglTexture;

    gl.bindTexture(gl.TEXTURE_2D, tx8); // take texture and framebuffer from renderbuffer

    gfx.renderer.setRenderTarget(renderBuffer);

    var fb = properties.get(renderBuffer).__webglFramebuffer;

    var tx = properties.get(renderBuffer.texture).__webglTexture; // set framebuffer


    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    fb.width = renderBuffer.width;
    fb.height = renderBuffer.height;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0); // mapping textures

    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
  };

  Miew.prototype._renderScene = function () {
    return function (camera, distortion, target) {
      distortion = distortion || false;
      target = target || null;
      var gfx = this._gfx; // render to offscreen buffer

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(target);
      gfx.renderer.clear();

      if (gfx.renderer.xr.enabled) {
        gfx.renderer.render(gfx.scene, camera);
        return;
      } // clean buffer for normals texture


      gfx.renderer.setClearColor(0x000000, 0.0);
      gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
      gfx.renderer.clearColor();
      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.clear();
      var bHaveComplexes = this._getComplexVisual() !== null;

      var volumeVisual = this._getVolumeVisual();

      var ssao = bHaveComplexes && settings.now.ao;

      if (ssao) {
        this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
      }

      if (settings.now.transparency === 'prepass') {
        this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
      } else if (settings.now.transparency === 'standard') {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.render(gfx.scene, camera);
      }

      if (ssao) {
        this._enableMRT(false, null, null);
      } // when fxaa we should get resulting image in temp off-screen buff2 for further postprocessing with fxaa filter
      // otherwise we render to canvas


      var outline = bHaveComplexes && settings.now.outline.on;
      var fxaa = bHaveComplexes && settings.now.fxaa;
      var volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
      var dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
      var srcBuffer = gfx.offscreenBuf;

      if (ssao) {
        this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);

        if (!fxaa && !distortion && !volume && !outline) {
          srcBuffer = dstBuffer;
          dstBuffer = target;
          gfx.renderer.setRenderTarget(dstBuffer);
          gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
        }
      } else {
        // just copy color buffer to dst buffer
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
      } // outline


      if (outline) {
        srcBuffer = dstBuffer;
        dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;

        if (srcBuffer != null) {
          this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
        }
      } // render selected part with outline material


      this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);

      if (volume) {
        // copy current picture to the buffer that retains depth-data of the original molecule render
        // so that volume renderer could use depth-test
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        dstBuffer = gfx.offscreenBuf;

        this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex); // if this is the last stage -- copy image to target


        if (!fxaa && !distortion) {
          gfx.renderer.setRenderTarget(target);
          gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        }
      }

      srcBuffer = dstBuffer;

      if (fxaa) {
        dstBuffer = distortion ? gfx.offscreenBuf4 : target;

        this._performFXAA(srcBuffer, dstBuffer);

        srcBuffer = dstBuffer;
      }

      if (distortion) {
        dstBuffer = target;

        this._performDistortion(srcBuffer, dstBuffer, true);
      }
    };
  }();

  Miew.prototype._performDistortion = function () {
    var _scene = new THREE.Scene();

    var _camera = new THREE.OrthographicCamera(-1.0, 1.0, 1.0, -1.0, -500, 1000);

    var _material = new THREE.RawShaderMaterial({
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        aberration: {
          type: 'fv3',
          value: new THREE.Vector3(1.0)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentScreenQuadFromDistTex,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });

    var _geo = gfxutils.buildDistorionMesh(10, 10, settings.now.debug.stereoBarrel);

    _scene.add(new meshes.Mesh(_geo, _material));

    return function (srcBuffer, targetBuffer, mesh) {
      this._gfx.renderer.setRenderTarget(targetBuffer);

      this._gfx.renderer.clear();

      if (mesh) {
        _material.uniforms.srcTex.value = srcBuffer.texture;

        _material.uniforms.aberration.value.set(0.995, 1.0, 1.01);

        this._gfx.renderer.render(_scene, _camera);
      } else {
        this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings.now.debug.stereoBarrel);
      }
    };
  }();

  Miew.prototype._renderOutline = function () {
    var _outlineMaterial = new OutlineMaterial({
      depth: true
    });

    return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx; // apply Sobel filter -- draw outline

      _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
      _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);

      _outlineMaterial.uniforms.color.value = new THREE.Color(settings.now.outline.color);
      _outlineMaterial.uniforms.threshold.value = settings.now.outline.threshold;
      _outlineMaterial.uniforms.thickness.value = new THREE.Vector2(settings.now.outline.thickness, settings.now.outline.thickness);
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._renderShadowMap = function () {
    var pars = {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    };
    return function () {
      if (!settings.now.shadow.on) {
        return;
      }

      var gfx = this._gfx;
      var currentRenderTarget = gfx.renderer.getRenderTarget();
      var activeCubeFace = gfx.renderer.getActiveCubeFace();
      var activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
      var _state = gfx.renderer.state; // Set GL state for depth map.

      _state.setBlending(THREE.NoBlending);

      _state.buffers.color.setClear(1, 1, 1, 1);

      _state.buffers.depth.setTest(true);

      _state.setScissorTest(false);

      for (var i = 0; i < gfx.scene.children.length; i++) {
        if (gfx.scene.children[i].type === 'DirectionalLight') {
          var light = gfx.scene.children[i];

          if (light.shadow.map == null) {
            light.shadow.map = new THREE.WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, pars);
            light.shadow.camera.updateProjectionMatrix();
          }

          light.shadow.updateMatrices(light);
          gfx.renderer.setRenderTarget(light.shadow.map);
          gfx.renderer.clear();
          gfx.renderer.render(gfx.scene, light.shadow.camera);
        }
      }

      gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
  }();
  /**
   * Check if there is selection which must be rendered or not.
   * @private
   * @returns {boolean} true on existing selection to render
   */


  Miew.prototype._hasSelectionToRender = function () {
    var selPivot = this._gfx.selectionPivot;

    for (var i = 0; i < selPivot.children.length; i++) {
      var selPivotChild = selPivot.children[i];

      if (selPivotChild.children.length > 0) {
        return true;
      }
    }

    return false;
  };

  Miew.prototype._renderSelection = function () {
    var _outlineMaterial = new OutlineMaterial();

    return function (camera, srcBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx; // clear offscreen buffer (leave z-buffer intact)

      gfx.renderer.setClearColor('black', 0); // render selection to offscreen buffer

      gfx.renderer.setRenderTarget(srcBuffer);
      gfx.renderer.clear(true, false, false);

      if (self._hasSelectionToRender()) {
        gfx.selectionRoot.matrix = gfx.root.matrix;
        gfx.selectionPivot.matrix = gfx.pivot.matrix;
        gfx.renderer.render(gfx.selectionScene, camera);
      } else {
        // just render something to force "target clear" operation to finish
        gfx.renderer.renderDummyQuad();
      } // overlay to screen


      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6); // apply Sobel filter -- draw outline

      _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);

      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
    if (!renderTarget) {
      return false;
    }

    var gfx = this._gfx;
    var oldRT = gfx.renderer.getRenderTarget();
    gfx.renderer.setRenderTarget(renderTarget);
    var context = gfx.renderer.getContext();
    var result = context.checkFramebufferStatus(context.FRAMEBUFFER);
    gfx.renderer.setRenderTarget(oldRT);

    if (result !== context.FRAMEBUFFER_COMPLETE) {
      // floatFrameBufferWarning = ;
      this.logger.warn('Device doesn\'t support electron density rendering');
      return false;
    }

    return true;
  };

  Miew.prototype._renderVolume = function () {
    var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial();
    var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial();
    var cubeOffsetMat = new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5);
    var world2colorMat = new THREE.Matrix4();
    var volumeRenderingSupported;
    return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
      var gfx = this._gfx;

      if (typeof volumeRenderingSupported === 'undefined') {
        volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
      }

      if (!volumeRenderingSupported) {
        return;
      }

      var mesh = volumeVisual.getMesh();
      mesh.rebuild(gfx.camera); // use main camera to prepare special textures to be used by volumetric rendering
      // these textures have the size of the window and are stored in offscreen buffers

      gfx.renderer.setClearColor('black', 0);
      gfx.renderer.setRenderTarget(tmpBuf1);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf2);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf1); // draw plane with its own material, because it differs slightly from volumeBFMat

      camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeBFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.setRenderTarget(tmpBuf2);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeFFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.scene.overrideMaterial = null;
      camera.layers.set(gfxutils.LAYERS.DEFAULT); // prepare texture that contains molecule positions

      world2colorMat.copy(mesh.matrixWorld).invert();
      UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
      camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.render(gfx.scene, camera); // render volume

      var vm = mesh.material;
      vm.uniforms._BFRight.value = tmpBuf1.texture;
      vm.uniforms._FFRight.value = tmpBuf2.texture;
      vm.uniforms._WFFRight.value = tmpBuf3.texture;
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.renderer.setRenderTarget(dstBuf);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();
  /*  Render scene with 'ZPrepass transparency Effect'
     * Idea: transparent objects are rendered in two passes. The first one writes result only into depth buffer.
     * The second pass reads depth buffer and writes only to color buffer. The method results in
     * correct image of front part of the semi-transparent objects, but we can see only front transparent objects
     * and opaque objects inside, there is no transparent objects inside.
     * Notes: 1. Opaque objects should be rendered strictly before semi-transparent ones.
     * 2. Realization doesn't use camera layers because scene traversing is used for material changes and
     * we can use it to select needed meshes and don't complicate meshes builders with layers
    */


  Miew.prototype._renderWithPrepassTransparency = function () {
    return function (camera, targetBuffer) {
      var gfx = this._gfx;
      gfx.renderer.setRenderTarget(targetBuffer); // opaque objects

      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      gfx.renderer.render(gfx.scene, camera); // transparent objects z prepass

      camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
      gfx.renderer.getContext().colorMask(false, false, false, false); // don't update color buffer

      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.getContext().colorMask(true, true, true, true); // update color buffer
      // transparent objects color pass

      camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
      gfx.renderer.render(gfx.scene, camera); // restore default layer

      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();

  Miew.prototype._performFXAA = function () {
    var _fxaaMaterial = new FXAAMaterial();

    return function (srcBuffer, targetBuffer) {
      if (typeof srcBuffer === 'undefined' || typeof targetBuffer === 'undefined') {
        return;
      }

      var gfx = this._gfx; // clear canvas

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.clear(); // do fxaa processing of offscreen buff2

      _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _fxaaMaterial.uniforms.srcTexelSize.value.set(1.0 / srcBuffer.width, 1.0 / srcBuffer.height);

      _fxaaMaterial.uniforms.bgColor.value.set(settings.now.bg.color);

      if (_fxaaMaterial.bgTransparent !== settings.now.bg.transparent) {
        _fxaaMaterial.setValues({
          bgTransparent: settings.now.bg.transparent
        });

        _fxaaMaterial.needsUpdate = true;
      }

      gfx.renderer.renderScreenQuad(_fxaaMaterial);
    };
  }();

  Miew.prototype._performAO = function () {
    var _aoMaterial = new AOMaterial();

    var _horBlurMaterial = new AOHorBlurMaterial();

    var _vertBlurMaterial = new AOVertBlurWithBlendMaterial();

    var _scale = new THREE.Vector3();

    return function (srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
      if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
        return;
      }

      var gfx = this._gfx;
      var tanHalfFOV = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
      _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
      _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;

      _aoMaterial.uniforms.srcTexelSize.value.set(1.0 / srcColorBuffer.width, 1.0 / srcColorBuffer.height);

      _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);

      _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      gfx.root.matrix.extractScale(_scale);
      _aoMaterial.uniforms.kernelRadius.value = settings.now.debug.ssaoKernelRadius * _scale.x;
      _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius(); // diameter

      _aoMaterial.uniforms.factor.value = settings.now.debug.ssaoFactor; // N: should be tempBuffer1 for proper use of buffers (see buffers using outside the function)

      gfx.renderer.setRenderTarget(tempBuffer1);
      gfx.renderer.renderScreenQuad(_aoMaterial);
      _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;

      _horBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer1.width, 1.0 / tempBuffer1.height);

      _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      gfx.renderer.setRenderTarget(tempBuffer);
      gfx.renderer.renderScreenQuad(_horBlurMaterial);
      _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
      _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;

      _vertBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer.width, 1.0 / tempBuffer.height);

      _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      var fog = gfx.scene.fog;

      if (fog) {
        _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);

        _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings.now.fogAlpha);
      }

      if (_vertBlurMaterial.useFog !== settings.now.fog || _vertBlurMaterial.fogTransparent !== settings.now.bg.transparent) {
        _vertBlurMaterial.setValues({
          useFog: settings.now.fog,
          fogTransparent: settings.now.bg.transparent
        });

        _vertBlurMaterial.needsUpdate = true;
      }

      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_vertBlurMaterial);
    };
  }();
  /**
   * Reset the viewer, unload molecules.
   * @param {boolean=} keepReps - Keep representations while resetting viewer state.
   */


  Miew.prototype.reset = function ()
  /* keepReps */
  {
    if (this._picker) {
      this._picker.reset();
    }

    this._lastPick = null;

    this._releaseAllVisuals();

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetObjects();

    if (this._gfx) {
      gfxutils.clearTree(this._gfx.pivot);

      this._gfx.renderer2d.reset();
    }

    this.setNeedRender();
  };

  Miew.prototype._resetScene = function () {
    this._objectControls.reset();

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.resetReps();
    this.resetPivot();
    this.rebuildAll();
  };

  Miew.prototype.resetView = function () {
    // reset controls
    if (this._picker) {
      this._picker.reset();
    }

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetScene(); // reset selection


    this._forEachComplexVisual(function (visual) {
      visual.updateSelectionMask({});
      visual.rebuildSelectionGeometry();
    });
  };

  Miew.prototype._export = function (format) {
    var TheExporter = ___default['default'].head(io.exporters.find({
      format: format
    }));

    if (!TheExporter) {
      this.logger.error('Could not find suitable exporter for this source');
      return Promise.reject(new Error('Could not find suitable exporter for this source'));
    }

    this.dispatchEvent({
      type: 'exporting'
    });

    if (this._visuals[this._curVisualName] instanceof ComplexVisual) {
      var dataSource = null;

      if (TheExporter.SourceClass === ComplexVisual) {
        dataSource = this._visuals[this._curVisualName];
      } else if (TheExporter.SourceClass === Complex) {
        dataSource = this._visuals[this._curVisualName]._complex;
      }

      var exporter = new TheExporter(dataSource, {
        miewVersion: Miew.VERSION
      });
      return exporter["export"]().then(function (data) {
        return data;
      });
    }

    if (this._visuals[this._curVisualName] instanceof VolumeVisual) {
      return Promise.reject(new Error('Sorry, exporter for volume data not implemented yet'));
    }

    return Promise.reject(new Error('Unexpected format of data'));
  };

  var rePdbId = /^(?:(pdb|cif|mmtf|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
  var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
  var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;

  function resolveSourceShortcut(source, opts) {
    if (!___default['default'].isString(source)) {
      return source;
    } // e.g. "mmtf:1CRN"


    var matchesPdbId = rePdbId.exec(source);

    if (matchesPdbId) {
      var _matchesPdbId = slicedToArray(matchesPdbId, 3),
          _matchesPdbId$ = _matchesPdbId[1],
          format = _matchesPdbId$ === void 0 ? 'pdb' : _matchesPdbId$,
          id = _matchesPdbId[2];

      format = format.toLowerCase();
      id = id.toUpperCase();

      switch (format) {
        case 'pdb':
          source = "https://files.rcsb.org/download/".concat(id, ".pdb");
          break;

        case 'cif':
          source = "https://files.rcsb.org/download/".concat(id, ".cif");
          break;

        case 'mmtf':
          source = "https://mmtf.rcsb.org/v1.0/full/".concat(id);
          break;

        case 'ccp4':
          source = "https://www.ebi.ac.uk/pdbe/coordinates/files/".concat(id.toLowerCase(), ".ccp4");
          break;

        case 'dsn6':
          source = "https://edmaps.rcsb.org/maps/".concat(id.toLowerCase(), "_2fofc.dsn6");
          break;

        default:
          throw new Error('Unexpected data format shortcut');
      }

      opts.fileType = format;
      opts.fileName = "".concat(id, ".").concat(format);
      opts.sourceType = 'url';
      return source;
    } // e.g. "pc:aspirin"


    var matchesPubchem = rePubchem.exec(source);

    if (matchesPubchem) {
      var compound = matchesPubchem[1].toLowerCase();
      source = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/".concat(compound, "/JSON?record_type=3d");
      opts.fileType = 'pubchem';
      opts.fileName = "".concat(compound, ".json");
      opts.sourceType = 'url';
      return source;
    } // otherwise is should be an URL


    if (opts.sourceType === 'url' || opts.sourceType === undefined) {
      opts.sourceType = 'url'; // e.g. "./data/1CRN.pdb"

      if (!reUrlScheme.test(source)) {
        source = utils.resolveURL(source);
      }
    }

    return source;
  }

  function updateBinaryMode(opts) {
    var binary = opts.binary; // detect by format

    if (opts.fileType !== undefined) {
      var TheParser = ___default['default'].head(io.parsers.find({
        format: opts.fileType
      }));

      if (TheParser) {
        binary = TheParser.binary || false;
      } else {
        throw new Error('Could not find suitable parser for this format');
      }
    } // detect by file extension


    if (binary === undefined && opts.fileExt !== undefined) {
      var _TheParser = ___default['default'].head(io.parsers.find({
        ext: opts.fileExt
      }));

      if (_TheParser) {
        binary = _TheParser.binary || false;
      }
    } // temporary workaround for animation


    if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
      opts.binary = true;
      opts.animation = true; // who cares?
    } // update if detected


    if (binary !== undefined) {
      if (opts.binary !== undefined && opts.binary !== binary) {
        opts.context.logger.warn('Overriding incorrect binary mode');
      }
    }

    opts.binary = binary || false;
  }

  function _fetchData(source, opts, job) {
    return new Promise(function (resolve) {
      if (job.shouldCancel()) {
        throw new Error('Operation cancelled');
      }

      job.notify({
        type: 'fetching'
      }); // allow for source shortcuts

      source = resolveSourceShortcut(source, opts); // detect a proper loader

      var TheLoader = ___default['default'].head(io.loaders.find({
        type: opts.sourceType,
        source: source
      }));

      if (!TheLoader) {
        throw new Error(LOADER_NOT_FOUND);
      } // split file name


      var fileName = opts.fileName || TheLoader.extractName(source);

      if (fileName) {
        var _utils$splitFileName = utils.splitFileName(fileName),
            _utils$splitFileName2 = slicedToArray(_utils$splitFileName, 2),
            name = _utils$splitFileName2[0],
            fileExt = _utils$splitFileName2[1];

        ___default['default'].defaults(opts, {
          name: name,
          fileExt: fileExt,
          fileName: fileName
        });
      } // should it be text or binary?


      updateBinaryMode(opts); // FIXME: All new settings retrieved from server are applied after the loading is complete. However, we need some
      // flags to alter the loading process itself. Here we apply them in advance. Dirty hack. Kill the server, remove
      // all hacks and everybody's happy.

      var newOptions = ___default['default'].get(opts, 'preset.expression');

      if (!___default['default'].isUndefined(newOptions)) {
        newOptions = JSON.parse(newOptions);

        if (newOptions && newOptions.settings) {
          var keys = ['singleUnit'];

          for (var keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
            var key = keys[keyIndex];

            var value = ___default['default'].get(newOptions.settings, key);

            if (!___default['default'].isUndefined(value)) {
              settings.set(key, value);
            }
          }
        }
      } // create a loader


      var loader = new TheLoader(source, opts);
      loader.context = opts.context;
      job.addEventListener('cancel', function () {
        return loader.abort();
      });
      loader.addEventListener('progress', function (event) {
        if (event.lengthComputable && event.total > 0) {
          reportProgress(loader.logger, 'Fetching', event.loaded / event.total);
        } else {
          reportProgress(loader.logger, 'Fetching');
        }
      });
      console.time('fetch');
      var promise = loader.load().then(function (data) {
        console.timeEnd('fetch');
        opts.context.logger.info('Fetching finished');
        job.notify({
          type: 'fetchingDone',
          data: data
        });
        return data;
      })["catch"](function (error) {
        console.timeEnd('fetch');
        opts.context.logger.debug(error.message);

        if (error.stack) {
          opts.context.logger.debug(error.stack);
        }

        opts.context.logger.error('Fetching failed');
        job.notify({
          type: 'fetchingDone',
          error: error
        });
        throw error;
      });
      resolve(promise);
    });
  }

  function _parseData(data, opts, job) {
    if (job.shouldCancel()) {
      return Promise.reject(new Error('Operation cancelled'));
    }

    job.notify({
      type: 'parsing'
    });

    var TheParser = ___default['default'].head(io.parsers.find({
      format: opts.fileType,
      ext: opts.fileExt,
      data: data
    }));

    if (!TheParser) {
      return Promise.reject(new Error('Could not find suitable parser'));
    }

    var parser = new TheParser(data, opts);
    parser.context = opts.context;
    job.addEventListener('cancel', function () {
      return parser.abort();
    });
    console.time('parse');
    return parser.parse().then(function (dataSet) {
      console.timeEnd('parse');
      job.notify({
        type: 'parsingDone',
        data: dataSet
      });
      return dataSet;
    })["catch"](function (error) {
      console.timeEnd('parse');
      opts.error = error;
      opts.context.logger.debug(error.message);

      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }

      opts.context.logger.error('Parsing failed');
      job.notify({
        type: 'parsingDone',
        error: error
      });
      throw error;
    });
  }
  /**
   * Load molecule asynchronously.
   * @param {string|File} source - Molecule source to load (e.g. PDB ID, URL or File object).
   * @param {object=} opts - Options.
   * @param {string=} opts.sourceType - Data source type (e.g. 'url', 'file').
   * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
   * @param {string=} opts.mdFile - .nc file path.
   * @param {boolean=} opts.keepRepsInfo - prevent reset of object and reps information.
   * @returns {Promise} name of the visual that was added to the viewer
   */


  Miew.prototype.load = function (source, opts) {
    var _this3 = this;

    opts = ___default['default'].merge({}, opts, {
      context: this
    }); // for a single-file scenario

    if (!this.settings.now.use.multiFile) {
      // abort all loaders in progress
      if (this._loading.length) {
        this._loading.forEach(function (job) {
          job.cancel();
        });

        this._loading.length = 0;
      } // reset


      if (!opts.animation) {
        // FIXME: sometimes it is set AFTERWARDS!
        this.reset(true);
      }
    }

    this._interpolator.reset();

    this.dispatchEvent({
      type: 'loading',
      options: opts,
      source: source
    });
    var job = new JobHandle();

    this._loading.push(job);

    job.addEventListener('notification', function (e) {
      _this3.dispatchEvent(e.slaveEvent);
    });

    this._spinner.spin(this._container);

    var onLoadEnd = function onLoadEnd(anything) {
      var jobIndex = _this3._loading.indexOf(job);

      if (jobIndex !== -1) {
        _this3._loading.splice(jobIndex, 1);
      }

      _this3._spinner.stop();

      _this3._refreshTitle();

      job.notify({
        type: 'loadingDone',
        anything: anything
      });
      return anything;
    };

    return _fetchData(source, opts, job).then(function (data) {
      return _parseData(data, opts, job);
    }).then(function (object) {
      var name = _this3._onLoad(object, opts);

      return onLoadEnd(name);
    })["catch"](function (err) {
      _this3.logger.error('Could not load data');

      _this3.logger.debug(err);

      throw onLoadEnd(err);
    });
  };
  /**
   * Unload molecule (delete corresponding visual).
   * @param {string=} name - name of the visual
   */


  Miew.prototype.unload = function (name) {
    this._removeVisual(name || this.getCurrentVisual());

    this.resetPivot();

    if (settings.now.shadow.on) {
      this._updateShadowCamera();
    }
  };
  /**
   * Start new animation. Now is broken.
   * @param fileData - new data to animate
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._startAnimation = function (fileData) {
    this._stopAnimation();

    var self = this;

    var visual = this._getComplexVisual();

    if (visual === null) {
      this.logger.error('Unable to start animation - no molecule is loaded.');
      return;
    }

    try {
      this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
        onLoadStatusChanged: function onLoadStatusChanged() {
          self.dispatchEvent({
            type: 'mdPlayerStateChanged',
            state: {
              isPlaying: self._isAnimating,
              isLoading: self._frameInfo ? self._frameInfo.isLoading : true
            }
          });
        },
        onError: function onError(message) {
          self._stopAnimation();

          self.logger.error(message);
        }
      });
    } catch (e) {
      this.logger.error('Animation file does not fit to current complex!');
      return;
    }

    this._continueAnimation();
  };
  /**
   * Pause current animation. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._pauseAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    this._isAnimating = false;
    clearInterval(this._animInterval);
    this._animInterval = null;

    if (this._frameInfo) {
      this.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: this._isAnimating,
          isLoading: this._frameInfo.isLoading
        }
      });
    }
  };
  /**
   * Continue current animation after pausing. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._continueAnimation = function () {
    this._isAnimating = true;
    var minFrameTime = 1000 / settings.now.maxfps;
    minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
    var self = this;
    var pivot = self._gfx.pivot;

    var visual = this._getComplexVisual();

    if (visual) {
      visual.resetSelectionMask();
      visual.rebuildSelectionGeometry();
      this._msgAtomInfo.style.opacity = 0.0;
    }

    this._animInterval = setInterval(function () {
      self.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: self._isAnimating,
          isLoading: self._frameInfo.isLoading
        }
      });

      if (self._frameInfo.frameIsReady) {
        pivot.updateToFrame(self._frameInfo);

        self._updateObjsToFrame(self._frameInfo);

        self._refreshTitle(" Frame ".concat(self._frameInfo._currFrame, " of ").concat(self._frameInfo._framesCount, " time interval - ").concat(self._frameInfo._timeStep));

        try {
          self._frameInfo.nextFrame();
        } catch (e) {
          self.logger.error('Error during animation');

          self._stopAnimation();

          return;
        }

        self._needRender = true;
      }
    }, minFrameTime);
  };
  /**
   * Stop current animation. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._stopAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    clearInterval(this._animInterval);

    this._frameInfo.disableEvents();

    this._frameInfo = null;
    this._animInterval = null;
    this.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: null
    });
  };
  /**
   * Invoked upon successful loading of some data source
   * @param {DataSource} dataSource - Data source for visualization (molecular complex or other)
   * @param {object} opts - Options.
   * @private
   */


  Miew.prototype._onLoad = function (dataSource, opts) {
    var gfx = this._gfx;
    var visualName = null;

    if (opts.animation) {
      this._refreshTitle();

      this._startAnimation(dataSource);

      return null;
    }

    this._stopAnimation();

    if (!opts || !opts.keepRepsInfo) {
      this._opts.reps = null;
      this._opts._objects = null;
    }

    if (dataSource.id === 'Complex') {
      var complex = dataSource; // update title

      if (opts.fileName) {
        complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
      } else if (opts.amberFileName) {
        complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
      } else {
        complex.name = "Dynamic ".concat(opts.fileType, " molecule");
      }

      visualName = this._addVisual(new ComplexVisual(complex.name, complex));
      this._curVisualName = visualName;
      var desc = this.info();
      this.logger.info("Parsed ".concat(opts.fileName, " (").concat(desc.atoms, " atoms, ").concat(desc.bonds, " bonds, ").concat(desc.residues, " residues, ").concat(desc.chains, " chains)."));

      if (___default['default'].isNumber(this._opts.unit)) {
        complex.setCurrentUnit(this._opts.unit);
      }

      if (opts.preset) ; else if (settings.now.autoPreset) {
        switch (opts.fileType) {
          case 'cml':
            this.resetReps('small');
            break;

          case 'pdb':
          case 'mmtf':
          case 'cif':
            if (hasValidResidues(complex)) {
              this.resetReps('macro');
            } else {
              this.resetReps('small');
            }

            break;

          default:
            this.resetReps('default');
            break;
        }
      } else {
        this.resetReps('default');
      }
    } else if (dataSource.id === 'Volume') {
      this.resetEd();
      visualName = this._onLoadEd(dataSource);
    }

    gfx.camera.updateProjectionMatrix();

    this._updateFog(); // reset global transform


    gfx.root.resetTransform();
    this.resetPivot(); // set scale to fit everything on the screen

    this._objectControls.setScale(settings.now.radiusToFit / this._getBSphereRadius());

    this._resetObjects();

    if (settings.now.autoResolution) {
      this._tweakResolution();
    }

    if (settings.now.shadow.on) {
      this._updateShadowCamera();
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    this._refreshTitle();

    return visualName;
  };

  Miew.prototype.resetEd = function () {
    if (this._edLoader) {
      this._edLoader.abort();

      this._edLoader = null;
    } // free all resources


    this._removeVisual(this._getVolumeVisual());

    this._needRender = true;
  };

  Miew.prototype.loadEd = function (source) {
    var _this4 = this;

    this.resetEd();

    var TheLoader = ___default['default'].head(io.loaders.find({
      source: source
    }));

    if (!TheLoader) {
      this.logger.error(LOADER_NOT_FOUND);
      return Promise.reject(new Error(LOADER_NOT_FOUND));
    }

    var loader = this._edLoader = new TheLoader(source, {
      binary: true
    });
    loader.context = this;
    return loader.load().then(function (data) {
      var TheParser = ___default['default'].head(io.parsers.find({
        format: 'ccp4'
      }));

      if (!TheParser) {
        throw new Error(PARSER_NOT_FOUND);
      }

      var parser = new TheParser(data);
      parser.context = _this4;
      return parser.parse().then(function (dataSource) {
        _this4._onLoadEd(dataSource);
      });
    })["catch"](function (error) {
      _this4.logger.error('Could not load ED data');

      _this4.logger.debug(error);
    });
  };

  Miew.prototype._onLoadEd = function (dataSource) {
    dataSource.normalize();
    var volumeVisual = new VolumeVisual('volume', dataSource);
    volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME); // volume mesh is not visible to common render

    var visualName = this._addVisual(volumeVisual);

    this._needRender = true;
    return visualName;
  };

  Miew.prototype._needRebuild = function () {
    var needsRebuild = false;

    this._forEachComplexVisual(function (visual) {
      needsRebuild = needsRebuild || visual.needsRebuild();
    });

    return needsRebuild;
  };

  Miew.prototype._rebuildObjects = function () {
    var self = this;
    var gfx = this._gfx;
    var i;
    var n; // remove old object geometry

    var toRemove = [];

    for (i = 0; i < gfx.pivot.children.length; ++i) {
      var child = gfx.pivot.children[i];

      if (!(child instanceof Visual)) {
        toRemove.push(child);
      }
    }

    for (i = 0; i < toRemove.length; ++i) {
      toRemove[i].parent.remove(toRemove[i]);
    }

    setTimeout(function () {
      var objList = self._objects;

      for (i = 0, n = objList.length; i < n; ++i) {
        var obj = objList[i];

        if (obj.needsRebuild) {
          obj.build();
        }

        if (obj.getGeometry()) {
          gfx.pivot.add(obj.getGeometry());
        }
      }
    }, 10);
  };

  Miew.prototype.changeUnit = function (unitIdx, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      throw new Error('There is no complex to change!');
    }

    function currentUnitInfo() {
      var unit = visual ? visual.getComplex().getCurrentUnit() : 0;
      var type = unit > 0 ? "Bio molecule ".concat(unit) : 'Asymmetric unit';
      return "Current unit: ".concat(unit, " (").concat(type, ")");
    }

    if (unitIdx === undefined) {
      return currentUnitInfo();
    }

    if (___default['default'].isString(unitIdx)) {
      unitIdx = Math.max(parseInt(unitIdx, 10), 0);
    }

    if (visual.getComplex().setCurrentUnit(unitIdx)) {
      this._resetScene();

      this._updateInfoPanel();
    }

    return currentUnitInfo();
  };
  /**
   * Start to rebuild geometry asynchronously.
   */


  Miew.prototype.rebuild = function () {
    var _this5 = this;

    if (this._building) {
      this.logger.warn('Miew.rebuild(): already building!');
      return;
    }

    this._building = true;
    this.dispatchEvent({
      type: 'rebuilding'
    });

    this._rebuildObjects();

    this._gfx.renderer2d.reset();

    var rebuildActions = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.needsRebuild()) {
        rebuildActions.push(visual.rebuild().then(function () {
          return new Promise(function (resolve) {
            visual.rebuildSelectionGeometry();
            resolve();
          });
        }));
      }
    }); // Start asynchronous rebuild


    var self = this;

    this._spinner.spin(this._container);

    Promise.all(rebuildActions).then(function () {
      self._spinner.stop();

      self._needRender = true;

      self._refreshTitle();

      _this5.dispatchEvent({
        type: 'buildingDone'
      });

      self._building = false;
    });
  };
  /** Mark all representations for rebuilding */


  Miew.prototype.rebuildAll = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setNeedsRebuild();
    });
  };

  Miew.prototype._refreshTitle = function (appendix) {
    var title;
    appendix = appendix === undefined ? '' : appendix;

    var visual = this._getComplexVisual();

    if (visual) {
      title = visual.getComplex().name;
      var rep = visual.repGet(visual.repCurrent());
      title += rep ? " \u2013 ".concat(rep.mode.name, " Mode") : '';
    } else {
      title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data';
    }

    title += appendix;
    this.dispatchEvent({
      type: 'titleChanged',
      data: title
    });
  };

  Miew.prototype.setNeedRender = function () {
    this._needRender = true;
  };

  Miew.prototype._extractRepresentation = function () {
    var _this6 = this;

    var changed = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.getSelectionCount() === 0) {
        return;
      }

      var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
      var defPreset = settings.now.presets["default"];
      var res = visual.repAdd({
        selector: selector,
        mode: defPreset[0].mode.id,
        colorer: defPreset[0].colorer.id,
        material: defPreset[0].material.id
      });

      if (!res) {
        if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
          _this6.logger.warn("Number of representations is limited to ".concat(ComplexVisual.NUM_REPRESENTATION_BITS));
        }

        return;
      }

      _this6.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });

      visual.repCurrent(res.index);
      changed.push(visual.name);
    });

    if (changed.length > 0) {
      this.logger.report("New representation from selection for complexes: ".concat(changed.join(', ')));
    }
  };
  /**
   * Change current representation list.
   * @param {array} reps - Representation list.
   */


  Miew.prototype._setReps = function (reps) {
    reps = reps || this._opts && this._opts.reps || [];

    this._forEachComplexVisual(function (visual) {
      return visual.resetReps(reps);
    });
  };
  /**
   * Apply existing preset to current scene.
   * @param preset
   */


  Miew.prototype.applyPreset = function (preset) {
    var presets = settings.now.presets;
    var presList = [preset || settings.defaults.preset, settings.defaults.preset, Object.keys(presets)[0]];
    var reps = null;

    for (var i = 0; !reps && i < presList.length; ++i) {
      settings.set('preset', presList[i]);
      reps = presets[settings.now.preset];

      if (!reps) {
        this.logger.warn("Unknown preset \"".concat(settings.now.preset, "\""));
      }
    }

    this._setReps(reps);
  };
  /**
   * Reset current representation list to initial values.
   * @param {string} [preset] - The source preset in case of uninitialized representation list.
   */


  Miew.prototype.resetReps = function (preset) {
    var reps = this._opts && this._opts.reps;

    if (reps) {
      this._setReps(reps);
    } else {
      this.applyPreset(preset);
    }
  };
  /**
   * Get number of representations created so far.
   * @returns {number} Number of reps.
   */


  Miew.prototype.repCount = function (name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repCount() : 0;
  };
  /**
   * Get or set the current representation index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @param {string=} [name] - Complex name. Defaults to the current one.
   * @returns {number} The current index.
   */


  Miew.prototype.repCurrent = function (index, name) {
    var visual = this._getComplexVisual(name);

    var newIdx = visual ? visual.repCurrent(index) : -1;

    if (index && newIdx !== index) {
      this.logger.warn("Representation ".concat(index, " was not found. Current rep remains unchanged."));
    }

    return newIdx;
  };
  /**
   * Get or set representation by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
   * @param {object=} rep - Optional representation description.
   * @param {string=} rep.selector - Selector string.
   * @param {string=} rep.mode - Mode id.
   * @param {string=} rep.colorer - Colorer id.
   * @param {string=} rep.material - Material id.
   * @returns {?object} Representation description.
   */


  Miew.prototype.rep = function (index, rep) {
    var visual = this._getComplexVisual('');

    if (!visual) {
      return null;
    }

    var res = visual.rep(index, rep);

    if (res.status === 'created') {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });
    } else if (res.status === 'changed') {
      this.dispatchEvent({
        type: 'repChanged',
        index: res.index,
        name: visual.name
      });
    }

    return res.desc;
  };
  /**
   * Get representation (not just description) by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
   * @returns {?object} Representation.
   */


  Miew.prototype.repGet = function (index, name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repGet(index) : null;
  };
  /**
   * Add new representation.
   * @param {object=} rep - Representation description.
   * @returns {number} Index of the new representation.
   */


  Miew.prototype.repAdd = function (rep, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return -1;
    }

    var res = visual.repAdd(rep);

    if (res) {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: name
      });
      return res.index;
    }

    return -1;
  };
  /**
   * Remove representation.
   * @param {number=} index - Zero-based representation index.
   */


  Miew.prototype.repRemove = function (index, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return;
    }

    visual.repRemove(index);
    this.dispatchEvent({
      type: 'repRemoved',
      index: index,
      name: name
    });
  };
  /**
   * Hide representation.
   * @param {number} index - Zero-based representation index.
   * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
   */


  Miew.prototype.repHide = function (index, hide, name) {
    this._needRender = true;

    var visual = this._getComplexVisual(name);

    return visual ? visual.repHide(index, hide) : null;
  };

  Miew.prototype._setEditMode = function (mode) {
    this._editMode = mode;
    var elem = this._msgMode;

    if (elem) {
      elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0;

      if (mode !== EDIT_MODE.COMPLEX) {
        var t = elem.getElementsByTagName('p')[0];
        t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
      }
    }

    this.dispatchEvent({
      type: 'editModeChanged',
      data: mode === EDIT_MODE.COMPLEX
    });
  };

  Miew.prototype._enterComponentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var editors = [];

    this._forEachComplexVisual(function (visual) {
      var editor = visual.beginComponentEdit();

      if (editor) {
        editors.push(editor);
      }
    });

    if (editors === []) {
      return;
    }

    this._editors = editors;
    this.logger.info('COMPONENT EDIT MODE -- ON');

    this._setEditMode(EDIT_MODE.COMPONENT);

    this._objectControls.keysTranslateObj(true);
  };

  Miew.prototype._applyComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this.rebuildAll();
  };

  Miew.prototype._discardComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._needRender = true;
    this.rebuildAll();
  };

  Miew.prototype._enterFragmentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var selectedVisuals = [];

    this._forEachComplexVisual(function (visual) {
      if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
        selectedVisuals.push(visual);
      }
    });

    if (selectedVisuals.length !== 1) {
      // either we have no selection or
      // we have selected atoms in two or more visuals -- not supported
      return;
    }

    var editor = selectedVisuals[0].beginFragmentEdit();

    if (!editor) {
      return;
    }

    this._editors = [editor];
    this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)');

    this._setEditMode(EDIT_MODE.FRAGMENT);

    this._objectControls.allowTranslation(false);

    this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());

    this._needRender = true;
  };

  Miew.prototype._applyFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.rebuildAll();
  };

  Miew.prototype._discardFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this._needRender = true;
  };

  Miew.prototype._onPick = function (event) {
    if (!settings.now.picking) {
      // picking is disabled
      return;
    }

    if (this._animInterval !== null) {
      // animation playback is on
      return;
    }

    if (this._editMode === EDIT_MODE.FRAGMENT) {
      // prevent picking in fragment edit mode
      return;
    }

    if (this._objectControls.isEditingAltObj()) {
      // prevent picking during component rotation
      return;
    } // update last pick & find complex


    var complex = null;

    if (event.obj.atom) {
      complex = event.obj.atom.residue.getChain().getComplex();
      this._lastPick = event.obj.atom;
    } else if (event.obj.residue) {
      complex = event.obj.residue.getChain().getComplex();
      this._lastPick = event.obj.residue;
    } else if (event.obj.chain) {
      complex = event.obj.chain.getComplex();
      this._lastPick = event.obj.chain;
    } else if (event.obj.molecule) {
      complex = event.obj.molecule.complex;
      this._lastPick = event.obj.molecule;
    } else {
      this._lastPick = null;
    }

    function _updateSelection(visual) {
      visual.updateSelectionMask(event.obj);
      visual.rebuildSelectionGeometry();
    } // update visual


    if (complex) {
      var visual = this._getVisualForComplex(complex);

      if (visual) {
        _updateSelection(visual);

        this._needRender = true;
      }
    } else {
      this._forEachComplexVisual(_updateSelection);

      this._needRender = true;
    }

    this._updateInfoPanel();

    this.dispatchEvent(event);
  };

  Miew.prototype._onKeyDown = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    switch (event.keyCode) {
      case 'C'.charCodeAt(0):
        if (settings.now.editing) {
          this._enterComponentEditMode();
        }

        break;

      case 'F'.charCodeAt(0):
        if (settings.now.editing) {
          this._enterFragmentEditMode();
        }

        break;

      case 'A'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit();

            break;
        }

        break;

      case 'D'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit();

            break;
        }

        break;

      case 'S'.charCodeAt(0):
        event.preventDefault();
        event.stopPropagation();
        settings.set('ao', !settings.now.ao);
        this._needRender = true;
        break;

      case 107:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.expandSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;

      case 109:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.shrinkSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;
    }
  };

  Miew.prototype._onKeyUp = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    if (event.keyCode === 'X'.charCodeAt(0)) {
      this._extractRepresentation();
    }
  };

  Miew.prototype._updateInfoPanel = function () {
    var info = this._msgAtomInfo.getElementsByTagName('p')[0];

    var atom;
    var residue;
    var count = 0;

    this._forEachComplexVisual(function (visual) {
      count += visual.getSelectionCount();
    });

    while (info.firstChild) {
      info.removeChild(info.firstChild);
    }

    if (count === 0) {
      this._msgAtomInfo.style.opacity = 0.0;
      return;
    }

    var firstLine = "".concat(String(count), " atom").concat(count !== 1 ? 's' : '', " selected");

    if (this._lastPick !== null) {
      firstLine += ', the last pick:';
    }

    var secondLine = '';
    var aName = '';
    var coordLine = '';

    if (this._lastPick instanceof Atom$2) {
      atom = this._lastPick;
      residue = atom.residue;
      aName = atom.name;
      var location = atom.location !== 32 ? String.fromCharCode(atom.location) : ''; // 32 is code of white-space

      secondLine = "".concat(atom.element.fullName, " #").concat(atom.serial).concat(location, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim(), ".");
      secondLine += aName;
      coordLine = "Coord: (".concat(atom.position.x.toFixed(2).toString(), ",     ").concat(atom.position.y.toFixed(2).toString(), ",     ").concat(atom.position.z.toFixed(2).toString(), ")");
    } else if (this._lastPick instanceof Residue$1) {
      residue = this._lastPick;
      secondLine = "".concat(residue._type._fullName, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim());
    } else if (this._lastPick instanceof Chain$2) {
      secondLine = "chain ".concat(this._lastPick._name);
    } else if (this._lastPick instanceof Molecule$8) {
      secondLine = "molecule ".concat(this._lastPick._name);
    }

    info.appendChild(document.createTextNode(firstLine));

    if (secondLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(secondLine));
    }

    if (coordLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(coordLine));
    }

    this._msgAtomInfo.style.opacity = 1.0;
  };

  Miew.prototype._getAltObj = function () {
    if (this._editors) {
      var altObj = null;

      for (var i = 0; i < this._editors.length; ++i) {
        var nextAltObj = this._editors[i].getAltObj();

        if (nextAltObj.objects.length > 0) {
          if (altObj) {
            // we have selected atoms in two or more visuals -- not supported
            altObj = null;
            break;
          }

          altObj = nextAltObj;
        }
      }

      if (altObj) {
        return altObj;
      }
    }

    return {
      objects: [],
      pivot: new THREE.Vector3(0, 0, 0)
    };
  };

  Miew.prototype.resetPivot = function () {
    var boundingBox = new THREE.Box3();
    var center = new THREE.Vector3();
    return function () {
      boundingBox.makeEmpty();

      this._forEachVisual(function (visual) {
        boundingBox.union(visual.getBoundaries().boundingBox);
      });

      boundingBox.getCenter(center);

      this._objectControls.setPivot(center.negate());

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotResidue = function () {
    var center = new THREE.Vector3();
    return function (residue) {
      var visual = this._getVisualForComplex(residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      if (residue._controlPoint) {
        center.copy(residue._controlPoint);
      } else {
        var x = 0;
        var y = 0;
        var z = 0;
        var amount = residue._atoms.length;

        for (var i = 0; i < amount; ++i) {
          var p = residue._atoms[i].position;
          x += p.x / amount;
          y += p.y / amount;
          z += p.z / amount;
        }

        center.set(x, y, z);
      }

      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotAtom = function () {
    var center = new THREE.Vector3();
    return function (atom) {
      var visual = this._getVisualForComplex(atom.residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      center.copy(atom.position);
      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.getSelectionCenter = function () {
    var _centerInVisual = new THREE.Vector3(0.0, 0.0, 0.0);

    return function (center, includesAtom, selector) {
      center.set(0.0, 0.0, 0.0);
      var count = 0;

      this._forEachComplexVisual(function (visual) {
        if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
          center.add(_centerInVisual);
          count++;
        }
      });

      if (count === 0) {
        return false;
      }

      center.divideScalar(count);
      center.negate();
      return true;
    };
  }();

  Miew.prototype.setPivotSubset = function () {
    var _center = new THREE.Vector3(0.0, 0.0, 0.0);

    function _includesInCurSelection(atom, selectionBit) {
      return atom.mask & 1 << selectionBit;
    }

    function _includesInSelector(atom, selector) {
      return selector.selector.includesAtom(atom);
    }

    return function (selector) {
      var includesAtom = selector ? _includesInSelector : _includesInCurSelection;

      if (this.getSelectionCenter(_center, includesAtom, selector)) {
        this._objectControls.setPivot(_center);

        this.dispatchEvent({
          type: 'transform'
        });
      } else {
        this.logger.warn('selection is empty. Center operation not performed');
      }
    };
  }();
  /**
   * Makes a screenshot.
   * @param {number} [width] - Width of an image. Defaults to the canvas width.
   * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
   *        if width is omitted too.
   * @returns {string} Data URL representing the image contents.
   */


  Miew.prototype.screenshot = function (width, height) {
    var gfx = this._gfx;
    var deviceWidth = gfx.renderer.domElement.width;
    var deviceHeight = gfx.renderer.domElement.height;

    function fov2Tan(fov) {
      return Math.tan(THREE.MathUtils.degToRad(0.5 * fov));
    }

    function tan2Fov(tan) {
      return THREE.MathUtils.radToDeg(Math.atan(tan)) * 2.0;
    }

    function getDataURL() {
      var dataURL;
      var currBrowser = utils.getBrowser();

      if (currBrowser === utils.browserType.SAFARI) {
        var canvas = document.createElement('canvas');
        var canvasContext = canvas.getContext('2d');
        canvas.width = width === undefined ? deviceWidth : width;
        canvas.height = height === undefined ? deviceHeight : height;
        canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
        dataURL = canvas.toDataURL('image/png');
      } else {
        // Copy current canvas to screenshot
        dataURL = gfx.renderer.domElement.toDataURL('image/png');
      }

      return dataURL;
    }

    height = height || width;
    var screenshotURI;

    if (width === undefined && height === undefined || width === deviceWidth && height === deviceHeight) {
      // renderer.domElement.toDataURL('image/png') returns flipped image in Safari
      // It hasn't been resolved yet, but getScreenshotSafari()
      // fixes it using an extra canvas.
      screenshotURI = getDataURL();
    } else {
      var originalAspect = gfx.camera.aspect;
      var originalFov = gfx.camera.fov;
      var originalTanFov2 = fov2Tan(gfx.camera.fov); // screenshot should contain the principal area of interest (a centered square touching screen sides)

      var areaOfInterestSize = Math.min(gfx.width, gfx.height);
      var areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height; // set appropriate camera aspect & FOV

      var shotAspect = width / height;
      gfx.renderer.setPixelRatio(1);
      gfx.camera.aspect = shotAspect;
      gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1.0));
      gfx.camera.updateProjectionMatrix(); // resize canvas to the required size of screenshot

      gfx.renderer.setDrawingBufferSize(width, height, 1); // make screenshot

      this._renderFrame(settings.now.stereo);

      screenshotURI = getDataURL(); // restore original camera & canvas proportions

      gfx.renderer.setPixelRatio(window.devicePixelRatio);
      gfx.camera.aspect = originalAspect;
      gfx.camera.fov = originalFov;
      gfx.camera.updateProjectionMatrix();
      gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
      this._needRender = true;
    }

    return screenshotURI;
  };
  /**
   * Makes screenshot and initiates a download.
   * @param {string} [filename] - Name of a file. Default to a 'screenshot-XXXXX.png', where XXXXX is a current
   *        date/time in seconds.
   * @param {number} [width] - Width of an image. Defaults to the canvas width.
   * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
   *        if width is omitted too.
   */


  Miew.prototype.screenshotSave = function (filename, width, height) {
    var uri = this.screenshot(width, height);
    utils.shotDownload(uri, filename);
  };

  Miew.prototype.save = function (opts) {
    var _this7 = this;

    this._export(opts.fileType).then(function (dataString) {
      var filename = _this7._visuals[_this7._curVisualName]._complex.name;
      utils.download(dataString, filename, opts.fileType);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone'
      });
    })["catch"](function (error) {
      _this7.logger.error('Could not export data');

      _this7.logger.debug(error);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone',
        error: error
      });
    });
  };

  Miew.prototype._tweakResolution = function () {
    var maxPerf = [['poor', 100], ['low', 500], ['medium', 1000], ['high', 5000], ['ultra', Number.MAX_VALUE]];
    var atomCount = 0;

    this._forEachComplexVisual(function (visual) {
      atomCount += visual.getComplex().getAtomCount();
    });

    if (atomCount > 0) {
      var performance = this._gfxScore * 10e5 / atomCount; // set resolution based on estimated performance

      for (var i = 0; i < maxPerf.length; ++i) {
        if (performance < maxPerf[i][1]) {
          this._autoChangeResolution(maxPerf[i][0]);

          break;
        }
      }
    }
  };

  Miew.prototype._autoChangeResolution = function (resolution) {
    if (resolution !== settings.now.resolution) {
      this.logger.report("Your rendering resolution was changed to \"".concat(resolution, "\" for best performance."));
    }

    settings.now.resolution = resolution;
  };
  /**
   * Save current settings to cookies.
   */


  Miew.prototype.saveSettings = function () {
    this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
  };
  /**
   * Load settings from cookies.
   */


  Miew.prototype.restoreSettings = function () {
    try {
      var cookie = this._cookies.getCookie(this._opts.settingsCookie);

      var diffs = cookie ? JSON.parse(cookie) : {};
      this.settings.applyDiffs(diffs, true);
    } catch (e) {
      this.logger.error("Cookies parse error: ".concat(e.message));
    }
  };
  /**
   * Reset current settings to the defaults.
   */


  Miew.prototype.resetSettings = function () {
    this.settings.reset();
  };
  /*
     * DANGEROUS and TEMPORARY. The method should change or disappear in future versions.
     * @param {string|object} opts - See {@link Miew} constructor.
     * @see {@link Miew#set}, {@link Miew#repAdd}, {@link Miew#rep}.
     */


  Miew.prototype.setOptions = function (opts) {
    if (typeof opts === 'string') {
      opts = Miew.options.fromAttr(opts);
    }

    if (opts.reps) {
      this._opts.reps = null;
    }

    ___default['default'].merge(this._opts, opts);

    if (opts.settings) {
      this.set(opts.settings);
    }

    this._opts._objects = opts._objects;

    this._resetObjects();

    if (opts.load) {
      this.load(opts.load, {
        fileType: opts.type
      });
    }

    if (opts.preset) {
      settings.now.preset = opts.preset;
    }

    if (opts.reps) {
      this.resetReps(opts.preset);
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    var visual = this._getComplexVisual();

    if (visual) {
      visual.getComplex().resetCurrentUnit();

      if (___default['default'].isNumber(opts.unit)) {
        visual.getComplex().setCurrentUnit(opts.unit);
      }

      this.resetView();
      this.rebuildAll();
    }
  };

  Miew.prototype.info = function (name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return {};
    }

    var complex = visual.getComplex();
    var metadata = complex.metadata;
    return {
      id: metadata.id || complex.name || 'UNKNOWN',
      title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
      atoms: complex.getAtomCount(),
      bonds: complex.getBondCount(),
      residues: complex.getResidueCount(),
      chains: complex.getChainCount()
    };
  };
  /*
     * OBJECTS SEGMENT
     */


  Miew.prototype.addObject = function (objData, bThrow) {
    var Ctor = null;

    if (objData.type === LinesObj.prototype.type) {
      Ctor = LinesObj;
    }

    if (Ctor === null) {
      throw new Error("Unknown scene object type - ".concat(objData.type));
    }

    try {
      var newObj = new Ctor(objData.params, objData.opts);

      this._addSceneObject(newObj);
    } catch (error) {
      if (!bThrow) {
        this.logger.debug("Error during scene object creation: ".concat(error.message));
      } else {
        throw error;
      }
    }

    this._needRender = true;
  };

  Miew.prototype._addSceneObject = function (sceneObject) {
    var visual = this._getComplexVisual();

    if (sceneObject.build && visual) {
      sceneObject.build(visual.getComplex());

      this._gfx.pivot.add(sceneObject.getGeometry());
    }

    var objects = this._objects;
    objects[objects.length] = sceneObject;
  };

  Miew.prototype._updateObjsToFrame = function (frameData) {
    var objs = this._objects;

    for (var i = 0, n = objs.length; i < n; ++i) {
      if (objs[i].updateToFrame) {
        objs[i].updateToFrame(frameData);
      }
    }
  };

  Miew.prototype._resetObjects = function () {
    var objs = this._opts._objects;
    this._objects = [];

    if (objs) {
      for (var i = 0, n = objs.length; i < n; ++i) {
        this.addObject(objs[i], false);
      }
    }
  };

  Miew.prototype.removeObject = function (index) {
    var obj = this._objects[index];

    if (!obj) {
      throw new Error("Scene object with index ".concat(index, " does not exist"));
    }

    obj.destroy();

    this._objects.splice(index, 1);

    this._needRender = true;
  };
  /**
   * Get a string with a URL to reproduce the current scene.
   *
   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
   * preset information regardless of the differences with settings
   * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
   * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
   * @returns {string} URL
   */


  Miew.prototype.getURL = function (opts) {
    return options.toURL(this.getState(___default['default'].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    })));
  };
  /**
   * Get a string with a script to reproduce the current scene.
   *
   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
   * preset information regardless of the differences with settings
   * @param {boolean} [opts.settings=true] - when this flag is true, changes in settings are included
   * @param {boolean} [opts.view=true] - when this flag is true, a view information is included
   * @returns {string} script
   */


  Miew.prototype.getScript = function (opts) {
    return options.toScript(this.getState(___default['default'].defaults(opts, {
      compact: true,
      settings: true,
      view: true
    })));
  };
  /*
     * Generates object that represents the current state of representations list
     * @param {boolean} compareWithDefaults - when this flag is true, reps list is compared (if possible)
     * to preset's defaults and only diffs are generated
     */


  Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
    var ans = {};
    var repCount = 0;

    if (complexVisual) {
      repCount = complexVisual.repCount();
    }

    var currPreset = settings.defaults.presets[settings.now.preset];
    var compare = compareWithDefaults;

    if (currPreset === undefined || currPreset.length > repCount) {
      compare = false;
      ans.preset = 'empty';
    } else if (settings.now.preset !== settings.defaults.preset) {
      ans.preset = settings.now.preset;
    }

    var repsDiff = [];
    var emptyReps = true;

    for (var i = 0, n = repCount; i < n; ++i) {
      repsDiff[i] = complexVisual.repGet(i).compare(compare ? currPreset[i] : null);

      if (!___default['default'].isEmpty(repsDiff[i])) {
        emptyReps = false;
      }
    }

    if (!emptyReps) {
      ans.reps = repsDiff;
    }

    return ans;
  };
  /*
     * Obtain object that represents current state of miew (might be used as options in constructor).
     * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
     * preset information regardless of the differences with settings
     * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
     * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
     * @returns {Object} State object.
     */


  Miew.prototype.getState = function (opts) {
    var state = {};
    opts = ___default['default'].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    }); // load

    var visual = this._getComplexVisual();

    if (visual !== null) {
      var complex = visual.getComplex();
      var metadata = complex.metadata;

      if (metadata.id) {
        var format = metadata.format ? "".concat(metadata.format, ":") : '';
        state.load = format + metadata.id;
      }

      var unit = complex.getCurrentUnit();

      if (unit !== 1) {
        state.unit = unit;
      }
    } // representations


    var repsInfo = this._compareReps(visual, opts.compact);

    if (repsInfo.preset) {
      state.preset = repsInfo.preset;
    }

    if (repsInfo.reps) {
      state.reps = repsInfo.reps;
    } // objects


    var objects = this._objects;
    var objectsState = [];

    for (var i = 0, n = objects.length; i < n; ++i) {
      objectsState[i] = objects[i].identify();
    }

    if (objects.length > 0) {
      state._objects = objectsState;
    } // view


    if (opts.view) {
      state.view = this.view();
    } // settings


    if (opts.settings) {
      var diff = this.settings.getDiffs(false);

      if (!___default['default'].isEmpty(diff)) {
        state.settings = diff;
      }
    }

    return state;
  };
  /**
   * Get parameter value.
   * @param {string} param - Parameter name or path (e.g. 'modes.BS.atom').
   * @param {*=} value - Default value.
   * @returns {*} Parameter value.
   */


  Miew.prototype.get = function (param, value) {
    return settings.get(param, value);
  };

  Miew.prototype._clipPlaneUpdateValue = function (radius) {
    var clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings.now.draft.clipPlaneFactor, settings.now.camNear);
    var opts = {
      clipPlaneValue: clipPlaneValue
    };

    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions(opts);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setUberOptions(opts);
      }
    }

    if (this._picker !== null) {
      this._picker.clipPlaneValue = clipPlaneValue;
    }
  };

  Miew.prototype._fogFarUpdateValue = function () {
    if (this._picker !== null) {
      if (this._gfx.scene.fog) {
        this._picker.fogFarValue = this._gfx.scene.fog.far;
      } else {
        this._picker.fogFarValue = undefined;
      }
    }
  };

  Miew.prototype._updateShadowmapMeshes = function (process) {
    this._forEachComplexVisual(function (visual) {
      var reprList = visual._reprList;

      for (var i = 0, n = reprList.length; i < n; ++i) {
        var repr = reprList[i];
        process(repr.geo, repr.material);
      }
    });
  };

  Miew.prototype._updateMaterials = function (values) {
    var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    this._forEachComplexVisual(function (visual) {
      return visual.setMaterialValues(values, needTraverse, process);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setValues(values);

        obj._line.material.needsUpdate = true;
      }
    }
  };

  Miew.prototype._fogAlphaChanged = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions({
        fogAlpha: settings.now.fogAlpha
      });
    });
  };

  Miew.prototype._embedWebXR = function () {
    var _this8 = this;

    // switch off
    if (settings.now.stereo !== 'WEBVR') {
      if (this.webVR) {
        this.webVR.disable();
      }

      this.webVR = null;
      return;
    } // switch on


    if (!this.webVR) {
      this.webVR = new WebVRPoC(function () {
        _this8._requestAnimationFrame(function () {
          return _this8._onTick();
        });

        _this8._needRender = true;

        _this8._onResize();
      });
    }

    this.webVR.enable(this._gfx);
  };

  Miew.prototype._initOnSettingsChanged = function () {
    var _this9 = this;

    var on = function on(props, func) {
      props = ___default['default'].isArray(props) ? props : [props];
      props.forEach(function (prop) {
        _this9.settings.addEventListener("change:".concat(prop), func);
      });
    };

    on('modes.VD.frame', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.showFrame(settings.now.modes.VD.frame);
      _this9._needRender = true;
    });
    on('modes.VD.isoMode', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.getMesh().material.updateDefines();
      _this9._needRender = true;
    });
    on('bg.color', function () {
      _this9._onBgColorChanged();
    });
    on('ao', function () {
      if (settings.now.ao && !isAOSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support ao');

        settings.set('ao', false);
      } else {
        var values = {
          normalsToGBuffer: settings.now.ao
        };

        _this9._setUberMaterialValues(values);
      }
    });
    on('zSprites', function () {
      if (settings.now.zSprites && !arezSpritesSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support zSprites');

        settings.set('zSprites', false);
      }

      _this9.rebuildAll();
    });
    on('fogColor', function () {
      _this9._onFogColorChanged();
    });
    on('fogColorEnable', function () {
      _this9._onFogColorChanged();
    });
    on('bg.transparent', function (evt) {
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      } // update materials


      _this9._updateMaterials({
        fogTransparent: evt.value
      });

      _this9.rebuildAll();
    });
    on('draft.clipPlane', function (evt) {
      // update materials
      _this9._updateMaterials({
        clipPlane: evt.value
      });

      _this9.rebuildAll();
    });
    on('shadow.on', function (evt) {
      // update materials
      var values = {
        shadowmap: evt.value,
        shadowmapType: settings.now.shadow.type
      };
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
      }

      _this9._updateMaterials(values, true);

      if (values.shadowmap) {
        _this9._updateShadowCamera();

        _this9._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
      } else {
        _this9._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
      }

      _this9._needRender = true;
    });
    on('shadow.type', function (evt) {
      // update materials if shadowmap is enable
      if (settings.now.shadow.on) {
        _this9._updateMaterials({
          shadowmapType: evt.value
        }, true);

        _this9._needRender = true;
      }
    });
    on('shadow.radius', function (evt) {
      for (var i = 0; i < _this9._gfx.scene.children.length; i++) {
        if (_this9._gfx.scene.children[i].shadow !== undefined) {
          var light = _this9._gfx.scene.children[i];
          light.shadow.radius = evt.value;
          _this9._needRender = true;
        }
      }
    });
    on('fps', function () {
      _this9._fps.show(settings.now.fps);
    });
    on(['fog', 'fogNearFactor', 'fogFarFactor'], function () {
      _this9._updateFog();

      _this9._needRender = true;
    });
    on('fogAlpha', function () {
      var fogAlpha = settings.now.fogAlpha;

      if (fogAlpha < 0 || fogAlpha > 1) {
        _this9.logger.warn('fogAlpha must belong range [0,1]');
      }

      _this9._fogAlphaChanged();

      _this9._needRender = true;
    });
    on('autoResolution', function (evt) {
      if (evt.value && !_this9._gfxScore) {
        _this9.logger.warn('Benchmarks are missed, autoresolution will not work! ' + 'Autoresolution should be set during miew startup.');
      }
    });
    on('stereo', function () {
      _this9._embedWebXR(settings.now.stereo === 'WEBVR');

      _this9._needRender = true;
    });
    on(['transparency', 'palette'], function () {
      _this9.rebuildAll();
    });
    on('resolution', function () {
      // update complex visuals
      _this9.rebuildAll(); // update volume visual


      var volume = _this9._getVolumeVisual();

      if (volume) {
        volume.getMesh().material.updateDefines();
        _this9._needRender = true;
      }
    });
    on(['axes', 'fxaa', 'ao', 'outline.on', 'outline.color', 'outline.threshold', 'outline.thickness'], function () {
      _this9._needRender = true;
    });
  };
  /**
   * Set parameter value.
   * @param {string|object} params - Parameter name or path (e.g. 'modes.BS.atom') or even settings object.
   * @param {*=} value - Value.
   */


  Miew.prototype.set = function (params, value) {
    settings.set(params, value);
  };
  /**
   * Select atoms with selection string.
   * @param {string} expression - string expression of selection
   * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
   */


  Miew.prototype.select = function (expression, append) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return;
    }

    var sel = expression;

    if (___default['default'].isString(expression)) {
      sel = selectors$4.parse(expression).selector;
    }

    visual.select(sel, append);
    this._lastPick = null;

    this._updateInfoPanel();

    this._needRender = true;
  };

  var VIEW_VERSION = '1';
  /**
   * Get or set view info packed into string.
   *
   * **Note:** view is stored for *left-handed* cs, euler angles are stored in radians and *ZXY-order*,
   *
   * @param {string=} expression - Optional string encoded the view
   */

  Miew.prototype.view = function (expression) {
    var self = this;
    var pivot = this._gfx.pivot;
    var transform = [];
    var eulerOrder = 'ZXY';

    function encode() {
      var pos = pivot.position;
      var scale = self._objectControls.getScale() / settings.now.radiusToFit;
      var euler = new THREE.Euler();
      euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder);
      transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
      return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
    }

    function decode() {
      // backwards compatible: old non-versioned view is the 0th version
      if (expression.length === 40) {
        expression = "0".concat(expression);
      }

      var version = expression[0];
      transform = utils.arrayFromBase64(expression.substr(1), Float32Array); // apply adapter for old versions

      if (version !== VIEW_VERSION) {
        if (version === '0') {
          // cancel radiusToFit included in old views
          transform[3] /= 8.0;
        } else {
          // do nothing
          self.logger.warn("Encoded view version mismatch, stored as ".concat(version, " vs ").concat(VIEW_VERSION, " expected"));
          return;
        }
      }

      var interpolator = self._interpolator;
      var srcView = interpolator.createView();
      srcView.position.copy(pivot.position);
      srcView.scale = self._objectControls.getScale();
      srcView.orientation.copy(self._objectControls.getOrientation());
      var dstView = interpolator.createView();
      dstView.position.set(transform[0], transform[1], transform[2]); // hack to make preset views work after we moved centering offset to visual nodes
      // FIXME should only store main pivot offset in preset

      if (self._getComplexVisual()) {
        dstView.position.sub(self._getComplexVisual().position);
      }

      dstView.scale = transform[3]; // eslint-disable-line prefer-destructuring

      dstView.orientation.setFromEuler(new THREE.Euler(transform[4], transform[5], transform[6], eulerOrder));
      interpolator.setup(srcView, dstView);
    }

    if (typeof expression === 'undefined') {
      return encode();
    }

    decode();
    return expression;
  };
  /*
     * Update current view due to viewinterpolator state
     */


  Miew.prototype._updateView = function () {
    var self = this;
    var pivot = this._gfx.pivot;
    var interpolator = this._interpolator;

    if (!interpolator.wasStarted()) {
      interpolator.start();
    }

    if (!interpolator.isMoving()) {
      return;
    }

    var res = interpolator.getCurrentView();

    if (res.success) {
      var curr = res.view;
      pivot.position.copy(curr.position);

      self._objectControls.setScale(curr.scale * settings.now.radiusToFit);

      self._objectControls.setOrientation(curr.orientation);

      this.dispatchEvent({
        type: 'transform'
      });
      self._needRender = true;
    }
  };
  /**
   * Translate object by vector
   * @param {number} x - translation value (Ang) along model's X axis
   * @param {number} y - translation value (Ang) along model's Y axis
   * @param {number} z - translation value (Ang) along model's Z axis
   */


  Miew.prototype.translate = function (x, y, z) {
    this._objectControls.translatePivot(x, y, z);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Rotate object by Euler angles
   * @param {number} x - rotation angle around X axis in radians
   * @param {number} y - rotation angle around Y axis in radians
   * @param {number} z - rotation angle around Z axis in radians
   */


  Miew.prototype.rotate = function (x, y, z) {
    this._objectControls.rotate(new THREE.Quaternion().setFromEuler(new THREE.Euler(x, y, z, 'XYZ')));

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Scale object by factor
   * @param {number} factor - scale multiplier, should greater than zero
   */


  Miew.prototype.scale = function (factor) {
    if (factor <= 0) {
      throw new RangeError('Scale should be greater than zero');
    }

    this._objectControls.scale(factor);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Center view on selection
   * @param {empty | subset | string} selector - defines part of molecule which must be centered (
   * empty - center on current selection;
   * subset - center on picked atom/residue/molecule;
   * string - center on atoms correspond to selection string)
   */


  Miew.prototype.center = function (selector) {
    // no arguments - center on current selection;
    if (selector === undefined) {
      this.setPivotSubset();
      this._needRender = true;
      return;
    } // subset with atom or residue - center on picked atom/residue;


    if (selector.obj !== undefined && ('atom' in selector.obj || 'residue' in selector.obj)) {
      // from event with selection
      if ('atom' in selector.obj) {
        this.setPivotAtom(selector.obj.atom);
      } else {
        this.setPivotResidue(selector.obj.residue);
      }

      this._needRender = true;
      return;
    } // string - center on atoms correspond to selection string


    if (selector.obj === undefined && selector !== '') {
      var sel = selectors$4.parse(selector);

      if (sel.error === undefined) {
        this.setPivotSubset(sel);
        this._needRender = true;
        return;
      }
    } // empty subset or incorrect/empty string - center on all molecule;


    this.resetPivot();
    this._needRender = true;
  };
  /**
   * Build selector that contains all atoms within given distance from group of atoms
   * @param {Selector} selector - selector describing source group of atoms
   * @param {number} radius - distance
   * @returns {Selector} selector describing result group of atoms
   */


  Miew.prototype.within = function (selector, radius) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return selectors$4.None();
    }

    if (selector instanceof String) {
      selector = selectors$4.parse(selector);
    }

    var res = visual.within(selector, radius);

    if (res) {
      visual.rebuildSelectionGeometry();
      this._needRender = true;
    }

    return res;
  };
  /**
   * Get atom position in 2D canvas coords
   * @param {string} fullAtomName - full atom name, like A.38.CG
   * @returns {Object} {x, y} or false if atom not found
   */


  Miew.prototype.projected = function (fullAtomName, complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return false;
    }

    var atom = visual.getComplex().getAtomByFullname(fullAtomName);

    if (atom === null) {
      return false;
    }

    var pos = atom.position.clone(); // we consider atom position to be affected only by common complex transform
    // ignoring any transformations that may add during editing

    this._gfx.pivot.updateMatrixWorldRecursive();

    this._gfx.camera.updateMatrixWorldRecursive();

    this._gfx.pivot.localToWorld(pos);

    pos.project(this._gfx.camera);
    return {
      x: (pos.x + 1.0) * 0.5 * this._gfx.width,
      y: (1.0 - pos.y) * 0.5 * this._gfx.height
    };
  };
  /**
   * Replace secondary structure with calculated one.
   *
   * DSSP algorithm implementation is used.
   *
   * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
   * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
   *
   * @param {string=} complexName - complex name
   */


  Miew.prototype.dssp = function (complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return;
    }

    visual.getComplex().dssp(); // rebuild dependent representations (cartoon or ss-colored)

    visual._reprList.forEach(function (rep) {
      if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
        rep.needsRebuild = true;
      }
    });
  };

  Miew.prototype.exportCML = function () {
    var self = this;

    function extractRotation(m) {
      var xAxis = new THREE.Vector3();
      var yAxis = new THREE.Vector3();
      var zAxis = new THREE.Vector3();
      m.extractBasis(xAxis, yAxis, zAxis);
      xAxis.normalize();
      yAxis.normalize();
      zAxis.normalize();
      var retMat = new THREE.Matrix4();
      retMat.identity();
      retMat.makeBasis(xAxis, yAxis, zAxis);
      return retMat;
    }

    function updateCMLData(complex) {
      var root = self._gfx.root;
      var mat = extractRotation(root.matrixWorld);
      var v4 = new THREE.Vector4(0, 0, 0, 0);
      var vCenter = new THREE.Vector4(0, 0, 0, 0);
      var xml = null;
      var ap = null; // update atoms in cml

      complex.forEachAtom(function (atom) {
        if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
          xml = atom.xmlNodeRef.xmlNode;
          ap = atom.position;
          v4.set(ap.x, ap.y, ap.z, 1.0);
          v4.applyMatrix4(mat);
          xml.setAttribute('x3', v4.x.toString());
          xml.setAttribute('y3', v4.y.toString());
          xml.setAttribute('z3', v4.z.toString());
          xml.removeAttribute('x2');
          xml.removeAttribute('y2');
        }
      }); // update stereo groups in cml

      complex.forEachSGroup(function (sGroup) {
        if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
          xml = sGroup.xmlNodeRef.xmlNode;
          ap = sGroup.getPosition();
          v4.set(ap.x, ap.y, ap.z, 1.0);
          var cp = sGroup.getCentralPoint();

          if (cp === null) {
            v4.applyMatrix4(mat);
          } else {
            vCenter.set(cp.x, cp.y, cp.z, 0.0);
            v4.add(vCenter);
            v4.applyMatrix4(mat); // pos in global space

            vCenter.set(cp.x, cp.y, cp.z, 1.0);
            vCenter.applyMatrix4(mat);
            v4.sub(vCenter);
          }

          xml.setAttribute('x', v4.x.toString());
          xml.setAttribute('y', v4.y.toString());
          xml.setAttribute('z', v4.z.toString());
        }
      });
    }

    var visual = self._getComplexVisual();

    var complex = visual ? visual.getComplex() : null;

    if (complex && complex.originalCML) {
      updateCMLData(complex); // serialize xml structure to string

      var oSerializer = new XMLSerializer();
      return oSerializer.serializeToString(complex.originalCML);
    }

    return null;
  };
  /**
   * Reproduce the RCSB PDB Molecule of the Month style by David S. Goodsell
   *
   * @see http://pdb101.rcsb.org/motm/motm-about
   */


  Miew.prototype.motm = function () {
    settings.set({
      fogColorEnable: true,
      fogColor: 0x000000,
      outline: {
        on: true,
        threshold: 0.01
      },
      bg: {
        color: 0xffffff
      }
    });

    this._forEachComplexVisual(function (visual) {
      var rep = [];
      var complex = visual.getComplex();
      var palette = palettes.get(settings.now.palette);

      for (var i = 0; i < complex.getChainCount(); i++) {
        var curChainName = complex._chains[i]._name;
        var curChainColor = palette.getChainColor(curChainName);
        rep[i] = {
          selector: "chain ".concat(curChainName),
          mode: 'VW',
          colorer: ['CB', {
            color: curChainColor,
            factor: 0.9
          }],
          material: 'FL'
        };
      }

      visual.resetReps(rep);
    });
  };

  Miew.prototype.VERSION =  "0.9.0+20230822.103925.6b542ed" ; // Uncomment this to get debug trace:
  // Miew.prototype.debugTracer = new utils.DebugTracer(Miew.prototype);

  ___default['default'].assign(Miew,
  /** @lends Miew */
  {
    VERSION: Miew.prototype.VERSION,
    registeredPlugins: [],
    // export namespaces // TODO: WIP: refactoring external interface
    chem: chem,
    io: io,
    modes: modes,
    colorers: colorers,
    materials: materials,
    palettes: palettes,
    options: options,
    settings: settings,
    utils: utils,
    gfx: {
      Representation: Representation
    },

    /**
     * Third-party libraries packaged together with Miew.
     *
     * @property {object} lodash - [Lodash](https://lodash.com/), a modern JavaScript utility library delivering
     *   modularity, performance & extras.
     * @property {object} three - [three.js](https://threejs.org/), JavaScript 3D library.
     *
     * @example
     * var _ = Miew.thirdParty.lodash;
     * var opts = _.merge({ ... }, Miew.options.fromURL(window.location.search));
     * var miew = new Miew(opts);
     */
    thirdParty: {
      lodash: ___default['default'],
      three: THREE__namespace
    }
  });

  /* eslint-disable */
  // DO NOT EDIT! Automatically generated from .jison
  /* parser generated by jison 0.4.18 */
  /*
    Returns a Parser object of the following structure:

    Parser: {
      yy: {}
    }

    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),

          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },

          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }


    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }


    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser$1 = (function(){
  var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,60],$V1=[1,62],$V2=[1,63],$V3=[1,65],$V4=[1,66],$V5=[1,67],$V6=[1,68],$V7=[1,69],$V8=[1,80],$V9=[1,72],$Va=[1,73],$Vb=[1,74],$Vc=[1,75],$Vd=[1,99],$Ve=[1,76],$Vf=[1,100],$Vg=[1,79],$Vh=[1,51],$Vi=[1,81],$Vj=[1,82],$Vk=[1,84],$Vl=[1,83],$Vm=[1,85],$Vn=[1,96],$Vo=[1,97],$Vp=[1,98],$Vq=[1,86],$Vr=[1,87],$Vs=[1,64],$Vt=[1,70],$Vu=[1,71],$Vv=[1,77],$Vw=[1,78],$Vx=[1,53],$Vy=[1,54],$Vz=[1,55],$VA=[1,61],$VB=[1,88],$VC=[1,89],$VD=[1,90],$VE=[1,91],$VF=[1,92],$VG=[1,93],$VH=[1,94],$VI=[1,95],$VJ=[1,101],$VK=[1,102],$VL=[1,103],$VM=[1,104],$VN=[1,105],$VO=[1,56],$VP=[1,57],$VQ=[1,58],$VR=[1,59],$VS=[1,115],$VT=[1,111],$VU=[1,114],$VV=[1,112],$VW=[1,113],$VX=[1,118],$VY=[1,117],$VZ=[1,134],$V_=[1,149],$V$=[1,150],$V01=[1,157],$V11=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],$V21=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,71,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],$V31=[5,6,7,9,13,15,17,18,19,20,23,25,26,27,30,33,34,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,82,83,84,85,86,87,88,89,90,91,92,93,94,95],$V41=[5,70,72],$V51=[5,74],$V61=[71,101];
  var parser = {trace: function trace () { },
  yy: {},
  symbols_: {"error":2,"Program":3,"Command":4,"EOF":5,"RESET":6,"BUILD":7,"ALL":8,"HELP":9,"Path":10,"MOTM":11,"OneArgCommand":12,"GET":13,"STRING":14,"SET":15,"Value":16,"SET_SAVE":17,"SET_RESTORE":18,"SET_RESET":19,"PRESET":20,"AddRepresentation":21,"EditRepresentation":22,"REMOVE":23,"RepresentationReference":24,"HIDE":25,"SHOW":26,"LIST":27,"EXPAND_KEY":28,"SELECTOR_KEY":29,"SELECT":30,"AS":31,"WordAll":32,"SELECTOR":33,"WITHIN":34,"NUMBER":35,"OF":36,"MATERIAL":37,"IDENTIFIER":38,"ModeCMD":39,"ColorCMD":40,"VIEW":41,"BASE_64":42,"UNIT":43,"DSSP":44,"SCALE":45,"ROTATE":46,"AxesList":47,"TRANSLATE":48,"CENTER":49,"GetURLBranch":50,"Screenshot":51,"LINE":52,"ArgList":53,"LISTOBJ":54,"REMOVEOBJ":55,"URL":56,"VIEW_KEY":57,"SCREENSHOT":58,"LOAD":59,"Url":60,"FILE_KEY":61,"ADD":62,"Description":63,"REP":64,"MODE":65,"COLOR":66,"Descriptor":67,"RepresentationOwnProperty":68,"RepresentationOwnPropertyOpts":69,"DESC_KEY":70,"=":71,"DESC_KEY_OPTS":72,"AxesArg":73,"DESC_KEY_AXES":74,"Arg":75,"PathWoDescKey":76,"HEX":77,"BOOL":78,"Word":79,"CommandSetWoDESC_KEY":80,"DescKeys":81,"CLEAR":82,"FILE_LIST":83,"FILE_REGISTER":84,"FILE_DELETE":85,"PRESET_ADD":86,"PRESET_DELETE":87,"PRESET_UPDATE":88,"PRESET_RENAME":89,"PRESET_OPEN":90,"CREATE_SCENARIO":91,"RESET_SCENARIO":92,"DELETE_SCENARIO":93,"ADD_SCENARIO_ITEM":94,"LIST_SCENARIO":95,"PDB_KEY":96,"DELAY_KEY":97,"PRST_KEY":98,"DESCRIPTION_KEY":99,"CommandSet":100,".":101,"PresetPath":102,"/":103,"HexOrNumber":104,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",6:"RESET",7:"BUILD",8:"ALL",9:"HELP",11:"MOTM",13:"GET",14:"STRING",15:"SET",17:"SET_SAVE",18:"SET_RESTORE",19:"SET_RESET",20:"PRESET",23:"REMOVE",25:"HIDE",26:"SHOW",27:"LIST",28:"EXPAND_KEY",29:"SELECTOR_KEY",30:"SELECT",31:"AS",33:"SELECTOR",34:"WITHIN",35:"NUMBER",36:"OF",37:"MATERIAL",38:"IDENTIFIER",41:"VIEW",42:"BASE_64",43:"UNIT",44:"DSSP",45:"SCALE",46:"ROTATE",48:"TRANSLATE",49:"CENTER",52:"LINE",54:"LISTOBJ",55:"REMOVEOBJ",56:"URL",57:"VIEW_KEY",58:"SCREENSHOT",59:"LOAD",61:"FILE_KEY",62:"ADD",64:"REP",65:"MODE",66:"COLOR",70:"DESC_KEY",71:"=",72:"DESC_KEY_OPTS",74:"DESC_KEY_AXES",77:"HEX",78:"BOOL",82:"CLEAR",83:"FILE_LIST",84:"FILE_REGISTER",85:"FILE_DELETE",86:"PRESET_ADD",87:"PRESET_DELETE",88:"PRESET_UPDATE",89:"PRESET_RENAME",90:"PRESET_OPEN",91:"CREATE_SCENARIO",92:"RESET_SCENARIO",93:"DELETE_SCENARIO",94:"ADD_SCENARIO_ITEM",95:"LIST_SCENARIO",96:"PDB_KEY",97:"DELAY_KEY",98:"PRST_KEY",99:"DESCRIPTION_KEY",101:".",103:"/"},
  productions_: [0,[3,2],[3,1],[4,1],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,3],[4,3],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,2],[4,4],[4,2],[4,6],[4,2],[4,1],[4,1],[4,1],[4,2],[4,2],[4,1],[4,2],[4,1],[4,2],[4,2],[4,2],[4,1],[4,2],[4,1],[4,1],[4,3],[4,3],[4,4],[4,4],[4,1],[4,2],[50,1],[50,2],[50,2],[50,3],[50,3],[51,1],[51,2],[51,3],[12,2],[12,2],[12,2],[21,1],[21,2],[21,2],[21,3],[22,2],[22,3],[39,2],[39,3],[40,2],[40,3],[24,1],[24,1],[63,1],[63,2],[63,3],[63,4],[67,1],[67,1],[67,2],[68,3],[69,3],[47,1],[47,2],[73,2],[53,1],[53,2],[75,3],[16,1],[16,1],[16,1],[16,1],[16,1],[79,1],[79,1],[32,1],[32,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[100,1],[100,1],[76,1],[76,3],[76,3],[10,1],[10,1],[10,3],[10,3],[10,3],[60,1],[102,1],[102,3],[104,1],[104,1]],
  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
  /* this == yyval */

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1:
   return $$[$0-1]; 
  case 3:
  this.$ = yy.miew.reset(false); yy.ClearContext(); yy.miew.resetReps("empty");
  break;
  case 4:
  this.$ = yy.miew.rebuild();
  break;
  case 5:
  this.$ = yy.miew.rebuildAll(); yy.miew.rebuild();
  break;
  case 6:
  this.$ = yy.echo(yy.utils.help().toString());
  break;
  case 7:
  this.$ = yy.echo(yy.utils.help($$[$0]).toString());
  break;
  case 8:
  this.$ = yy.miew.motm();
  break;
  case 10: case 11:
  this.$ = yy.utils.propagateProp($$[$0]); yy.echo(yy.miew.get($$[$0]).toString());
  break;
  case 12: case 13:
  this.$ = yy.miew.set($$[$0-1], yy.utils.propagateProp($$[$0-1], $$[$0]));break;
  case 14:
  this.$ = yy.miew.saveSettings();break;
  case 15:
  this.$ = yy.miew.restoreSettings();break;
  case 16:
  this.$ = yy.miew.resetSettings();break;
  case 17:
  this.$ = yy.miew.resetReps();
  break;
  case 18:
  this.$ = yy.miew.applyPreset($$[$0]);
  break;
  case 21:
  this.$ = yy.miew.repRemove($$[$0]); yy.representations.remove($$[$0]);
  break;
  case 22:
  this.$ = yy.miew.repHide($$[$0]);
  break;
  case 23:
  this.$ = yy.miew.repHide($$[$0], false);
  break;
  case 24:
  this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e'));
  break;
  case 25:
  this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
  break;
  case 26:
  this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
  break;
  case 27:
  this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
  break;
  case 28:
  this.$ = yy.miew.select(yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0], true));
  break;
  case 29:
  this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0-3].toLowerCase(), $$[$0-2], true); yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
  break;
  case 30:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {selector : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0])});
  break;
  case 31:
  this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0-2], true), Number($$[$0-4]));
  break;
  case 32:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {material : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 35:
  this.$ = yy.echo(yy.miew.view());
  break;
  case 36: case 37:
  this.$ = yy.miew.view($$[$0]);
  break;
  case 38:
  this.$ = yy.echo(yy.miew.changeUnit());
  break;
  case 39:
  this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
  break;
  case 40:
  this.$ = yy.miew.dssp();
  break;
  case 41:
  this.$ = yy.miew.scale($$[$0]);
  break;
  case 42:
   for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.rotate($$[$0][i]['x'] * Math.PI / 180.0, $$[$0][i]['y'] * Math.PI / 180.0, $$[$0][i]['z'] * Math.PI / 180.0);} 
  break;
  case 43:
   for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.translate($$[$0][i]['x'] || 0, $$[$0][i]['y'] || 0, $$[$0][i]['z'] || 0);} 
  break;
  case 44:
  this.$ = yy.miew.center();
  break;
  case 45:
  this.$ = yy.miew.center($$[$0]);
  break;
  case 48: case 49:
  this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-1], $$[$0]]}, true);
  break;
  case 50: case 51:
  this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-2], $$[$0-1]], opts:$$[$0].toJSO(yy.utils, 'objects', 'line')}, true);
  break;
  case 52:
  this.$ = yy.echo(yy.utils.listObjs(yy.miew));
  break;
  case 53:
  this.$ = yy.miew.removeObject($$[$0]);
  break;
  case 54:
  this.$ = yy.echo(yy.miew.getURL({view: false, settings: false}));
  break;
  case 55:
  this.$ = yy.echo(yy.miew.getURL({view: false, settings: true}));
  break;
  case 56:
  this.$ = yy.echo(yy.miew.getURL({view: true,  settings: false}));
  break;
  case 57: case 58:
  this.$ = yy.echo(yy.miew.getURL({view: true,  settings: true}));
  break;
  case 59:
  this.$ = yy.miew.screenshotSave();
  break;
  case 60:
  this.$ = yy.miew.screenshotSave('', Number($$[$0]));
  break;
  case 61:
  this.$ = yy.miew.screenshotSave('', Number($$[$0-1]), Number($$[$0]));
  break;
  case 62: case 63: case 64:
  this.$ = yy.utils.load(yy.miew, $$[$0]); yy.representations.clear();
  break;
  case 65:
  this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
  break;
  case 66:
  this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
  break;
  case 67:
  this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
  break;
  case 68:
  this.$ = yy.echo(yy.representations.add($$[$0-1], yy.miew.repAdd($$[$0])));
  break;
  case 69:
  this.$ = yy.miew.rep($$[$0]); yy.miew.repCurrent($$[$0]);
  break;
  case 70:
  this.$ = yy.miew.rep($$[$0-1], $$[$0]); yy.miew.repCurrent($$[$0-1]);
  break;
  case 71:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 72:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
  break;
  case 73:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 74:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
  break;
  case 75:
  this.$ = Number(yy.representations.get($$[$0]));
  break;
  case 76: case 92:
  this.$ = Number($$[$0]);
  break;
  case 77:
  this.$ = $$[$0];
  break;
  case 78:
  this.$ = yy._.assign($$[$0-1], $$[$0]);
  break;
  case 79:
  this.$ = yy._.assign($$[$0-2], $$[$0-1], $$[$0]);
  break;
  case 80:
  this.$ = yy._.assign($$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);
  break;
  case 81: case 82:
  this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
  break;
  case 83:
  this.$ = yy.CreateObjectPair($$[$0-1].key, new Array($$[$0-1].val, $$[$0].toJSO(yy.utils, $$[$0-1].key, $$[$0-1].val)));
  break;
  case 84: case 85:
  this.$ = Object.create({'key': yy.keyRemap($$[$0-2]), 'val': yy.utils.checkArg($$[$0-2], $$[$0])});
  break;
  case 86:
  this.$ = [$$[$0]];
  break;
  case 87:
  this.$ = $$[$0-1].concat($$[$0]);
  break;
  case 88:
  this.$ = yy.CreateObjectPair($$[$0-1].toLowerCase(), Number($$[$0]));
  break;
  case 89:
  this.$ = new yy.ArgList($$[$0]);
  break;
  case 90:
  this.$ = $$[$0-1].append($$[$0]);
  break;
  case 91:
  this.$ = new yy.Arg($$[$0-2], $$[$0]);
  break;
  case 93:
  this.$ = parseInt($$[$0]);
  break;
  case 94:
  this.$ = JSON.parse($$[$0]);
  break;
  case 95: case 96:
  this.$ = String($$[$0]);
  break;
  case 157: case 158: case 161: case 162: case 163:
  this.$ = $$[$0-2] + $$[$0-1] + $$[$0]; //cause of could be color word in path;
  break;
  case 166:
  this.$ = $$[$0-2] = $$[$0-2] + $$[$0-1] + $$[$0];
  break;
  }
  },
  table: [{3:1,4:2,5:[1,3],6:[1,4],7:[1,5],9:[1,6],11:[1,7],12:8,13:[1,9],15:[1,10],17:[1,11],18:[1,12],19:[1,13],20:[1,14],21:15,22:16,23:[1,17],25:[1,18],26:[1,19],27:[1,20],30:[1,21],33:[1,22],34:[1,23],37:[1,24],39:25,40:26,41:[1,27],43:[1,28],44:[1,29],45:[1,30],46:[1,31],48:[1,32],49:[1,33],50:34,51:35,52:[1,36],54:[1,37],55:[1,38],56:[1,44],58:[1,45],59:[1,39],62:[1,40],64:[1,41],65:[1,42],66:[1,43]},{1:[3]},{5:[1,46]},{1:[2,2]},{5:[2,3]},{5:[2,4],8:[1,47]},{5:[2,6],6:$V0,7:$V1,9:$V2,10:48,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,8]},{5:[2,9]},{6:$V0,7:$V1,9:$V2,10:106,13:$V3,14:[1,107],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{6:$V0,7:$V1,9:$V2,10:108,13:$V3,14:[1,109],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,14]},{5:[2,15]},{5:[2,16]},{5:[2,17],14:$VS,16:110,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,19]},{5:[2,20]},{24:116,35:$VX,38:$VY},{24:119,35:$VX,38:$VY},{24:120,35:$VX,38:$VY},{5:[2,25],24:121,28:[1,122],29:[1,123],35:$VX,38:$VY},{14:[1,124]},{14:[1,125]},{35:[1,126]},{38:[1,127]},{5:[2,33]},{5:[2,34]},{5:[2,35],14:[1,128],42:[1,129]},{5:[2,38],35:[1,130]},{5:[2,40]},{35:[1,131]},{47:132,73:133,74:$VZ},{47:135,73:133,74:$VZ},{5:[2,44],14:[1,136]},{5:[2,46]},{5:[2,47]},{6:$V0,7:$V1,9:$V2,10:138,13:$V3,14:[1,137],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,52]},{35:[1,139]},{14:[1,143],38:[1,141],60:140,61:[1,142]},{5:[2,65],38:[1,144],63:145,67:146,68:147,69:148,70:$V_,72:$V$},{24:151,35:$VX,38:$VY},{38:[1,152]},{38:[1,153]},{5:[2,54],29:[1,154],57:[1,155]},{5:[2,59],35:[1,156]},{1:[2,1]},{5:[2,5]},{5:[2,7],101:$V01},o($V11,[2,159]),o($V11,[2,160]),o($V21,[2,97]),o($V21,[2,98]),o($V11,[2,147]),o($V11,[2,148]),o($V11,[2,149]),o($V11,[2,150]),o($V11,[2,151]),o($V11,[2,152]),o($V11,[2,153]),o($V21,[2,101]),o($V21,[2,102]),o($V21,[2,103]),o($V21,[2,104]),o($V21,[2,105]),o($V21,[2,106]),o($V21,[2,107]),o($V21,[2,108]),o($V21,[2,109]),o($V21,[2,110]),o($V21,[2,111]),o($V21,[2,112]),o($V21,[2,113]),o($V21,[2,114]),o($V21,[2,115]),o($V21,[2,116]),o($V21,[2,117]),o($V21,[2,118]),o($V21,[2,119]),o($V21,[2,120]),o($V21,[2,121]),o($V21,[2,122]),o($V21,[2,123]),o($V21,[2,124]),o($V21,[2,125]),o($V21,[2,126]),o($V21,[2,127]),o($V21,[2,128]),o($V21,[2,129]),o($V21,[2,130]),o($V21,[2,131]),o($V21,[2,132]),o($V21,[2,133]),o($V21,[2,134]),o($V21,[2,135]),o($V21,[2,136]),o($V21,[2,137]),o($V21,[2,138]),o($V21,[2,139]),o($V21,[2,140]),o($V21,[2,141]),o($V21,[2,142]),o($V21,[2,143]),o($V21,[2,144]),o($V21,[2,145]),o($V21,[2,146]),{5:[2,10],101:$V01},{5:[2,11]},{14:$VS,16:158,35:$VT,38:$VU,77:$VV,78:$VW,101:$V01},{14:$VS,16:159,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,18]},o($V31,[2,92]),o($V31,[2,93]),o($V31,[2,94]),o($V31,[2,95]),o($V31,[2,96]),{5:[2,21]},o($V41,[2,75]),o($V41,[2,76]),{5:[2,22]},{5:[2,23]},{5:[2,24]},{5:[2,26]},{5:[2,27]},{5:[2,28],31:[1,160]},{5:[2,30]},{36:[1,161]},{5:[2,32]},{5:[2,36]},{5:[2,37]},{5:[2,39]},{5:[2,41]},{5:[2,42],73:162,74:$VZ},o($V51,[2,86]),{35:[1,163]},{5:[2,43],73:162,74:$VZ},{5:[2,45]},{14:[1,164]},{6:$V0,7:$V1,9:$V2,10:165,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR,101:$V01},{5:[2,53]},{5:[2,62]},{5:[2,63]},{5:[2,64]},{5:[2,164]},{5:[2,66],63:166,67:146,68:147,69:148,70:$V_,72:$V$},{5:[2,67]},{5:[2,77],67:167,68:147,69:148,70:$V_,72:$V$},o($V41,[2,81]),o($V41,[2,82],{80:52,53:168,75:169,76:170,79:171,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN}),{71:[1,172]},{71:[1,173]},{5:[2,69],63:174,67:146,68:147,69:148,70:$V_,72:$V$},{5:[2,71],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:175,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,73],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:176,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,55],57:[1,177]},{5:[2,56],29:[1,178]},{5:[2,60],35:[1,179]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,181],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:180,80:52,81:182,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,12]},{5:[2,13]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:183,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:184,80:52,81:185,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{14:[1,186]},o($V51,[2,87]),o($V51,[2,88]),{5:[2,48],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:187,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,49],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:188,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,101:$V01},{5:[2,68]},{5:[2,78],67:189,68:147,69:148,70:$V_,72:$V$},o($V41,[2,83],{80:52,76:170,79:171,75:190,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN}),o($V31,[2,89]),{71:[1,191],101:[1,192]},o($V61,[2,156]),{14:$VS,16:193,35:$VT,38:$VU,77:$VV,78:$VW},{14:$VS,16:194,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,70]},{5:[2,72],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,74],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,57]},{5:[2,58]},{5:[2,61]},o($V11,[2,161]),o($V11,[2,162]),o($V11,[2,163]),{5:[2,29]},{5:[2,99]},{5:[2,100]},{31:[1,195]},{5:[2,50],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,51],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,79],67:196,68:147,69:148,70:$V_,72:$V$},o($V31,[2,90]),{14:$VS,16:197,35:$VT,38:$VU,77:$VV,78:$VW},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,199],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,79:198,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},o($V41,[2,84]),o($V31,[2,85]),{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:200,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:184,80:52,81:185,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,80]},o($V31,[2,91]),o($V61,[2,157]),o($V61,[2,158]),{5:[2,31]}],
  defaultActions: {3:[2,2],4:[2,3],7:[2,8],8:[2,9],11:[2,14],12:[2,15],13:[2,16],15:[2,19],16:[2,20],25:[2,33],26:[2,34],29:[2,40],34:[2,46],35:[2,47],37:[2,52],46:[2,1],47:[2,5],107:[2,11],110:[2,18],116:[2,21],119:[2,22],120:[2,23],121:[2,24],122:[2,26],123:[2,27],125:[2,30],127:[2,32],128:[2,36],129:[2,37],130:[2,39],131:[2,41],136:[2,45],139:[2,53],140:[2,62],141:[2,63],142:[2,64],143:[2,164],145:[2,67],158:[2,12],159:[2,13],166:[2,68],174:[2,70],177:[2,57],178:[2,58],179:[2,61],183:[2,29],184:[2,99],185:[2,100],196:[2,80],200:[2,31]},
  parseError: function parseError (str, hash) {
      if (hash.recoverable) {
          this.trace(str);
      } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
      }
  },
  parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
              sharedState.yy[k] = this.yy[k];
          }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
      } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
      }
              function lex() {
              var token;
              token = tstack.pop() || lexer.lex() || EOF;
              if (typeof token !== 'number') {
                  if (token instanceof Array) {
                      tstack = token;
                      token = tstack.pop();
                  }
                  token = self.symbols_[token] || token;
              }
              return token;
          }
      var symbol, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == 'undefined') {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === 'undefined' || !action.length || !action[0]) {
              var errStr = '';
              expected = [];
              for (p in table[state]) {
                  if (this.terminals_[p] && p > TERROR) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                  }
              }
              if (lexer.showPosition) {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
              } else {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
              }
              this.parseError(errStr, {
                  text: lexer.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer.yylineno,
                  loc: yyloc,
                  expected: expected
              });
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                  yyleng = lexer.yyleng;
                  yytext = lexer.yytext;
                  yylineno = lexer.yylineno;
                  yyloc = lexer.yylloc;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                  yyval._$.range = [
                      lstack[lstack.length - (len || 1)].range[0],
                      lstack[lstack.length - 1].range[1]
                  ];
              }
              r = this.performAction.apply(yyval, [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
              ].concat(args));
              if (typeof r !== 'undefined') {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }};


  /* generated by jison-lex 0.3.4 */
  var lexer = (function(){
  var lexer = ({

  EOF:1,

  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },

  // resets the lexer, sets new input
  setInput:function (input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
          };
          if (this.options.ranges) {
              this.yylloc.range = [0,0];
          }
          this.offset = 0;
          return this;
      },

  // consumes and returns one char from the input
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) {
              this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
      },

  // unshifts one char (or a string) into the input
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
              this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;

          this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ?
                  (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                   + oldLines[oldLines.length - lines.length].length - lines[0].length :
                this.yylloc.first_column - len
          };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
      },

  // When called from action, caches matched text and appends it on next action
  more:function () {
          this._more = true;
          return this;
      },

  // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
  reject:function () {
          if (this.options.backtrack_lexer) {
              this._backtrack = true;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });

          }
          return this;
      },

  // retain first n characters of the match
  less:function (n) {
          this.unput(this.match.slice(n));
      },

  // displays already matched input, i.e. for error messages
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },

  // displays upcoming input, i.e. for error messages
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },

  // displays the character position where the lexing error occurred, i.e. for error messages
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
      },

  // test the lexed token: return FALSE when not a match, otherwise return token
  test_match:function(match, indexed_rule) {
          var token,
              lines,
              backup;

          if (this.options.backtrack_lexer) {
              // save context
              backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
              };
              if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
              }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno += lines.length;
          }
          this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ?
                           lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                           this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
              this.done = false;
          }
          if (token) {
              return token;
          } else if (this._backtrack) {
              // recover context
              for (var k in backup) {
                  this[k] = backup[k];
              }
              return false; // rule action called reject() implying the next rule should be tested instead.
          }
          return false;
      },

  // return next match in input
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) {
              this.done = true;
          }

          var token,
              match,
              tempMatch,
              index;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (this.options.backtrack_lexer) {
                      token = this.test_match(tempMatch, rules[i]);
                      if (token !== false) {
                          return token;
                      } else if (this._backtrack) {
                          match = false;
                          continue; // rule action called reject() implying a rule MISmatch.
                      } else {
                          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                          return false;
                      }
                  } else if (!this.options.flex) {
                      break;
                  }
              }
          }
          if (match) {
              token = this.test_match(match, rules[index]);
              if (token !== false) {
                  return token;
              }
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });
          }
      },

  // return next match that has a token
  lex:function lex () {
          var r = this.next();
          if (r) {
              return r;
          } else {
              return this.lex();
          }
      },

  // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
  begin:function begin (condition) {
          this.conditionStack.push(condition);
      },

  // pop the previously active lexer condition state off the condition stack
  popState:function popState () {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
              return this.conditionStack.pop();
          } else {
              return this.conditionStack[0];
          }
      },

  // produce the lexer rule set which is active for the currently active lexer condition state
  _currentRules:function _currentRules () {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
              return this.conditions["INITIAL"].rules;
          }
      },

  // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
  topState:function topState (n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
              return this.conditionStack[n];
          } else {
              return "INITIAL";
          }
      },

  // alias for begin(condition)
  pushState:function pushState (condition) {
          this.begin(condition);
      },

  // return the number of states currently on the stack
  stateStackSize:function stateStackSize() {
          return this.conditionStack.length;
      },
  options: {"case-insensitive":true},
  performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
  switch($avoiding_name_collisions) {
  case 0:/* ignore whitespace */
  break;
  case 1:return '';
  case 2:return '';
  case 3:return 42;
  case 4:return 35;
  case 5:return 77;
  case 6:return 78;
  case 7:return 78;
  case 8:return 8;
  case 9:return 6;
  case 10:return 82;
  case 11:return 7;
  case 12:return 9;
  case 13:return 59;
  case 14:return 13
  case 15:return 15
  case 16:return 17
  case 17:return 18
  case 18:return 19
  case 19:return 20
  case 20:return 11
  case 21:return 62
  case 22:return 64
  case 23:return 23
  case 24:return 25
  case 25:return 26
  case 26:return 27
  case 27:return 30
  case 28:return 34
  case 29:return 33
  case 30:return 65
  case 31:return 66
  case 32:return 37
  case 33:return 41
  case 34:return 43
  case 35:return 52
  case 36:return 54
  case 37:return 55
  case 38:return 46
  case 39:return 48
  case 40:return 45
  case 41:return 49
  case 42:return 56
  case 43:return 58;
  case 44:return 44
  case 45:return 83
  case 46:return 84
  case 47:return 85
  case 48:return 86
  case 49:return 87
  case 50:return 88
  case 51:return 89
  case 52:return 90
  case 53:return 91
  case 54:return 92
  case 55:return 93
  case 56:return 94
  case 57:return 95
  case 58:return 70
  case 59:return 70
  case 60:return 72
  case 61:return 72
  case 62:return 74
  case 63:return 74
  case 64:return 74
  case 65:return 31
  case 66:return 36
  case 67:return 96
  case 68:return 97
  case 69:return 98
  case 70:return 99
  case 71:yy_.yytext = yy.utils.unquoteString(yy_.yytext); return 14;
  case 72:return 38;
  case 73:return 5;
  case 74:return 101;
  case 75:return 103;
  case 76:return '\\';
  case 77:return 28
  case 78:return 61
  case 79:return 29
  case 80:return 57
  case 81:return 71
  }
  },
  rules: [/^(?:\s+)/i,/^(?:[#].*)/i,/^(?:\/\/.*)/i,/^(?:([_A-Z0-9\/\+]+==))/i,/^(?:-?[0-9]+(\.[0-9]+)?\b)/i,/^(?:0[xX][0-9A-F]+\b)/i,/^(?:false\b)/i,/^(?:true\b)/i,/^(?:all\b)/i,/^(?:reset\b)/i,/^(?:clear\b)/i,/^(?:build\b)/i,/^(?:help\b)/i,/^(?:load\b)/i,/^(?:get\b)/i,/^(?:set\b)/i,/^(?:set_save\b)/i,/^(?:set_restore\b)/i,/^(?:set_reset\b)/i,/^(?:preset\b)/i,/^(?:motm\b)/i,/^(?:add\b)/i,/^(?:rep\b)/i,/^(?:remove\b)/i,/^(?:hide\b)/i,/^(?:show\b)/i,/^(?:list\b)/i,/^(?:select\b)/i,/^(?:within\b)/i,/^(?:selector\b)/i,/^(?:mode\b)/i,/^(?:color\b)/i,/^(?:material\b)/i,/^(?:view\b)/i,/^(?:unit\b)/i,/^(?:line\b)/i,/^(?:listobj\b)/i,/^(?:removeobj\b)/i,/^(?:rotate\b)/i,/^(?:translate\b)/i,/^(?:scale\b)/i,/^(?:center\b)/i,/^(?:url\b)/i,/^(?:screenshot\b)/i,/^(?:dssp\b)/i,/^(?:file_list\b)/i,/^(?:file_register\b)/i,/^(?:file_delete\b)/i,/^(?:preset_add\b)/i,/^(?:preset_delete\b)/i,/^(?:preset_update\b)/i,/^(?:preset_rename\b)/i,/^(?:preset_open\b)/i,/^(?:create_scenario\b)/i,/^(?:reset_scenario\b)/i,/^(?:delete_scenario\b)/i,/^(?:add_scenario_item\b)/i,/^(?:list_scenario\b)/i,/^(?:s\b)/i,/^(?:mt\b)/i,/^(?:m\b)/i,/^(?:c\b)/i,/^(?:x\b)/i,/^(?:y\b)/i,/^(?:z\b)/i,/^(?:as\b)/i,/^(?:of\b)/i,/^(?:pdb\b)/i,/^(?:delay\b)/i,/^(?:prst\b)/i,/^(?:desc\b)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:\.)/i,/^(?:\/)/i,/^(?:\\)/i,/^(?:-e\b)/i,/^(?:-f\b)/i,/^(?:-s\b)/i,/^(?:-v\b)/i,/^(?:=)/i],
  conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],"inclusive":true}}
  });
  return lexer;
  })();
  parser.lexer = lexer;
  function Parser () {
    this.yy = {};
  }
  Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();

  var MiewCLIParser = {parser: parser$1};
  var MiewCLIParser_1 = MiewCLIParser.parser;

  var modeIdDesc = {
    $help: ['Rendering mode shortcut', '    BS - balls and sticks mode', '    LN - lines mode', '    LC - licorice mode', '    VW - van der waals mode', '    TR - trace mode', '    TU - tube mode', '    CA - cartoon mode', '    SA - isosurface mode', '    QS - quick surface mode', '    SE - solvent excluded mode', '    TX - text mode'],
    BS: {
      $help: ['   Balls and sticks', '      aromrad = <number> #aromatic radius', '      atom = <number>    #atom radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    CA: {
      $help: ['   Cartoon', '      arrow = <number>   #arrow size', '      depth = <number>   #depth of surface', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> #', '      width = <number>  #secondary width\n']
    },
    LN: {
      $help: ['   Lines', '      atom = <number>    #atom radius', '      chunkarom = <number>', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      offsarom = <number>\n']
    },
    LC: {
      $help: ['   Licorice', '      aromrad = <number> #aromatic radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    VW: {
      $help: ['   Van der Waals', '      nothing\n']
    },
    TR: {
      $help: ['   Trace', '      radius = <number>  #tube radius\n']
    },
    TU: {
      $help: ['   Tube', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> \n']
    },
    SA: {
      $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
    },
    QS: {
      $help: ['   Quick surface', '      isoValue = <number>', '      scale = <number>', '      wireframe = <bool>', '      zClip = <bool> #clip z plane\n']
    },
    SE: {
      $help: ['   Solvent excluded surface', '      zClip = <bool> #clip z plane\n']
    },
    TX: {
      $help: ['   Text mode', '      template = <format string> string that can include "{{ id }}"', '          it will be replaced by value, id can be one of next:', '          serial, name, type, sequence, residue, chain, hetatm, water\n', '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', '      dx = <number> #offset along x', '      dy = <number> #offset along y', '      dz = <number> #offset along z', '      fg = <string> #text color modificator', '           could be keyword, named color or hex', '      fg = <string> #back color modificator', '           could be keyword, named color or hex', '      showBg = <bool> #if set show background', '           plate under text']
    }
  };
  var colorDesc = {
    $help: ['Coloring mode shortcut', '    EL - color by element', '    CH - color by chain', '    SQ - color by sequence', '    RT - color by residue type', '    SS - color by secondary structure', '    UN - uniform'],
    UN: {
      $help: ['Parameters of coloring modes customization', '   Uniform', '      color = <number|color> #RGB->HEX->dec\n'],
      color: {
        $help: Object.keys(palettes.get(settings.now.palette).namedColors).sort().join('\n')
      }
    }
  };
  var materialDesc = {
    $help: ['Material shortcut', '    DF - diffuse', '    TR - transparent', '    SF - soft plastic', '    PL - glossy plastic', '    ME - metal', '    GL - glass']
  };
  var addRepDesc = {
    $help: ['Short (packed) representation description as a set of variables', '    s=<EXPRESSION>', '        selector property', '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]', '        render mode property', '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]', '        color mode property', '    mt=<MATERIAL_ID>', '        material property'],
    s: {
      $help: 'Selection expression string as it is in menu->representations->selection'
    },
    m: modeIdDesc,
    c: colorDesc,
    mt: materialDesc
  };
  var setGetParameterDesc = {
    $help: ['Parameters of rendering modes customization: modes', 'Parameters of colorer customization: colorers', 'Autobuild: autobuild = (<number>|<bool>)'],
    modes: modeIdDesc,
    colorers: colorDesc
  };
  var help = {
    $help: ['help (<cmd name>| <path to property>)', 'You can get detailed information about command options', '   using "help cmd.opt.opt.[...]"\n', '   you can use one line comments', '   everything started from (#|//) will be skipped', '   Example: >build //some comment\n', 'List of available commands:'],
    reset: {
      $help: ['Reload current object, delete all representations', '    Nothing will work until load new object']
    },
    load: {
      $help: ['load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])', '    Load new pdb object from selected source'],
      PDBID: {
        $help: 'pdb id in remote molecule database'
      },
      URL: {
        $help: 'url to source file'
      },
      f: {
        $help: ['open file system dialog to fetch local file', 'optionally you can determine trajectory file', 'via URL for *.top model']
      }
    },
    clear: {
      $help: 'No args. Clear terminal'
    },
    add: {
      $help: ['add [<REP_NAME>] [<DESCRIPTION>]', '    Add new item to representation set with', '    default or <DESCRIPTION> params'],
      REP_NAME: {
        $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
      },
      DESCRIPTION: addRepDesc
    },
    rep: {
      $help: ['rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]', '    set current representation by name or index', '    edit current representation by <DESCRIPTION>'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      },
      DESCRIPTION: addRepDesc
    },
    remove: {
      $help: ['remove (<REP_NAME>|<REP_INDEX>)', 'Remove representation by name or index'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      }
    },
    selector: {
      $help: ['selector <EXPRESSION>', '   set selector from EXPRESSION to current representation'],
      EXPRESSION: {
        $help: 'Selection expression string as it is in menu->representations->selection'
      }
    },
    mode: {
      $help: ['mode <MODE_ID> [<PARAMETER>=<VALUE>...]', '   set rendering mode and apply parameters to current representation'],
      MODE_ID: modeIdDesc
    },
    color: {
      $help: ['color <COLORER_ID> [<PARAMETER>=<VALUE>...]', '   set colorer and apply parameters to current representation'],
      COLORER_ID: colorDesc
    },
    material: {
      $help: ['material <MATERIAL_ID>', '   set material to current representation'],
      MATERIAL_ID: materialDesc
    },
    build: {
      $help: 'build help str',
      add: {
        $help: 'build.add',
        "new": {
          $help: ['add.new', 'add.new new line 1', 'add.new new line 2', 'add.new new line 3']
        }
      },
      del: {
        $help: 'build.del'
      }
    },
    list: {
      $help: ['list [-e|-s|<REP_NAME>|<REP_INDEX>]', 'Print representations if no args print list of representations', '    -e expand list and show all representations', '    -s show all user-registered selectors', '    <REP_NAME>|<REP_INDEX> show only current representation']
    },
    hide: {
      $help: ['hide (<REP_NAME>|<REP_INDEX>)', 'Hide representation referenced in args']
    },
    show: {
      $help: ['show (<REP_NAME>|<REP_INDEX>)', 'Show representation referenced in args']
    },
    get: {
      $help: ['get <PARAMETER>', 'Print <PARAMETER> value', '    <PARAMETER> - path to option use get.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set: {
      $help: ['set <PARAMETER> <VALUE>', 'Set <PARAMETER> with <VALUE>', '    <PARAMETER> - path to option use set.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set_save: {
      $help: ['set_save', 'Save current settings to cookie']
    },
    set_restore: {
      $help: ['set_restore', 'Load and apply settings from cookie']
    },
    set_reset: {
      $help: ['set_reset', 'Reset current settings to the defaults']
    },
    preset: {
      $help: ['preset [<PRESET>]', 'Reset current representation or set preset to <PRESET>'],
      PRESET: {
        $help: ['default', 'wire', 'small', 'macro']
      }
    },
    unit: {
      $help: ['unit [<unit_id>]', 'Change current biological structure view. Zero <unit_id> value means asymmetric unit,', 'positive values set an assembly with corresponding number.', 'Being called with no parameters command prints current unit information.']
    },
    view: {
      $help: ['view [<ENCODED_VIEW>]', 'Get current encoded view or set if ENCODED_VIEW placed as argument'],
      ENCODED_VIEW: {
        $help: ['encoded view matrix string (binary code)']
      }
    },
    rotate: {
      $help: ['rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...', 'Rotate scene']
    },
    scale: {
      $help: ['scale <SCALE>', 'Scale scene']
    },
    select: {
      $help: ['select <SELECTOR_STRING> [as <SELECTOR_NAME>]', 'Select atoms using selector defined in SELECTOR_STRING', '    and if SELECTOR_NAME is defined register it in viewer', '    you can use it later as a complex selector']
    },
    within: {
      $help: ['within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>', 'Build within named selector', '    DISTANCE        <number>', '    SELECTOR_STRING <string(selection language)>', '    SELECTOR_NAME   <identifier>']
    },
    url: {
      $help: ['url [-s] [-v]', 'Report URL encoded scene', '    if -s set that include settings in the URL', '    if -v set that include view in the URL']
    },
    screenshot: {
      $help: ['screenshot [<WIDTH> [<HEIGHT>]]', 'Make a screenshot of the scene', '    WIDTH  <number> in pixels', '    HEIGHT <number> in pixels, equal to WIDTH by default']
    },
    line: {
      $help: ['line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]', 'Draw dashed line between two specified atoms']
    },
    removeobj: {
      $help: ['removeobj <id>', 'Remove scene object by its index. Indices could be obtained by <listobj> command']
    },
    listobj: {
      $help: ['listobj', 'Display the list of all existing scene objects']
    }
  };

  var selectors$5 = Miew.chem.selectors,
      modes$1 = Miew.modes,
      colorers$1 = Miew.colorers,
      materials$1 = Miew.materials,
      palettes$1 = Miew.palettes,
      options$1 = Miew.options,
      settings$1 = Miew.settings;

  function None() {}

  var NULL = function () {
    var obj = new None();
    return function () {
      return obj;
    };
  }();

  var RepresentationMap = /*#__PURE__*/function () {
    function RepresentationMap() {
      classCallCheck(this, RepresentationMap);

      this.representationMap = {};
      this.representationID = {};
    }

    createClass(RepresentationMap, [{
      key: "get",
      value: function get(strId) {
        return this.representationMap[strId] || this.representationID[strId] || '<no name>';
      }
    }, {
      key: "add",
      value: function add(strId, index) {
        if (strId === -1) {
          return 'Can not create representation: there is no data';
        }

        if (index !== undefined) {
          if (!this.representationMap.hasOwnProperty(strId)) {
            this.representationMap[strId.toString()] = index;
            this.representationID[index] = strId.toString();
          } else {
            return 'This name has already existed, registered without name';
          }
        }

        return "Representation ".concat(strId, " successfully added");
      }
    }, {
      key: "remove",
      value: function remove(index) {
        if (index && this.representationID.hasOwnProperty(index)) {
          delete this.representationMap[this.representationID[index]];
          delete this.representationID[index];
        }

        var sortedKeys = Object.keys(this.representationID).sort();

        for (var i in sortedKeys) {
          if (sortedKeys.hasOwnProperty(i)) {
            var id = sortedKeys[i];

            if (id > index) {
              this.representationID[id - 1] = this.representationID[id];
              this.representationMap[this.representationID[id]] -= 1;
              delete this.representationID[id];
            }
          }
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        this.representationMap = {};
        this.representationID = {};
      }
    }]);

    return RepresentationMap;
  }();

  var representationsStorage = new RepresentationMap();

  function keyRemap(key) {
    var keys = {
      s: 'selector',
      m: 'mode',
      c: 'colorer',
      mt: 'material',
      mode: 'modes',
      color: 'colorers',
      colorer: 'colorers',
      select: 'selector',
      material: 'materials',
      selector: 'selector'
    };
    var ans = keys[key];
    return ans === undefined ? key : ans;
  }

  var CLIUtils = /*#__PURE__*/function () {
    function CLIUtils() {
      classCallCheck(this, CLIUtils);
    }

    createClass(CLIUtils, [{
      key: "list",
      value: function list(miew, repMap, key) {
        var ret = '';

        if (miew && repMap !== undefined) {
          if (key === undefined || key === '-e') {
            var count = miew.repCount();

            for (var i = 0; i < count; i++) {
              ret += this.listRep(miew, repMap, i, key);
            }
          }
        }

        return ret;
      }
    }, {
      key: "listRep",
      value: function listRep(miew, repMap, repIndex, key) {
        var ret = '';
        var rep = miew.repGet(repIndex);

        if (!rep) {
          logger.warn("Rep ".concat(repIndex, " does not exist!"));
          return ret;
        }

        var index = repIndex;
        var repName = repMap.get(index);
        var mode = rep.mode,
            colorer = rep.colorer;
        var selectionStr = rep.selectorString;
        var material = rep.materialPreset;
        ret += "#".concat(index, " : ").concat(mode.name).concat(repName === '<no name>' ? '' : ", ".concat(repName), "\n");

        if (key !== undefined) {
          ret += "    selection : \"".concat(selectionStr, "\"\n");
          ret += "    mode      : (".concat(mode.id, "), ").concat(mode.name, "\n");
          ret += "    colorer   : (".concat(colorer.id, "), ").concat(colorer.name, "\n");
          ret += "    material  : (".concat(material.id, "), ").concat(material.name, "\n");
        }

        return ret;
      }
    }, {
      key: "listSelector",
      value: function listSelector(miew, context) {
        var ret = '';

        for (var k in context) {
          if (context.hasOwnProperty(k)) {
            ret += "".concat(k, " : \"").concat(context[k], "\"\n");
          }
        }

        return ret;
      }
    }, {
      key: "listObjs",
      value: function listObjs(miew) {
        var objs = miew._objects;

        if (!objs || !Array.isArray(objs) || objs.length === 0) {
          return 'There are no objects on the scene';
        }

        var strList = [];

        for (var i = 0, n = objs.length; i < n; ++i) {
          strList[i] = "".concat(i, ": ").concat(objs[i].toString());
        }

        return strList.join('\n');
      }
    }, {
      key: "joinHelpStr",
      value: function joinHelpStr(helpData) {
        if (helpData instanceof Array) {
          return helpData.join('\n');
        }

        return helpData;
      }
    }, {
      key: "help",
      value: function help$1(path) {
        if (___default['default'].isUndefined(path)) {
          return "".concat(this.joinHelpStr(help.$help), "\n").concat(___default['default'].slice(___default['default'].sortBy(___default['default'].keys(help)), 1).join(', '), "\n");
        }

        var helpItem = ___default['default'].get(help, path);

        return ___default['default'].isUndefined(helpItem) ? this.help() : "".concat(this.joinHelpStr(helpItem.$help), "\n");
      }
    }, {
      key: "load",
      value: function load(miew, arg) {
        if (miew === undefined || arg === undefined || arg === '-f') {
          return;
        }

        miew.awaitWhileCMDisInProcess();

        var finish = function finish() {
          return miew.finishAwaitingCMDInProcess();
        };

        miew.load(arg).then(finish, finish);
      }
    }, {
      key: "checkArg",
      value: function checkArg(key, arg, modificate) {
        if (key !== undefined && arg !== undefined) {
          if (keyRemap(key) === 'selector') {
            var res = selectors$5.parse(arg);

            if (res.error !== undefined) {
              var selExc = {
                message: res.error
              };
              throw selExc;
            }

            if (modificate !== undefined && modificate) {
              return res.selector;
            }

            return arg;
          }

          var modificators = {
            colorers: colorers$1,
            modes: modes$1,
            materials: materials$1
          };
          var modificator = key;
          var temp;

          while (modificator !== temp) {
            temp = modificator;
            modificator = keyRemap(temp);
          }

          if (modificators[modificator].get(arg) === undefined) {
            var exc = {
              message: "".concat(arg, " is not existed in ").concat(modificator)
            };
            throw exc;
          }

          return arg;
        }

        return NULL;
      }
    }, {
      key: "propagateProp",
      value: function propagateProp(path, arg) {
        if (path !== undefined) {
          var argExc = {};

          var adapter = options$1.adapters[_typeof_1(___default['default'].get(settings$1.defaults, path))];

          if (adapter === undefined) {
            var pathExc = {
              message: "".concat(path, " is not existed")
            };
            throw pathExc;
          }

          if ((path.endsWith('.color') || path.endsWith('.baseColor') || path.endsWith('.EL.carbon')) && typeof arg !== 'number') {
            arg = palettes$1.get(settings$1.now.palette).getNamedColor(arg);
          }

          if (path.endsWith('.fg') || path.endsWith('.bg')) {
            if (typeof arg !== 'number') {
              var val = palettes$1.get(settings$1.now.palette).getNamedColor(arg, true);

              if (val !== undefined) {
                arg = "0x".concat(val.toString(16));
              }
            } else {
              arg = "0x".concat(arg.toString(16));
            }
          }

          if (path.endsWith('.template')) {
            arg = arg.replace(/\\n/g, '\n'); // NOSONAR
          }

          if (arg !== undefined && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
            argExc = {
              message: "".concat(path, " must be a \"").concat(_typeof_1(___default['default'].get(settings$1.defaults, path)), "\"")
            };
            throw argExc;
          }
        }

        return arg;
      }
    }, {
      key: "unquoteString",
      value: function unquoteString(value) {
        return utils.unquoteString(value);
      }
    }]);

    return CLIUtils;
  }(); // repIndexOrRepMap could be RepresentationMap or index


  var utilFunctions = new CLIUtils();

  function CreateObjectPair(a, b) {
    var obj = {};
    obj[a] = b;
    return obj;
  }

  function ArgList(arg) {
    if (arg instanceof this.constructor) {
      return arg;
    }

    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }

  ArgList.prototype.append = function (value) {
    var values = this._values;
    values[values.length] = value;
    return this;
  };

  ArgList.prototype.remove = function (value) {
    var values = this._values;
    var index = values.indexOf(value);

    if (index >= 0) {
      values.splice(index, 1);
    }

    return this;
  };

  ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
    var res = {};
    var list = this._values;

    for (var i = 0, n = list.length; i < n; ++i) {
      ___default['default'].set(res, list[i].id, cliUtils.propagateProp("".concat(keyRemap(cmd), ".").concat(arg, ".").concat(list[i].id), list[i].val));
    }

    return res;
  };

  function Arg(_id, _val) {
    this.id = _id;
    this.val = _val;
  }

  var cliutils = Object.create({});
  cliutils.Arg = Arg;
  cliutils.ArgList = ArgList;
  cliutils.miew = null;
  cliutils.echo = null;
  cliutils.representations = representationsStorage;
  cliutils.utils = utilFunctions;
  cliutils._ = ___default['default'];
  cliutils.CreateObjectPair = CreateObjectPair;
  cliutils.keyRemap = keyRemap;
  cliutils.Context = selectors$5.Context;
  cliutils.ClearContext = selectors$5.ClearContext;
  cliutils.NULL = NULL;

  cliutils.notimplemented = function () {
    return this.NULL;
  };

  Miew.prototype.script = function (script, _printCallback, _errorCallback) {
    MiewCLIParser_1.yy.miew = this;
    MiewCLIParser_1.yy.echo = _printCallback;
    MiewCLIParser_1.yy.error = _errorCallback;

    if (this.cmdQueue === undefined) {
      this.cmdQueue = [];
    }

    if (this.commandInAction === undefined) {
      this.commandInAction = false;
    }

    this.cmdQueue = this.cmdQueue.concat(script.split('\n'));
  };

  Miew.prototype.awaitWhileCMDisInProcess = function () {
    this.commandInAction = true;
  };

  Miew.prototype.finishAwaitingCMDInProcess = function () {
    this.commandInAction = false;
  };

  Miew.prototype.isScriptingCommandAvailable = function () {
    return this.commandInAction !== undefined && !this.commandInAction && this.cmdQueue !== undefined && this.cmdQueue.length > 0;
  };

  Miew.prototype.callNextCmd = function () {
    if (this.isScriptingCommandAvailable()) {
      var cmd = this.cmdQueue.shift();
      var res = {};
      res.success = false;

      try {
        MiewCLIParser_1.parse(cmd);
        res.success = true;
      } catch (e) {
        res.error = e.message;
        MiewCLIParser_1.yy.error(res.error);
        this.finishAwaitingCMDInProcess();
      }

      return res;
    }

    return '';
  };

  MiewCLIParser_1.yy = cliutils; // workaround for incorrect JISON parser generator for AMD module

  MiewCLIParser_1.yy.parseError = MiewCLIParser_1.parseError;

  return Miew;

})));
//# sourceMappingURL=Miew.js.map
