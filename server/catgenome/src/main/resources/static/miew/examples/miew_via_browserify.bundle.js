(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
// threejs.org/license
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
}(this, (function (exports) { 'use strict';

	// Polyfills
	if (Number.EPSILON === undefined) {
		Number.EPSILON = Math.pow(2, -52);
	}

	if (Number.isInteger === undefined) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
		Number.isInteger = function (value) {
			return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
		};
	} //


	if (Math.sign === undefined) {
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
		Math.sign = function (x) {
			return x < 0 ? -1 : x > 0 ? 1 : +x;
		};
	}

	if ('name' in Function.prototype === false) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
		Object.defineProperty(Function.prototype, 'name', {
			get: function get() {
				return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
			}
		});
	}

	if (Object.assign === undefined) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
		Object.assign = function (target) {

			if (target === undefined || target === null) {
				throw new TypeError('Cannot convert undefined or null to object');
			}

			var output = Object(target);

			for (var index = 1; index < arguments.length; index++) {
				var source = arguments[index];

				if (source !== undefined && source !== null) {
					for (var nextKey in source) {
						if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
							output[nextKey] = source[nextKey];
						}
					}
				}
			}

			return output;
		};
	}

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var runtime = function (exports) {

		var Op = Object.prototype;
		var hasOwn = Op.hasOwnProperty;
		var undefined$1; // More compressible than void 0.

		var $Symbol = typeof Symbol === "function" ? Symbol : {};
		var iteratorSymbol = $Symbol.iterator || "@@iterator";
		var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
		var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

		function define(obj, key, value) {
			Object.defineProperty(obj, key, {
				value: value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			return obj[key];
		}

		try {
			// IE 8 has a broken Object.defineProperty that only works on DOM objects.
			define({}, "");
		} catch (err) {
			define = function define(obj, key, value) {
				return obj[key] = value;
			};
		}

		function wrap(innerFn, outerFn, self, tryLocsList) {
			// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
			var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
			var generator = Object.create(protoGenerator.prototype);
			var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
			// .throw, and .return methods.

			generator._invoke = makeInvokeMethod(innerFn, self, context);
			return generator;
		}

		exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
		// record like context.tryEntries[i].completion. This interface could
		// have been (and was previously) designed to take a closure to be
		// invoked without arguments, but in all the cases we care about we
		// already have an existing method we want to call, so there's no need
		// to create a new function object. We can even get away with assuming
		// the method takes exactly one argument, since that happens to be true
		// in every case, so we don't have to touch the arguments object. The
		// only additional allocation required is the completion record, which
		// has a stable shape and so hopefully should be cheap to allocate.

		function tryCatch(fn, obj, arg) {
			try {
				return {
					type: "normal",
					arg: fn.call(obj, arg)
				};
			} catch (err) {
				return {
					type: "throw",
					arg: err
				};
			}
		}

		var GenStateSuspendedStart = "suspendedStart";
		var GenStateSuspendedYield = "suspendedYield";
		var GenStateExecuting = "executing";
		var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
		// breaking out of the dispatch switch statement.

		var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
		// .constructor.prototype properties for functions that return Generator
		// objects. For full spec compliance, you may wish to configure your
		// minifier not to mangle the names of these two functions.

		function Generator() {}

		function GeneratorFunction() {}

		function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
		// don't natively support it.


		var IteratorPrototype = {};

		IteratorPrototype[iteratorSymbol] = function () {
			return this;
		};

		var getProto = Object.getPrototypeOf;
		var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

		if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
			// This environment has a native %IteratorPrototype%; use it instead
			// of the polyfill.
			IteratorPrototype = NativeIteratorPrototype;
		}

		var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
		GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
		GeneratorFunctionPrototype.constructor = GeneratorFunction;
		GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
		// Iterator interface in terms of a single ._invoke method.

		function defineIteratorMethods(prototype) {
			["next", "throw", "return"].forEach(function (method) {
				define(prototype, method, function (arg) {
					return this._invoke(method, arg);
				});
			});
		}

		exports.isGeneratorFunction = function (genFun) {
			var ctor = typeof genFun === "function" && genFun.constructor;
			return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
			// do is to check its .name property.
			(ctor.displayName || ctor.name) === "GeneratorFunction" : false;
		};

		exports.mark = function (genFun) {
			if (Object.setPrototypeOf) {
				Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
			} else {
				genFun.__proto__ = GeneratorFunctionPrototype;
				define(genFun, toStringTagSymbol, "GeneratorFunction");
			}

			genFun.prototype = Object.create(Gp);
			return genFun;
		}; // Within the body of any async function, `await x` is transformed to
		// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
		// `hasOwn.call(value, "__await")` to determine if the yielded value is
		// meant to be awaited.


		exports.awrap = function (arg) {
			return {
				__await: arg
			};
		};

		function AsyncIterator(generator, PromiseImpl) {
			function invoke(method, arg, resolve, reject) {
				var record = tryCatch(generator[method], generator, arg);

				if (record.type === "throw") {
					reject(record.arg);
				} else {
					var result = record.arg;
					var value = result.value;

					if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
						return PromiseImpl.resolve(value.__await).then(function (value) {
							invoke("next", value, resolve, reject);
						}, function (err) {
							invoke("throw", err, resolve, reject);
						});
					}

					return PromiseImpl.resolve(value).then(function (unwrapped) {
						// When a yielded Promise is resolved, its final value becomes
						// the .value of the Promise<{value,done}> result for the
						// current iteration.
						result.value = unwrapped;
						resolve(result);
					}, function (error) {
						// If a rejected Promise was yielded, throw the rejection back
						// into the async generator function so it can be handled there.
						return invoke("throw", error, resolve, reject);
					});
				}
			}

			var previousPromise;

			function enqueue(method, arg) {
				function callInvokeWithMethodAndArg() {
					return new PromiseImpl(function (resolve, reject) {
						invoke(method, arg, resolve, reject);
					});
				}

				return previousPromise = // If enqueue has been called before, then we want to wait until
				// all previous Promises have been resolved before calling invoke,
				// so that results are always delivered in the correct order. If
				// enqueue has not been called before, then it is important to
				// call invoke immediately, without waiting on a callback to fire,
				// so that the async generator function has the opportunity to do
				// any necessary setup in a predictable way. This predictability
				// is why the Promise constructor synchronously invokes its
				// executor callback, and why async functions synchronously
				// execute code before the first await. Since we implement simple
				// async functions in terms of async generators, it is especially
				// important to get this right, even though it requires care.
				previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
				// invocations of the iterator.
				callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
			} // Define the unified helper method that is used to implement .next,
			// .throw, and .return (see defineIteratorMethods).


			this._invoke = enqueue;
		}

		defineIteratorMethods(AsyncIterator.prototype);

		AsyncIterator.prototype[asyncIteratorSymbol] = function () {
			return this;
		};

		exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
		// AsyncIterator objects; they just return a Promise for the value of
		// the final result produced by the iterator.

		exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
			if (PromiseImpl === void 0) PromiseImpl = Promise;
			var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
			return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
			: iter.next().then(function (result) {
				return result.done ? result.value : iter.next();
			});
		};

		function makeInvokeMethod(innerFn, self, context) {
			var state = GenStateSuspendedStart;
			return function invoke(method, arg) {
				if (state === GenStateExecuting) {
					throw new Error("Generator is already running");
				}

				if (state === GenStateCompleted) {
					if (method === "throw") {
						throw arg;
					} // Be forgiving, per 25.3.3.3.3 of the spec:
					// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


					return doneResult();
				}

				context.method = method;
				context.arg = arg;

				while (true) {
					var delegate = context.delegate;

					if (delegate) {
						var delegateResult = maybeInvokeDelegate(delegate, context);

						if (delegateResult) {
							if (delegateResult === ContinueSentinel) continue;
							return delegateResult;
						}
					}

					if (context.method === "next") {
						// Setting context._sent for legacy support of Babel's
						// function.sent implementation.
						context.sent = context._sent = context.arg;
					} else if (context.method === "throw") {
						if (state === GenStateSuspendedStart) {
							state = GenStateCompleted;
							throw context.arg;
						}

						context.dispatchException(context.arg);
					} else if (context.method === "return") {
						context.abrupt("return", context.arg);
					}

					state = GenStateExecuting;
					var record = tryCatch(innerFn, self, context);

					if (record.type === "normal") {
						// If an exception is thrown from innerFn, we leave state ===
						// GenStateExecuting and loop back for another invocation.
						state = context.done ? GenStateCompleted : GenStateSuspendedYield;

						if (record.arg === ContinueSentinel) {
							continue;
						}

						return {
							value: record.arg,
							done: context.done
						};
					} else if (record.type === "throw") {
						state = GenStateCompleted; // Dispatch the exception by looping back around to the
						// context.dispatchException(context.arg) call above.

						context.method = "throw";
						context.arg = record.arg;
					}
				}
			};
		} // Call delegate.iterator[context.method](context.arg) and handle the
		// result, either by returning a { value, done } result from the
		// delegate iterator, or by modifying context.method and context.arg,
		// setting context.delegate to null, and returning the ContinueSentinel.


		function maybeInvokeDelegate(delegate, context) {
			var method = delegate.iterator[context.method];

			if (method === undefined$1) {
				// A .throw or .return when the delegate iterator has no .throw
				// method always terminates the yield* loop.
				context.delegate = null;

				if (context.method === "throw") {
					// Note: ["return"] must be used for ES3 parsing compatibility.
					if (delegate.iterator["return"]) {
						// If the delegate iterator has a return method, give it a
						// chance to clean up.
						context.method = "return";
						context.arg = undefined$1;
						maybeInvokeDelegate(delegate, context);

						if (context.method === "throw") {
							// If maybeInvokeDelegate(context) changed context.method from
							// "return" to "throw", let that override the TypeError below.
							return ContinueSentinel;
						}
					}

					context.method = "throw";
					context.arg = new TypeError("The iterator does not provide a 'throw' method");
				}

				return ContinueSentinel;
			}

			var record = tryCatch(method, delegate.iterator, context.arg);

			if (record.type === "throw") {
				context.method = "throw";
				context.arg = record.arg;
				context.delegate = null;
				return ContinueSentinel;
			}

			var info = record.arg;

			if (!info) {
				context.method = "throw";
				context.arg = new TypeError("iterator result is not an object");
				context.delegate = null;
				return ContinueSentinel;
			}

			if (info.done) {
				// Assign the result of the finished delegate to the temporary
				// variable specified by delegate.resultName (see delegateYield).
				context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

				context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
				// exception, let the outer generator proceed normally. If
				// context.method was "next", forget context.arg since it has been
				// "consumed" by the delegate iterator. If context.method was
				// "return", allow the original .return call to continue in the
				// outer generator.

				if (context.method !== "return") {
					context.method = "next";
					context.arg = undefined$1;
				}
			} else {
				// Re-yield the result returned by the delegate method.
				return info;
			} // The delegate iterator is finished, so forget it and continue with
			// the outer generator.


			context.delegate = null;
			return ContinueSentinel;
		} // Define Generator.prototype.{next,throw,return} in terms of the
		// unified ._invoke helper method.


		defineIteratorMethods(Gp);
		define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
		// @@iterator function is called on it. Some browsers' implementations of the
		// iterator prototype chain incorrectly implement this, causing the Generator
		// object to not be returned from this call. This ensures that doesn't happen.
		// See https://github.com/facebook/regenerator/issues/274 for more details.

		Gp[iteratorSymbol] = function () {
			return this;
		};

		Gp.toString = function () {
			return "[object Generator]";
		};

		function pushTryEntry(locs) {
			var entry = {
				tryLoc: locs[0]
			};

			if (1 in locs) {
				entry.catchLoc = locs[1];
			}

			if (2 in locs) {
				entry.finallyLoc = locs[2];
				entry.afterLoc = locs[3];
			}

			this.tryEntries.push(entry);
		}

		function resetTryEntry(entry) {
			var record = entry.completion || {};
			record.type = "normal";
			delete record.arg;
			entry.completion = record;
		}

		function Context(tryLocsList) {
			// The root entry object (effectively a try statement without a catch
			// or a finally block) gives us a place to store values thrown from
			// locations where there is no enclosing try statement.
			this.tryEntries = [{
				tryLoc: "root"
			}];
			tryLocsList.forEach(pushTryEntry, this);
			this.reset(true);
		}

		exports.keys = function (object) {
			var keys = [];

			for (var key in object) {
				keys.push(key);
			}

			keys.reverse(); // Rather than returning an object with a next method, we keep
			// things simple and return the next function itself.

			return function next() {
				while (keys.length) {
					var key = keys.pop();

					if (key in object) {
						next.value = key;
						next.done = false;
						return next;
					}
				} // To avoid creating an additional object, we just hang the .value
				// and .done properties off the next function object itself. This
				// also ensures that the minifier will not anonymize the function.


				next.done = true;
				return next;
			};
		};

		function values(iterable) {
			if (iterable) {
				var iteratorMethod = iterable[iteratorSymbol];

				if (iteratorMethod) {
					return iteratorMethod.call(iterable);
				}

				if (typeof iterable.next === "function") {
					return iterable;
				}

				if (!isNaN(iterable.length)) {
					var i = -1,
							next = function next() {
						while (++i < iterable.length) {
							if (hasOwn.call(iterable, i)) {
								next.value = iterable[i];
								next.done = false;
								return next;
							}
						}

						next.value = undefined$1;
						next.done = true;
						return next;
					};

					return next.next = next;
				}
			} // Return an iterator with no values.


			return {
				next: doneResult
			};
		}

		exports.values = values;

		function doneResult() {
			return {
				value: undefined$1,
				done: true
			};
		}

		Context.prototype = {
			constructor: Context,
			reset: function reset(skipTempReset) {
				this.prev = 0;
				this.next = 0; // Resetting context._sent for legacy support of Babel's
				// function.sent implementation.

				this.sent = this._sent = undefined$1;
				this.done = false;
				this.delegate = null;
				this.method = "next";
				this.arg = undefined$1;
				this.tryEntries.forEach(resetTryEntry);

				if (!skipTempReset) {
					for (var name in this) {
						// Not sure about the optimal order of these conditions:
						if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
							this[name] = undefined$1;
						}
					}
				}
			},
			stop: function stop() {
				this.done = true;
				var rootEntry = this.tryEntries[0];
				var rootRecord = rootEntry.completion;

				if (rootRecord.type === "throw") {
					throw rootRecord.arg;
				}

				return this.rval;
			},
			dispatchException: function dispatchException(exception) {
				if (this.done) {
					throw exception;
				}

				var context = this;

				function handle(loc, caught) {
					record.type = "throw";
					record.arg = exception;
					context.next = loc;

					if (caught) {
						// If the dispatched exception was caught by a catch block,
						// then let that catch block handle the exception normally.
						context.method = "next";
						context.arg = undefined$1;
					}

					return !!caught;
				}

				for (var i = this.tryEntries.length - 1; i >= 0; --i) {
					var entry = this.tryEntries[i];
					var record = entry.completion;

					if (entry.tryLoc === "root") {
						// Exception thrown outside of any try block that could handle
						// it, so set the completion value of the entire function to
						// throw the exception.
						return handle("end");
					}

					if (entry.tryLoc <= this.prev) {
						var hasCatch = hasOwn.call(entry, "catchLoc");
						var hasFinally = hasOwn.call(entry, "finallyLoc");

						if (hasCatch && hasFinally) {
							if (this.prev < entry.catchLoc) {
								return handle(entry.catchLoc, true);
							} else if (this.prev < entry.finallyLoc) {
								return handle(entry.finallyLoc);
							}
						} else if (hasCatch) {
							if (this.prev < entry.catchLoc) {
								return handle(entry.catchLoc, true);
							}
						} else if (hasFinally) {
							if (this.prev < entry.finallyLoc) {
								return handle(entry.finallyLoc);
							}
						} else {
							throw new Error("try statement without catch or finally");
						}
					}
				}
			},
			abrupt: function abrupt(type, arg) {
				for (var i = this.tryEntries.length - 1; i >= 0; --i) {
					var entry = this.tryEntries[i];

					if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
						var finallyEntry = entry;
						break;
					}
				}

				if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
					// Ignore the finally entry if control is not jumping to a
					// location outside the try/catch block.
					finallyEntry = null;
				}

				var record = finallyEntry ? finallyEntry.completion : {};
				record.type = type;
				record.arg = arg;

				if (finallyEntry) {
					this.method = "next";
					this.next = finallyEntry.finallyLoc;
					return ContinueSentinel;
				}

				return this.complete(record);
			},
			complete: function complete(record, afterLoc) {
				if (record.type === "throw") {
					throw record.arg;
				}

				if (record.type === "break" || record.type === "continue") {
					this.next = record.arg;
				} else if (record.type === "return") {
					this.rval = this.arg = record.arg;
					this.method = "return";
					this.next = "end";
				} else if (record.type === "normal" && afterLoc) {
					this.next = afterLoc;
				}

				return ContinueSentinel;
			},
			finish: function finish(finallyLoc) {
				for (var i = this.tryEntries.length - 1; i >= 0; --i) {
					var entry = this.tryEntries[i];

					if (entry.finallyLoc === finallyLoc) {
						this.complete(entry.completion, entry.afterLoc);
						resetTryEntry(entry);
						return ContinueSentinel;
					}
				}
			},
			"catch": function _catch(tryLoc) {
				for (var i = this.tryEntries.length - 1; i >= 0; --i) {
					var entry = this.tryEntries[i];

					if (entry.tryLoc === tryLoc) {
						var record = entry.completion;

						if (record.type === "throw") {
							var thrown = record.arg;
							resetTryEntry(entry);
						}

						return thrown;
					}
				} // The context.catch method must only be called with a location
				// argument that corresponds to a known catch block.


				throw new Error("illegal catch attempt");
			},
			delegateYield: function delegateYield(iterable, resultName, nextLoc) {
				this.delegate = {
					iterator: values(iterable),
					resultName: resultName,
					nextLoc: nextLoc
				};

				if (this.method === "next") {
					// Deliberately forget the last sent value so that we don't
					// accidentally pass it on to the delegate.
					this.arg = undefined$1;
				}

				return ContinueSentinel;
			}
		}; // Regardless of whether this script is executing as a CommonJS module
		// or not, return the runtime object so that we can declare the variable
		// regeneratorRuntime in the outer scope, which allows this module to be
		// injected easily by `bin/regenerator --include-runtime script.js`.

		return exports;
	}( // If this script is executing as a CommonJS module, use module.exports
	// as the regeneratorRuntime namespace. Otherwise create a new empty
	// object. Either way, the resulting object will be used to initialize
	// the regeneratorRuntime variable at the top of this file.
	typeof module === "object" ? module.exports : {});

	try {
		regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
		// This module should not be running in strict mode, so the above
		// assignment should always work unless something is misconfigured. Just
		// in case runtime.js accidentally runs in strict mode, we can escape
		// strict mode using a global Function call. This could conceivably fail
		// if a Content Security Policy forbids using Function, but in that case
		// the proper solution is to fix the accidental strict mode problem. If
		// you've misconfigured your bundler to force strict mode and applied a
		// CSP to forbid Function, and you're not willing to fix either of those
		// problems, please detail your unique predicament in a GitHub issue.
		Function("r", "regeneratorRuntime = r")(runtime);
	}

	var REVISION = '125dev';
	var MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	var TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var VSMShadowMap = 3;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var CineonToneMapping = 3;
	var ACESFilmicToneMapping = 4;
	var CustomToneMapping = 5;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipmapNearestFilter = 1004;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipmapLinearFilter = 1005;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipmapNearestFilter = 1007;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipmapLinearFilter = 1008;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RedIntegerFormat = 1029;
	var RGFormat = 1030;
	var RGIntegerFormat = 1031;
	var RGBIntegerFormat = 1032;
	var RGBAIntegerFormat = 1033;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGB_ETC2_Format = 37492;
	var RGBA_ETC2_EAC_Format = 37496;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var RGBA_BPTC_Format = 36492;
	var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var NormalAnimationBlendMode = 2500;
	var AdditiveAnimationBlendMode = 2501;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
	var ZeroStencilOp = 0;
	var KeepStencilOp = 7680;
	var ReplaceStencilOp = 7681;
	var IncrementStencilOp = 7682;
	var DecrementStencilOp = 7683;
	var IncrementWrapStencilOp = 34055;
	var DecrementWrapStencilOp = 34056;
	var InvertStencilOp = 5386;
	var NeverStencilFunc = 512;
	var LessStencilFunc = 513;
	var EqualStencilFunc = 514;
	var LessEqualStencilFunc = 515;
	var GreaterStencilFunc = 516;
	var NotEqualStencilFunc = 517;
	var GreaterEqualStencilFunc = 518;
	var AlwaysStencilFunc = 519;
	var StaticDrawUsage = 35044;
	var DynamicDrawUsage = 35048;
	var StreamDrawUsage = 35040;
	var StaticReadUsage = 35045;
	var DynamicReadUsage = 35049;
	var StreamReadUsage = 35041;
	var StaticCopyUsage = 35046;
	var DynamicCopyUsage = 35050;
	var StreamCopyUsage = 35042;
	var GLSL1 = '100';
	var GLSL3 = '300 es';

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		try {
			var info = gen[key](arg);
			var value = info.value;
		} catch (error) {
			reject(error);
			return;
		}

		if (info.done) {
			resolve(value);
		} else {
			Promise.resolve(value).then(_next, _throw);
		}
	}

	function _asyncToGenerator(fn) {
		return function () {
			var self = this,
					args = arguments;
			return new Promise(function (resolve, reject) {
				var gen = fn.apply(self, args);

				function _next(value) {
					asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
				}

				function _throw(err) {
					asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
				}

				_next(undefined);
			});
		};
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	function _inheritsLoose(subClass, superClass) {
		subClass.prototype = Object.create(superClass.prototype);
		subClass.prototype.constructor = subClass;
		subClass.__proto__ = superClass;
	}

	function _assertThisInitialized(self) {
		if (self === void 0) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}

		return self;
	}

	function _unsupportedIterableToArray(o, minLen) {
		if (!o) return;
		if (typeof o === "string") return _arrayLikeToArray(o, minLen);
		var n = Object.prototype.toString.call(o).slice(8, -1);
		if (n === "Object" && o.constructor) n = o.constructor.name;
		if (n === "Map" || n === "Set") return Array.from(o);
		if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
		if (len == null || len > arr.length) len = arr.length;

		for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

		return arr2;
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
		var it;

		if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
			if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
				if (it) o = it;
				var i = 0;
				return function () {
					if (i >= o.length) return {
						done: true
					};
					return {
						done: false,
						value: o[i++]
					};
				};
			}

			throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}

		it = o[Symbol.iterator]();
		return it.next.bind(it);
	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	function EventDispatcher() {}

	Object.assign(EventDispatcher.prototype, {
		addEventListener: function addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			var listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		},
		hasEventListener: function hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			var listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		},
		removeEventListener: function removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			var listeners = this._listeners;
			var listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				var index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		},
		dispatchEvent: function dispatchEvent(event) {
			if (this._listeners === undefined) return;
			var listeners = this._listeners;
			var listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				var array = listenerArray.slice(0);

				for (var i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}
			}
		}
	});

	var _lut = [];

	for (var i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	var _seed = 1234567;
	var MathUtils = {
		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,
		generateUUID: function generateUUID() {
			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
			var d0 = Math.random() * 0xffffffff | 0;
			var d1 = Math.random() * 0xffffffff | 0;
			var d2 = Math.random() * 0xffffffff | 0;
			var d3 = Math.random() * 0xffffffff | 0;
			var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

			return uuid.toUpperCase();
		},
		clamp: function clamp(value, min, max) {
			return Math.max(min, Math.min(max, value));
		},
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
		euclideanModulo: function euclideanModulo(n, m) {
			return (n % m + m) % m;
		},
		// Linear mapping from range <a1, a2> to range <b1, b2>
		mapLinear: function mapLinear(x, a1, a2, b1, b2) {
			return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
		},
		// https://en.wikipedia.org/wiki/Linear_interpolation
		lerp: function lerp(x, y, t) {
			return (1 - t) * x + t * y;
		},
		// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
		damp: function damp(x, y, lambda, dt) {
			return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
		},
		// https://www.desmos.com/calculator/vcsjnyz7x4
		pingpong: function pingpong(x, length) {
			if (length === void 0) {
				length = 1;
			}

			return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
		},
		// http://en.wikipedia.org/wiki/Smoothstep
		smoothstep: function smoothstep(x, min, max) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * (3 - 2 * x);
		},
		smootherstep: function smootherstep(x, min, max) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * x * (x * (x * 6 - 15) + 10);
		},
		// Random integer from <low, high> interval
		randInt: function randInt(low, high) {
			return low + Math.floor(Math.random() * (high - low + 1));
		},
		// Random float from <low, high> interval
		randFloat: function randFloat(low, high) {
			return low + Math.random() * (high - low);
		},
		// Random float from <-range/2, range/2> interval
		randFloatSpread: function randFloatSpread(range) {
			return range * (0.5 - Math.random());
		},
		// Deterministic pseudo-random float in the interval [ 0, 1 ]
		seededRandom: function seededRandom(s) {
			if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

			_seed = _seed * 16807 % 2147483647;
			return (_seed - 1) / 2147483646;
		},
		degToRad: function degToRad(degrees) {
			return degrees * MathUtils.DEG2RAD;
		},
		radToDeg: function radToDeg(radians) {
			return radians * MathUtils.RAD2DEG;
		},
		isPowerOfTwo: function isPowerOfTwo(value) {
			return (value & value - 1) === 0 && value !== 0;
		},
		ceilPowerOfTwo: function ceilPowerOfTwo(value) {
			return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
		},
		floorPowerOfTwo: function floorPowerOfTwo(value) {
			return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
		},
		setQuaternionFromProperEuler: function setQuaternionFromProperEuler(q, a, b, c, order) {
			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians
			var cos = Math.cos;
			var sin = Math.sin;
			var c2 = cos(b / 2);
			var s2 = sin(b / 2);
			var c13 = cos((a + c) / 2);
			var s13 = sin((a + c) / 2);
			var c1_3 = cos((a - c) / 2);
			var s1_3 = sin((a - c) / 2);
			var c3_1 = cos((c - a) / 2);
			var s3_1 = sin((c - a) / 2);

			switch (order) {
				case 'XYX':
					q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
					break;

				case 'YZY':
					q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
					break;

				case 'ZXZ':
					q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
					break;

				case 'XZX':
					q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
					break;

				case 'YXY':
					q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
					break;

				case 'ZYZ':
					q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
					break;

				default:
					console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
			}
		}
	};

	var Vector2 = /*#__PURE__*/function () {
		function Vector2(x, y) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			Object.defineProperty(this, 'isVector2', {
				value: true
			});
			this.x = x;
			this.y = y;
		}

		var _proto = Vector2.prototype;

		_proto.set = function set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		};

		_proto.multiply = function multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		};

		_proto.divide = function divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.applyMatrix3 = function applyMatrix3(m) {
			var x = this.x,
					y = this.y;
			var e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y;
		};

		_proto.cross = function cross(v) {
			return this.x * v.y - this.y * v.x;
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.angle = function angle() {
			// computes the angle in radians with respect to the positive x-axis
			var angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		};

		_proto.distanceTo = function distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		};

		_proto.distanceToSquared = function distanceToSquared(v) {
			var dx = this.x - v.x,
					dy = this.y - v.y;
			return dx * dx + dy * dy;
		};

		_proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		};

		_proto.rotateAround = function rotateAround(center, angle) {
			var c = Math.cos(angle),
					s = Math.sin(angle);
			var x = this.x - center.x;
			var y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		};

		_createClass(Vector2, [{
			key: "width",
			get: function get() {
				return this.x;
			},
			set: function set(value) {
				this.x = value;
			}
		}, {
			key: "height",
			get: function get() {
				return this.y;
			},
			set: function set(value) {
				this.y = value;
			}
		}]);

		return Vector2;
	}();

	var Matrix3 = /*#__PURE__*/function () {
		function Matrix3() {
			Object.defineProperty(this, 'isMatrix3', {
				value: true
			});
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		var _proto = Matrix3.prototype;

		_proto.set = function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			var te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		};

		_proto.identity = function identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().fromArray(this.elements);
		};

		_proto.copy = function copy(m) {
			var te = this.elements;
			var me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		};

		_proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		};

		_proto.setFromMatrix4 = function setFromMatrix4(m) {
			var me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		};

		_proto.multiply = function multiply(m) {
			return this.multiplyMatrices(this, m);
		};

		_proto.premultiply = function premultiply(m) {
			return this.multiplyMatrices(m, this);
		};

		_proto.multiplyMatrices = function multiplyMatrices(a, b) {
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
			var a11 = ae[0],
					a12 = ae[3],
					a13 = ae[6];
			var a21 = ae[1],
					a22 = ae[4],
					a23 = ae[7];
			var a31 = ae[2],
					a32 = ae[5],
					a33 = ae[8];
			var b11 = be[0],
					b12 = be[3],
					b13 = be[6];
			var b21 = be[1],
					b22 = be[4],
					b23 = be[7];
			var b31 = be[2],
					b32 = be[5],
					b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			var te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		};

		_proto.determinant = function determinant() {
			var te = this.elements;
			var a = te[0],
					b = te[1],
					c = te[2],
					d = te[3],
					e = te[4],
					f = te[5],
					g = te[6],
					h = te[7],
					i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		};

		_proto.invert = function invert() {
			var te = this.elements,
					n11 = te[0],
					n21 = te[1],
					n31 = te[2],
					n12 = te[3],
					n22 = te[4],
					n32 = te[5],
					n13 = te[6],
					n23 = te[7],
					n33 = te[8],
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
					det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			var detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		};

		_proto.transpose = function transpose() {
			var tmp;
			var m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		};

		_proto.getNormalMatrix = function getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).copy(this).invert().transpose();
		};

		_proto.transposeIntoArray = function transposeIntoArray(r) {
			var m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		};

		_proto.setUvTransform = function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			var c = Math.cos(rotation);
			var s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		};

		_proto.scale = function scale(sx, sy) {
			var te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		};

		_proto.rotate = function rotate(theta) {
			var c = Math.cos(theta);
			var s = Math.sin(theta);
			var te = this.elements;
			var a11 = te[0],
					a12 = te[3],
					a13 = te[6];
			var a21 = te[1],
					a22 = te[4],
					a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		};

		_proto.translate = function translate(tx, ty) {
			var te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		};

		_proto.equals = function equals(matrix) {
			var te = this.elements;
			var me = matrix.elements;

			for (var i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			for (var i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		};

		return Matrix3;
	}();

	var _canvas;

	var ImageUtils = {
		getDataURL: function getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			var canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}
	};

	var textureId = 0;

	function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		if (image === void 0) {
			image = Texture.DEFAULT_IMAGE;
		}

		if (mapping === void 0) {
			mapping = Texture.DEFAULT_MAPPING;
		}

		if (wrapS === void 0) {
			wrapS = ClampToEdgeWrapping;
		}

		if (wrapT === void 0) {
			wrapT = ClampToEdgeWrapping;
		}

		if (magFilter === void 0) {
			magFilter = LinearFilter;
		}

		if (minFilter === void 0) {
			minFilter = LinearMipmapLinearFilter;
		}

		if (format === void 0) {
			format = RGBAFormat;
		}

		if (type === void 0) {
			type = UnsignedByteType;
		}

		if (anisotropy === void 0) {
			anisotropy = 1;
		}

		if (encoding === void 0) {
			encoding = LinearEncoding;
		}

		Object.defineProperty(this, 'id', {
			value: textureId++
		});
		this.uuid = MathUtils.generateUUID();
		this.name = '';
		this.image = image;
		this.mipmaps = [];
		this.mapping = mapping;
		this.wrapS = wrapS;
		this.wrapT = wrapT;
		this.magFilter = magFilter;
		this.minFilter = minFilter;
		this.anisotropy = anisotropy;
		this.format = format;
		this.internalFormat = null;
		this.type = type;
		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);
		this.center = new Vector2(0, 0);
		this.rotation = 0;
		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

		this.encoding = encoding;
		this.version = 0;
		this.onUpdate = null;
	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: Texture,
		isTexture: true,
		updateMatrix: function updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		},
		copy: function copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			return this;
		},
		toJSON: function toJSON(meta) {
			var isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			var output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				var image = this.image;

				if (image.uuid === undefined) {
					image.uuid = MathUtils.generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					var url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (var i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		},
		dispose: function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		},
		transformUv: function transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		}
	});
	Object.defineProperty(Texture.prototype, 'needsUpdate', {
		set: function set(value) {
			if (value === true) this.version++;
		}
	});

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	var Vector4 = /*#__PURE__*/function () {
		function Vector4(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 1;
			}

			Object.defineProperty(this, 'isVector4', {
				value: true
			});
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		var _proto = Vector4.prototype;

		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setZ = function setZ(z) {
			this.z = z;
			return this;
		};

		_proto.setW = function setW(w) {
			this.w = w;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		};

		_proto.multiply = function multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		};

		_proto.applyMatrix4 = function applyMatrix4(m) {
			var x = this.x,
					y = this.y,
					z = this.z,
					w = this.w;
			var e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.setAxisAngleFromQuaternion = function setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			var s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		};

		_proto.setAxisAngleFromRotationMatrix = function setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			var angle, x, y, z; // variables for result

			var epsilon = 0.01,
					// margin to allow for rounding errors
			epsilon2 = 0.1,
					// margin to distinguish between 0 and 180 degrees
			te = m.elements,
					m11 = te[0],
					m12 = te[4],
					m13 = te[8],
					m21 = te[1],
					m22 = te[5],
					m23 = te[9],
					m31 = te[2],
					m32 = te[6],
					m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				var xx = (m11 + 1) / 2;
				var yy = (m22 + 1) / 2;
				var zz = (m33 + 1) / 2;
				var xy = (m12 + m21) / 4;
				var xz = (m13 + m31) / 4;
				var yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		};

		_createClass(Vector4, [{
			key: "width",
			get: function get() {
				return this.z;
			},
			set: function set(value) {
				this.z = value;
			}
		}, {
			key: "height",
			get: function get() {
				return this.w;
			},
			set: function set(value) {
				this.w = value;
			}
		}]);

		return Vector4;
	}();

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	var WebGLRenderTarget = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(WebGLRenderTarget, _EventDispatcher);

		function WebGLRenderTarget(width, height, options) {
			var _this;

			_this = _EventDispatcher.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'isWebGLRenderTarget', {
				value: true
			});
			_this.width = width;
			_this.height = height;
			_this.scissor = new Vector4(0, 0, width, height);
			_this.scissorTest = false;
			_this.viewport = new Vector4(0, 0, width, height);
			options = options || {};
			_this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			_this.texture.image = {};
			_this.texture.image.width = width;
			_this.texture.image.height = height;
			_this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			_this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			_this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			_this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			_this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
			return _this;
		}

		var _proto = WebGLRenderTarget.prototype;

		_proto.setSize = function setSize(width, height) {
			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		return WebGLRenderTarget;
	}(EventDispatcher);

	var WebGLMultisampleRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
		_inheritsLoose(WebGLMultisampleRenderTarget, _WebGLRenderTarget);

		function WebGLMultisampleRenderTarget(width, height, options) {
			var _this;

			_this = _WebGLRenderTarget.call(this, width, height, options) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'isWebGLMultisampleRenderTarget', {
				value: true
			});
			_this.samples = 4;
			return _this;
		}

		var _proto = WebGLMultisampleRenderTarget.prototype;

		_proto.copy = function copy(source) {
			_WebGLRenderTarget.prototype.copy.call(this, source);

			this.samples = source.samples;
			return this;
		};

		return WebGLMultisampleRenderTarget;
	}(WebGLRenderTarget);

	var Quaternion = /*#__PURE__*/function () {
		function Quaternion(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 1;
			}

			Object.defineProperty(this, 'isQuaternion', {
				value: true
			});
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		Quaternion.slerp = function slerp(qa, qb, qm, t) {
			return qm.copy(qa).slerp(qb, t);
		};

		Quaternion.slerpFlat = function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			var x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			var x1 = src1[srcOffset1 + 0],
					y1 = src1[srcOffset1 + 1],
					z1 = src1[srcOffset1 + 2],
					w1 = src1[srcOffset1 + 3];

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				var s = 1 - t;
				var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
						dir = cos >= 0 ? 1 : -1,
						sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					var sin = Math.sqrt(sqrSin),
							len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				var tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		};

		Quaternion.multiplyQuaternionsFlat = function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			var x0 = src0[srcOffset0];
			var y0 = src0[srcOffset0 + 1];
			var z0 = src0[srcOffset0 + 2];
			var w0 = src0[srcOffset0 + 3];
			var x1 = src1[srcOffset1];
			var y1 = src1[srcOffset1 + 1];
			var z1 = src1[srcOffset1 + 2];
			var w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		};

		var _proto = Quaternion.prototype;

		_proto.set = function set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		};

		_proto.copy = function copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		};

		_proto.setFromEuler = function setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			var x = euler._x,
					y = euler._y,
					z = euler._z,
					order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;
			var c1 = cos(x / 2);
			var c2 = cos(y / 2);
			var c3 = cos(z / 2);
			var s1 = sin(x / 2);
			var s2 = sin(y / 2);
			var s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		};

		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			var halfAngle = angle / 2,
					s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		};

		_proto.setFromRotationMatrix = function setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			var te = m.elements,
					m11 = te[0],
					m12 = te[4],
					m13 = te[8],
					m21 = te[1],
					m22 = te[5],
					m23 = te[9],
					m31 = te[2],
					m32 = te[6],
					m33 = te[10],
					trace = m11 + m22 + m33;

			if (trace > 0) {
				var s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

				this._w = (m32 - m23) / _s;
				this._x = 0.25 * _s;
				this._y = (m12 + m21) / _s;
				this._z = (m13 + m31) / _s;
			} else if (m22 > m33) {
				var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

				this._w = (m13 - m31) / _s2;
				this._x = (m12 + m21) / _s2;
				this._y = 0.25 * _s2;
				this._z = (m23 + m32) / _s2;
			} else {
				var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

				this._w = (m21 - m12) / _s3;
				this._x = (m13 + m31) / _s3;
				this._y = (m23 + m32) / _s3;
				this._z = 0.25 * _s3;
			}

			this._onChangeCallback();

			return this;
		};

		_proto.setFromUnitVectors = function setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			var EPS = 0.000001;
			var r = vFrom.dot(vTo) + 1;

			if (r < EPS) {
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		};

		_proto.angleTo = function angleTo(q) {
			return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
		};

		_proto.rotateTowards = function rotateTowards(q, step) {
			var angle = this.angleTo(q);
			if (angle === 0) return this;
			var t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		};

		_proto.identity = function identity() {
			return this.set(0, 0, 0, 1);
		};

		_proto.invert = function invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		};

		_proto.conjugate = function conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		};

		_proto.dot = function dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		};

		_proto.lengthSq = function lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		};

		_proto.length = function length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		};

		_proto.normalize = function normalize() {
			var l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		};

		_proto.multiply = function multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		};

		_proto.premultiply = function premultiply(q) {
			return this.multiplyQuaternions(q, this);
		};

		_proto.multiplyQuaternions = function multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			var qax = a._x,
					qay = a._y,
					qaz = a._z,
					qaw = a._w;
			var qbx = b._x,
					qby = b._y,
					qbz = b._z,
					qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		};

		_proto.slerp = function slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			var x = this._x,
					y = this._y,
					z = this._z,
					w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
					ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		};

		_proto.equals = function equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		};

		_proto._onChange = function _onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		};

		_proto._onChangeCallback = function _onChangeCallback() {};

		_createClass(Quaternion, [{
			key: "x",
			get: function get() {
				return this._x;
			},
			set: function set(value) {
				this._x = value;

				this._onChangeCallback();
			}
		}, {
			key: "y",
			get: function get() {
				return this._y;
			},
			set: function set(value) {
				this._y = value;

				this._onChangeCallback();
			}
		}, {
			key: "z",
			get: function get() {
				return this._z;
			},
			set: function set(value) {
				this._z = value;

				this._onChangeCallback();
			}
		}, {
			key: "w",
			get: function get() {
				return this._w;
			},
			set: function set(value) {
				this._w = value;

				this._onChangeCallback();
			}
		}]);

		return Quaternion;
	}();

	var Vector3 = /*#__PURE__*/function () {
		function Vector3(x, y, z) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			Object.defineProperty(this, 'isVector3', {
				value: true
			});
			this.x = x;
			this.y = y;
			this.z = z;
		}

		var _proto = Vector3.prototype;

		_proto.set = function set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setZ = function setZ(z) {
			this.z = z;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y, this.z);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		};

		_proto.multiply = function multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		};

		_proto.multiplyVectors = function multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		};

		_proto.applyEuler = function applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion.setFromEuler(euler));
		};

		_proto.applyAxisAngle = function applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
		};

		_proto.applyMatrix3 = function applyMatrix3(m) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		};

		_proto.applyNormalMatrix = function applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		};

		_proto.applyMatrix4 = function applyMatrix4(m) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		};

		_proto.applyQuaternion = function applyQuaternion(q) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var qx = q.x,
					qy = q.y,
					qz = q.z,
					qw = q.w; // calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		};

		_proto.project = function project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		};

		_proto.unproject = function unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		};

		_proto.transformDirection = function transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		};

		_proto.divide = function divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?
		;

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		};

		_proto.cross = function cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		};

		_proto.crossVectors = function crossVectors(a, b) {
			var ax = a.x,
					ay = a.y,
					az = a.z;
			var bx = b.x,
					by = b.y,
					bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		};

		_proto.projectOnVector = function projectOnVector(v) {
			var denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			var scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		};

		_proto.projectOnPlane = function projectOnPlane(planeNormal) {
			_vector.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector);
		};

		_proto.reflect = function reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
		};

		_proto.angleTo = function angleTo(v) {
			var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			var theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(MathUtils.clamp(theta, -1, 1));
		};

		_proto.distanceTo = function distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		};

		_proto.distanceToSquared = function distanceToSquared(v) {
			var dx = this.x - v.x,
					dy = this.y - v.y,
					dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		};

		_proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		};

		_proto.setFromSpherical = function setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		};

		_proto.setFromSphericalCoords = function setFromSphericalCoords(radius, phi, theta) {
			var sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		};

		_proto.setFromCylindrical = function setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		};

		_proto.setFromCylindricalCoords = function setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		};

		_proto.setFromMatrixPosition = function setFromMatrixPosition(m) {
			var e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		};

		_proto.setFromMatrixScale = function setFromMatrixScale(m) {
			var sx = this.setFromMatrixColumn(m, 0).length();
			var sy = this.setFromMatrixColumn(m, 1).length();
			var sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		};

		_proto.setFromMatrixColumn = function setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		};

		_proto.setFromMatrix3Column = function setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		};

		return Vector3;
	}();

	var _vector = /*@__PURE__*/new Vector3();

	var _quaternion = /*@__PURE__*/new Quaternion();

	var Box3 = /*#__PURE__*/function () {
		function Box3(min, max) {
			Object.defineProperty(this, 'isBox3', {
				value: true
			});
			this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
			this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
		}

		var _proto = Box3.prototype;

		_proto.set = function set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		};

		_proto.setFromArray = function setFromArray(array) {
			var minX = +Infinity;
			var minY = +Infinity;
			var minZ = +Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			var maxZ = -Infinity;

			for (var i = 0, l = array.length; i < l; i += 3) {
				var x = array[i];
				var y = array[i + 1];
				var z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		};

		_proto.setFromBufferAttribute = function setFromBufferAttribute(attribute) {
			var minX = +Infinity;
			var minY = +Infinity;
			var minZ = +Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			var maxZ = -Infinity;

			for (var i = 0, l = attribute.count; i < l; i++) {
				var x = attribute.getX(i);
				var y = attribute.getY(i);
				var z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points) {
			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		};

		_proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
			var halfSize = _vector$1.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		};

		_proto.setFromObject = function setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		};

		_proto.getCenter = function getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getCenter() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		};

		_proto.getSize = function getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getSize() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		};

		_proto.expandByPoint = function expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		};

		_proto.expandByVector = function expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		};

		_proto.expandByScalar = function expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		};

		_proto.expandByObject = function expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			var geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box.copy(geometry.boundingBox);

				_box.applyMatrix4(object.matrixWorld);

				this.union(_box);
			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		};

		_proto.containsBox = function containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		};

		_proto.getParameter = function getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			if (target === undefined) {
				console.warn('THREE.Box3: .getParameter() target is now required');
				target = new Vector3();
			}

			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		};

		_proto.intersectsBox = function intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			var min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		};

		_proto.intersectsTriangle = function intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0.subVectors(triangle.a, _center);

			_v1.subVectors(triangle.b, _center);

			_v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1, _v0);

			_f1.subVectors(_v2, _v1);

			_f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0, _v1, _v2, _extents);
		};

		_proto.clampPoint = function clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .clampPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(point).clamp(this.min, this.max);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		};

		_proto.getBoundingSphere = function getBoundingSphere(target) {
			if (target === undefined) {
				console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
			}

			this.getCenter(target.center);
			target.radius = this.getSize(_vector$1).length() * 0.5;
			return target;
		};

		_proto.intersect = function intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		};

		_proto.union = function union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		};

		_proto.equals = function equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		};

		return Box3;
	}();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			var p0 = v0.dot(_testAxis);
			var p1 = v1.dot(_testAxis);
			var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	var _vector$1 = /*@__PURE__*/new Vector3();

	var _box = /*@__PURE__*/new Box3(); // triangle centered vertices


	var _v0 = /*@__PURE__*/new Vector3();

	var _v1 = /*@__PURE__*/new Vector3();

	var _v2 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	var _f0 = /*@__PURE__*/new Vector3();

	var _f1 = /*@__PURE__*/new Vector3();

	var _f2 = /*@__PURE__*/new Vector3();

	var _center = /*@__PURE__*/new Vector3();

	var _extents = /*@__PURE__*/new Vector3();

	var _triangleNormal = /*@__PURE__*/new Vector3();

	var _testAxis = /*@__PURE__*/new Vector3();

	var _box$1 = /*@__PURE__*/new Box3();

	var Sphere = /*#__PURE__*/function () {
		function Sphere(center, radius) {
			this.center = center !== undefined ? center : new Vector3();
			this.radius = radius !== undefined ? radius : -1;
		}

		var _proto = Sphere.prototype;

		_proto.set = function set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points, optionalCenter) {
			var center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$1.setFromPoints(points).getCenter(center);
			}

			var maxRadiusSq = 0;

			for (var i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			return this.radius < 0;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			var radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsSphere(this);
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		};

		_proto.clampPoint = function clampPoint(point, target) {
			var deltaLengthSq = this.center.distanceToSquared(point);

			if (target === undefined) {
				console.warn('THREE.Sphere: .clampPoint() target is now required');
				target = new Vector3();
			}

			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		};

		_proto.getBoundingBox = function getBoundingBox(target) {
			if (target === undefined) {
				console.warn('THREE.Sphere: .getBoundingBox() target is now required');
				target = new Box3();
			}

			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		};

		_proto.translate = function translate(offset) {
			this.center.add(offset);
			return this;
		};

		_proto.equals = function equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		};

		return Sphere;
	}();

	var _vector$2 = /*@__PURE__*/new Vector3();

	var _segCenter = /*@__PURE__*/new Vector3();

	var _segDir = /*@__PURE__*/new Vector3();

	var _diff = /*@__PURE__*/new Vector3();

	var _edge1 = /*@__PURE__*/new Vector3();

	var _edge2 = /*@__PURE__*/new Vector3();

	var _normal = /*@__PURE__*/new Vector3();

	var Ray = /*#__PURE__*/function () {
		function Ray(origin, direction) {
			this.origin = origin !== undefined ? origin : new Vector3();
			this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
		}

		var _proto = Ray.prototype;

		_proto.set = function set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		};

		_proto.at = function at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .at() target is now required');
				target = new Vector3();
			}

			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		};

		_proto.lookAt = function lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		};

		_proto.recast = function recast(t) {
			this.origin.copy(this.at(t, _vector$2));
			return this;
		};

		_proto.closestPointToPoint = function closestPointToPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			target.subVectors(point, this.origin);
			var directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		};

		_proto.distanceSqToPoint = function distanceSqToPoint(point) {
			var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$2.distanceToSquared(point);
		};

		_proto.distanceSqToSegment = function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			var segExtent = v0.distanceTo(v1) * 0.5;
			var a01 = -this.direction.dot(_segDir);

			var b0 = _diff.dot(this.direction);

			var b1 = -_diff.dot(_segDir);

			var c = _diff.lengthSq();

			var det = Math.abs(1 - a01 * a01);
			var s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		};

		_proto.intersectSphere = function intersectSphere(sphere, target) {
			_vector$2.subVectors(sphere.center, this.origin);

			var tca = _vector$2.dot(this.direction);

			var d2 = _vector$2.dot(_vector$2) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		};

		_proto.distanceToPlane = function distanceToPlane(plane) {
			var denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		};

		_proto.intersectPlane = function intersectPlane(plane, target) {
			var t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			// check if the ray lies on the plane first
			var distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			var denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		};

		_proto.intersectBox = function intersectBox(box, target) {
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
			var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
			var origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return this.intersectBox(box, _vector$2) !== null;
		};

		_proto.intersectTriangle = function intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			var DdN = this.direction.dot(_normal);
			var sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			var QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		};

		_proto.equals = function equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		};

		return Ray;
	}();

	var Matrix4 = /*#__PURE__*/function () {
		function Matrix4() {
			Object.defineProperty(this, 'isMatrix4', {
				value: true
			});
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		var _proto = Matrix4.prototype;

		_proto.set = function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			var te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		};

		_proto.identity = function identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.clone = function clone() {
			return new Matrix4().fromArray(this.elements);
		};

		_proto.copy = function copy(m) {
			var te = this.elements;
			var me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		};

		_proto.copyPosition = function copyPosition(m) {
			var te = this.elements,
					me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		};

		_proto.setFromMatrix3 = function setFromMatrix3(m) {
			var me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		};

		_proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		};

		_proto.makeBasis = function makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.extractRotation = function extractRotation(m) {
			// this method does not support reflection matrices
			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();

			var scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();

			var scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		};

		_proto.makeRotationFromEuler = function makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			var te = this.elements;
			var x = euler.x,
					y = euler.y,
					z = euler.z;
			var a = Math.cos(x),
					b = Math.sin(x);
			var c = Math.cos(y),
					d = Math.sin(y);
			var e = Math.cos(z),
					f = Math.sin(z);

			if (euler.order === 'XYZ') {
				var ae = a * e,
						af = a * f,
						be = b * e,
						bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				var ce = c * e,
						cf = c * f,
						de = d * e,
						df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				var _ce = c * e,
						_cf = c * f,
						_de = d * e,
						_df = d * f;

				te[0] = _ce - _df * b;
				te[4] = -a * f;
				te[8] = _de + _cf * b;
				te[1] = _cf + _de * b;
				te[5] = a * e;
				te[9] = _df - _ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				var _ae = a * e,
						_af = a * f,
						_be = b * e,
						_bf = b * f;

				te[0] = c * e;
				te[4] = _be * d - _af;
				te[8] = _ae * d + _bf;
				te[1] = c * f;
				te[5] = _bf * d + _ae;
				te[9] = _af * d - _be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				var ac = a * c,
						ad = a * d,
						bc = b * c,
						bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				var _ac = a * c,
						_ad = a * d,
						_bc = b * c,
						_bd = b * d;

				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = _ac * f + _bd;
				te[5] = a * e;
				te[9] = _ad * f - _bc;
				te[2] = _bc * f - _ad;
				te[6] = b * e;
				te[10] = _bd * f + _ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		};

		_proto.makeRotationFromQuaternion = function makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		};

		_proto.lookAt = function lookAt(eye, target, up) {
			var te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		};

		_proto.multiply = function multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		};

		_proto.premultiply = function premultiply(m) {
			return this.multiplyMatrices(m, this);
		};

		_proto.multiplyMatrices = function multiplyMatrices(a, b) {
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
			var a11 = ae[0],
					a12 = ae[4],
					a13 = ae[8],
					a14 = ae[12];
			var a21 = ae[1],
					a22 = ae[5],
					a23 = ae[9],
					a24 = ae[13];
			var a31 = ae[2],
					a32 = ae[6],
					a33 = ae[10],
					a34 = ae[14];
			var a41 = ae[3],
					a42 = ae[7],
					a43 = ae[11],
					a44 = ae[15];
			var b11 = be[0],
					b12 = be[4],
					b13 = be[8],
					b14 = be[12];
			var b21 = be[1],
					b22 = be[5],
					b23 = be[9],
					b24 = be[13];
			var b31 = be[2],
					b32 = be[6],
					b33 = be[10],
					b34 = be[14];
			var b41 = be[3],
					b42 = be[7],
					b43 = be[11],
					b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			var te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		};

		_proto.determinant = function determinant() {
			var te = this.elements;
			var n11 = te[0],
					n12 = te[4],
					n13 = te[8],
					n14 = te[12];
			var n21 = te[1],
					n22 = te[5],
					n23 = te[9],
					n24 = te[13];
			var n31 = te[2],
					n32 = te[6],
					n33 = te[10],
					n34 = te[14];
			var n41 = te[3],
					n42 = te[7],
					n43 = te[11],
					n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		};

		_proto.transpose = function transpose() {
			var te = this.elements;
			var tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		};

		_proto.setPosition = function setPosition(x, y, z) {
			var te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		};

		_proto.invert = function invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
					n11 = te[0],
					n21 = te[1],
					n31 = te[2],
					n41 = te[3],
					n12 = te[4],
					n22 = te[5],
					n32 = te[6],
					n42 = te[7],
					n13 = te[8],
					n23 = te[9],
					n33 = te[10],
					n43 = te[11],
					n14 = te[12],
					n24 = te[13],
					n34 = te[14],
					n44 = te[15],
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			var detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		};

		_proto.scale = function scale(v) {
			var te = this.elements;
			var x = v.x,
					y = v.y,
					z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		};

		_proto.getMaxScaleOnAxis = function getMaxScaleOnAxis() {
			var te = this.elements;
			var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		};

		_proto.makeTranslation = function makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationX = function makeRotationX(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationY = function makeRotationY(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationZ = function makeRotationZ(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationAxis = function makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var x = axis.x,
					y = axis.y,
					z = axis.z;
			var tx = t * x,
					ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeScale = function makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeShear = function makeShear(x, y, z) {
			this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.compose = function compose(position, quaternion, scale) {
			var te = this.elements;
			var x = quaternion._x,
					y = quaternion._y,
					z = quaternion._z,
					w = quaternion._w;
			var x2 = x + x,
					y2 = y + y,
					z2 = z + z;
			var xx = x * x2,
					xy = x * y2,
					xz = x * z2;
			var yy = y * y2,
					yz = y * z2,
					zz = z * z2;
			var wx = w * x2,
					wy = w * y2,
					wz = w * z2;
			var sx = scale.x,
					sy = scale.y,
					sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		};

		_proto.decompose = function decompose(position, quaternion, scale) {
			var te = this.elements;

			var sx = _v1$1.set(te[0], te[1], te[2]).length();

			var sy = _v1$1.set(te[4], te[5], te[6]).length();

			var sz = _v1$1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			var det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1.copy(this);

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;
			_m1.elements[0] *= invSX;
			_m1.elements[1] *= invSX;
			_m1.elements[2] *= invSX;
			_m1.elements[4] *= invSY;
			_m1.elements[5] *= invSY;
			_m1.elements[6] *= invSY;
			_m1.elements[8] *= invSZ;
			_m1.elements[9] *= invSZ;
			_m1.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		};

		_proto.makePerspective = function makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			var te = this.elements;
			var x = 2 * near / (right - left);
			var y = 2 * near / (top - bottom);
			var a = (right + left) / (right - left);
			var b = (top + bottom) / (top - bottom);
			var c = -(far + near) / (far - near);
			var d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		};

		_proto.makeOrthographic = function makeOrthographic(left, right, top, bottom, near, far) {
			var te = this.elements;
			var w = 1.0 / (right - left);
			var h = 1.0 / (top - bottom);
			var p = 1.0 / (far - near);
			var x = (right + left) * w;
			var y = (top + bottom) * h;
			var z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		};

		_proto.equals = function equals(matrix) {
			var te = this.elements;
			var me = matrix.elements;

			for (var i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			for (var i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		};

		return Matrix4;
	}();

	var _v1$1 = /*@__PURE__*/new Vector3();

	var _m1 = /*@__PURE__*/new Matrix4();

	var _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	var _one = /*@__PURE__*/new Vector3(1, 1, 1);

	var _x = /*@__PURE__*/new Vector3();

	var _y = /*@__PURE__*/new Vector3();

	var _z = /*@__PURE__*/new Vector3();

	var Euler = /*#__PURE__*/function () {
		function Euler(x, y, z, order) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (order === void 0) {
				order = Euler.DefaultOrder;
			}

			Object.defineProperty(this, 'isEuler', {
				value: true
			});
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		var _proto = Euler.prototype;

		_proto.set = function set(x, y, z, order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		};

		_proto.copy = function copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		};

		_proto.setFromRotationMatrix = function setFromRotationMatrix(m, order, update) {
			var clamp = MathUtils.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[0],
					m12 = te[4],
					m13 = te[8];
			var m21 = te[1],
					m22 = te[5],
					m23 = te[9];
			var m31 = te[2],
					m32 = te[6],
					m33 = te[10];
			order = order || this._order;

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update !== false) this._onChangeCallback();
			return this;
		};

		_proto.setFromQuaternion = function setFromQuaternion(q, order, update) {
			_matrix.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix, order, update);
		};

		_proto.setFromVector3 = function setFromVector3(v, order) {
			return this.set(v.x, v.y, v.z, order || this._order);
		};

		_proto.reorder = function reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$1.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$1, newOrder);
		};

		_proto.equals = function equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		};

		_proto.fromArray = function fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		};

		_proto.toVector3 = function toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		};

		_proto._onChange = function _onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		};

		_proto._onChangeCallback = function _onChangeCallback() {};

		_createClass(Euler, [{
			key: "x",
			get: function get() {
				return this._x;
			},
			set: function set(value) {
				this._x = value;

				this._onChangeCallback();
			}
		}, {
			key: "y",
			get: function get() {
				return this._y;
			},
			set: function set(value) {
				this._y = value;

				this._onChangeCallback();
			}
		}, {
			key: "z",
			get: function get() {
				return this._z;
			},
			set: function set(value) {
				this._z = value;

				this._onChangeCallback();
			}
		}, {
			key: "order",
			get: function get() {
				return this._order;
			},
			set: function set(value) {
				this._order = value;

				this._onChangeCallback();
			}
		}]);

		return Euler;
	}();

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	var _matrix = /*@__PURE__*/new Matrix4();

	var _quaternion$1 = /*@__PURE__*/new Quaternion();

	var Layers = /*#__PURE__*/function () {
		function Layers() {
			this.mask = 1 | 0;
		}

		var _proto = Layers.prototype;

		_proto.set = function set(channel) {
			this.mask = 1 << channel | 0;
		};

		_proto.enable = function enable(channel) {
			this.mask |= 1 << channel | 0;
		};

		_proto.enableAll = function enableAll() {
			this.mask = 0xffffffff | 0;
		};

		_proto.toggle = function toggle(channel) {
			this.mask ^= 1 << channel | 0;
		};

		_proto.disable = function disable(channel) {
			this.mask &= ~(1 << channel | 0);
		};

		_proto.disableAll = function disableAll() {
			this.mask = 0;
		};

		_proto.test = function test(layers) {
			return (this.mask & layers.mask) !== 0;
		};

		return Layers;
	}();

	var _object3DId = 0;

	var _v1$2 = new Vector3();

	var _q1 = new Quaternion();

	var _m1$1 = new Matrix4();

	var _target = new Vector3();

	var _position = new Vector3();

	var _scale = new Vector3();

	var _quaternion$2 = new Quaternion();

	var _xAxis = new Vector3(1, 0, 0);

	var _yAxis = new Vector3(0, 1, 0);

	var _zAxis = new Vector3(0, 0, 1);

	var _addedEvent = {
		type: 'added'
	};
	var _removedEvent = {
		type: 'removed'
	};

	function Object3D() {
		Object.defineProperty(this, 'id', {
			value: _object3DId++
		});
		this.uuid = MathUtils.generateUUID();
		this.name = '';
		this.type = 'Object3D';
		this.parent = null;
		this.children = [];
		this.up = Object3D.DefaultUp.clone();
		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3(1, 1, 1);

		function onRotationChange() {
			quaternion.setFromEuler(rotation, false);
		}

		function onQuaternionChange() {
			rotation.setFromQuaternion(quaternion, undefined, false);
		}

		rotation._onChange(onRotationChange);

		quaternion._onChange(onQuaternionChange);

		Object.defineProperties(this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		});
		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();
		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
		this.layers = new Layers();
		this.visible = true;
		this.castShadow = false;
		this.receiveShadow = false;
		this.frustumCulled = true;
		this.renderOrder = 0;
		this.animations = [];
		this.userData = {};
	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: Object3D,
		isObject3D: true,
		onBeforeRender: function onBeforeRender() {},
		onAfterRender: function onAfterRender() {},
		applyMatrix4: function applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		},
		applyQuaternion: function applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		},
		setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		},
		setRotationFromEuler: function setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		},
		setRotationFromMatrix: function setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		},
		setRotationFromQuaternion: function setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		},
		rotateOnAxis: function rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		},
		rotateOnWorldAxis: function rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		},
		rotateX: function rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		},
		rotateY: function rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		},
		rotateZ: function rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		},
		translateOnAxis: function translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$2.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$2.multiplyScalar(distance));
			return this;
		},
		translateX: function translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		},
		translateY: function translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		},
		translateZ: function translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		},
		localToWorld: function localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		},
		worldToLocal: function worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		},
		lookAt: function lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			var parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		},
		add: function add(object) {
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		},
		remove: function remove(object) {
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			var index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		},
		clear: function clear() {
			for (var i = 0; i < this.children.length; i++) {
				var object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		},
		attach: function attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			object.updateWorldMatrix(false, false);
			this.add(object);
			return this;
		},
		getObjectById: function getObjectById(id) {
			return this.getObjectByProperty('id', id);
		},
		getObjectByName: function getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		},
		getObjectByProperty: function getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (var i = 0, l = this.children.length; i < l; i++) {
				var child = this.children[i];
				var object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		},
		getWorldPosition: function getWorldPosition(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldPosition() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		},
		getWorldQuaternion: function getWorldQuaternion(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
				target = new Quaternion();
			}

			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position, target, _scale);
			return target;
		},
		getWorldScale: function getWorldScale(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldScale() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position, _quaternion$2, target);
			return target;
		},
		getWorldDirection: function getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			var e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		},
		raycast: function raycast() {},
		traverse: function traverse(callback) {
			callback(this);
			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		},
		traverseVisible: function traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		},
		traverseAncestors: function traverseAncestors(callback) {
			var parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		},
		updateMatrix: function updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		},
		updateMatrixWorld: function updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		},
		updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
			var parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				var children = this.children;

				for (var i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		},
		toJSON: function toJSON(meta) {
			// meta is a string when called from JSON.stringify
			var isRootObject = meta === undefined || typeof meta === 'string';
			var output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			var object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				var parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					var shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (var i = 0, l = shapes.length; i < l; i++) {
							var shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					var uuids = [];

					for (var _i = 0, _l = this.material.length; _i < _l; _i++) {
						uuids.push(serialize(meta.materials, this.material[_i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (var _i2 = 0; _i2 < this.children.length; _i2++) {
					object.children.push(this.children[_i2].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (var _i3 = 0; _i3 < this.animations.length; _i3++) {
					var animation = this.animations[_i3];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				var geometries = extractFromCache(meta.geometries);
				var materials = extractFromCache(meta.materials);
				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);

				var _shapes = extractFromCache(meta.shapes);

				var skeletons = extractFromCache(meta.skeletons);
				var animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (_shapes.length > 0) output.shapes = _shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				var values = [];

				for (var key in cache) {
					var data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		},
		clone: function clone(recursive) {
			return new this.constructor().copy(this, recursive);
		},
		copy: function copy(source, recursive) {
			if (recursive === void 0) {
				recursive = true;
			}

			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (var i = 0; i < source.children.length; i++) {
					var child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		}
	});

	var _vector1 = /*@__PURE__*/new Vector3();

	var _vector2 = /*@__PURE__*/new Vector3();

	var _normalMatrix = /*@__PURE__*/new Matrix3();

	var Plane = /*#__PURE__*/function () {
		function Plane(normal, constant) {
			Object.defineProperty(this, 'isPlane', {
				value: true
			}); // normal is assumed to be normalized

			this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
			this.constant = constant !== undefined ? constant : 0;
		}

		var _proto = Plane.prototype;

		_proto.set = function set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		};

		_proto.setComponents = function setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		};

		_proto.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		};

		_proto.setFromCoplanarPoints = function setFromCoplanarPoints(a, b, c) {
			var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		};

		_proto.normalize = function normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		};

		_proto.negate = function negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		};

		_proto.distanceToSphere = function distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		};

		_proto.projectPoint = function projectPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .projectPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		};

		_proto.intersectLine = function intersectLine(line, target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .intersectLine() target is now required');
				target = new Vector3();
			}

			var direction = line.delta(_vector1);
			var denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return undefined;
			}

			var t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return undefined;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		};

		_proto.intersectsLine = function intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			var startSign = this.distanceToPoint(line.start);
			var endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsPlane(this);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		};

		_proto.coplanarPoint = function coplanarPoint(target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .coplanarPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.constant);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix, optionalNormalMatrix) {
			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			var normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		};

		_proto.equals = function equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		};

		return Plane;
	}();

	var _v0$1 = /*@__PURE__*/new Vector3();

	var _v1$3 = /*@__PURE__*/new Vector3();

	var _v2$1 = /*@__PURE__*/new Vector3();

	var _v3 = /*@__PURE__*/new Vector3();

	var _vab = /*@__PURE__*/new Vector3();

	var _vac = /*@__PURE__*/new Vector3();

	var _vbc = /*@__PURE__*/new Vector3();

	var _vap = /*@__PURE__*/new Vector3();

	var _vbp = /*@__PURE__*/new Vector3();

	var _vcp = /*@__PURE__*/new Vector3();

	var Triangle = /*#__PURE__*/function () {
		function Triangle(a, b, c) {
			this.a = a !== undefined ? a : new Vector3();
			this.b = b !== undefined ? b : new Vector3();
			this.c = c !== undefined ? c : new Vector3();
		}

		Triangle.getNormal = function getNormal(a, b, c, target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getNormal() target is now required');
				target = new Vector3();
			}

			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			var targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		;

		Triangle.getBarycoord = function getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$3.subVectors(b, a);

			_v2$1.subVectors(point, a);

			var dot00 = _v0$1.dot(_v0$1);

			var dot01 = _v0$1.dot(_v1$3);

			var dot02 = _v0$1.dot(_v2$1);

			var dot11 = _v1$3.dot(_v1$3);

			var dot12 = _v1$3.dot(_v2$1);

			var denom = dot00 * dot11 - dot01 * dot01;

			if (target === undefined) {
				console.warn('THREE.Triangle: .getBarycoord() target is now required');
				target = new Vector3();
			} // collinear or singular triangle


			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			var invDenom = 1 / denom;
			var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		};

		Triangle.containsPoint = function containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3);
			return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
		};

		Triangle.getUV = function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3.x);
			target.addScaledVector(uv2, _v3.y);
			target.addScaledVector(uv3, _v3.z);
			return target;
		};

		Triangle.isFrontFacing = function isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$3.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
		};

		var _proto = Triangle.prototype;

		_proto.set = function set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		};

		_proto.setFromPointsAndIndices = function setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		};

		_proto.getArea = function getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$3.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$3).length() * 0.5;
		};

		_proto.getMidpoint = function getMidpoint(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getMidpoint() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		};

		_proto.getNormal = function getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		};

		_proto.getPlane = function getPlane(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getPlane() target is now required');
				target = new Plane();
			}

			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		};

		_proto.getBarycoord = function getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		};

		_proto.getUV = function getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		};

		_proto.containsPoint = function containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		};

		_proto.isFrontFacing = function isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsTriangle(this);
		};

		_proto.closestPointToPoint = function closestPointToPoint(p, target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			var a = this.a,
					b = this.b,
					c = this.c;
			var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			var d1 = _vab.dot(_vap);

			var d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			var d3 = _vab.dot(_vbp);

			var d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			var vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			var d5 = _vab.dot(_vcp);

			var d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			var vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			var va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			var denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		};

		_proto.equals = function equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		};

		return Triangle;
	}();

	var _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	var _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	var _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	var Color = /*#__PURE__*/function () {
		function Color(r, g, b) {
			Object.defineProperty(this, 'isColor', {
				value: true
			});

			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		var _proto = Color.prototype;

		_proto.set = function set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		};

		_proto.setHex = function setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		};

		_proto.setRGB = function setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		};

		_proto.setHSL = function setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = MathUtils.euclideanModulo(h, 1);
			s = MathUtils.clamp(s, 0, 1);
			l = MathUtils.clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				var q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		};

		_proto.setStyle = function setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			var m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				var color;
				var name = m[1];
				var components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat(color[1]) / 360;
							var s = parseInt(color[2], 10) / 100;
							var l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				var hex = m[1];
				var size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		};

		_proto.setColorName = function setColorName(style) {
			// color keywords
			var hex = _colorKeywords[style];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this.r, this.g, this.b);
		};

		_proto.copy = function copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		};

		_proto.copyGammaToLinear = function copyGammaToLinear(color, gammaFactor) {
			if (gammaFactor === void 0) {
				gammaFactor = 2.0;
			}

			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		};

		_proto.copyLinearToGamma = function copyLinearToGamma(color, gammaFactor) {
			if (gammaFactor === void 0) {
				gammaFactor = 2.0;
			}

			var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		};

		_proto.convertGammaToLinear = function convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		};

		_proto.convertLinearToGamma = function convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		};

		_proto.copySRGBToLinear = function copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		};

		_proto.copyLinearToSRGB = function copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		};

		_proto.convertSRGBToLinear = function convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		};

		_proto.convertLinearToSRGB = function convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		};

		_proto.getHex = function getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		};

		_proto.getHexString = function getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		};

		_proto.getHSL = function getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			if (target === undefined) {
				console.warn('THREE.Color: .getHSL() target is now required');
				target = {
					h: 0,
					s: 0,
					l: 0
				};
			}

			var r = this.r,
					g = this.g,
					b = this.b;
			var max = Math.max(r, g, b);
			var min = Math.min(r, g, b);
			var hue, saturation;
			var lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				var delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		};

		_proto.getStyle = function getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		};

		_proto.offsetHSL = function offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		};

		_proto.add = function add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		};

		_proto.addColors = function addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		};

		_proto.sub = function sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		};

		_proto.multiply = function multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		};

		_proto.lerp = function lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		};

		_proto.lerpColors = function lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		};

		_proto.lerpHSL = function lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
			var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
			var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		};

		_proto.equals = function equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		};

		_proto.toJSON = function toJSON() {
			return this.getHex();
		};

		return Color;
	}();

	Color.NAMES = _colorKeywords;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	var Face3 = /*#__PURE__*/function () {
		function Face3(a, b, c, normal, color, materialIndex) {
			if (materialIndex === void 0) {
				materialIndex = 0;
			}

			this.a = a;
			this.b = b;
			this.c = c;
			this.normal = normal && normal.isVector3 ? normal : new Vector3();
			this.vertexNormals = Array.isArray(normal) ? normal : [];
			this.color = color && color.isColor ? color : new Color();
			this.vertexColors = Array.isArray(color) ? color : [];
			this.materialIndex = materialIndex;
		}

		var _proto = Face3.prototype;

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
			this.normal.copy(source.normal);
			this.color.copy(source.color);
			this.materialIndex = source.materialIndex;

			for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
				this.vertexNormals[i] = source.vertexNormals[i].clone();
			}

			for (var _i = 0, _il = source.vertexColors.length; _i < _il; _i++) {
				this.vertexColors[_i] = source.vertexColors[_i].clone();
			}

			return this;
		};

		return Face3;
	}();

	var materialId = 0;

	function Material() {
		Object.defineProperty(this, 'id', {
			value: materialId++
		});
		this.uuid = MathUtils.generateUUID();
		this.name = '';
		this.type = 'Material';
		this.fog = true;
		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = false;
		this.opacity = 1;
		this.transparent = false;
		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;
		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
		this.shadowSide = null;
		this.colorWrite = true;
		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
		this.dithering = false;
		this.alphaTest = 0;
		this.premultipliedAlpha = false;
		this.visible = true;
		this.toneMapped = true;
		this.userData = {};
		this.version = 0;
	}

	Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: Material,
		isMaterial: true,
		onBeforeCompile: function onBeforeCompile()
		/* shaderobject, renderer */
		{},
		customProgramCacheKey: function customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		},
		setValues: function setValues(values) {
			if (values === undefined) return;

			for (var key in values) {
				var newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				var currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		},
		toJSON: function toJSON(meta) {
			var isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
			if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

				data.refractionRatio = this.refractionRatio;
				if (this.combine !== undefined) data.combine = this.combine;
				if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			}

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.size !== undefined) data.size = this.size;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.morphTargets === true) data.morphTargets = true;
			if (this.morphNormals === true) data.morphNormals = true;
			if (this.skinning === true) data.skinning = true;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				var values = [];

				for (var key in cache) {
					var _data = cache[key];
					delete _data.metadata;
					values.push(_data);
				}

				return values;
			}

			if (isRoot) {
				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		},
		copy: function copy(source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			var srcPlanes = source.clippingPlanes;
			var dstPlanes = null;

			if (srcPlanes !== null) {
				var n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (var i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		},
		dispose: function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	});
	Object.defineProperty(Material.prototype, 'needsUpdate', {
		set: function set(value) {
			if (value === true) this.version++;
		}
	});

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshBasicMaterial';
		this.color = new Color(0xffffff); // emissive

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.skinning = false;
		this.morphTargets = false;
		this.setValues(parameters);
	}

	MeshBasicMaterial.prototype = Object.create(Material.prototype);
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		return this;
	};

	var _vector$3 = new Vector3();

	var _vector2$1 = new Vector2();

	function BufferAttribute(array, itemSize, normalized) {
		if (Array.isArray(array)) {
			throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		}

		this.name = '';
		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;
		this.usage = StaticDrawUsage;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0;
	}

	Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
		set: function set(value) {
			if (value === true) this.version++;
		}
	});
	Object.assign(BufferAttribute.prototype, {
		isBufferAttribute: true,
		onUploadCallback: function onUploadCallback() {},
		setUsage: function setUsage(value) {
			this.usage = value;
			return this;
		},
		copy: function copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		},
		copyAt: function copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (var i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		},
		copyArray: function copyArray(array) {
			this.array.set(array);
			return this;
		},
		copyColorsArray: function copyColorsArray(colors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = colors.length; i < l; i++) {
				var color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		},
		copyVector2sArray: function copyVector2sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		},
		copyVector3sArray: function copyVector3sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		},
		copyVector4sArray: function copyVector4sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		},
		applyMatrix3: function applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (var i = 0, l = this.count; i < l; i++) {
					_vector2$1.fromBufferAttribute(this, i);

					_vector2$1.applyMatrix3(m);

					this.setXY(i, _vector2$1.x, _vector2$1.y);
				}
			} else if (this.itemSize === 3) {
				for (var _i = 0, _l = this.count; _i < _l; _i++) {
					_vector$3.fromBufferAttribute(this, _i);

					_vector$3.applyMatrix3(m);

					this.setXYZ(_i, _vector$3.x, _vector$3.y, _vector$3.z);
				}
			}

			return this;
		},
		applyMatrix4: function applyMatrix4(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.applyMatrix4(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		},
		applyNormalMatrix: function applyNormalMatrix(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.applyNormalMatrix(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		},
		transformDirection: function transformDirection(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.transformDirection(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		},
		set: function set(value, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.array.set(value, offset);
			return this;
		},
		getX: function getX(index) {
			return this.array[index * this.itemSize];
		},
		setX: function setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		},
		getY: function getY(index) {
			return this.array[index * this.itemSize + 1];
		},
		setY: function setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		},
		getZ: function getZ(index) {
			return this.array[index * this.itemSize + 2];
		},
		setZ: function setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		},
		getW: function getW(index) {
			return this.array[index * this.itemSize + 3];
		},
		setW: function setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		},
		setXY: function setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		},
		setXYZ: function setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		},
		setXYZW: function setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		},
		onUpload: function onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		},
		clone: function clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		},
		toJSON: function toJSON() {
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
		}
	}); //

	function Int8BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
	}

	Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

	function Uint8BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
	}

	Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

	function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
	}

	Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

	function Int16BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
	}

	Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

	function Uint16BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
	}

	Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

	function Int32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
	}

	Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

	function Uint32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
	}

	Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

	function Float16BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
	}

	Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	function Float32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
	}

	Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

	function Float64BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
	}

	Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; //

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		var max = array[0];

		for (var i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	var _id = 0;

	var _m1$2 = new Matrix4();

	var _obj = new Object3D();

	var _offset = new Vector3();

	var _box$2 = new Box3();

	var _boxMorphTargets = new Box3();

	var _vector$4 = new Vector3();

	function BufferGeometry() {
		Object.defineProperty(this, 'id', {
			value: _id++
		});
		this.uuid = MathUtils.generateUUID();
		this.name = '';
		this.type = 'BufferGeometry';
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.morphTargetsRelative = false;
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		this.drawRange = {
			start: 0,
			count: Infinity
		};
		this.userData = {};
	}

	BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: BufferGeometry,
		isBufferGeometry: true,
		getIndex: function getIndex() {
			return this.index;
		},
		setIndex: function setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		},
		getAttribute: function getAttribute(name) {
			return this.attributes[name];
		},
		setAttribute: function setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		},
		deleteAttribute: function deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		},
		hasAttribute: function hasAttribute(name) {
			return this.attributes[name] !== undefined;
		},
		addGroup: function addGroup(start, count, materialIndex) {
			if (materialIndex === void 0) {
				materialIndex = 0;
			}

			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		},
		clearGroups: function clearGroups() {
			this.groups = [];
		},
		setDrawRange: function setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		},
		applyMatrix4: function applyMatrix4(matrix) {
			var position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			var normal = this.attributes.normal;

			if (normal !== undefined) {
				var normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			var tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		},
		rotateX: function rotateX(angle) {
			// rotate geometry around world x-axis
			_m1$2.makeRotationX(angle);

			this.applyMatrix4(_m1$2);
			return this;
		},
		rotateY: function rotateY(angle) {
			// rotate geometry around world y-axis
			_m1$2.makeRotationY(angle);

			this.applyMatrix4(_m1$2);
			return this;
		},
		rotateZ: function rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1$2.makeRotationZ(angle);

			this.applyMatrix4(_m1$2);
			return this;
		},
		translate: function translate(x, y, z) {
			// translate geometry
			_m1$2.makeTranslation(x, y, z);

			this.applyMatrix4(_m1$2);
			return this;
		},
		scale: function scale(x, y, z) {
			// scale geometry
			_m1$2.makeScale(x, y, z);

			this.applyMatrix4(_m1$2);
			return this;
		},
		lookAt: function lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		},
		center: function center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		},
		setFromPoints: function setFromPoints(points) {
			var position = [];

			for (var i = 0, l = points.length; i < l; i++) {
				var point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		},
		computeBoundingBox: function computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
						var morphAttribute = morphAttributesPosition[i];

						_box$2.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$4.addVectors(this.boundingBox.min, _box$2.min);

							this.boundingBox.expandByPoint(_vector$4);

							_vector$4.addVectors(this.boundingBox.max, _box$2.max);

							this.boundingBox.expandByPoint(_vector$4);
						} else {
							this.boundingBox.expandByPoint(_box$2.min);
							this.boundingBox.expandByPoint(_box$2.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		},
		computeBoundingSphere: function computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				var center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
						var morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

							_box$2.expandByPoint(_vector$4);

							_vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

							_box$2.expandByPoint(_vector$4);
						} else {
							_box$2.expandByPoint(_boxMorphTargets.min);

							_box$2.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$2.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				var maxRadiusSq = 0;

				for (var _i = 0, _il = position.count; _i < _il; _i++) {
					_vector$4.fromBufferAttribute(position, _i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++) {
						var _morphAttribute = morphAttributesPosition[_i2];
						var morphTargetsRelative = this.morphTargetsRelative;

						for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
							_vector$4.fromBufferAttribute(_morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$4.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		},
		computeFaceNormals: function computeFaceNormals() {// backwards compatibility
		},
		computeTangents: function computeTangents() {
			var index = this.index;
			var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			var indices = index.array;
			var positions = attributes.position.array;
			var normals = attributes.normal.array;
			var uvs = attributes.uv.array;
			var nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			var tangents = attributes.tangent.array;
			var tan1 = [],
					tan2 = [];

			for (var i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			var vA = new Vector3(),
					vB = new Vector3(),
					vC = new Vector3(),
					uvA = new Vector2(),
					uvB = new Vector2(),
					uvC = new Vector2(),
					sdir = new Vector3(),
					tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			var groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (var _i3 = 0, il = groups.length; _i3 < il; ++_i3) {
				var group = groups[_i3];
				var start = group.start;
				var count = group.count;

				for (var j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			var tmp = new Vector3(),
					tmp2 = new Vector3();
			var n = new Vector3(),
					n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				var t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				var test = tmp2.dot(tan2[v]);
				var w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (var _i4 = 0, _il3 = groups.length; _i4 < _il3; ++_i4) {
				var _group = groups[_i4];
				var _start = _group.start;
				var _count = _group.count;

				for (var _j = _start, _jl = _start + _count; _j < _jl; _j += 3) {
					handleVertex(indices[_j + 0]);
					handleVertex(indices[_j + 1]);
					handleVertex(indices[_j + 2]);
				}
			}
		},
		computeVertexNormals: function computeVertexNormals() {
			var index = this.index;
			var positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				var normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (var i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				var pA = new Vector3(),
						pB = new Vector3(),
						pC = new Vector3();
				var nA = new Vector3(),
						nB = new Vector3(),
						nC = new Vector3();
				var cb = new Vector3(),
						ab = new Vector3(); // indexed elements

				if (index) {
					for (var _i5 = 0, _il4 = index.count; _i5 < _il4; _i5 += 3) {
						var vA = index.getX(_i5 + 0);
						var vB = index.getX(_i5 + 1);
						var vC = index.getX(_i5 + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (var _i6 = 0, _il5 = positionAttribute.count; _i6 < _il5; _i6 += 3) {
						pA.fromBufferAttribute(positionAttribute, _i6 + 0);
						pB.fromBufferAttribute(positionAttribute, _i6 + 1);
						pC.fromBufferAttribute(positionAttribute, _i6 + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(_i6 + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(_i6 + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(_i6 + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		},
		merge: function merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			var attributes = this.attributes;

			for (var key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				var attribute1 = attributes[key];
				var attributeArray1 = attribute1.array;
				var attribute2 = geometry.attributes[key];
				var attributeArray2 = attribute2.array;
				var attributeOffset = attribute2.itemSize * offset;
				var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (var i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		},
		normalizeNormals: function normalizeNormals() {
			var normals = this.attributes.normal;

			for (var i = 0, il = normals.count; i < il; i++) {
				_vector$4.fromBufferAttribute(normals, i);

				_vector$4.normalize();

				normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
			}
		},
		toNonIndexed: function toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				var array = attribute.array;
				var itemSize = attribute.itemSize;
				var normalized = attribute.normalized;
				var array2 = new array.constructor(indices.length * itemSize);
				var index = 0,
						index2 = 0;

				for (var i = 0, l = indices.length; i < l; i++) {
					index = indices[i] * itemSize;

					for (var j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			var geometry2 = new BufferGeometry();
			var indices = this.index.array;
			var attributes = this.attributes; // attributes

			for (var name in attributes) {
				var attribute = attributes[name];
				var newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			var morphAttributes = this.morphAttributes;

			for (var _name in morphAttributes) {
				var morphArray = [];
				var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

				for (var i = 0, il = morphAttribute.length; i < il; i++) {
					var _attribute = morphAttribute[i];

					var _newAttribute = convertBufferAttribute(_attribute, indices);

					morphArray.push(_newAttribute);
				}

				geometry2.morphAttributes[_name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			var groups = this.groups;

			for (var _i7 = 0, l = groups.length; _i7 < l; _i7++) {
				var group = groups[_i7];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		},
		toJSON: function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				var parameters = this.parameters;

				for (var key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			}

			data.data = {
				attributes: {}
			};
			var index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			var attributes = this.attributes;

			for (var _key in attributes) {
				var attribute = attributes[_key];
				var attributeData = attribute.toJSON(data.data);
				if (attribute.name !== '') attributeData.name = attribute.name;
				data.data.attributes[_key] = attributeData;
			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for (var _key2 in this.morphAttributes) {
				var attributeArray = this.morphAttributes[_key2];
				var array = [];

				for (var i = 0, il = attributeArray.length; i < il; i++) {
					var _attribute2 = attributeArray[i];

					var _attributeData = _attribute2.toJSON(data.data);

					if (_attribute2.name !== '') _attributeData.name = _attribute2.name;
					array.push(_attributeData);
				}

				if (array.length > 0) {
					morphAttributes[_key2] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			var groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			var boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		},
		clone: function clone() {
			/*
			 // Handle primitives
				 const parameters = this.parameters;
				 if ( parameters !== undefined ) {
				 const values = [];
				 for ( const key in parameters ) {
				 values.push( parameters[ key ] );
				 }
				 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
				 }
				 return new this.constructor().copy( this );
			 */
			return new BufferGeometry().copy(this);
		},
		copy: function copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			var data = {}; // name

			this.name = source.name; // index

			var index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			var attributes = source.attributes;

			for (var name in attributes) {
				var attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			var morphAttributes = source.morphAttributes;

			for (var _name2 in morphAttributes) {
				var array = [];
				var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

				for (var i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[_name2] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			var groups = source.groups;

			for (var _i8 = 0, _l = groups.length; _i8 < _l; _i8++) {
				var group = groups[_i8];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			var boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			var boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData;
			return this;
		},
		dispose: function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	});

	var _inverseMatrix = new Matrix4();

	var _ray = new Ray();

	var _sphere = new Sphere();

	var _vA = new Vector3();

	var _vB = new Vector3();

	var _vC = new Vector3();

	var _tempA = new Vector3();

	var _tempB = new Vector3();

	var _tempC = new Vector3();

	var _morphA = new Vector3();

	var _morphB = new Vector3();

	var _morphC = new Vector3();

	var _uvA = new Vector2();

	var _uvB = new Vector2();

	var _uvC = new Vector2();

	var _intersectionPoint = new Vector3();

	var _intersectionPointWorld = new Vector3();

	function Mesh(geometry, material) {
		if (geometry === void 0) {
			geometry = new BufferGeometry();
		}

		if (material === void 0) {
			material = new MeshBasicMaterial();
		}

		Object3D.call(this);
		this.type = 'Mesh';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}

	Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Mesh,
		isMesh: true,
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		},
		updateMorphTargets: function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		},
		raycast: function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray.intersectsBox(geometry.boundingBox) === false) return;
			}

			var intersection;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var position = geometry.attributes.position;
				var morphPosition = geometry.morphAttributes.position;
				var morphTargetsRelative = geometry.morphTargetsRelative;
				var uv = geometry.attributes.uv;
				var uv2 = geometry.attributes.uv2;
				var groups = geometry.groups;
				var drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (var i = 0, il = groups.length; i < il; i++) {
							var group = groups[i];
							var groupMaterial = material[group.materialIndex];
							var start = Math.max(group.start, drawRange.start);
							var end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (var j = start, jl = end; j < jl; j += 3) {
								var a = index.getX(j);
								var b = index.getX(j + 1);
								var c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						var _start = Math.max(0, drawRange.start);

						var _end = Math.min(index.count, drawRange.start + drawRange.count);

						for (var _i = _start, _il = _end; _i < _il; _i += 3) {
							var _a = index.getX(_i);

							var _b = index.getX(_i + 1);

							var _c = index.getX(_i + 2);

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);

							if (intersection) {
								intersection.faceIndex = Math.floor(_i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {
							var _group = groups[_i2];
							var _groupMaterial = material[_group.materialIndex];

							var _start2 = Math.max(_group.start, drawRange.start);

							var _end2 = Math.min(_group.start + _group.count, drawRange.start + drawRange.count);

							for (var _j = _start2, _jl = _end2; _j < _jl; _j += 3) {
								var _a2 = _j;

								var _b2 = _j + 1;

								var _c2 = _j + 2;

								intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);

								if (intersection) {
									intersection.faceIndex = Math.floor(_j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = _group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						var _start3 = Math.max(0, drawRange.start);

						var _end3 = Math.min(position.count, drawRange.start + drawRange.count);

						for (var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3) {
							var _a3 = _i3;

							var _b3 = _i3 + 1;

							var _c3 = _i3 + 2;

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);

							if (intersection) {
								intersection.faceIndex = Math.floor(_i3 / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}
	});

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		var intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA.fromBufferAttribute(position, a);

		_vB.fromBufferAttribute(position, b);

		_vC.fromBufferAttribute(position, c);

		var morphInfluences = object.morphTargetInfluences;

		if (material.morphTargets && morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (var i = 0, il = morphPosition.length; i < il; i++) {
				var influence = morphInfluences[i];
				var morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA), influence);

					_morphB.addScaledVector(_tempB.sub(_vB), influence);

					_morphC.addScaledVector(_tempC.sub(_vC), influence);
				}
			}

			_vA.add(_morphA);

			_vB.add(_morphB);

			_vC.add(_morphC);
		}

		if (object.isSkinnedMesh) {
			object.boneTransform(a, _vA);
			object.boneTransform(b, _vB);
			object.boneTransform(c, _vC);
		}

		var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA.fromBufferAttribute(uv, a);

				_uvB.fromBufferAttribute(uv, b);

				_uvC.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
			}

			if (uv2) {
				_uvA.fromBufferAttribute(uv2, a);

				_uvB.fromBufferAttribute(uv2, b);

				_uvC.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
			}

			var face = new Face3(a, b, c);
			Triangle.getNormal(_vA, _vB, _vC, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	var BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(BoxGeometry, _BufferGeometry);

		function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
			var _this;

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (depth === void 0) {
				depth = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 1;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (depthSegments === void 0) {
				depthSegments = 1;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'BoxGeometry';
			_this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = _assertThisInitialized(_this); // segments


			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var numberOfVertices = 0;
			var groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
				var vertexCounter = 0;
				var groupCount = 0;
				var vector = new Vector3(); // generate vertices, normals and uvs

				for (var iy = 0; iy < gridY1; iy++) {
					var y = iy * segmentHeight - heightHalf;

					for (var ix = 0; ix < gridX1; ix++) {
						var x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (var _iy = 0; _iy < gridY; _iy++) {
					for (var _ix = 0; _ix < gridX; _ix++) {
						var a = numberOfVertices + _ix + gridX1 * _iy;
						var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
						var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
						var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}

			return _this;
		}

		return BoxGeometry;
	}(BufferGeometry);

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		var dst = {};

		for (var u in src) {
			dst[u] = {};

			for (var p in src[u]) {
				var property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		var merged = {};

		for (var u = 0; u < uniforms.length; u++) {
			var tmp = cloneUniforms(uniforms[u]);

			for (var p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	var UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial(parameters) {
		Material.call(this);
		this.type = 'ShaderMaterial';
		this.defines = {};
		this.uniforms = {};
		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;
		this.linewidth = 1;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets

		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false,
			// set to use derivatives
			fragDepth: false,
			// set to use fragment depth values
			drawBuffers: false,
			// set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD

		}; // When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.

		this.defaultAttributeValues = {
			'color': [1, 1, 1],
			'uv': [0, 0],
			'uv2': [0, 0]
		};
		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;
		this.glslVersion = null;

		if (parameters !== undefined) {
			if (parameters.attributes !== undefined) {
				console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
			}

			this.setValues(parameters);
		}
	}

	ShaderMaterial.prototype = Object.create(Material.prototype);
	ShaderMaterial.prototype.constructor = ShaderMaterial;
	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
		this.uniforms = cloneUniforms(source.uniforms);
		this.defines = Object.assign({}, source.defines);
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.lights = source.lights;
		this.clipping = source.clipping;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		this.extensions = Object.assign({}, source.extensions);
		this.glslVersion = source.glslVersion;
		return this;
	};

	ShaderMaterial.prototype.toJSON = function (meta) {
		var data = Material.prototype.toJSON.call(this, meta);
		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for (var name in this.uniforms) {
			var uniform = this.uniforms[name];
			var value = uniform.value;

			if (value && value.isTexture) {
				data.uniforms[name] = {
					type: 't',
					value: value.toJSON(meta).uuid
				};
			} else if (value && value.isColor) {
				data.uniforms[name] = {
					type: 'c',
					value: value.getHex()
				};
			} else if (value && value.isVector2) {
				data.uniforms[name] = {
					type: 'v2',
					value: value.toArray()
				};
			} else if (value && value.isVector3) {
				data.uniforms[name] = {
					type: 'v3',
					value: value.toArray()
				};
			} else if (value && value.isVector4) {
				data.uniforms[name] = {
					type: 'v4',
					value: value.toArray()
				};
			} else if (value && value.isMatrix3) {
				data.uniforms[name] = {
					type: 'm3',
					value: value.toArray()
				};
			} else if (value && value.isMatrix4) {
				data.uniforms[name] = {
					type: 'm4',
					value: value.toArray()
				};
			} else {
				data.uniforms[name] = {
					value: value
				}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
			}
		}

		if (Object.keys(this.defines).length > 0) data.defines = this.defines;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
		var extensions = {};

		for (var key in this.extensions) {
			if (this.extensions[key] === true) extensions[key] = true;
		}

		if (Object.keys(extensions).length > 0) data.extensions = extensions;
		return data;
	};

	function Camera() {
		Object3D.call(this);
		this.type = 'Camera';
		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
	}

	Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Camera,
		isCamera: true,
		copy: function copy(source, recursive) {
			Object3D.prototype.copy.call(this, source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		},
		getWorldDirection: function getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Camera: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			var e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		},
		updateMatrixWorld: function updateMatrixWorld(force) {
			Object3D.prototype.updateMatrixWorld.call(this, force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		},
		updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
			Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		}
	});

	function PerspectiveCamera(fov, aspect, near, far) {
		if (fov === void 0) {
			fov = 50;
		}

		if (aspect === void 0) {
			aspect = 1;
		}

		if (near === void 0) {
			near = 0.1;
		}

		if (far === void 0) {
			far = 2000;
		}

		Camera.call(this);
		this.type = 'PerspectiveCamera';
		this.fov = fov;
		this.zoom = 1;
		this.near = near;
		this.far = far;
		this.focus = 10;
		this.aspect = aspect;
		this.view = null;
		this.filmGauge = 35; // width of the film (default in millimeters)

		this.filmOffset = 0; // horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();
	}

	PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
		constructor: PerspectiveCamera,
		isPerspectiveCamera: true,
		copy: function copy(source, recursive) {
			Camera.prototype.copy.call(this, source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function getFocalLength() {
			var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		},
		getEffectiveFOV: function getEffectiveFOV() {
			return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
		},
		getFilmWidth: function getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		},
		getFilmHeight: function getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		},
		clearViewOffset: function clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		},
		updateProjectionMatrix: function updateProjectionMatrix() {
			var near = this.near;
			var top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
			var height = 2 * top;
			var width = this.aspect * height;
			var left = -0.5 * width;
			var view = this.view;

			if (this.view !== null && this.view.enabled) {
				var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			var skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		},
		toJSON: function toJSON(meta) {
			var data = Object3D.prototype.toJSON.call(this, meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}
	});

	var fov = 90,
			aspect = 1;

	function CubeCamera(near, far, renderTarget) {
		Object3D.call(this);
		this.type = 'CubeCamera';

		if (renderTarget.isWebGLCubeRenderTarget !== true) {
			console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
			return;
		}

		this.renderTarget = renderTarget;
		var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
		cameraPX.layers = this.layers;
		cameraPX.up.set(0, -1, 0);
		cameraPX.lookAt(new Vector3(1, 0, 0));
		this.add(cameraPX);
		var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
		cameraNX.layers = this.layers;
		cameraNX.up.set(0, -1, 0);
		cameraNX.lookAt(new Vector3(-1, 0, 0));
		this.add(cameraNX);
		var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
		cameraPY.layers = this.layers;
		cameraPY.up.set(0, 0, 1);
		cameraPY.lookAt(new Vector3(0, 1, 0));
		this.add(cameraPY);
		var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
		cameraNY.layers = this.layers;
		cameraNY.up.set(0, 0, -1);
		cameraNY.lookAt(new Vector3(0, -1, 0));
		this.add(cameraNY);
		var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.layers = this.layers;
		cameraPZ.up.set(0, -1, 0);
		cameraPZ.lookAt(new Vector3(0, 0, 1));
		this.add(cameraPZ);
		var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.layers = this.layers;
		cameraNZ.up.set(0, -1, 0);
		cameraNZ.lookAt(new Vector3(0, 0, -1));
		this.add(cameraNZ);

		this.update = function (renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			var currentXrEnabled = renderer.xr.enabled;
			var currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		};
	}

	CubeCamera.prototype = Object.create(Object3D.prototype);
	CubeCamera.prototype.constructor = CubeCamera;

	function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;
		Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.flipY = false; // Why CubeTexture._needsFlipEnvMap is necessary:
		//
		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		// when using WebGLCubeRenderTarget.texture as a cube texture.

		this._needsFlipEnvMap = true;
	}

	CubeTexture.prototype = Object.create(Texture.prototype);
	CubeTexture.prototype.constructor = CubeTexture;
	CubeTexture.prototype.isCubeTexture = true;
	Object.defineProperty(CubeTexture.prototype, 'images', {
		get: function get() {
			return this.image;
		},
		set: function set(value) {
			this.image = value;
		}
	});

	var WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
		_inheritsLoose(WebGLCubeRenderTarget, _WebGLRenderTarget);

		function WebGLCubeRenderTarget(size, options, dummy) {
			var _this;

			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			_this = _WebGLRenderTarget.call(this, size, size, options) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'isWebGLCubeRenderTarget', {
				value: true
			});
			options = options || {};
			_this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			_this.texture._needsFlipEnvMap = false;
			return _this;
		}

		var _proto = WebGLCubeRenderTarget.prototype;

		_proto.fromEquirectangularTexture = function fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			var shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
				fragmentShader:
				/* glsl */
				"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
			};
			var geometry = new BoxGeometry(5, 5, 5);
			var material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			var mesh = new Mesh(geometry, material);
			var currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			var camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		};

		_proto.clear = function clear(renderer, color, depth, stencil) {
			var currentRenderTarget = renderer.getRenderTarget();

			for (var i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		};

		return WebGLCubeRenderTarget;
	}(WebGLRenderTarget);

	function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.image = {
			data: data || null,
			width: width || 1,
			height: height || 1
		};
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
		this.needsUpdate = true;
	}

	DataTexture.prototype = Object.create(Texture.prototype);
	DataTexture.prototype.constructor = DataTexture;
	DataTexture.prototype.isDataTexture = true;

	var _sphere$1 = /*@__PURE__*/new Sphere();

	var _vector$5 = /*@__PURE__*/new Vector3();

	var Frustum = /*#__PURE__*/function () {
		function Frustum(p0, p1, p2, p3, p4, p5) {
			this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
		}

		var _proto = Frustum.prototype;

		_proto.set = function set(p0, p1, p2, p3, p4, p5) {
			var planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(frustum) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		};

		_proto.setFromProjectionMatrix = function setFromProjectionMatrix(m) {
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[0],
					me1 = me[1],
					me2 = me[2],
					me3 = me[3];
			var me4 = me[4],
					me5 = me[5],
					me6 = me[6],
					me7 = me[7];
			var me8 = me[8],
					me9 = me[9],
					me10 = me[10],
					me11 = me[11];
			var me12 = me[12],
					me13 = me[13],
					me14 = me[14],
					me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		};

		_proto.intersectsObject = function intersectsObject(object) {
			var geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$1);
		};

		_proto.intersectsSprite = function intersectsSprite(sprite) {
			_sphere$1.center.set(0, 0, 0);

			_sphere$1.radius = 0.7071067811865476;

			_sphere$1.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$1);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = -sphere.radius;

			for (var i = 0; i < 6; i++) {
				var distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				var plane = planes[i]; // corner at max distance

				_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$5) < 0) {
					return false;
				}
			}

			return true;
		};

		_proto.containsPoint = function containsPoint(point) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		};

		return Frustum;
	}();

	function WebGLAnimation() {
		var context = null;
		var isAnimating = false;
		var animationLoop = null;
		var requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function start() {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function stop() {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function setAnimationLoop(callback) {
				animationLoop = callback;
			},
			setContext: function setContext(value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			var array = attribute.array;
			var usage = attribute.usage;
			var buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			var type = 5126;

			if (array instanceof Float32Array) {
				type = 5126;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = 5131;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = 5123;
				}
			} else if (array instanceof Int16Array) {
				type = 5122;
			} else if (array instanceof Uint32Array) {
				type = 5125;
			} else if (array instanceof Int32Array) {
				type = 5124;
			} else if (array instanceof Int8Array) {
				type = 5120;
			} else if (array instanceof Uint8Array) {
				type = 5121;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			var array = attribute.array;
			var updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			var data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				var cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			var data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	var PlaneGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(PlaneGeometry, _BufferGeometry);

		function PlaneGeometry(width, height, widthSegments, heightSegments) {
			var _this;

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 1;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'PlaneGeometry';
			_this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			var width_half = width / 2;
			var height_half = height / 2;
			var gridX = Math.floor(widthSegments);
			var gridY = Math.floor(heightSegments);
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
			var segment_width = width / gridX;
			var segment_height = height / gridY; //

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			for (var iy = 0; iy < gridY1; iy++) {
				var y = iy * segment_height - height_half;

				for (var ix = 0; ix < gridX1; ix++) {
					var x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (var _iy = 0; _iy < gridY; _iy++) {
				for (var _ix = 0; _ix < gridX; _ix++) {
					var a = _ix + gridX1 * _iy;
					var b = _ix + gridX1 * (_iy + 1);
					var c = _ix + 1 + gridX1 * (_iy + 1);
					var d = _ix + 1 + gridX1 * _iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		return PlaneGeometry;
	}(BufferGeometry);

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

	var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmissionmap_fragment: transmissionmap_fragment,
		transmissionmap_pars_fragment: transmissionmap_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			refractionRatio: {
				value: 0.98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	var ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: new Color(0x000000)
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		var clearColor = new Color(0x000000);
		var clearAlpha = 0;
		var planeMesh;
		var boxMesh;
		var currentBackground = null;
		var currentBackgroundVersion = 0;
		var currentTonemapping = null;

		function render(renderList, scene, camera, forceClear) {
			var background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			var xr = renderer.xr;
			var session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function get() {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				if (background.isWebGLCubeRenderTarget) {
					// TODO Deprecate
					background = background.texture;
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function get() {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function getClearColor() {
				return clearColor;
			},
			setClearColor: function setClearColor(color, alpha) {
				if (alpha === void 0) {
					alpha = 1;
				}

				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function getClearAlpha() {
				return clearAlpha;
			},
			setClearAlpha: function setClearAlpha(alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		var maxVertexAttributes = gl.getParameter(34921);
		var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		var vaoAvailable = capabilities.isWebGL2 || extension !== null;
		var bindingStates = {};
		var defaultState = createBindingState(null);
		var currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			var updateBuffers = false;

			if (vaoAvailable) {
				var state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				var wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, 34963);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(34963, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			var wireframe = material.wireframe === true;
			var programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			var stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			var state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			var newAttributes = [];
			var enabledAttributes = [];
			var attributeDivisors = [];

			for (var i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			var cachedAttributes = currentState.attributes;
			var geometryAttributes = geometry.attributes;
			var attributesNum = 0;

			for (var key in geometryAttributes) {
				var cachedAttribute = cachedAttributes[key];
				var geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			var cache = {};
			var attributes = geometry.attributes;
			var attributesNum = 0;

			for (var key in attributes) {
				var attribute = attributes[key];
				var data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			var newAttributes = currentState.newAttributes;

			for (var i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;
			var attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				var _extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

				_extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);

				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;

			for (var i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			var geometryAttributes = geometry.attributes;
			var programAttributes = program.getAttributes();
			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for (var name in programAttributes) {
				var programAttribute = programAttributes[name];

				if (programAttribute >= 0) {
					var geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {
						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;
						var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(34962, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(34962, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
						}
					} else if (name === 'instanceMatrix') {
						var _attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore


						if (_attribute === undefined) continue;
						var _buffer = _attribute.buffer;
						var _type = _attribute.type;
						enableAttributeAndDivisor(programAttribute + 0, 1);
						enableAttributeAndDivisor(programAttribute + 1, 1);
						enableAttributeAndDivisor(programAttribute + 2, 1);
						enableAttributeAndDivisor(programAttribute + 3, 1);
						gl.bindBuffer(34962, _buffer);
						gl.vertexAttribPointer(programAttribute + 0, 4, _type, false, 64, 0);
						gl.vertexAttribPointer(programAttribute + 1, 4, _type, false, 64, 16);
						gl.vertexAttribPointer(programAttribute + 2, 4, _type, false, 64, 32);
						gl.vertexAttribPointer(programAttribute + 3, 4, _type, false, 64, 48);
					} else if (name === 'instanceColor') {
						var _attribute2 = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore


						if (_attribute2 === undefined) continue;
						var _buffer2 = _attribute2.buffer;
						var _type2 = _attribute2.type;
						enableAttributeAndDivisor(programAttribute, 1);
						gl.bindBuffer(34962, _buffer2);
						gl.vertexAttribPointer(programAttribute, 3, _type2, false, 12, 0);
					} else if (materialDefaultAttributeValues !== undefined) {
						var value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (var geometryId in bindingStates) {
				var programMap = bindingStates[geometryId];

				for (var programId in programMap) {
					var stateMap = programMap[programId];

					for (var wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			var programMap = bindingStates[geometry.id];

			for (var programId in programMap) {
				var stateMap = programMap[programId];

				for (var wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (var geometryId in bindingStates) {
				var programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				var stateMap = programMap[program.id];

				for (var wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			var extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		var maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;
			var extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension !== null) {
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		var maxTextures = gl.getParameter(34930);
		var maxVertexTextures = gl.getParameter(35660);
		var maxTextureSize = gl.getParameter(3379);
		var maxCubemapSize = gl.getParameter(34076);
		var maxAttributes = gl.getParameter(34921);
		var maxVertexUniforms = gl.getParameter(36347);
		var maxVaryings = gl.getParameter(36348);
		var maxFragmentUniforms = gl.getParameter(36349);
		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
		var floatVertexTextures = vertexTextures && floatFragmentTextures;
		var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
		return {
			isWebGL2: isWebGL2,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		var scope = this;
		var globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		var plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
				uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			var planes = material.clippingPlanes,
					clipIntersection = material.clipIntersection,
					clipShadows = material.clipShadows;
			var materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4;
				var dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (var i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			var nPlanes = planes !== null ? planes.length : 0;
			var dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		var cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture) {
				var mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						var cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						var image = texture.image;

						if (image && image.height > 0) {
							var currentRenderList = renderer.getRenderList();
							var currentRenderTarget = renderer.getRenderTarget();
							var renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							renderer.setRenderList(currentRenderList);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			var texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			var cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		var extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			var extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function has(name) {
				return getExtension(name) !== null;
			},
			init: function init(capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
			},
			get: function get(name) {
				var extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		var geometries = {};
		var wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			var geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (var name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			var attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (var name in geometryAttributes) {
				attributes.update(geometryAttributes[name], 34962);
			} // morph targets


			var morphAttributes = geometry.morphAttributes;

			for (var _name in morphAttributes) {
				var array = morphAttributes[_name];

				for (var i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], 34962);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			var indices = [];
			var geometryIndex = geometry.index;
			var geometryPosition = geometry.attributes.position;
			var version = 0;

			if (geometryIndex !== null) {
				var array = geometryIndex.array;
				version = geometryIndex.version;

				for (var i = 0, l = array.length; i < l; i += 3) {
					var a = array[i + 0];
					var b = array[i + 1];
					var c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				var _array = geometryPosition.array;
				version = geometryPosition.version;

				for (var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3) {
					var _a = _i + 0;

					var _b = _i + 1;

					var _c = _i + 2;

					indices.push(_a, _b, _b, _c, _c, _a);
				}
			}

			var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			var previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			var currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				var geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var mode;

		function setMode(value) {
			mode = value;
		}

		var type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			var extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		var memory = {
			geometries: 0,
			textures: 0
		};
		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case 4:
					render.triangles += instanceCount * (count / 3);
					break;

				case 1:
					render.lines += instanceCount * (count / 2);
					break;

				case 3:
					render.lines += instanceCount * (count - 1);
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl) {
		var influencesList = {};
		var morphInfluences = new Float32Array(8);
		var workInfluences = [];

		for (var i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			var length = objectInfluences === undefined ? 0 : objectInfluences.length;
			var influences = influencesList[geometry.id];

			if (influences === undefined) {
				// initialise list
				influences = [];

				for (var _i = 0; _i < length; _i++) {
					influences[_i] = [_i, 0];
				}

				influencesList[geometry.id] = influences;
			} // Collect influences


			for (var _i2 = 0; _i2 < length; _i2++) {
				var influence = influences[_i2];
				influence[0] = _i2;
				influence[1] = objectInfluences[_i2];
			}

			influences.sort(absNumericalSort);

			for (var _i3 = 0; _i3 < 8; _i3++) {
				if (_i3 < length && influences[_i3][1]) {
					workInfluences[_i3][0] = influences[_i3][0];
					workInfluences[_i3][1] = influences[_i3][1];
				} else {
					workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[_i3][1] = 0;
				}
			}

			workInfluences.sort(numericalSort);
			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
			var morphInfluencesSum = 0;

			for (var _i4 = 0; _i4 < 8; _i4++) {
				var _influence = workInfluences[_i4];
				var index = _influence[0];
				var value = _influence[1];

				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + _i4, morphTargets[index]);
					}

					if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + _i4, morphNormals[index]);
					}

					morphInfluences[_i4] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + _i4) === true) {
						geometry.deleteAttribute('morphTarget' + _i4);
					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + _i4) === true) {
						geometry.deleteAttribute('morphNormal' + _i4);
					}

					morphInfluences[_i4] = 0;
				}
			} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


			var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		var updateMap = new WeakMap();

		function update(object) {
			var frame = info.render.frame;
			var geometry = object.geometry;
			var buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, 34962);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, 34962);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			var instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	function DataTexture2DArray(data, width, height, depth) {
		if (data === void 0) {
			data = null;
		}

		if (width === void 0) {
			width = 1;
		}

		if (height === void 0) {
			height = 1;
		}

		if (depth === void 0) {
			depth = 1;
		}

		Texture.call(this, null);
		this.image = {
			data: data,
			width: width,
			height: height,
			depth: depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.needsUpdate = true;
	}

	DataTexture2DArray.prototype = Object.create(Texture.prototype);
	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	function DataTexture3D(data, width, height, depth) {
		if (data === void 0) {
			data = null;
		}

		if (width === void 0) {
			width = 1;
		}

		if (height === void 0) {
			height = 1;
		}

		if (depth === void 0) {
			depth = 1;
		}

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839
		Texture.call(this, null);
		this.image = {
			data: data,
			width: width,
			height: height,
			depth: depth
		};
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
		this.wrapR = ClampToEdgeWrapping;
		this.generateMipmaps = false;
		this.flipY = false;
		this.needsUpdate = true;
	}

	DataTexture3D.prototype = Object.create(Texture.prototype);
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array(16);
	var mat3array = new Float32Array(9);
	var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		var firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize;
		var r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (var i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (var i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (var i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		var r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (var i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or MatrixN)


	function setValueM2(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	}

	function setValueT3D1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	} // Integer / Boolean vectors or arrays thereof (always flat arrays)


	function setValueV1i(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	}

	function setValueV2i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // uint


	function setValueV1ui(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Integer / Boolean vectors or arrays thereof (always flat arrays)


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	}

	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of vectors (flat or from THREE classes)


	function setValueV2fArray(gl, v) {
		var data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		var data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		var data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (flat or from THREE clases)


	function setValueM2Array(gl, v) {
		var data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		var data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		var data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of textures (2D / Cube)


	function setValueT1Array(gl, v, textures) {
		var n = v.length;
		var units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (var i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		var n = v.length;
		var units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (var i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		var cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		var seq = this.seq;

		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	var RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		var path = activeInfo.name,
				pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			var match = RePathPart.exec(path),
					matchEnd = RePathPart.lastIndex;
			var id = match[1];
			var idIsIndex = match[2] === ']',
					subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				var map = container.map;
				var next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		var n = gl.getProgramParameter(program, 35718);

		for (var i = 0; i < n; ++i) {
			var info = gl.getActiveUniform(program, i),
					addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		var u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		var v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i],
					v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		var r = [];

		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		var shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	var programIdCount = 0;

	function addLineNumbers(string) {
		var lines = string.split('\n');

		for (var i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			case LogLuvEncoding:
				return ['LogLuv', '( value )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		var status = gl.getShaderParameter(shader, 35713);
		var log = gl.getShaderInfoLog(shader).trim();
		if (status && log === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		var source = gl.getShaderSource(shader);
		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
	}

	function getTexelDecodingFunction(functionName, encoding) {
		var components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		var components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		var toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		var chunks = [];

		for (var name in defines) {
			var value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		var attributes = {};
		var n = gl.getProgramParameter(program, 35721);

		for (var i = 0; i < n; i++) {
			var info = gl.getActiveAttrib(program, i);
			var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name);
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		var string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		var string = '';

		for (var i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		var gl = renderer.getContext();
		var defines = parameters.defines;
		var vertexShader = parameters.vertexShader;
		var fragmentShader = parameters.fragmentShader;
		var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		var envMapModeDefine = generateEnvMapModeDefine(parameters);
		var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		var customDefines = generateDefines(defines);
		var program = gl.createProgram();
		var prefixVertex, prefixFragment;
		var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
			'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		var vertexGlsl = versionString + prefixVertex + vertexShader;
		var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
		var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			var programLog = gl.getProgramInfoLog(program).trim();
			var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			var runnable = true;
			var haveDiagnostics = true;

			if (gl.getProgramParameter(program, 35714) === false) {
				runnable = false;
				var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		var cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
		var programs = [];
		var isWebGL2 = capabilities.isWebGL2;
		var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		var floatVertexTextures = capabilities.floatVertexTextures;
		var maxVertexUniforms = capabilities.maxVertexUniforms;
		var vertexTextures = capabilities.vertexTextures;
		var precision = capabilities.precision;
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		var parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmissionMap'];

		function getMaxBones(object) {
			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				var nVertexUniforms = maxVertexUniforms;
				var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				var maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			var encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}

			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;
			var envMap = cubemaps.get(material.envMap || environment);
			var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			var vertexShader, fragmentShader;

			if (shaderID) {
				var shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			var currentRenderTarget = renderer.getRenderTarget();
			var parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				alphaMap: !!material.alphaMap,
				gradientMap: !!material.gradientMap,
				sheen: !!material.sheen,
				transmissionMap: !!material.transmissionMap,
				combine: material.combine,
				vertexTangents: material.normalMap && material.vertexTangents,
				vertexColors: material.vertexColors,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			var array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.fragmentShader);
				array.push(parameters.vertexShader);
			}

			if (parameters.defines !== undefined) {
				for (var name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (var i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			var shaderID = shaderIDs[material.type];
			var uniforms;

			if (shaderID) {
				var shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			var program; // Check if code has been already compiled

			for (var p = 0, pl = programs.length; p < pl; p++) {
				var preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				var i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		var properties = new WeakMap();

		function get(object) {
			var map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		var renderItems = [];
		var renderItemsIndex = 0;
		var opaque = [];
		var transparent = [];
		var defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			var renderItem = renderItems[renderItemsIndex];
			var materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			(material.transparent === true ? transparent : opaque).push(renderItem);
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			(material.transparent === true ? transparent : opaque).unshift(renderItem);
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				var renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		var lists = new WeakMap();

		function get(scene, camera) {
			var cameras = lists.get(scene);
			var list;

			if (cameras === undefined) {
				list = new WebGLRenderList(properties);
				lists.set(scene, new WeakMap());
				lists.get(scene).set(camera, list);
			} else {
				list = cameras.get(camera);

				if (list === undefined) {
					list = new WebGLRenderList(properties);
					cameras.set(camera, list);
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		var lights = {};
		return {
			get: function get(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				var uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		var lights = {};
		return {
			get: function get(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				var uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	var nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		var cache = new UniformsCache();
		var shadowCache = ShadowUniformsCache();
		var state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (var i = 0; i < 9; i++) {
			state.probe.push(new Vector3());
		}

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup(lights) {
			var r = 0,
					g = 0,
					b = 0;

			for (var _i = 0; _i < 9; _i++) {
				state.probe[_i].set(0, 0, 0);
			}

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
			var numDirectionalShadows = 0;
			var numPointShadows = 0;
			var numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst);

			for (var _i2 = 0, l = lights.length; _i2 < l; _i2++) {
				var light = lights[_i2];
				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;
				var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
				} else if (light.isLightProbe) {
					for (var j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					var uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);

					if (light.castShadow) {
						var shadow = light.shadow;
						var shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					var _uniforms = cache.get(light);

					_uniforms.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms.color.copy(color).multiplyScalar(intensity);

					_uniforms.distance = distance;
					_uniforms.coneCos = Math.cos(light.angle);
					_uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					_uniforms.decay = light.decay;

					if (light.castShadow) {
						var _shadow = light.shadow;

						var _shadowUniforms = shadowCache.get(light);

						_shadowUniforms.shadowBias = _shadow.bias;
						_shadowUniforms.shadowNormalBias = _shadow.normalBias;
						_shadowUniforms.shadowRadius = _shadow.radius;
						_shadowUniforms.shadowMapSize = _shadow.mapSize;
						state.spotShadow[spotLength] = _shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = _uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light


					_uniforms2.color.copy(color).multiplyScalar(intensity);

					_uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);

					_uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);

					state.rectArea[rectAreaLength] = _uniforms2;
					rectAreaLength++;
				} else if (light.isPointLight) {
					var _uniforms3 = cache.get(light);

					_uniforms3.color.copy(light.color).multiplyScalar(light.intensity);

					_uniforms3.distance = light.distance;
					_uniforms3.decay = light.decay;

					if (light.castShadow) {
						var _shadow2 = light.shadow;

						var _shadowUniforms2 = shadowCache.get(light);

						_shadowUniforms2.shadowBias = _shadow2.bias;
						_shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
						_shadowUniforms2.shadowRadius = _shadow2.radius;
						_shadowUniforms2.shadowMapSize = _shadow2.mapSize;
						_shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
						_shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
						state.pointShadow[pointLength] = _shadowUniforms2;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = _uniforms3;
					pointLength++;
				} else if (light.isHemisphereLight) {
					var _uniforms4 = cache.get(light);

					_uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);

					_uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);

					state.hemi[hemiLength] = _uniforms4;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			var hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
			var viewMatrix = camera.matrixWorldInverse;

			for (var _i3 = 0, l = lights.length; _i3 < l; _i3++) {
				var light = lights[_i3];

				if (light.isDirectionalLight) {
					var uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					var _uniforms5 = state.spot[spotLength];

					_uniforms5.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms5.position.applyMatrix4(viewMatrix);

					_uniforms5.direction.setFromMatrixPosition(light.matrixWorld);

					vector3.setFromMatrixPosition(light.target.matrixWorld);

					_uniforms5.direction.sub(vector3);

					_uniforms5.direction.transformDirection(viewMatrix);

					spotLength++;
				} else if (light.isRectAreaLight) {
					var _uniforms6 = state.rectArea[rectAreaLength];

					_uniforms6.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors


					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);

					_uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);

					_uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);

					_uniforms6.halfWidth.applyMatrix4(matrix42);

					_uniforms6.halfHeight.applyMatrix4(matrix42);

					rectAreaLength++;
				} else if (light.isPointLight) {
					var _uniforms7 = state.point[pointLength];

					_uniforms7.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms7.position.applyMatrix4(viewMatrix);

					pointLength++;
				} else if (light.isHemisphereLight) {
					var _uniforms8 = state.hemi[hemiLength];

					_uniforms8.direction.setFromMatrixPosition(light.matrixWorld);

					_uniforms8.direction.transformDirection(viewMatrix);

					_uniforms8.direction.normalize();

					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		var lights = new WebGLLights(extensions, capabilities);
		var lightsArray = [];
		var shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights() {
			lights.setup(lightsArray);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		var renderStates = new WeakMap();

		function get(scene, renderCallDepth) {
			if (renderCallDepth === void 0) {
				renderCallDepth = 0;
			}

			var renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, []);
				renderStates.get(scene).push(renderState);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshDepthMaterial';
		this.depthPacking = BasicDepthPacking;
		this.skinning = false;
		this.morphTargets = false;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.fog = false;
		this.setValues(parameters);
	}

	MeshDepthMaterial.prototype = Object.create(Material.prototype);
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.depthPacking = source.depthPacking;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		return this;
	};

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshDistanceMaterial';
		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;
		this.skinning = false;
		this.morphTargets = false;
		this.map = null;
		this.alphaMap = null;
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.fog = false;
		this.setValues(parameters);
	}

	MeshDistanceMaterial.prototype = Object.create(Material.prototype);
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.referencePosition.copy(source.referencePosition);
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		return this;
	};

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
		var _frustum = new Frustum();

		var _shadowMapSize = new Vector2(),
				_viewportSize = new Vector2(),
				_viewport = new Vector4(),
				_depthMaterials = [],
				_distanceMaterials = [],
				_materialCache = {};

		var shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		var shadowMaterialVertical = new ShaderMaterial({
			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vsm_vert,
			fragmentShader: vsm_frag
		});
		var shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		var fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		var scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			var currentRenderTarget = _renderer.getRenderTarget();

			var activeCubeFace = _renderer.getActiveCubeFace();

			var activeMipmapLevel = _renderer.getActiveMipmapLevel();

			var _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (var i = 0, il = lights.length; i < il; i++) {
				var light = lights[i];
				var shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				var shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
					if (_shadowMapSize.x > maxTextureSize) {
						_viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > maxTextureSize) {
						_viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					var pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					var _pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, _pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				var viewportCount = shadow.getViewportCount();

				for (var vp = 0; vp < viewportCount; vp++) {
					var viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			var geometry = _objects.update(fullScreenMesh); // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
			var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
			var material = _depthMaterials[index];

			if (material === undefined) {
				material = new MeshDepthMaterial({
					depthPacking: RGBADepthPacking,
					morphTargets: useMorphing,
					skinning: useSkinning
				});
				_depthMaterials[index] = material;
			}

			return material;
		}

		function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
			var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
			var material = _distanceMaterials[index];

			if (material === undefined) {
				material = new MeshDistanceMaterial({
					morphTargets: useMorphing,
					skinning: useSkinning
				});
				_distanceMaterials[index] = material;
			}

			return material;
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			var result = null;
			var getMaterialVariant = getDepthMaterialVariant;
			var customMaterial = object.customDepthMaterial;

			if (light.isPointLight === true) {
				getMaterialVariant = getDistanceMaterialVariant;
				customMaterial = object.customDistanceMaterial;
			}

			if (customMaterial === undefined) {
				var useMorphing = false;

				if (material.morphTargets === true) {
					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
				}

				var useSkinning = false;

				if (object.isSkinnedMesh === true) {
					if (material.skinning === true) {
						useSkinning = true;
					} else {
						console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
					}
				}

				var useInstancing = object.isInstancedMesh === true;
				result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
			} else {
				result = customMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				var keyA = result.uuid,
						keyB = material.uuid;
				var materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				var cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			var visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					var geometry = _objects.update(object);

					var material = object.material;

					if (Array.isArray(material)) {
						var groups = geometry.groups;

						for (var k = 0, kl = groups.length; k < kl; k++) {
							var group = groups[k];
							var groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						var _depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial, object, null);
					}
				}
			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		var _equationToGL, _factorToGL;

		var isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			var locked = false;
			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function setMask(colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function reset() {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			var locked = false;
			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;
			return {
				setTest: function setTest(depthTest) {
					if (depthTest) {
						enable(2929);
					} else {
						disable(2929);
					}
				},
				setMask: function setMask(depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function setFunc(depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(512);
									break;

								case AlwaysDepth:
									gl.depthFunc(519);
									break;

								case LessDepth:
									gl.depthFunc(513);
									break;

								case LessEqualDepth:
									gl.depthFunc(515);
									break;

								case EqualDepth:
									gl.depthFunc(514);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(518);
									break;

								case GreaterDepth:
									gl.depthFunc(516);
									break;

								case NotEqualDepth:
									gl.depthFunc(517);
									break;

								default:
									gl.depthFunc(515);
							}
						} else {
							gl.depthFunc(515);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function reset() {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			var locked = false;
			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;
			return {
				setTest: function setTest(stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(2960);
						} else {
							disable(2960);
						}
					}
				},
				setMask: function setMask(stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function reset() {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();
		var enabledCapabilities = {};
		var currentProgram = null;
		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;
		var currentFlipSided = null;
		var currentCullFace = null;
		var currentLineWidth = null;
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
		var maxTextures = gl.getParameter(35661);
		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter(7938);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};
		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture(type, target, count) {
			var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			var texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, 10241, 9728);
			gl.texParameteri(type, 10240, 9728);

			for (var i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
			}

			return texture;
		}

		var emptyTextures = {};
		emptyTextures[3553] = createTexture(3553, 3553, 1);
		emptyTextures[34067] = createTexture(34067, 34069, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(2929);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(2884);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		var equationToGL = (_equationToGL = {}, _equationToGL[AddEquation] = 32774, _equationToGL[SubtractEquation] = 32778, _equationToGL[ReverseSubtractEquation] = 32779, _equationToGL);

		if (isWebGL2) {
			equationToGL[MinEquation] = 32775;
			equationToGL[MaxEquation] = 32776;
		} else {
			var extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		var factorToGL = (_factorToGL = {}, _factorToGL[ZeroFactor] = 0, _factorToGL[OneFactor] = 1, _factorToGL[SrcColorFactor] = 768, _factorToGL[SrcAlphaFactor] = 770, _factorToGL[SrcAlphaSaturateFactor] = 776, _factorToGL[DstColorFactor] = 774, _factorToGL[DstAlphaFactor] = 772, _factorToGL[OneMinusSrcColorFactor] = 769, _factorToGL[OneMinusSrcAlphaFactor] = 771, _factorToGL[OneMinusDstColorFactor] = 775, _factorToGL[OneMinusDstAlphaFactor] = 773, _factorToGL);

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled) {
					disable(3042);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (!currentBlendingEnabled) {
				enable(3042);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(32774);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(1, 771, 1, 771);
								break;

							case AdditiveBlending:
								gl.blendFunc(1, 1);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(0, 0, 769, 771);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(0, 768, 0, 770);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(770, 771, 1, 771);
								break;

							case AdditiveBlending:
								gl.blendFunc(770, 1);
								break;

							case SubtractiveBlending:
								gl.blendFunc(0, 769);
								break;

							case MultiplyBlending:
								gl.blendFunc(0, 768);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(2884) : enable(2884);
			var flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			var stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(2304);
				} else {
					gl.frontFace(2305);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(2884);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(1029);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(1028);
					} else {
						gl.cullFace(1032);
					}
				}
			} else {
				disable(2884);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(32823);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(32823);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(3089);
			} else {
				disable(3089);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			var boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			var boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			currentProgram = null;
			currentBlendingEnabled = null;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		var _wrappingToGL, _filterToGL;

		var isWebGL2 = capabilities.isWebGL2;
		var maxTextures = capabilities.maxTextures;
		var maxCubemapSize = capabilities.maxCubemapSize;
		var maxTextureSize = capabilities.maxTextureSize;
		var maxSamples = capabilities.maxSamples;

		var _videoTextures = new WeakMap();

		var _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		var useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			var scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
					var width = floor(scale * image.width);
					var height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					var context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo(image) {
			return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height) {
			_gl.generateMipmap(target);

			var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

			textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
		}

		function getInternalFormat(internalFormatName, glFormat, glType) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			var internalFormat = glFormat;

			if (glFormat === 6403) {
				if (glType === 5126) internalFormat = 33326;
				if (glType === 5131) internalFormat = 33325;
				if (glType === 5121) internalFormat = 33321;
			}

			if (glFormat === 6407) {
				if (glType === 5126) internalFormat = 34837;
				if (glType === 5131) internalFormat = 34843;
				if (glType === 5121) internalFormat = 32849;
			}

			if (glFormat === 6408) {
				if (glType === 5126) internalFormat = 34836;
				if (glType === 5131) internalFormat = 34842;
				if (glType === 5121) internalFormat = 32856;
			}

			if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return 9728;
			}

			return 9729;
		} //


		function onTextureDispose(event) {
			var texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			var renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
			info.memory.textures--;
		} //


		function deallocateTexture(texture) {
			var textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(renderTarget.texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (var i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			properties.remove(renderTarget.texture);
			properties.remove(renderTarget);
		} //


		var textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			var textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			var textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				var image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(3553, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(35866, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(32879, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(34067, textureProperties.__webglTexture);
		}

		var wrappingToGL = (_wrappingToGL = {}, _wrappingToGL[RepeatWrapping] = 10497, _wrappingToGL[ClampToEdgeWrapping] = 33071, _wrappingToGL[MirroredRepeatWrapping] = 33648, _wrappingToGL);
		var filterToGL = (_filterToGL = {}, _filterToGL[NearestFilter] = 9728, _filterToGL[NearestMipmapNearestFilter] = 9984, _filterToGL[NearestMipmapLinearFilter] = 9986, _filterToGL[LinearFilter] = 9729, _filterToGL[LinearMipmapNearestFilter] = 9985, _filterToGL[LinearMipmapLinearFilter] = 9987, _filterToGL);

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

				if (textureType === 32879 || textureType === 35866) {
					_gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, 10242, 33071);

				_gl.texParameteri(textureType, 10243, 33071);

				if (textureType === 32879 || textureType === 35866) {
					_gl.texParameteri(textureType, 32882, 33071);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			var extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension) {
				if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
				if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			var textureType = 3553;
			if (texture.isDataTexture2DArray) textureType = 35866;
			if (texture.isDataTexture3D) textureType = 32879;
			initTexture(textureProperties, texture);
			state.activeTexture(33984 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(37440, texture.flipY);

			_gl.pixelStorei(37441, texture.premultiplyAlpha);

			_gl.pixelStorei(3317, texture.unpackAlignment);

			var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
			var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			var supportsMips = isPowerOfTwo(image) || isWebGL2,
					glFormat = utils.convert(texture.format);
			var glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(textureType, texture, supportsMips);
			var mipmap;
			var mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = 6402;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = 36012;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = 33190;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = 35056;
					} else {
						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === 6402) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (var i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (var _i = 0, _il = mipmaps.length; _i < _il; _i++) {
					mipmap = mipmaps[_i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (var _i2 = 0, _il2 = mipmaps.length; _i2 < _il2; _i2++) {
						mipmap = mipmaps[_i2];
						state.texImage2D(3553, _i2, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(33984 + slot);
			state.bindTexture(34067, textureProperties.__webglTexture);

			_gl.pixelStorei(37440, texture.flipY);

			_gl.pixelStorei(37441, texture.premultiplyAlpha);

			_gl.pixelStorei(3317, texture.unpackAlignment);

			var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			var cubeImage = [];

			for (var i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			var image = cubeImage[0],
					supportsMips = isPowerOfTwo(image) || isWebGL2,
					glFormat = utils.convert(texture.format),
					glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(34067, texture, supportsMips);
			var mipmaps;

			if (isCompressed) {
				for (var _i3 = 0; _i3 < 6; _i3++) {
					mipmaps = cubeImage[_i3].mipmaps;

					for (var j = 0; j < mipmaps.length; j++) {
						var mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {
				mipmaps = texture.mipmaps;

				for (var _i4 = 0; _i4 < 6; _i4++) {
					if (isDataTexture) {
						state.texImage2D(34069 + _i4, 0, glInternalFormat, cubeImage[_i4].width, cubeImage[_i4].height, 0, glFormat, glType, cubeImage[_i4].data);

						for (var _j = 0; _j < mipmaps.length; _j++) {
							var _mipmap = mipmaps[_j];
							var mipmapImage = _mipmap.image[_i4].image;
							state.texImage2D(34069 + _i4, _j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(34069 + _i4, 0, glInternalFormat, glFormat, glType, cubeImage[_i4]);

						for (var _j2 = 0; _j2 < mipmaps.length; _j2++) {
							var _mipmap2 = mipmaps[_j2];
							state.texImage2D(34069 + _i4, _j2 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i4]);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length;
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(34067, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
			var glFormat = utils.convert(renderTarget.texture.format);
			var glType = utils.convert(renderTarget.texture.type);
			var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
			state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

			_gl.bindFramebuffer(36160, framebuffer);

			_gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

			_gl.bindFramebuffer(36160, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(36161, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				var glInternalFormat = 33189;

				if (isMultisample) {
					var depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = 36012;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = 33190;
						}
					}

					var samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					var _samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(36161, _samples, 35056, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
			} else {
				var glFormat = utils.convert(renderTarget.texture.format);
				var glType = utils.convert(renderTarget.texture.type);

				var _glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

				if (isMultisample) {
					var _samples2 = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(36161, _glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(36161, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

			_gl.bindFramebuffer(36160, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			var renderTargetProperties = properties.get(renderTarget);
			var isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (var i = 0; i < 6; i++) {
						_gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					_gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			_gl.bindFramebuffer(36160, null);
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(renderTarget.texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);
			textureProperties.__webglTexture = _gl.createTexture();
			info.memory.textures++;
			var isCube = renderTarget.isWebGLCubeRenderTarget === true;
			var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
			var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
				renderTarget.texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (var i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

						var glFormat = utils.convert(renderTarget.texture.format);
						var glType = utils.convert(renderTarget.texture.type);
						var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
						var samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						_gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(36161, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						_gl.bindFramebuffer(36160, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(34067, textureProperties.__webglTexture);
				setTextureParameters(34067, renderTarget.texture, supportsMips);

				for (var _i5 = 0; _i5 < 6; _i5++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i5], renderTarget, 36064, 34069 + _i5);
				}

				if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
					generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(34067, null);
			} else {
				state.bindTexture(3553, textureProperties.__webglTexture);
				setTextureParameters(3553, renderTarget.texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

				if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
					generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(3553, null);
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			var texture = renderTarget.texture;
			var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

				var webglTexture = properties.get(texture).__webglTexture;

				state.bindTexture(target, webglTexture);
				generateMipmap(target, texture, renderTarget.width, renderTarget.height);
				state.bindTexture(target, null);
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					var renderTargetProperties = properties.get(renderTarget);

					_gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

					_gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;
					if (renderTarget.depthBuffer) mask |= 256;
					if (renderTarget.stencilBuffer) mask |= 1024;

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

					_gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905

				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			var frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			var extension;
			if (p === UnsignedByteType) return 5121;
			if (p === UnsignedShort4444Type) return 32819;
			if (p === UnsignedShort5551Type) return 32820;
			if (p === UnsignedShort565Type) return 33635;
			if (p === ByteType) return 5120;
			if (p === ShortType) return 5122;
			if (p === UnsignedShortType) return 5123;
			if (p === IntType) return 5124;
			if (p === UnsignedIntType) return 5125;
			if (p === FloatType) return 5126;

			if (p === HalfFloatType) {
				if (isWebGL2) return 5131;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return 6406;
			if (p === RGBFormat) return 6407;
			if (p === RGBAFormat) return 6408;
			if (p === LuminanceFormat) return 6409;
			if (p === LuminanceAlphaFormat) return 6410;
			if (p === DepthFormat) return 6402;
			if (p === DepthStencilFormat) return 34041;
			if (p === RedFormat) return 6403; // WebGL2 formats.

			if (p === RedIntegerFormat) return 36244;
			if (p === RGFormat) return 33319;
			if (p === RGIntegerFormat) return 33320;
			if (p === RGBIntegerFormat) return 36248;
			if (p === RGBAIntegerFormat) return 36249;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return 34042;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	function ArrayCamera(array) {
		if (array === void 0) {
			array = [];
		}

		PerspectiveCamera.call(this);
		this.cameras = array;
	}

	ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
		constructor: ArrayCamera,
		isArrayCamera: true
	});

	function Group() {
		Object3D.call(this);
		this.type = 'Group';
	}

	Group.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Group,
		isGroup: true
	});

	function WebXRController() {
		this._targetRay = null;
		this._grip = null;
		this._hand = null;
	}

	Object.assign(WebXRController.prototype, {
		constructor: WebXRController,
		getHandSpace: function getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		},
		getTargetRaySpace: function getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
			}

			return this._targetRay;
		},
		getGripSpace: function getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
			}

			return this._grip;
		},
		dispatchEvent: function dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		},
		disconnect: function disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		},
		update: function update(inputSource, frame, referenceSpace) {
			var inputPose = null;
			var gripPose = null;
			var handPose = null;
			var targetRay = this._targetRay;
			var grip = this._grip;
			var hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (hand && inputSource.hand) {
					handPose = true;

					for (var _iterator = _createForOfIteratorHelperLoose(inputSource.hand.values()), _step; !(_step = _iterator()).done;) {
						var inputjoint = _step.value;
						// Update the joints groups with the XRJoint poses
						var jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							var _joint = new Group();

							_joint.matrixAutoUpdate = false;
							_joint.visible = false;
							hand.joints[inputjoint.jointName] = _joint; // ??

							hand.add(_joint);
						}

						var joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					var indexTip = hand.joints['index-finger-tip'];
					var thumbTip = hand.joints['thumb-tip'];
					var distance = indexTip.position.distanceTo(thumbTip.position);
					var distanceToPinch = 0.02;
					var threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (targetRay !== null) {
						inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

						if (inputPose !== null) {
							targetRay.matrix.fromArray(inputPose.transform.matrix);
							targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
						}
					}

					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		}
	});

	function WebXRManager(renderer, gl) {
		var scope = this;
		var session = null;
		var framebufferScaleFactor = 1.0;
		var referenceSpace = null;
		var referenceSpaceType = 'local-floor';
		var pose = null;
		var controllers = [];
		var inputSourcesMap = new Map(); //

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable(1);
		cameraL.viewport = new Vector4();
		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable(2);
		cameraR.viewport = new Vector4();
		var cameras = [cameraL, cameraR];
		var cameraVR = new ArrayCamera();
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);
		var _currentDepthNear = null;
		var _currentDepthFar = null; //

		this.enabled = false;
		this.isPresenting = false;

		this.getController = function (index) {
			var controller = controllers[index];

			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}

			return controller.getTargetRaySpace();
		};

		this.getControllerGrip = function (index) {
			var controller = controllers[index];

			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}

			return controller.getGripSpace();
		};

		this.getHand = function (index) {
			var controller = controllers[index];

			if (controller === undefined) {
				controller = new WebXRController();
				controllers[index] = controller;
			}

			return controller.getHandSpace();
		}; //


		function onSessionEvent(event) {
			var controller = inputSourcesMap.get(event.inputSource);

			if (controller) {
				controller.dispatchEvent({
					type: event.type,
					data: event.inputSource
				});
			}
		}

		function onSessionEnd() {
			inputSourcesMap.forEach(function (controller, inputSource) {
				controller.disconnect(inputSource);
			});
			inputSourcesMap.clear();
			_currentDepthNear = null;
			_currentDepthFar = null; //

			renderer.setFramebuffer(null);
			renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

			animation.stop();
			scope.isPresenting = false;
			scope.dispatchEvent({
				type: 'sessionend'
			});
		}

		this.setFramebufferScaleFactor = function (value) {
			framebufferScaleFactor = value;

			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
			}
		};

		this.setReferenceSpaceType = function (value) {
			referenceSpaceType = value;

			if (scope.isPresenting === true) {
				console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
			}
		};

		this.getReferenceSpace = function () {
			return referenceSpace;
		};

		this.getSession = function () {
			return session;
		};

		this.setSession = /*#__PURE__*/function () {
			var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value) {
				var attributes, layerInit, baseLayer;
				return regeneratorRuntime.wrap(function _callee$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {
							case 0:
								session = value;

								if (!(session !== null)) {
									_context.next = 24;
									break;
								}

								session.addEventListener('select', onSessionEvent);
								session.addEventListener('selectstart', onSessionEvent);
								session.addEventListener('selectend', onSessionEvent);
								session.addEventListener('squeeze', onSessionEvent);
								session.addEventListener('squeezestart', onSessionEvent);
								session.addEventListener('squeezeend', onSessionEvent);
								session.addEventListener('end', onSessionEnd);
								session.addEventListener('inputsourceschange', onInputSourcesChange);
								attributes = gl.getContextAttributes();

								if (!(attributes.xrCompatible !== true)) {
									_context.next = 14;
									break;
								}

								_context.next = 14;
								return gl.makeXRCompatible();

							case 14:
								layerInit = {
									antialias: attributes.antialias,
									alpha: attributes.alpha,
									depth: attributes.depth,
									stencil: attributes.stencil,
									framebufferScaleFactor: framebufferScaleFactor
								}; // eslint-disable-next-line no-undef

								baseLayer = new XRWebGLLayer(session, gl, layerInit);
								session.updateRenderState({
									baseLayer: baseLayer
								});
								_context.next = 19;
								return session.requestReferenceSpace(referenceSpaceType);

							case 19:
								referenceSpace = _context.sent;
								animation.setContext(session);
								animation.start();
								scope.isPresenting = true;
								scope.dispatchEvent({
									type: 'sessionstart'
								});

							case 24:
							case "end":
								return _context.stop();
						}
					}
				}, _callee);
			}));

			return function (_x) {
				return _ref.apply(this, arguments);
			};
		}();

		function onInputSourcesChange(event) {
			var inputSources = session.inputSources; // Assign inputSources to available controllers

			for (var i = 0; i < controllers.length; i++) {
				inputSourcesMap.set(inputSources[i], controllers[i]);
			} // Notify disconnected


			for (var _i = 0; _i < event.removed.length; _i++) {
				var inputSource = event.removed[_i];
				var controller = inputSourcesMap.get(inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: 'disconnected',
						data: inputSource
					});
					inputSourcesMap.delete(inputSource);
				}
			} // Notify connected


			for (var _i2 = 0; _i2 < event.added.length; _i2++) {
				var _inputSource = event.added[_i2];

				var _controller = inputSourcesMap.get(_inputSource);

				if (_controller) {
					_controller.dispatchEvent({
						type: 'connected',
						data: _inputSource
					});
				}
			}
		} //


		var cameraLPos = new Vector3();
		var cameraRPos = new Vector3();
		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */

		function setProjectionFromUnion(camera, cameraL, cameraR) {
			cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
			cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
			var ipd = cameraLPos.distanceTo(cameraRPos);
			var projL = cameraL.projectionMatrix.elements;
			var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.

			var near = projL[14] / (projL[10] - 1);
			var far = projL[14] / (projL[10] + 1);
			var topFov = (projL[9] + 1) / projL[5];
			var bottomFov = (projL[9] - 1) / projL[5];
			var leftFov = (projL[8] - 1) / projL[0];
			var rightFov = (projR[8] + 1) / projR[0];
			var left = near * leftFov;
			var right = near * rightFov; // Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.

			var zOffset = ipd / (-leftFov + rightFov);
			var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

			cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
			camera.translateX(xOffset);
			camera.translateZ(zOffset);
			camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
			camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.

			var near2 = near + zOffset;
			var far2 = far + zOffset;
			var left2 = left - xOffset;
			var right2 = right + (ipd - xOffset);
			var top2 = topFov * far / far2 * near2;
			var bottom2 = bottomFov * far / far2 * near2;
			camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
		}

		function updateCamera(camera, parent) {
			if (parent === null) {
				camera.matrixWorld.copy(camera.matrix);
			} else {
				camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
			}

			camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
		}

		this.getCamera = function (camera) {
			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
				// Note that the new renderState won't apply until the next frame. See #18320
				session.updateRenderState({
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				});
				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;
			}

			var parent = camera.parent;
			var cameras = cameraVR.cameras;
			updateCamera(cameraVR, parent);

			for (var i = 0; i < cameras.length; i++) {
				updateCamera(cameras[i], parent);
			} // update camera and its children


			camera.matrixWorld.copy(cameraVR.matrixWorld);
			camera.matrix.copy(cameraVR.matrix);
			camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
			var children = camera.children;

			for (var _i3 = 0, l = children.length; _i3 < l; _i3++) {
				children[_i3].updateMatrixWorld(true);
			} // update projection matrix for proper view frustum culling


			if (cameras.length === 2) {
				setProjectionFromUnion(cameraVR, cameraL, cameraR);
			} else {
				// assume single camera setup (AR)
				cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
			}

			return cameraVR;
		}; // Animation Loop


		var onAnimationFrameCallback = null;

		function onAnimationFrame(time, frame) {
			pose = frame.getViewerPose(referenceSpace);

			if (pose !== null) {
				var views = pose.views;
				var baseLayer = session.renderState.baseLayer;
				renderer.setFramebuffer(baseLayer.framebuffer);
				var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

				if (views.length !== cameraVR.cameras.length) {
					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;
				}

				for (var i = 0; i < views.length; i++) {
					var view = views[i];
					var viewport = baseLayer.getViewport(view);
					var camera = cameras[i];
					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

					if (i === 0) {
						cameraVR.matrix.copy(camera.matrix);
					}

					if (cameraVRNeedsUpdate === true) {
						cameraVR.cameras.push(camera);
					}
				}
			} //


			var inputSources = session.inputSources;

			for (var _i4 = 0; _i4 < controllers.length; _i4++) {
				var controller = controllers[_i4];
				var inputSource = inputSources[_i4];
				controller.update(inputSource, frame, referenceSpace);
			}

			if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
		};

		this.dispose = function () {};
	}

	Object.assign(WebXRManager.prototype, EventDispatcher.prototype);

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			var envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				var maxMipLevel = properties.get(envMap).__maxMipLevel;

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel;
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			var uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			var envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material) {
			refreshUniformsStandard(uniforms, material);
			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.sheen) uniforms.sheen.value.copy(material.sheen);

			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}

			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}

			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}

			uniforms.transmission.value = material.transmission;

			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters) {
		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
				_context = parameters.context !== undefined ? parameters.context : null,
				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
				_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
				_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		var currentRenderList = null;
		var currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its state isolated from the parent render call.

		var renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4; // internal properties

		var _this = this;

		var _isContextLost = false; // internal state cache

		var _framebuffer = null;
		var _currentActiveCubeFace = 0;
		var _currentActiveMipmapLevel = 0;
		var _currentRenderTarget = null;
		var _currentFramebuffer = null;

		var _currentMaterialId = -1;

		var _currentCamera = null;

		var _currentViewport = new Vector4();

		var _currentScissor = new Vector4();

		var _currentScissorTest = null; //

		var _width = _canvas.width;
		var _height = _canvas.height;
		var _pixelRatio = 1;
		var _opaqueSort = null;
		var _transparentSort = null;

		var _viewport = new Vector4(0, 0, _width, _height);

		var _scissor = new Vector4(0, 0, _width, _height);

		var _scissorTest = false; // frustum

		var _frustum = new Frustum(); // clipping


		var _clippingEnabled = false;
		var _localClippingEnabled = false; // camera matrices cache

		var _projScreenMatrix = new Matrix4();

		var _vector3 = new Vector3();

		var _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		var _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (var i = 0; i < contextNames.length; i++) {
				var contextName = contextNames[i];

				var context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				var contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		var extensions, capabilities, state, info;
		var properties, textures, cubemaps, attributes, geometries, objects;
		var programCache, materials, renderLists, renderStates, clipping;
		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
		var utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		var xr = new WebXRManager(_this, _gl);
		this.xr = xr; // shadow map

		var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
		this.shadowMap = shadowMap; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			var extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			var extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
				target = new Vector2();
			}

			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
				target = new Vector2();
			}

			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
				target = new Vector4();
			}

			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
				target = new Color();
			}

			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			var bits = 0;
			if (color === undefined || color) bits |= 16384;
			if (depth === undefined || depth) bits |= 256;
			if (stencil === undefined || stencil) bits |= 1024;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore()
		/* event */
		{
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			initGLContext();
		}

		function onMaterialDispose(event) {
			var material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReference(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReference(material) {
			var programInfo = properties.get(material).program;

			if (programInfo !== undefined) {
				programCache.releaseProgram(programInfo);
			}
		} // Buffer rendering


		function renderObjectImmediate(object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes();
			var buffers = properties.get(object);
			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
			var programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(34962, buffers.position);

				_gl.bufferData(34962, object.positionArray, 35048);

				bindingStates.enableAttribute(programAttributes.position);

				_gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(34962, buffers.normal);

				_gl.bufferData(34962, object.normalArray, 35048);

				bindingStates.enableAttribute(programAttributes.normal);

				_gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(34962, buffers.uv);

				_gl.bufferData(34962, object.uvArray, 35048);

				bindingStates.enableAttribute(programAttributes.uv);

				_gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(34962, buffers.color);

				_gl.bufferData(34962, object.colorArray, 35048);

				bindingStates.enableAttribute(programAttributes.color);

				_gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays(4, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			var program = setProgram(camera, scene, material, object);
			state.setMaterial(material, frontFaceCW); //

			var index = geometry.index;
			var position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			var rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			if (material.morphTargets || material.morphNormals) {
				morphtargets.update(object, geometry, material, program);
			}

			bindingStates.setup(object, material, program, geometry, index);
			var attribute;
			var renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			var dataCount = index !== null ? index.count : position.count;
			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;
			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;
			var drawStart = Math.max(rangeStart, groupStart);
			var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			var drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(1);
				} else {
					renderer.setMode(4);
				}
			} else if (object.isLine) {
				var lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(1);
				} else if (object.isLineLoop) {
					renderer.setMode(2);
				} else {
					renderer.setMode(3);
				}
			} else if (object.isPoints) {
				renderer.setMode(0);
			} else if (object.isSprite) {
				renderer.setMode(4);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights();
			var compiled = new WeakMap();
			scene.traverse(function (object) {
				var material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (var i = 0; i < material.length; i++) {
							var material2 = material[i];

							if (compiled.has(material2) === false) {
								initMaterial(material2, scene, object);
								compiled.set(material2);
							}
						}
					} else if (compiled.has(material) === false) {
						initMaterial(material, scene, object);
						compiled.set(material);
					}
				}
			});
		}; // Animation Loop


		var onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (xr.isPresenting) return;
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		}; // Rendering


		this.render = function (scene, camera) {
			var renderTarget, forceClear;

			if (arguments[2] !== undefined) {
				console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
				renderTarget = arguments[2];
			}

			if (arguments[3] !== undefined) {
				console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
				forceClear = arguments[3];
			}

			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // reset caching for this frame

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				camera = xr.getCamera(camera);
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, camera);
			currentRenderList.init();
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			var shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			currentRenderState.setupLights();
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset();

			if (renderTarget !== undefined) {
				this.setRenderTarget(renderTarget);
			} //


			background.render(currentRenderList, scene, camera, forceClear); // render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); //

			if (_currentRenderTarget !== null) {
				// Generate mipmap if we're using any kind of mipmap filtering
				textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget(_currentRenderTarget);
			} // Ensure depth buffer writing is enabled so it can be cleared on next render


			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			currentRenderList = null;
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			var visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						var geometry = objects.update(object);
						var material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						var _geometry = objects.update(object);

						var _material = object.material;

						if (Array.isArray(_material)) {
							var groups = _geometry.groups;

							for (var i = 0, l = groups.length; i < l; i++) {
								var group = groups[i];
								var groupMaterial = _material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, _geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (_material.visible) {
							currentRenderList.push(object, _geometry, _material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			var children = object.children;

			for (var _i = 0, _l = children.length; _i < _l; _i++) {
				projectObject(children[_i], camera, groupOrder, sortObjects);
			}
		}

		function renderObjects(renderList, scene, camera) {
			var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for (var i = 0, l = renderList.length; i < l; i++) {
				var renderItem = renderList[i];
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if (camera.isArrayCamera) {
					var cameras = camera.cameras;

					for (var j = 0, jl = cameras.length; j < jl; j++) {
						var camera2 = cameras[j];

						if (object.layers.test(camera2.layers)) {
							state.viewport(_currentViewport.copy(camera2.viewport));
							currentRenderState.setupLightsView(camera2);
							renderObject(object, scene, camera2, geometry, material, group);
						}
					}
				} else {
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

			if (object.isImmediateRenderObject) {
				var program = setProgram(camera, scene, material, object);
				state.setMaterial(material);
				bindingStates.reset();
				renderObjectImmediate(object, program);
			} else {
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function initMaterial(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			var materialProperties = properties.get(material);
			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;
			var lightsStateVersion = lights.state.version;
			var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			var programCacheKey = programCache.getProgramCacheKey(parameters);
			var program = materialProperties.program;
			var programChange = true; // always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);

			if (program === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
			} else if (program.cacheKey !== programCacheKey) {
				// changed glsl or parameters
				releaseMaterialProgramReference(material);
			} else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
				programChange = false;
			} else if (parameters.shaderID !== undefined) {
				// same glsl and uniform list
				return;
			} else {
				// only rebuild uniform list
				programChange = false;
			}

			if (programChange) {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				materialProperties.program = program;
				materialProperties.uniforms = parameters.uniforms;
				materialProperties.outputEncoding = parameters.outputEncoding;
			}

			var uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				materialProperties.numClippingPlanes = clipping.numPlanes;
				materialProperties.numIntersection = clipping.numIntersection;
				uniforms.clippingPlanes = clipping.uniform;
			} // store the light setup it was created for


			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			var progUniforms = materialProperties.program.getUniforms();
			var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.uniformsList = uniformsList;
		}

		function setProgram(camera, scene, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;
			var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			var envMap = cubemaps.get(material.envMap || environment);
			var materialProperties = properties.get(material);
			var lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			}

			if (material.version === materialProperties.__version) {
				if (material.fog && materialProperties.fog !== fog) {
					initMaterial(material, scene, object);
				} else if (materialProperties.environment !== environment) {
					initMaterial(material, scene, object);
				} else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					initMaterial(material, scene, object);
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					initMaterial(material, scene, object);
				} else if (materialProperties.outputEncoding !== encoding) {
					initMaterial(material, scene, object);
				} else if (materialProperties.envMap !== envMap) {
					initMaterial(material, scene, object);
				}
			} else {
				initMaterial(material, scene, object);
				materialProperties.__version = material.version;
			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
			var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					var uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures


			if (material.skinning) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				var skeleton = object.skeleton;

				if (skeleton) {
					var bones = skeleton.bones;

					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) {
							// layout (1 matrix = 4 pixels)
							//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
							//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
							//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
							//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
							var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

							size = MathUtils.ceilPowerOfTwo(size);
							size = Math.max(size, 4);
							var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

							boneMatrices.set(skeleton.boneMatrices); // copy current values

							var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;
						}

						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		} //


		this.setFramebuffer = function (value) {
			if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
			_framebuffer = value;
		};

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderList = function () {
			return currentRenderList;
		};

		this.setRenderList = function (renderList) {
			currentRenderList = renderList;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
			if (activeCubeFace === void 0) {
				activeCubeFace = 0;
			}

			if (activeMipmapLevel === void 0) {
				activeMipmapLevel = 0;
			}

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			var framebuffer = _framebuffer;
			var isCube = false;

			if (renderTarget) {
				var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			if (_currentFramebuffer !== framebuffer) {
				_gl.bindFramebuffer(36160, framebuffer);

				_currentFramebuffer = framebuffer;
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				var textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			}
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			var framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				var restore = false;

				if (framebuffer !== _currentFramebuffer) {
					_gl.bindFramebuffer(36160, framebuffer);

					restore = true;
				}

				try {
					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(36160) === 36053) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					if (restore) {
						_gl.bindFramebuffer(36160, _currentFramebuffer);
					}
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level) {
			if (level === void 0) {
				level = 0;
			}

			var levelScale = Math.pow(2, -level);
			var width = Math.floor(texture.image.width * levelScale);
			var height = Math.floor(texture.image.height * levelScale);
			var glFormat = utils.convert(texture.format);
			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
			if (level === void 0) {
				level = 0;
			}

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert(dstTexture.format);
			var glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(37440, dstTexture.flipY);

			_gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(3317, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	function WebGL1Renderer(parameters) {
		WebGLRenderer.call(this, parameters);
	}

	WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
		constructor: WebGL1Renderer,
		isWebGL1Renderer: true
	});

	var FogExp2 = /*#__PURE__*/function () {
		function FogExp2(color, density) {
			Object.defineProperty(this, 'isFogExp2', {
				value: true
			});
			this.name = '';
			this.color = new Color(color);
			this.density = density !== undefined ? density : 0.00025;
		}

		var _proto = FogExp2.prototype;

		_proto.clone = function clone() {
			return new FogExp2(this.color, this.density);
		};

		_proto.toJSON = function toJSON()
		/* meta */
		{
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		};

		return FogExp2;
	}();

	var Fog = /*#__PURE__*/function () {
		function Fog(color, near, far) {
			Object.defineProperty(this, 'isFog', {
				value: true
			});
			this.name = '';
			this.color = new Color(color);
			this.near = near !== undefined ? near : 1;
			this.far = far !== undefined ? far : 1000;
		}

		var _proto = Fog.prototype;

		_proto.clone = function clone() {
			return new Fog(this.color, this.near, this.far);
		};

		_proto.toJSON = function toJSON()
		/* meta */
		{
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		};

		return Fog;
	}();

	var Scene = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Scene, _Object3D);

		function Scene() {
			var _this;

			_this = _Object3D.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'isScene', {
				value: true
			});
			_this.type = 'Scene';
			_this.background = null;
			_this.environment = null;
			_this.fog = null;
			_this.overrideMaterial = null;
			_this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: _assertThisInitialized(_this)
				})); // eslint-disable-line no-undef

			}

			return _this;
		}

		var _proto = Scene.prototype;

		_proto.copy = function copy(source, recursive) {
			_Object3D.prototype.copy.call(this, source, recursive);

			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Object3D.prototype.toJSON.call(this, meta);

			if (this.background !== null) data.object.background = this.background.toJSON(meta);
			if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		};

		return Scene;
	}(Object3D);

	function InterleavedBuffer(array, stride) {
		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;
		this.usage = StaticDrawUsage;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0;
		this.uuid = MathUtils.generateUUID();
	}

	Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
		set: function set(value) {
			if (value === true) this.version++;
		}
	});
	Object.assign(InterleavedBuffer.prototype, {
		isInterleavedBuffer: true,
		onUploadCallback: function onUploadCallback() {},
		setUsage: function setUsage(value) {
			this.usage = value;
			return this;
		},
		copy: function copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		},
		copyAt: function copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (var i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		},
		set: function set(value, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.array.set(value, offset);
			return this;
		},
		clone: function clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = MathUtils.generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			var ib = new InterleavedBuffer(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		},
		onUpload: function onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		},
		toJSON: function toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = MathUtils.generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}
	});

	var _vector$6 = new Vector3();

	function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
		this.name = '';
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
		this.normalized = normalized === true;
	}

	Object.defineProperties(InterleavedBufferAttribute.prototype, {
		count: {
			get: function get() {
				return this.data.count;
			}
		},
		array: {
			get: function get() {
				return this.data.array;
			}
		},
		needsUpdate: {
			set: function set(value) {
				this.data.needsUpdate = value;
			}
		}
	});
	Object.assign(InterleavedBufferAttribute.prototype, {
		isInterleavedBufferAttribute: true,
		applyMatrix4: function applyMatrix4(m) {
			for (var i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		},
		setX: function setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		},
		setY: function setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		},
		setZ: function setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		},
		setW: function setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		},
		getX: function getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		},
		getY: function getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		},
		getZ: function getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		},
		getW: function getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		},
		setXY: function setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		},
		setXYZ: function setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		},
		setXYZW: function setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		},
		clone: function clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				var array = [];

				for (var i = 0; i < this.count; i++) {
					var index = i * this.data.stride + this.offset;

					for (var j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		},
		toJSON: function toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				var array = [];

				for (var i = 0; i < this.count; i++) {
					var index = i * this.data.stride + this.offset;

					for (var j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}
	});

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	function SpriteMaterial(parameters) {
		Material.call(this);
		this.type = 'SpriteMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.alphaMap = null;
		this.rotation = 0;
		this.sizeAttenuation = true;
		this.transparent = true;
		this.setValues(parameters);
	}

	SpriteMaterial.prototype = Object.create(Material.prototype);
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.rotation = source.rotation;
		this.sizeAttenuation = source.sizeAttenuation;
		return this;
	};

	var _geometry;

	var _intersectPoint = new Vector3();

	var _worldScale = new Vector3();

	var _mvPosition = new Vector3();

	var _alignedPosition = new Vector2();

	var _rotatedPosition = new Vector2();

	var _viewWorldMatrix = new Matrix4();

	var _vA$1 = new Vector3();

	var _vB$1 = new Vector3();

	var _vC$1 = new Vector3();

	var _uvA$1 = new Vector2();

	var _uvB$1 = new Vector2();

	var _uvC$1 = new Vector2();

	function Sprite(material) {
		Object3D.call(this);
		this.type = 'Sprite';

		if (_geometry === undefined) {
			_geometry = new BufferGeometry();
			var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
			var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

			_geometry.setIndex([0, 1, 2, 0, 2, 3]);

			_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

			_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
		}

		this.geometry = _geometry;
		this.material = material !== undefined ? material : new SpriteMaterial();
		this.center = new Vector2(0.5, 0.5);
	}

	Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Sprite,
		isSprite: true,
		raycast: function raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			var rotation = this.material.rotation;
			var sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			var center = this.center;
			transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA$1.set(0, 0);

			_uvB$1.set(1, 0);

			_uvC$1.set(1, 1); // check first triangle


			var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB$1.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
				face: null,
				object: this
			});
		},
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}
	});

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	var _v1$4 = new Vector3();

	var _v2$2 = new Vector3();

	function LOD() {
		Object3D.call(this);
		this._currentLevel = 0;
		this.type = 'LOD';
		Object.defineProperties(this, {
			levels: {
				enumerable: true,
				value: []
			}
		});
		this.autoUpdate = true;
	}

	LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: LOD,
		isLOD: true,
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source, false);
			var levels = source.levels;

			for (var i = 0, l = levels.length; i < l; i++) {
				var level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		},
		addLevel: function addLevel(object, distance) {
			if (distance === void 0) {
				distance = 0;
			}

			distance = Math.abs(distance);
			var levels = this.levels;
			var l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		},
		getCurrentLevel: function getCurrentLevel() {
			return this._currentLevel;
		},
		getObjectForDistance: function getObjectForDistance(distance) {
			var levels = this.levels;

			if (levels.length > 0) {
				var i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		},
		raycast: function raycast(raycaster, intersects) {
			var levels = this.levels;

			if (levels.length > 0) {
				_v1$4.setFromMatrixPosition(this.matrixWorld);

				var distance = raycaster.ray.origin.distanceTo(_v1$4);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		},
		update: function update(camera) {
			var levels = this.levels;

			if (levels.length > 1) {
				_v1$4.setFromMatrixPosition(camera.matrixWorld);

				_v2$2.setFromMatrixPosition(this.matrixWorld);

				var distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
				levels[0].object.visible = true;
				var i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		},
		toJSON: function toJSON(meta) {
			var data = Object3D.prototype.toJSON.call(this, meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			var levels = this.levels;

			for (var i = 0, l = levels.length; i < l; i++) {
				var level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		}
	});

	var _basePosition = new Vector3();

	var _skinIndex = new Vector4();

	var _skinWeight = new Vector4();

	var _vector$7 = new Vector3();

	var _matrix$1 = new Matrix4();

	function SkinnedMesh(geometry, material) {
		if (geometry && geometry.isGeometry) {
			console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
		}

		Mesh.call(this, geometry, material);
		this.type = 'SkinnedMesh';
		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();
	}

	SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
		constructor: SkinnedMesh,
		isSkinnedMesh: true,
		copy: function copy(source) {
			Mesh.prototype.copy.call(this, source);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		},
		bind: function bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		},
		pose: function pose() {
			this.skeleton.pose();
		},
		normalizeSkinWeights: function normalizeSkinWeights() {
			var vector = new Vector4();
			var skinWeight = this.geometry.attributes.skinWeight;

			for (var i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				var scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		},
		updateMatrixWorld: function updateMatrixWorld(force) {
			Mesh.prototype.updateMatrixWorld.call(this, force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		},
		boneTransform: function boneTransform(index, target) {
			var skeleton = this.skeleton;
			var geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (var i = 0; i < 4; i++) {
				var weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					var boneIndex = _skinIndex.getComponent(i);

					_matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		}
	});

	function Bone() {
		Object3D.call(this);
		this.type = 'Bone';
	}

	Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Bone,
		isBone: true
	});

	var _offsetMatrix = new Matrix4();

	var _identityMatrix = new Matrix4();

	function Skeleton(bones, boneInverses) {
		if (bones === void 0) {
			bones = [];
		}

		if (boneInverses === void 0) {
			boneInverses = [];
		}

		this.uuid = MathUtils.generateUUID();
		this.bones = bones.slice(0);
		this.boneInverses = boneInverses;
		this.boneMatrices = null;
		this.boneTexture = null;
		this.boneTextureSize = 0;
		this.frame = -1;
		this.init();
	}

	Object.assign(Skeleton.prototype, {
		init: function init() {
			var bones = this.bones;
			var boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (var i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		},
		calculateInverses: function calculateInverses() {
			this.boneInverses.length = 0;

			for (var i = 0, il = this.bones.length; i < il; i++) {
				var inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		},
		pose: function pose() {
			// recover the bind-time world matrices
			for (var i = 0, il = this.bones.length; i < il; i++) {
				var bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (var _i = 0, _il = this.bones.length; _i < _il; _i++) {
				var _bone = this.bones[_i];

				if (_bone) {
					if (_bone.parent && _bone.parent.isBone) {
						_bone.matrix.copy(_bone.parent.matrixWorld).invert();

						_bone.matrix.multiply(_bone.matrixWorld);
					} else {
						_bone.matrix.copy(_bone.matrixWorld);
					}

					_bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
				}
			}
		},
		update: function update() {
			var bones = this.bones;
			var boneInverses = this.boneInverses;
			var boneMatrices = this.boneMatrices;
			var boneTexture = this.boneTexture; // flatten bone matrices to array

			for (var i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		},
		clone: function clone() {
			return new Skeleton(this.bones, this.boneInverses);
		},
		getBoneByName: function getBoneByName(name) {
			for (var i = 0, il = this.bones.length; i < il; i++) {
				var bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		},
		dispose: function dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		},
		fromJSON: function fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (var i = 0, l = json.bones.length; i < l; i++) {
				var uuid = json.bones[i];
				var bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		},
		toJSON: function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			var bones = this.bones;
			var boneInverses = this.boneInverses;

			for (var i = 0, l = bones.length; i < l; i++) {
				var bone = bones[i];
				data.bones.push(bone.uuid);
				var boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		}
	});

	var _instanceLocalMatrix = new Matrix4();

	var _instanceWorldMatrix = new Matrix4();

	var _instanceIntersects = [];

	var _mesh = new Mesh();

	function InstancedMesh(geometry, material, count) {
		Mesh.call(this, geometry, material);
		this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
		this.instanceColor = null;
		this.count = count;
		this.frustumCulled = false;
	}

	InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
		constructor: InstancedMesh,
		isInstancedMesh: true,
		copy: function copy(source) {
			Mesh.prototype.copy.call(this, source);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		},
		getColorAt: function getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		},
		getMatrixAt: function getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		},
		raycast: function raycast(raycaster, intersects) {
			var matrixWorld = this.matrixWorld;
			var raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
					var intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		},
		setColorAt: function setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		},
		setMatrixAt: function setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		},
		updateMorphTargets: function updateMorphTargets() {},
		dispose: function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	});

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	function LineBasicMaterial(parameters) {
		Material.call(this);
		this.type = 'LineBasicMaterial';
		this.color = new Color(0xffffff);
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
		this.morphTargets = false;
		this.setValues(parameters);
	}

	LineBasicMaterial.prototype = Object.create(Material.prototype);
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
		this.morphTargets = source.morphTargets;
		return this;
	};

	var _start = new Vector3();

	var _end = new Vector3();

	var _inverseMatrix$1 = new Matrix4();

	var _ray$1 = new Ray();

	var _sphere$2 = new Sphere();

	function Line(geometry, material) {
		if (geometry === void 0) {
			geometry = new BufferGeometry();
		}

		if (material === void 0) {
			material = new LineBasicMaterial();
		}

		Object3D.call(this);
		this.type = 'Line';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}

	Line.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Line,
		isLine: true,
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		},
		computeLineDistances: function computeLineDistances() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					var positionAttribute = geometry.attributes.position;
					var lineDistances = [0];

					for (var i = 1, l = positionAttribute.count; i < l; i++) {
						_start.fromBufferAttribute(positionAttribute, i - 1);

						_end.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		},
		raycast: function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere);

			_sphere$2.applyMatrix4(matrixWorld);

			_sphere$2.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			var localThresholdSq = localThreshold * localThreshold;
			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if (index !== null) {
					var indices = index.array;

					for (var i = 0, l = indices.length - 1; i < l; i += step) {
						var a = indices[i];
						var b = indices[i + 1];
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					for (var _i = 0, _l = positionAttribute.count - 1; _i < _l; _i += step) {
						vStart.fromBufferAttribute(positionAttribute, _i);
						vEnd.fromBufferAttribute(positionAttribute, _i + 1);

						var _distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (_distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						var _distance = raycaster.ray.origin.distanceTo(interRay);

						if (_distance < raycaster.near || _distance > raycaster.far) continue;
						intersects.push({
							distance: _distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: _i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		},
		updateMorphTargets: function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}
	});

	var _start$1 = new Vector3();

	var _end$1 = new Vector3();

	function LineSegments(geometry, material) {
		Line.call(this, geometry, material);
		this.type = 'LineSegments';
	}

	LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
		constructor: LineSegments,
		isLineSegments: true,
		computeLineDistances: function computeLineDistances() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					var positionAttribute = geometry.attributes.position;
					var lineDistances = [];

					for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start$1.fromBufferAttribute(positionAttribute, i);

						_end$1.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}
	});

	function LineLoop(geometry, material) {
		Line.call(this, geometry, material);
		this.type = 'LineLoop';
	}

	LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
		constructor: LineLoop,
		isLineLoop: true
	});

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 *	morphTargets: <bool>
	 * }
	 */

	function PointsMaterial(parameters) {
		Material.call(this);
		this.type = 'PointsMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.alphaMap = null;
		this.size = 1;
		this.sizeAttenuation = true;
		this.morphTargets = false;
		this.setValues(parameters);
	}

	PointsMaterial.prototype = Object.create(Material.prototype);
	PointsMaterial.prototype.constructor = PointsMaterial;
	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.map = source.map;
		this.alphaMap = source.alphaMap;
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
		this.morphTargets = source.morphTargets;
		return this;
	};

	var _inverseMatrix$2 = new Matrix4();

	var _ray$2 = new Ray();

	var _sphere$3 = new Sphere();

	var _position$1 = new Vector3();

	function Points(geometry, material) {
		if (geometry === void 0) {
			geometry = new BufferGeometry();
		}

		if (material === void 0) {
			material = new PointsMaterial();
		}

		Object3D.call(this);
		this.type = 'Points';
		this.geometry = geometry;
		this.material = material;
		this.updateMorphTargets();
	}

	Points.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Points,
		isPoints: true,
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		},
		raycast: function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			_sphere$3.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

			var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			var localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if (index !== null) {
					var indices = index.array;

					for (var i = 0, il = indices.length; i < il; i++) {
						var a = indices[i];

						_position$1.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					for (var _i = 0, l = positionAttribute.count; _i < l; _i++) {
						_position$1.fromBufferAttribute(positionAttribute, _i);

						testPoint(_position$1, _i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		},
		updateMorphTargets: function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}
	});

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			var intersectPoint = new Vector3();

			_ray$2.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			var distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.format = format !== undefined ? format : RGBFormat;
		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.generateMipmaps = false;
		var scope = this;

		function updateVideo() {
			scope.needsUpdate = true;
			video.requestVideoFrameCallback(updateVideo);
		}

		if ('requestVideoFrameCallback' in video) {
			video.requestVideoFrameCallback(updateVideo);
		}
	}

	VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
		constructor: VideoTexture,
		clone: function clone() {
			return new this.constructor(this.image).copy(this);
		},
		isVideoTexture: true,
		update: function update() {
			var video = this.image;
			var hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}
	});

	function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		this.image = {
			width: width,
			height: height
		};
		this.mipmaps = mipmaps; // no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false; // can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;
	}

	CompressedTexture.prototype = Object.create(Texture.prototype);
	CompressedTexture.prototype.constructor = CompressedTexture;
	CompressedTexture.prototype.isCompressedTexture = true;

	function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.needsUpdate = true;
	}

	CanvasTexture.prototype = Object.create(Texture.prototype);
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
		format = format !== undefined ? format : DepthFormat;

		if (format !== DepthFormat && format !== DepthStencilFormat) {
			throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
		}

		if (type === undefined && format === DepthFormat) type = UnsignedShortType;
		if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
		this.image = {
			width: width,
			height: height
		};
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
		this.flipY = false;
		this.generateMipmaps = false;
	}

	DepthTexture.prototype = Object.create(Texture.prototype);
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	var CircleGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(CircleGeometry, _BufferGeometry);

		function CircleGeometry(radius, segments, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (segments === void 0) {
				segments = 8;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'CircleGeometry';
			_this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var vertex = new Vector3();
			var uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (var s = 0, i = 3; s <= segments; s++, i += 3) {
				var segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (var _i = 1; _i <= segments; _i++) {
				indices.push(_i, _i + 1, 0);
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		return CircleGeometry;
	}(BufferGeometry);

	var CylinderGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(CylinderGeometry, _BufferGeometry);

		function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			var _this;

			if (radiusTop === void 0) {
				radiusTop = 1;
			}

			if (radiusBottom === void 0) {
				radiusBottom = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (openEnded === void 0) {
				openEnded = false;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'CylinderGeometry';
			_this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = _assertThisInitialized(_this);

			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var index = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				var normal = new Vector3();
				var vertex = new Vector3();
				var groupCount = 0; // this will be used to calculate the normal

				var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (var y = 0; y <= heightSegments; y++) {
					var indexRow = [];
					var v = y / heightSegments; // calculate the radius of the current row

					var radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (var x = 0; x <= radialSegments; x++) {
						var u = x / radialSegments;
						var theta = u * thetaLength + thetaStart;
						var sinTheta = Math.sin(theta);
						var cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (var _x = 0; _x < radialSegments; _x++) {
					for (var _y = 0; _y < heightSegments; _y++) {
						// we use the index array to access the correct indices
						var a = indexArray[_y][_x];
						var b = indexArray[_y + 1][_x];
						var c = indexArray[_y + 1][_x + 1];
						var d = indexArray[_y][_x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				var centerIndexStart = index;
				var uv = new Vector2();
				var vertex = new Vector3();
				var groupCount = 0;
				var radius = top === true ? radiusTop : radiusBottom;
				var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (var x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (var _x2 = 0; _x2 <= radialSegments; _x2++) {
					var u = _x2 / radialSegments;
					var theta = u * thetaLength + thetaStart;
					var cosTheta = Math.cos(theta);
					var sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (var _x3 = 0; _x3 < radialSegments; _x3++) {
					var c = centerIndexStart + _x3;
					var i = centerIndexEnd + _x3;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}

			return _this;
		}

		return CylinderGeometry;
	}(BufferGeometry);

	var ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
		_inheritsLoose(ConeGeometry, _CylinderGeometry);

		function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (openEnded === void 0) {
				openEnded = false;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
			_this.type = 'ConeGeometry';
			_this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			return _this;
		}

		return ConeGeometry;
	}(CylinderGeometry);

	var PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(PolyhedronGeometry, _BufferGeometry);

		function PolyhedronGeometry(vertices, indices, radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'PolyhedronGeometry';
			_this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			var vertexBuffer = [];
			var uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			_this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				_this.computeVertexNormals(); // flat normals

			} else {
				_this.normalizeNormals(); // smooth normals

			} // helper functions


			function subdivide(detail) {
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (var i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				var cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				var v = []; // construct all of the vertices for this subdivision

				for (var i = 0; i <= cols; i++) {
					v[i] = [];
					var aj = a.clone().lerp(c, i / cols);
					var bj = b.clone().lerp(c, i / cols);
					var rows = cols - i;

					for (var j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (var _i = 0; _i < cols; _i++) {
					for (var _j = 0; _j < 2 * (cols - _i) - 1; _j++) {
						var k = Math.floor(_j / 2);

						if (_j % 2 === 0) {
							pushVertex(v[_i][k + 1]);
							pushVertex(v[_i + 1][k]);
							pushVertex(v[_i][k]);
						} else {
							pushVertex(v[_i][k + 1]);
							pushVertex(v[_i + 1][k + 1]);
							pushVertex(v[_i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (var i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				var vertex = new Vector3();

				for (var i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					var u = azimuth(vertex) / 2 / Math.PI + 0.5;
					var v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (var i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					var x0 = uvBuffer[i + 0];
					var x1 = uvBuffer[i + 2];
					var x2 = uvBuffer[i + 4];
					var max = Math.max(x0, x1, x2);
					var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				var stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
				var centroid = new Vector3();
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					var azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}

			return _this;
		}

		return PolyhedronGeometry;
	}(BufferGeometry);

	var DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(DodecahedronGeometry, _PolyhedronGeometry);

		function DodecahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var t = (1 + Math.sqrt(5)) / 2;
			var r = 1 / t;
			var vertices = [// (1, 1, 1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, 1/, )
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (1/, , 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (, 0, 1/)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'DodecahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		return DodecahedronGeometry;
	}(PolyhedronGeometry);

	var _v0$2 = new Vector3();

	var _v1$5 = new Vector3();

	var _normal$1 = new Vector3();

	var _triangle = new Triangle();

	var EdgesGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(EdgesGeometry, _BufferGeometry);

		function EdgesGeometry(geometry, thresholdAngle) {
			var _this;

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'EdgesGeometry';
			_this.parameters = {
				thresholdAngle: thresholdAngle
			};
			thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

			if (geometry.isGeometry === true) {
				console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return _assertThisInitialized(_this);
			}

			var precisionPoints = 4;
			var precision = Math.pow(10, precisionPoints);
			var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
			var indexAttr = geometry.getIndex();
			var positionAttr = geometry.getAttribute('position');
			var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
			var indexArr = [0, 0, 0];
			var vertKeys = ['a', 'b', 'c'];
			var hashes = new Array(3);
			var edgeData = {};
			var vertices = [];

			for (var i = 0; i < indexCount; i += 3) {
				if (indexAttr) {
					indexArr[0] = indexAttr.getX(i);
					indexArr[1] = indexAttr.getX(i + 1);
					indexArr[2] = indexAttr.getX(i + 2);
				} else {
					indexArr[0] = i;
					indexArr[1] = i + 1;
					indexArr[2] = i + 2;
				}

				var a = _triangle.a,
						b = _triangle.b,
						c = _triangle.c;
				a.fromBufferAttribute(positionAttr, indexArr[0]);
				b.fromBufferAttribute(positionAttr, indexArr[1]);
				c.fromBufferAttribute(positionAttr, indexArr[2]);

				_triangle.getNormal(_normal$1); // create hashes for the edge from the vertices


				hashes[0] = Math.round(a.x * precision) + "," + Math.round(a.y * precision) + "," + Math.round(a.z * precision);
				hashes[1] = Math.round(b.x * precision) + "," + Math.round(b.y * precision) + "," + Math.round(b.z * precision);
				hashes[2] = Math.round(c.x * precision) + "," + Math.round(c.y * precision) + "," + Math.round(c.z * precision); // skip degenerate triangles

				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
					continue;
				} // iterate over every edge


				for (var j = 0; j < 3; j++) {
					// get the first and next vertex making up the edge
					var jNext = (j + 1) % 3;
					var vecHash0 = hashes[j];
					var vecHash1 = hashes[jNext];
					var v0 = _triangle[vertKeys[j]];
					var v1 = _triangle[vertKeys[jNext]];
					var hash = vecHash0 + "_" + vecHash1;
					var reverseHash = vecHash1 + "_" + vecHash0;

					if (reverseHash in edgeData && edgeData[reverseHash]) {
						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
							vertices.push(v0.x, v0.y, v0.z);
							vertices.push(v1.x, v1.y, v1.z);
						}

						edgeData[reverseHash] = null;
					} else if (!(hash in edgeData)) {
						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {
							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal$1.clone()
						};
					}
				}
			} // iterate over all remaining, unmatched edges and add them to the vertex array


			for (var key in edgeData) {
				if (edgeData[key]) {
					var _edgeData$key = edgeData[key],
							index0 = _edgeData$key.index0,
							index1 = _edgeData$key.index1;

					_v0$2.fromBufferAttribute(positionAttr, index0);

					_v1$5.fromBufferAttribute(positionAttr, index1);

					vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
					vertices.push(_v1$5.x, _v1$5.y, _v1$5.z);
				}
			}

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			return _this;
		}

		return EdgesGeometry;
	}(BufferGeometry);

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	var Earcut = {
		triangulate: function triangulate(data, holeIndices, dim) {
			dim = dim || 2;
			var hasHoles = holeIndices && holeIndices.length;
			var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			var outerNode = linkedList(data, 0, outerLen, dim, true);
			var triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			var minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (var i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		var i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) {
				last = insertNode(i, data[i], data[i + 1], last);
			}
		} else {
			for (i = end - dim; i >= start; i -= dim) {
				last = insertNode(i, data[i], data[i + 1], last);
			}
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		var p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		var stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		var a = ear.prev,
				b = ear,
				c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		var p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		var a = ear.prev,
				b = ear,
				c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
				minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
				maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
				maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		var minZ = zOrder(minTX, minTY, minX, minY, invSize),
				maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		var p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		var p = start;

		do {
			var a = p.prev,
					b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		var a = start;

		do {
			var b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					var c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		var queue = [];
		var i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		var p = outerNode;
		var hx = hole.x;
		var hy = hole.y;
		var qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
				mx = m.x,
				my = m.y;
		var tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		var p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		var i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		var p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		var o1 = sign(area(p1, q1, p2));
		var o2 = sign(area(p1, q1, q2));
		var o3 = sign(area(p2, q2, p1));
		var o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		var p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		var p = a,
				inside = false;
		var px = (a.x + b.x) / 2,
				py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		var a2 = new Node(a.i, a.x, a.y),
				b2 = new Node(b.i, b.x, b.y),
				an = a.next,
				bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		var p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		var sum = 0;

		for (var i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	var ShapeUtils = {
		// calculate area of the contour polygon
		area: function area(contour) {
			var n = contour.length;
			var a = 0.0;

			for (var p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		},
		isClockWise: function isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		},
		triangulateShape: function triangulateShape(contour, holes) {
			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			var holeIndices = []; // array of hole indices

			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			var holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (var i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			var triangles = Earcut.triangulate(vertices, holeIndices); //

			for (var _i = 0; _i < triangles.length; _i += 3) {
				faces.push(triangles.slice(_i, _i + 3));
			}

			return faces;
		}
	};

	function removeDupEndPts(points) {
		var l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (var i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	var ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(ExtrudeGeometry, _BufferGeometry);

		function ExtrudeGeometry(shapes, options) {
			var _this;

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'ExtrudeGeometry';
			_this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];

			var scope = _assertThisInitialized(_this);

			var verticesArray = [];
			var uvArray = [];

			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				addShape(shape);
			} // build geometry


			_this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));

			_this.computeVertexNormals(); // functions


			function addShape(shape) {
				var placeholder = []; // options

				var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				var steps = options.steps !== undefined ? options.steps : 1;
				var depth = options.depth !== undefined ? options.depth : 100;
				var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				var extrudePath = options.extrudePath;
				var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				var extrudePts,
						extrudeByPath = false;
				var splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				var shapePoints = shape.extractPoints(curveSegments);
				var vertices = shapePoints.shape;
				var holes = shapePoints.holes;
				var reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (var h = 0, hl = holes.length; h < hl; h++) {
						var ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				var faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				var contour = vertices; // vertices has all points but contour has only points of circumference

				for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
					var _ahole = holes[_h];
					vertices = vertices.concat(_ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				var vlen = vertices.length,
						flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					var v_prev_x = inPt.x - inPrev.x,
							v_prev_y = inPt.y - inPrev.y;
					var v_next_x = inNext.x - inPt.x,
							v_next_y = inNext.y - inPt.y;
					var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						var v_prev_len = Math.sqrt(v_prev_lensq);
						var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						var ptNextShift_x = inNext.x - v_next_y / v_next_len;
						var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						var direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				var contourMovements = [];

				for (var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);
				}

				var holesMovements = [];
				var oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
					var _ahole2 = holes[_h2];
					oneHoleMovements = [];

					for (var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++) {
						if (_j === _il) _j = 0;
						if (_k === _il) _k = 0; //	(j)---(i)---(k)

						oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (var b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					var t = b / bevelSegments;
					var z = bevelThickness * Math.cos(t * Math.PI / 2);

					var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape


					for (var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++) {
						var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
						var _ahole3 = holes[_h3];
						oneHoleMovements = holesMovements[_h3];

						for (var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++) {
							var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);

							v(_vert.x, _vert.y, -z);
						}
					}
				}

				var bs = bevelSize + bevelOffset; // Back facing vertices

				for (var _i5 = 0; _i5 < vlen; _i5++) {
					var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];

					if (!extrudeByPath) {
						v(_vert2.x, _vert2.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (var s = 1; s <= steps; s++) {
					for (var _i6 = 0; _i6 < vlen; _i6++) {
						var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];

						if (!extrudeByPath) {
							v(_vert3.x, _vert3.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (var _b = bevelSegments - 1; _b >= 0; _b--) {
					var _t = _b / bevelSegments;

					var _z = bevelThickness * Math.cos(_t * Math.PI / 2);

					var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape


					for (var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++) {
						var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);

						v(_vert4.x, _vert4.y, depth + _z);
					} // expand holes


					for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
						var _ahole4 = holes[_h4];
						oneHoleMovements = holesMovements[_h4];

						for (var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++) {
							var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);

							if (!extrudeByPath) {
								v(_vert5.x, _vert5.y, depth + _z);
							} else {
								v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					var start = verticesArray.length / 3;

					if (bevelEnabled) {
						var layer = 0; // steps + 1

						var offset = vlen * layer; // Bottom faces

						for (var _i9 = 0; _i9 < flen; _i9++) {
							var face = faces[_i9];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (var _i10 = 0; _i10 < flen; _i10++) {
							var _face = faces[_i10];
							f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
						}
					} else {
						// Bottom faces
						for (var _i11 = 0; _i11 < flen; _i11++) {
							var _face2 = faces[_i11];
							f3(_face2[2], _face2[1], _face2[0]);
						} // Top faces


						for (var _i12 = 0; _i12 < flen; _i12++) {
							var _face3 = faces[_i12];
							f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					var start = verticesArray.length / 3;
					var layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
						var _ahole5 = holes[_h5];
						sidewalls(_ahole5, layeroffset); //, true

						layeroffset += _ahole5.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					var i = contour.length;

					while (--i >= 0) {
						var _j2 = i;

						var _k2 = i - 1;

						if (_k2 < 0) _k2 = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++) {
							var slen1 = vlen * _s;
							var slen2 = vlen * (_s + 1);

							var a = layeroffset + _j2 + slen1,
									_b2 = layeroffset + _k2 + slen1,
									c = layeroffset + _k2 + slen2,
									d = layeroffset + _j2 + slen2;

							f4(a, _b2, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}

			return _this;
		}

		var _proto = ExtrudeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = BufferGeometry.prototype.toJSON.call(this);
			var shapes = this.parameters.shapes;
			var options = this.parameters.options;
			return _toJSON(shapes, options, data);
		};

		return ExtrudeGeometry;
	}(BufferGeometry);

	var WorldUVGenerator = {
		generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
			var a_x = vertices[indexA * 3];
			var a_y = vertices[indexA * 3 + 1];
			var b_x = vertices[indexB * 3];
			var b_y = vertices[indexB * 3 + 1];
			var c_x = vertices[indexC * 3];
			var c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
			var a_x = vertices[indexA * 3];
			var a_y = vertices[indexA * 3 + 1];
			var a_z = vertices[indexA * 3 + 2];
			var b_x = vertices[indexB * 3];
			var b_y = vertices[indexB * 3 + 1];
			var b_z = vertices[indexB * 3 + 2];
			var c_x = vertices[indexC * 3];
			var c_y = vertices[indexC * 3 + 1];
			var c_z = vertices[indexC * 3 + 2];
			var d_x = vertices[indexD * 3];
			var d_y = vertices[indexD * 3 + 1];
			var d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < 0.01) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function _toJSON(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	var IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(IcosahedronGeometry, _PolyhedronGeometry);

		function IcosahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var t = (1 + Math.sqrt(5)) / 2;
			var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'IcosahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		return IcosahedronGeometry;
	}(PolyhedronGeometry);

	var LatheGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(LatheGeometry, _BufferGeometry);

		function LatheGeometry(points, segments, phiStart, phiLength) {
			var _this;

			if (segments === void 0) {
				segments = 12;
			}

			if (phiStart === void 0) {
				phiStart = 0;
			}

			if (phiLength === void 0) {
				phiLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'LatheGeometry';
			_this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

			var indices = [];
			var vertices = [];
			var uvs = []; // helper variables

			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2(); // generate vertices and uvs

			for (var i = 0; i <= segments; i++) {
				var phi = phiStart + i * inverseSegments * phiLength;
				var sin = Math.sin(phi);
				var cos = Math.cos(phi);

				for (var j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (var _i = 0; _i < segments; _i++) {
				for (var _j = 0; _j < points.length - 1; _j++) {
					var base = _j + _i * points.length;
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals


			_this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).


			if (phiLength === Math.PI * 2) {
				var normals = _this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3(); // this is the buffer offset for the last line of vertices

				var _base = segments * points.length * 3;

				for (var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[_j2 + 0];
					n1.y = normals[_j2 + 1];
					n1.z = normals[_j2 + 2]; // select the normal of the vertex in the last line

					n2.x = normals[_base + _j2 + 0];
					n2.y = normals[_base + _j2 + 1];
					n2.z = normals[_base + _j2 + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;
					normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;
					normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;
				}
			}

			return _this;
		}

		return LatheGeometry;
	}(BufferGeometry);

	var OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(OctahedronGeometry, _PolyhedronGeometry);

		function OctahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'OctahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		return OctahedronGeometry;
	}(PolyhedronGeometry);

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	function ParametricGeometry(func, slices, stacks) {
		BufferGeometry.call(this);
		this.type = 'ParametricGeometry';
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		}; // buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
		var EPS = 0.00001;
		var normal = new Vector3();
		var p0 = new Vector3(),
				p1 = new Vector3();
		var pu = new Vector3(),
				pv = new Vector3();

		if (func.length < 3) {
			console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
		} // generate vertices, normals and uvs


		var sliceCount = slices + 1;

		for (var i = 0; i <= stacks; i++) {
			var v = i / stacks;

			for (var j = 0; j <= slices; j++) {
				var u = j / slices; // vertex

				func(u, v, p0);
				vertices.push(p0.x, p0.y, p0.z); // normal
				// approximate tangent vectors via finite differences

				if (u - EPS >= 0) {
					func(u - EPS, v, p1);
					pu.subVectors(p0, p1);
				} else {
					func(u + EPS, v, p1);
					pu.subVectors(p1, p0);
				}

				if (v - EPS >= 0) {
					func(u, v - EPS, p1);
					pv.subVectors(p0, p1);
				} else {
					func(u, v + EPS, p1);
					pv.subVectors(p1, p0);
				} // cross product of tangent vectors returns surface normal


				normal.crossVectors(pu, pv).normalize();
				normals.push(normal.x, normal.y, normal.z); // uv

				uvs.push(u, v);
			}
		} // generate indices


		for (var _i = 0; _i < stacks; _i++) {
			for (var _j = 0; _j < slices; _j++) {
				var a = _i * sliceCount + _j;
				var b = _i * sliceCount + _j + 1;
				var c = (_i + 1) * sliceCount + _j + 1;
				var d = (_i + 1) * sliceCount + _j; // faces one and two

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		} // build geometry


		this.setIndex(indices);
		this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	var RingGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(RingGeometry, _BufferGeometry);

		function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
			var _this;

			if (innerRadius === void 0) {
				innerRadius = 0.5;
			}

			if (outerRadius === void 0) {
				outerRadius = 1;
			}

			if (thetaSegments === void 0) {
				thetaSegments = 8;
			}

			if (phiSegments === void 0) {
				phiSegments = 1;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'RingGeometry';
			_this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // some helper variables

			var radius = innerRadius;
			var radiusStep = (outerRadius - innerRadius) / phiSegments;
			var vertex = new Vector3();
			var uv = new Vector2(); // generate vertices, normals and uvs

			for (var j = 0; j <= phiSegments; j++) {
				for (var i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					var segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (var _j = 0; _j < phiSegments; _j++) {
				var thetaSegmentLevel = _j * (thetaSegments + 1);

				for (var _i = 0; _i < thetaSegments; _i++) {
					var _segment = _i + thetaSegmentLevel;

					var a = _segment;
					var b = _segment + thetaSegments + 1;
					var c = _segment + thetaSegments + 2;
					var d = _segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		return RingGeometry;
	}(BufferGeometry);

	var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(ShapeGeometry, _BufferGeometry);

		function ShapeGeometry(shapes, curveSegments) {
			var _this;

			if (curveSegments === void 0) {
				curveSegments = 12;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'ShapeGeometry';
			_this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var groupStart = 0;
			var groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (var i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);

					_this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support


					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions


			function addShape(shape) {
				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints(curveSegments);
				var shapeVertices = points.shape;
				var shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {
					var shapeHole = shapeHoles[_i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[_i] = shapeHole.reverse();
					}
				}

				var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {
					var _shapeHole = shapeHoles[_i2];
					shapeVertices = shapeVertices.concat(_shapeHole);
				} // vertices, normals, uvs


				for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {
					var vertex = shapeVertices[_i3];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {
					var face = faces[_i4];
					var a = face[0] + indexOffset;
					var b = face[1] + indexOffset;
					var c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}

			return _this;
		}

		var _proto = ShapeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = BufferGeometry.prototype.toJSON.call(this);
			var shapes = this.parameters.shapes;
			return _toJSON$1(shapes, data);
		};

		return ShapeGeometry;
	}(BufferGeometry);

	function _toJSON$1(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	var SphereGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(SphereGeometry, _BufferGeometry);

		function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 8;
			}

			if (heightSegments === void 0) {
				heightSegments = 6;
			}

			if (phiStart === void 0) {
				phiStart = 0;
			}

			if (phiLength === void 0) {
				phiLength = Math.PI * 2;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'SphereGeometry';
			_this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			var index = 0;
			var grid = [];
			var vertex = new Vector3();
			var normal = new Vector3(); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // generate vertices, normals and uvs

			for (var iy = 0; iy <= heightSegments; iy++) {
				var verticesRow = [];
				var v = iy / heightSegments; // special case for the poles

				var uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (var ix = 0; ix <= widthSegments; ix++) {
					var u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (var _iy = 0; _iy < heightSegments; _iy++) {
				for (var _ix = 0; _ix < widthSegments; _ix++) {
					var a = grid[_iy][_ix + 1];
					var b = grid[_iy][_ix];
					var c = grid[_iy + 1][_ix];
					var d = grid[_iy + 1][_ix + 1];
					if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		return SphereGeometry;
	}(BufferGeometry);

	var TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(TetrahedronGeometry, _PolyhedronGeometry);

		function TetrahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'TetrahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		return TetrahedronGeometry;
	}(PolyhedronGeometry);

	var TextGeometry = /*#__PURE__*/function (_ExtrudeGeometry) {
		_inheritsLoose(TextGeometry, _ExtrudeGeometry);

		function TextGeometry(text, parameters) {
			var _this;

			if (parameters === void 0) {
				parameters = {};
			}

			var font = parameters.font;

			if (!(font && font.isFont)) {
				console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
				return new BufferGeometry() || _assertThisInitialized(_this);
			}

			var shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
			_this = _ExtrudeGeometry.call(this, shapes, parameters) || this;
			_this.type = 'TextGeometry';
			return _this;
		}

		return TextGeometry;
	}(ExtrudeGeometry);

	var TorusGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TorusGeometry, _BufferGeometry);

		function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (tube === void 0) {
				tube = 0.4;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (tubularSegments === void 0) {
				tubularSegments = 6;
			}

			if (arc === void 0) {
				arc = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TorusGeometry';
			_this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3(); // generate vertices, normals and uvs

			for (var j = 0; j <= radialSegments; j++) {
				for (var i = 0; i <= tubularSegments; i++) {
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (var _j = 1; _j <= radialSegments; _j++) {
				for (var _i = 1; _i <= tubularSegments; _i++) {
					// indices
					var a = (tubularSegments + 1) * _j + _i - 1;
					var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
					var c = (tubularSegments + 1) * (_j - 1) + _i;
					var d = (tubularSegments + 1) * _j + _i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		return TorusGeometry;
	}(BufferGeometry);

	var TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TorusKnotGeometry, _BufferGeometry);

		function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (tube === void 0) {
				tube = 0.4;
			}

			if (tubularSegments === void 0) {
				tubularSegments = 64;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (p === void 0) {
				p = 2;
			}

			if (q === void 0) {
				q = 3;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TorusKnotGeometry';
			_this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var P1 = new Vector3();
			var P2 = new Vector3();
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3(); // generate vertices, normals and uvs

			for (var i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (var j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					var v = j / radialSegments * Math.PI * 2;
					var cx = -tube * Math.cos(v);
					var cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (var _j = 1; _j <= tubularSegments; _j++) {
				for (var _i = 1; _i <= radialSegments; _i++) {
					// indices
					var a = (radialSegments + 1) * (_j - 1) + (_i - 1);
					var b = (radialSegments + 1) * _j + (_i - 1);
					var c = (radialSegments + 1) * _j + _i;
					var d = (radialSegments + 1) * (_j - 1) + _i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve


			function calculatePositionOnCurve(u, p, q, radius, position) {
				var cu = Math.cos(u);
				var su = Math.sin(u);
				var quOverP = q / p * u;
				var cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}

			return _this;
		}

		return TorusKnotGeometry;
	}(BufferGeometry);

	var TubeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TubeGeometry, _BufferGeometry);

		function TubeGeometry(path, tubularSegments, radius, radialSegments, closed) {
			var _this;

			if (tubularSegments === void 0) {
				tubularSegments = 64;
			}

			if (radius === void 0) {
				radius = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (closed === void 0) {
				closed = false;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TubeGeometry';
			_this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			_this.tangents = frames.tangents;
			_this.normals = frames.normals;
			_this.binormals = frames.binormals; // helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
			var P = new Vector3(); // buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = []; // create buffer data

			generateBufferData(); // build geometry

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions


			function generateBufferData() {
				for (var i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				var N = frames.normals[i];
				var B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (var j = 0; j <= radialSegments; j++) {
					var v = j / radialSegments * Math.PI * 2;
					var sin = Math.sin(v);
					var cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (var j = 1; j <= tubularSegments; j++) {
					for (var i = 1; i <= radialSegments; i++) {
						var a = (radialSegments + 1) * (j - 1) + (i - 1);
						var b = (radialSegments + 1) * j + (i - 1);
						var c = (radialSegments + 1) * j + i;
						var d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (var i = 0; i <= tubularSegments; i++) {
					for (var j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}

			return _this;
		}

		var _proto = TubeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = BufferGeometry.prototype.toJSON.call(this);
			data.path = this.parameters.path.toJSON();
			return data;
		};

		return TubeGeometry;
	}(BufferGeometry);

	var WireframeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(WireframeGeometry, _BufferGeometry);

		function WireframeGeometry(geometry) {
			var _this;

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'WireframeGeometry';

			if (geometry.isGeometry === true) {
				console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return _assertThisInitialized(_this);
			} // buffer


			var vertices = []; // helper variables

			var edge = [0, 0],
					edges = {};
			var vertex = new Vector3();

			if (geometry.index !== null) {
				// indexed BufferGeometry
				var position = geometry.attributes.position;
				var indices = geometry.index;
				var groups = geometry.groups;

				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				} // create a data structure that contains all eges without duplicates


				for (var o = 0, ol = groups.length; o < ol; ++o) {
					var group = groups[o];
					var start = group.start;
					var count = group.count;

					for (var i = start, l = start + count; i < l; i += 3) {
						for (var j = 0; j < 3; j++) {
							var edge1 = indices.getX(i + j);
							var edge2 = indices.getX(i + (j + 1) % 3);
							edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

							edge[1] = Math.max(edge1, edge2);
							var key = edge[0] + ',' + edge[1];

							if (edges[key] === undefined) {
								edges[key] = {
									index1: edge[0],
									index2: edge[1]
								};
							}
						}
					}
				} // generate vertices


				for (var _key in edges) {
					var e = edges[_key];
					vertex.fromBufferAttribute(position, e.index1);
					vertices.push(vertex.x, vertex.y, vertex.z);
					vertex.fromBufferAttribute(position, e.index2);
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			} else {
				// non-indexed BufferGeometry
				var _position = geometry.attributes.position;

				for (var _i = 0, _l = _position.count / 3; _i < _l; _i++) {
					for (var _j = 0; _j < 3; _j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
						var index1 = 3 * _i + _j;
						vertex.fromBufferAttribute(_position, index1);
						vertices.push(vertex.x, vertex.y, vertex.z);
						var index2 = 3 * _i + (_j + 1) % 3;
						vertex.fromBufferAttribute(_position, index2);
						vertices.push(vertex.x, vertex.y, vertex.z);
					}
				}
			} // build geometry


			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			return _this;
		}

		return WireframeGeometry;
	}(BufferGeometry);

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial(parameters) {
		Material.call(this);
		this.type = 'ShadowMaterial';
		this.color = new Color(0x000000);
		this.transparent = true;
		this.setValues(parameters);
	}

	ShadowMaterial.prototype = Object.create(Material.prototype);
	ShadowMaterial.prototype.constructor = ShadowMaterial;
	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		return this;
	};

	function RawShaderMaterial(parameters) {
		ShaderMaterial.call(this, parameters);
		this.type = 'RawShaderMaterial';
	}

	RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial(parameters) {
		Material.call(this);
		this.defines = {
			'STANDARD': ''
		};
		this.type = 'MeshStandardMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.roughness = 1.0;
		this.metalness = 0.0;
		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.roughnessMap = null;
		this.metalnessMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.envMapIntensity = 1.0;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.vertexTangents = false;
		this.setValues(parameters);
	}

	MeshStandardMaterial.prototype = Object.create(Material.prototype);
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.defines = {
			'STANDARD': ''
		};
		this.color.copy(source.color);
		this.roughness = source.roughness;
		this.metalness = source.metalness;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.roughnessMap = source.roughnessMap;
		this.metalnessMap = source.metalnessMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		this.vertexTangents = source.vertexTangents;
		return this;
	};

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	reflectivity: <float>,
	 *	ior: <float>,
	 *
	 *	sheen: <Color>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshPhysicalMaterial(parameters) {
		MeshStandardMaterial.call(this);
		this.defines = {
			'STANDARD': '',
			'PHYSICAL': ''
		};
		this.type = 'MeshPhysicalMaterial';
		this.clearcoat = 0.0;
		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2(1, 1);
		this.clearcoatNormalMap = null;
		this.reflectivity = 0.5; // maps to F0 = 0.04

		Object.defineProperty(this, 'ior', {
			get: function get() {
				return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
			},
			set: function set(ior) {
				this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
			}
		});
		this.sheen = null; // null will disable sheen bsdf

		this.transmission = 0.0;
		this.transmissionMap = null;
		this.setValues(parameters);
	}

	MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function (source) {
		MeshStandardMaterial.prototype.copy.call(this, source);
		this.defines = {
			'STANDARD': '',
			'PHYSICAL': ''
		};
		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
		this.reflectivity = source.reflectivity;

		if (source.sheen) {
			this.sheen = (this.sheen || new Color()).copy(source.sheen);
		} else {
			this.sheen = null;
		}

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;
		return this;
	};

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshPhongMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.specular = new Color(0x111111);
		this.shininess = 30;
		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.setValues(parameters);
	}

	MeshPhongMaterial.prototype = Object.create(Material.prototype);
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.specular.copy(source.specular);
		this.shininess = source.shininess;
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		return this;
	};

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshToonMaterial(parameters) {
		Material.call(this);
		this.defines = {
			'TOON': ''
		};
		this.type = 'MeshToonMaterial';
		this.color = new Color(0xffffff);
		this.map = null;
		this.gradientMap = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.alphaMap = null;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.setValues(parameters);
	}

	MeshToonMaterial.prototype = Object.create(Material.prototype);
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.map = source.map;
		this.gradientMap = source.gradientMap;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		return this;
	};

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshNormalMaterial';
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.fog = false;
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.setValues(parameters);
	}

	MeshNormalMaterial.prototype = Object.create(Material.prototype);
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		return this;
	};

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial(parameters) {
		Material.call(this);
		this.type = 'MeshLambertMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.map = null;
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
		this.specularMap = null;
		this.alphaMap = null;
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.setValues(parameters);
	}

	MeshLambertMaterial.prototype = Object.create(Material.prototype);
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.color.copy(source.color);
		this.map = source.map;
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
		this.specularMap = source.specularMap;
		this.alphaMap = source.alphaMap;
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		return this;
	};

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	function MeshMatcapMaterial(parameters) {
		Material.call(this);
		this.defines = {
			'MATCAP': ''
		};
		this.type = 'MeshMatcapMaterial';
		this.color = new Color(0xffffff); // diffuse

		this.matcap = null;
		this.map = null;
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.alphaMap = null;
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
		this.setValues(parameters);
	}

	MeshMatcapMaterial.prototype = Object.create(Material.prototype);
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	MeshMatcapMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);
		this.defines = {
			'MATCAP': ''
		};
		this.color.copy(source.color);
		this.matcap = source.matcap;
		this.map = source.map;
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
		this.alphaMap = source.alphaMap;
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
		return this;
	};

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	function LineDashedMaterial(parameters) {
		LineBasicMaterial.call(this);
		this.type = 'LineDashedMaterial';
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
		this.setValues(parameters);
	}

	LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function (source) {
		LineBasicMaterial.prototype.copy.call(this, source);
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
		return this;
	};

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	var AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function arraySlice(array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function convertArray(array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function isTypedArray(object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function getKeyframeOrder(times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			var n = times.length;
			var result = new Array(n);

			for (var i = 0; i !== n; ++i) {
				result[i] = i;
			}

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function sortedArray(values, stride, order) {
			var nValues = values.length;
			var result = new values.constructor(nValues);

			for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				var srcOffset = order[i] * stride;

				for (var j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
			var i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			var value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function subclip(sourceClip, name, startFrame, endFrame, fps) {
			if (fps === void 0) {
				fps = 30;
			}

			var clip = sourceClip.clone();
			clip.name = name;
			var tracks = [];

			for (var i = 0; i < clip.tracks.length; ++i) {
				var track = clip.tracks[i];
				var valueSize = track.getValueSize();
				var times = [];
				var values = [];

				for (var j = 0; j < track.times.length; ++j) {
					var frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (var k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			var minStartTime = Infinity;

			for (var _i = 0; _i < clip.tracks.length; ++_i) {
				if (minStartTime > clip.tracks[_i].times[0]) {
					minStartTime = clip.tracks[_i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (var _i2 = 0; _i2 < clip.tracks.length; ++_i2) {
				clip.tracks[_i2].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame, referenceClip, fps) {
			if (referenceFrame === void 0) {
				referenceFrame = 0;
			}

			if (referenceClip === void 0) {
				referenceClip = targetClip;
			}

			if (fps === void 0) {
				fps = 30;
			}

			if (fps <= 0) fps = 30;
			var numTracks = referenceClip.tracks.length;
			var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			var _loop = function _loop(i) {
				var referenceTrack = referenceClip.tracks[i];
				var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') return "continue"; // Find the track in the target clip whose name and type matches the reference track

				var targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) return "continue";
				var referenceOffset = 0;
				var referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				var targetOffset = 0;
				var targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				var lastIndex = referenceTrack.times.length - 1;
				var referenceValue = void 0; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					var startIndex = referenceOffset;
					var endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					var _startIndex = lastIndex * referenceValueSize + referenceOffset;

					var _endIndex = _startIndex + referenceValueSize - referenceOffset;

					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);
				} else {
					// Interpolate to the reference value
					var interpolant = referenceTrack.createInterpolant();
					var _startIndex2 = referenceOffset;

					var _endIndex2 = referenceValueSize - referenceOffset;

					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				var numTimes = targetTrack.times.length;

				for (var j = 0; j < numTimes; ++j) {
					var valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (var k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			};

			for (var i = 0; i < numTracks; ++i) {
				var _ret = _loop(i);

				if (_ret === "continue") continue;
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
		this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	}

	Object.assign(Interpolant.prototype, {
		evaluate: function evaluate(t) {
			var pp = this.parameterPositions;
			var i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					var right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (var giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							var t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (var _giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === _giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						var mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		},
		settings: null,
		// optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
		// --- Protected interface
		DefaultSettings_: {},
		getSettings_: function getSettings_() {
			return this.settings || this.DefaultSettings_;
		},
		copySampleValue_: function copySampleValue_(index) {
			// copies a sample value to the result buffer
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

			for (var i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		},
		// Template methods for derived classes:
		interpolate_: function interpolate_()
		/* i1, t0, t, t1 */
		{
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		},
		intervalChanged_: function intervalChanged_()
		/* i1, t0, t1 */
		{// empty
		}
	}); // DECLARE ALIAS AFTER assign prototype

	Object.assign(Interpolant.prototype, {
		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,
		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_
	});

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
	}

	CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
		constructor: CubicInterpolant,
		DefaultSettings_: {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		},
		intervalChanged_: function intervalChanged_(i1, t0, t1) {
			var pp = this.parameterPositions;
			var iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			var halfDt = (t1 - t0) * 0.5,
					stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		},
		interpolate_: function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					o1 = i1 * stride,
					o0 = o1 - stride,
					oP = this._offsetPrev,
					oN = this._offsetNext,
					wP = this._weightPrev,
					wN = this._weightNext,
					p = (t - t0) / (t1 - t0),
					pp = p * p,
					ppp = pp * p; // evaluate polynomials

			var sP = -wP * ppp + 2 * wP * pp - wP * p;
			var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp; // combine data linearly

			for (var i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		}
	});

	function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
		constructor: LinearInterpolant,
		interpolate_: function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
					weight1 = (t - t0) / (t1 - t0),
					weight0 = 1 - weight1;

			for (var i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		}
	});

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
		constructor: DiscreteInterpolant,
		interpolate_: function interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		}
	});

	function KeyframeTrack(name, times, values, interpolation) {
		if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
		this.name = name;
		this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
		this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
		this.setInterpolation(interpolation || this.DefaultInterpolation);
	} // Static methods


	Object.assign(KeyframeTrack, {
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
		toJSON: function toJSON(track) {
			var trackType = track.constructor;
			var json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== undefined) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				var interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		}
	});
	Object.assign(KeyframeTrack.prototype, {
		constructor: KeyframeTrack,
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
		DefaultInterpolation: InterpolateLinear,
		InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		},
		InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		},
		InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		},
		setInterpolation: function setInterpolation(interpolation) {
			var factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		},
		getInterpolation: function getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		},
		getValueSize: function getValueSize() {
			return this.values.length / this.times.length;
		},
		// move all keyframes either forwards or backwards in time
		shift: function shift(timeOffset) {
			if (timeOffset !== 0.0) {
				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		},
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function scale(timeScale) {
			if (timeScale !== 1.0) {
				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		},
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function trim(startTime, endTime) {
			var times = this.times,
					nKeys = times.length;
			var from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		},
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function validate() {
			var valid = true;
			var valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			var times = this.times,
					values = this.values,
					nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			var prevTime = null;

			for (var i = 0; i !== nKeys; i++) {
				var currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (var _i = 0, n = values.length; _i !== n; ++_i) {
						var value = values[_i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		},
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			var times = AnimationUtils.arraySlice(this.times),
					values = AnimationUtils.arraySlice(this.values),
					stride = this.getValueSize(),
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
					lastIndex = times.length - 1;
			var writeIndex = 1;

			for (var i = 1; i < lastIndex; ++i) {
				var keep = false;
				var time = times[i];
				var timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

						for (var j = 0; j !== stride; ++j) {
							var value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						var readOffset = i * stride,
								writeOffset = writeIndex * stride;

						for (var _j = 0; _j !== stride; ++_j) {
							values[writeOffset + _j] = values[readOffset + _j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j2 = 0; _j2 !== stride; ++_j2) {
					values[_writeOffset + _j2] = values[_readOffset + _j2];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		},
		clone: function clone() {
			var times = AnimationUtils.arraySlice(this.times, 0);
			var values = AnimationUtils.arraySlice(this.values, 0);
			var TypedKeyframeTrack = this.constructor;
			var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		}
	});

	/**
	 * A Track of Boolean keyframe values.
	 */

	function BooleanKeyframeTrack(name, times, values) {
		KeyframeTrack.call(this, name, times, values);
	}

	BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: BooleanKeyframeTrack,
		ValueTypeName: 'bool',
		ValueBufferType: Array,
		DefaultInterpolation: InterpolateDiscrete,
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined // Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	});

	/**
	 * A Track of keyframe values that represent color.
	 */

	function ColorKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: ColorKeyframeTrack,
		ValueTypeName: 'color' // ValueBufferType is inherited
		// DefaultInterpolation is inherited
		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	});

	/**
	 * A Track of numeric keyframe values.
	 */

	function NumberKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: NumberKeyframeTrack,
		ValueTypeName: 'number' // ValueBufferType is inherited
		// DefaultInterpolation is inherited

	});

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
		constructor: QuaternionLinearInterpolant,
		interpolate_: function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					alpha = (t - t0) / (t1 - t0);
			var offset = i1 * stride;

			for (var end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		}
	});

	/**
	 * A Track of quaternion keyframe values.
	 */

	function QuaternionKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: QuaternionKeyframeTrack,
		ValueTypeName: 'quaternion',
		// ValueBufferType is inherited
		DefaultInterpolation: InterpolateLinear,
		InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		},
		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	});

	/**
	 * A Track that interpolates Strings
	 */

	function StringKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: StringKeyframeTrack,
		ValueTypeName: 'string',
		ValueBufferType: Array,
		DefaultInterpolation: InterpolateDiscrete,
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
	});

	/**
	 * A Track of vectored keyframe values.
	 */

	function VectorKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
		constructor: VectorKeyframeTrack,
		ValueTypeName: 'vector' // ValueBufferType is inherited
		// DefaultInterpolation is inherited

	});

	function AnimationClip(name, duration, tracks, blendMode) {
		if (duration === void 0) {
			duration = -1;
		}

		if (blendMode === void 0) {
			blendMode = NormalAnimationBlendMode;
		}

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;
		this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks

		if (this.duration < 0) {
			this.resetDuration();
		}
	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		var trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			var times = [],
					values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	Object.assign(AnimationClip, {
		parse: function parse(json) {
			var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / (json.fps || 1.0);

			for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			var clip = new AnimationClip(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		},
		toJSON: function toJSON(clip) {
			var tracks = [],
					clipTracks = clip.tracks;
			var json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (var i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		},
		CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for (var i = 0; i < numMorphTargets; i++) {
				var times = [];
				var values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				var order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new AnimationClip(name, -1, tracks);
		},
		findByName: function findByName(objectOrClipArray, name) {
			var clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (var i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		},
		CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (var i = 0, il = morphTargets.length; i < il; i++) {
				var morphTarget = morphTargets[i];
				var parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					var name = parts[1];
					var animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			var clips = [];

			for (var _name in animationToMorphTargets) {
				clips.push(AnimationClip.CreateFromMorphTargetSequence(_name, animationToMorphTargets[_name], fps, noLoop));
			}

			return clips;
		},
		// parse the animation.hierarchy format
		parseAnimation: function parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					var times = [];
					var values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			var tracks = [];
			var clipName = animation.name || 'default';
			var fps = animation.fps || 30;
			var blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			var duration = animation.length || -1;
			var hierarchyTracks = animation.hierarchy || [];

			for (var h = 0; h < hierarchyTracks.length; h++) {
				var animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					var morphTargetNames = {};
					var k = void 0;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (var morphTargetName in morphTargetNames) {
						var times = [];
						var values = [];

						for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
							var animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					var boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			var clip = new AnimationClip(clipName, duration, tracks, blendMode);
			return clip;
		}
	});
	Object.assign(AnimationClip.prototype, {
		resetDuration: function resetDuration() {
			var tracks = this.tracks;
			var duration = 0;

			for (var i = 0, n = tracks.length; i !== n; ++i) {
				var track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		},
		trim: function trim() {
			for (var i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		},
		validate: function validate() {
			var valid = true;

			for (var i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		},
		optimize: function optimize() {
			for (var i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		},
		clone: function clone() {
			var tracks = [];

			for (var i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
		},
		toJSON: function toJSON() {
			return AnimationClip.toJSON(this);
		}
	});

	var Cache = {
		enabled: false,
		files: {},
		add: function add(key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function get(key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function remove(key) {
			delete this.files[key];
		},
		clear: function clear() {
			this.files = {};
		}
	};

	function LoadingManager(onLoad, onProgress, onError) {
		var scope = this;
		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
		var handlers = []; // Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function (url) {
			itemsTotal++;

			if (isLoading === false) {
				if (scope.onStart !== undefined) {
					scope.onStart(url, itemsLoaded, itemsTotal);
				}
			}

			isLoading = true;
		};

		this.itemEnd = function (url) {
			itemsLoaded++;

			if (scope.onProgress !== undefined) {
				scope.onProgress(url, itemsLoaded, itemsTotal);
			}

			if (itemsLoaded === itemsTotal) {
				isLoading = false;

				if (scope.onLoad !== undefined) {
					scope.onLoad();
				}
			}
		};

		this.itemError = function (url) {
			if (scope.onError !== undefined) {
				scope.onError(url);
			}
		};

		this.resolveURL = function (url) {
			if (urlModifier) {
				return urlModifier(url);
			}

			return url;
		};

		this.setURLModifier = function (transform) {
			urlModifier = transform;
			return this;
		};

		this.addHandler = function (regex, loader) {
			handlers.push(regex, loader);
			return this;
		};

		this.removeHandler = function (regex) {
			var index = handlers.indexOf(regex);

			if (index !== -1) {
				handlers.splice(index, 2);
			}

			return this;
		};

		this.getHandler = function (file) {
			for (var i = 0, l = handlers.length; i < l; i += 2) {
				var regex = handlers[i];
				var loader = handlers[i + 1];
				if (regex.global) regex.lastIndex = 0; // see #17920

				if (regex.test(file)) {
					return loader;
				}
			}

			return null;
		};
	}

	var DefaultLoadingManager = new LoadingManager();

	function Loader(manager) {
		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};
	}

	Object.assign(Loader.prototype, {
		load: function load()
		/* url, onLoad, onProgress, onError */
		{},
		loadAsync: function loadAsync(url, onProgress) {
			var scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		},
		parse: function parse()
		/* data */
		{},
		setCrossOrigin: function setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		},
		setWithCredentials: function setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		},
		setPath: function setPath(path) {
			this.path = path;
			return this;
		},
		setResourcePath: function setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		},
		setRequestHeader: function setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}
	});

	var loading = {};

	function FileLoader(manager) {
		Loader.call(this, manager);
	}

	FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: FileLoader,
		load: function load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Check for data: URI


			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match(dataUriRegex);
			var request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

			if (dataUriRegexResult) {
				var mimeType = dataUriRegexResult[1];
				var isBase64 = !!dataUriRegexResult[2];
				var data = dataUriRegexResult[3];
				data = decodeURIComponent(data);
				if (isBase64) data = atob(data);

				try {
					var response;
					var responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
						case 'arraybuffer':
						case 'blob':
							var view = new Uint8Array(data.length);

							for (var i = 0; i < data.length; i++) {
								view[i] = data.charCodeAt(i);
							}

							if (responseType === 'blob') {
								response = new Blob([view.buffer], {
									type: mimeType
								});
							} else {
								response = view.buffer;
							}

							break;

						case 'document':
							var parser = new DOMParser();
							response = parser.parseFromString(data, mimeType);
							break;

						case 'json':
							response = JSON.parse(data);
							break;

						default:
							// 'text' or other
							response = data;
							break;
					} // Wait for next browser tick like standard XMLHttpRequest event dispatching does


					setTimeout(function () {
						if (onLoad) onLoad(response);
						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {
						if (onError) onError(error);
						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests
				loading[url] = [];
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.addEventListener('load', function (event) {
					var response = this.response;
					var callbacks = loading[url];
					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.

						Cache.add(url, response);

						for (var _i = 0, il = callbacks.length; _i < il; _i++) {
							var callback = callbacks[_i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (var _i2 = 0, _il = callbacks.length; _i2 < _il; _i2++) {
							var _callback = callbacks[_i2];
							if (_callback.onError) _callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);
				request.addEventListener('progress', function (event) {
					var callbacks = loading[url];

					for (var _i3 = 0, il = callbacks.length; _i3 < il; _i3++) {
						var callback = callbacks[_i3];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);
				request.addEventListener('error', function (event) {
					var callbacks = loading[url];
					delete loading[url];

					for (var _i4 = 0, il = callbacks.length; _i4 < il; _i4++) {
						var callback = callbacks[_i4];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				request.addEventListener('abort', function (event) {
					var callbacks = loading[url];
					delete loading[url];

					for (var _i5 = 0, il = callbacks.length; _i5 < il; _i5++) {
						var callback = callbacks[_i5];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (var header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);
			return request;
		},
		setResponseType: function setResponseType(value) {
			this.responseType = value;
			return this;
		},
		setMimeType: function setMimeType(value) {
			this.mimeType = value;
			return this;
		}
	});

	function AnimationLoader(manager) {
		Loader.call(this, manager);
	}

	AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: AnimationLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		},
		parse: function parse(json) {
			var animations = [];

			for (var i = 0; i < json.length; i++) {
				var clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		}
	});

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function CompressedTextureLoader(manager) {
		Loader.call(this, manager);
	}

	CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: CompressedTextureLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var images = [];
			var texture = new CompressedTexture();
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			var loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					var texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (var i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					var texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (var f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (var _i = 0; _i < texDatas.mipmapCount; _i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		}
	});

	function ImageLoader(manager) {
		Loader.call(this, manager);
	}

	ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: ImageLoader,
		load: function load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}
	});

	function CubeTextureLoader(manager) {
		Loader.call(this, manager);
	}

	CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: CubeTextureLoader,
		load: function load(urls, onLoad, onProgress, onError) {
			var texture = new CubeTexture();
			var loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			var loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (var i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		}
	});

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function DataTextureLoader(manager) {
		Loader.call(this, manager);
	}

	DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: DataTextureLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var texture = new DataTexture();
			var loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				var texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}
	});

	function TextureLoader(manager) {
		Loader.call(this, manager);
	}

	TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: TextureLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var texture = new Texture();
			var loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

				var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}
	});

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	function Curve() {
		this.type = 'Curve';
		this.arcLengthDivisions = 200;
	}

	Object.assign(Curve.prototype, {
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
		getPoint: function getPoint()
		/* t, optionalTarget */
		{
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		},
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
		getPointAt: function getPointAt(u, optionalTarget) {
			var t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		},
		// Get sequence of points using getPoint( t )
		getPoints: function getPoints(divisions) {
			if (divisions === void 0) {
				divisions = 5;
			}

			var points = [];

			for (var d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		},
		// Get sequence of points using getPointAt( u )
		getSpacedPoints: function getSpacedPoints(divisions) {
			if (divisions === void 0) {
				divisions = 5;
			}

			var points = [];

			for (var d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		},
		// Get total curve arc length
		getLength: function getLength() {
			var lengths = this.getLengths();
			return lengths[lengths.length - 1];
		},
		// Get list of cumulative segment lengths
		getLengths: function getLengths(divisions) {
			if (divisions === undefined) divisions = this.arcLengthDivisions;

			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			var cache = [];
			var current,
					last = this.getPoint(0);
			var sum = 0;
			cache.push(0);

			for (var p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		},
		updateArcLengths: function updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		},
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
		getUtoTmapping: function getUtoTmapping(u, distance) {
			var arcLengths = this.getLengths();
			var i = 0;
			var il = arcLengths.length;
			var targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			var low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			var lengthBefore = arcLengths[i];
			var lengthAfter = arcLengths[i + 1];
			var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			var t = (i + segmentFraction) / (il - 1);
			return t;
		},
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
		getTangent: function getTangent(t, optionalTarget) {
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			var pt1 = this.getPoint(t1);
			var pt2 = this.getPoint(t2);
			var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		},
		getTangentAt: function getTangentAt(u, optionalTarget) {
			var t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		},
		computeFrenetFrames: function computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			var normal = new Vector3();
			var tangents = [];
			var normals = [];
			var binormals = [];
			var vec = new Vector3();
			var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (var i = 0; i <= segments; i++) {
				var u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
				tangents[i].normalize();
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs(tangents[0].x);
			var ty = Math.abs(tangents[0].y);
			var tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (var _i = 1; _i <= segments; _i++) {
				normals[_i] = normals[_i - 1].clone();
				binormals[_i] = binormals[_i - 1].clone();
				vec.crossVectors(tangents[_i - 1], tangents[_i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					var theta = Math.acos(MathUtils.clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1)); // clamp for floating pt errors

					normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[_i].crossVectors(tangents[_i], normals[_i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				var _theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));

				_theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					_theta = -_theta;
				}

				for (var _i2 = 1; _i2 <= segments; _i2++) {
					// twist a little...
					normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));

					binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		},
		copy: function copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		},
		toJSON: function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		},
		fromJSON: function fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}
	});

	function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		Curve.call(this);
		this.type = 'EllipseCurve';
		this.aX = aX || 0;
		this.aY = aY || 0;
		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;
		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;
		this.aClockwise = aClockwise || false;
		this.aRotation = aRotation || 0;
	}

	EllipseCurve.prototype = Object.create(Curve.prototype);
	EllipseCurve.prototype.constructor = EllipseCurve;
	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
		var point = optionalTarget || new Vector2();
		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

		while (deltaAngle < 0) {
			deltaAngle += twoPi;
		}

		while (deltaAngle > twoPi) {
			deltaAngle -= twoPi;
		}

		if (deltaAngle < Number.EPSILON) {
			if (samePoints) {
				deltaAngle = 0;
			} else {
				deltaAngle = twoPi;
			}
		}

		if (this.aClockwise === true && !samePoints) {
			if (deltaAngle === twoPi) {
				deltaAngle = -twoPi;
			} else {
				deltaAngle = deltaAngle - twoPi;
			}
		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos(angle);
		var y = this.aY + this.yRadius * Math.sin(angle);

		if (this.aRotation !== 0) {
			var cos = Math.cos(this.aRotation);
			var sin = Math.sin(this.aRotation);
			var tx = x - this.aX;
			var ty = y - this.aY; // Rotate the point about the center of the ellipse.

			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
		}

		return point.set(x, y);
	};

	EllipseCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.aX = source.aX;
		this.aY = source.aY;
		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;
		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;
		this.aClockwise = source.aClockwise;
		this.aRotation = source.aRotation;
		return this;
	};

	EllipseCurve.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.aX = this.aX;
		data.aY = this.aY;
		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;
		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;
		data.aClockwise = this.aClockwise;
		data.aRotation = this.aRotation;
		return data;
	};

	EllipseCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.aX = json.aX;
		this.aY = json.aY;
		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;
		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;
		this.aClockwise = json.aClockwise;
		this.aRotation = json.aRotation;
		return this;
	};

	function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		this.type = 'ArcCurve';
	}

	ArcCurve.prototype = Object.create(EllipseCurve.prototype);
	ArcCurve.prototype.constructor = ArcCurve;
	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		var c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function calc(t) {
				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	var tmp = new Vector3();
	var px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

	function CatmullRomCurve3(points, closed, curveType, tension) {
		if (points === void 0) {
			points = [];
		}

		if (closed === void 0) {
			closed = false;
		}

		if (curveType === void 0) {
			curveType = 'centripetal';
		}

		if (tension === void 0) {
			tension = 0.5;
		}

		Curve.call(this);
		this.type = 'CatmullRomCurve3';
		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;
	}

	CatmullRomCurve3.prototype = Object.create(Curve.prototype);
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector3();
		}

		var point = optionalTarget;
		var points = this.points;
		var l = points.length;
		var p = (l - (this.closed ? 0 : 1)) * t;
		var intPoint = Math.floor(p);
		var weight = p - intPoint;

		if (this.closed) {
			intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
		} else if (weight === 0 && intPoint === l - 1) {
			intPoint = l - 2;
			weight = 1;
		}

		var p0, p3; // 4 points (p1 & p2 defined below)

		if (this.closed || intPoint > 0) {
			p0 = points[(intPoint - 1) % l];
		} else {
			// extrapolate first point
			tmp.subVectors(points[0], points[1]).add(points[0]);
			p0 = tmp;
		}

		var p1 = points[intPoint % l];
		var p2 = points[(intPoint + 1) % l];

		if (this.closed || intPoint + 2 < l) {
			p3 = points[(intPoint + 2) % l];
		} else {
			// extrapolate last point
			tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
			p3 = tmp;
		}

		if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
			var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
			var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

			if (dt1 < 1e-4) dt1 = 1.0;
			if (dt0 < 1e-4) dt0 = dt1;
			if (dt2 < 1e-4) dt2 = dt1;
			px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
			py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
			pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
		} else if (this.curveType === 'catmullrom') {
			px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
			py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
			pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
		}

		point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
		return point;
	};

	CatmullRomCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.points = [];

		for (var i = 0, l = source.points.length; i < l; i++) {
			var point = source.points[i];
			this.points.push(point.clone());
		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;
		return this;
	};

	CatmullRomCurve3.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.points = [];

		for (var i = 0, l = this.points.length; i < l; i++) {
			var point = this.points[i];
			data.points.push(point.toArray());
		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;
		return data;
	};

	CatmullRomCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.points = [];

		for (var i = 0, l = json.points.length; i < l; i++) {
			var point = json.points[i];
			this.points.push(new Vector3().fromArray(point));
		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;
		return this;
	};

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		var v0 = (p2 - p0) * 0.5;
		var v1 = (p3 - p1) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		var k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		var k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		var k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	function CubicBezierCurve(v0, v1, v2, v3) {
		if (v0 === void 0) {
			v0 = new Vector2();
		}

		if (v1 === void 0) {
			v1 = new Vector2();
		}

		if (v2 === void 0) {
			v2 = new Vector2();
		}

		if (v3 === void 0) {
			v3 = new Vector2();
		}

		Curve.call(this);
		this.type = 'CubicBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}

	CubicBezierCurve.prototype = Object.create(Curve.prototype);
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector2();
		}

		var point = optionalTarget;
		var v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2,
				v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
		return point;
	};

	CubicBezierCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	};

	CubicBezierCurve.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	};

	CubicBezierCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	};

	function CubicBezierCurve3(v0, v1, v2, v3) {
		if (v0 === void 0) {
			v0 = new Vector3();
		}

		if (v1 === void 0) {
			v1 = new Vector3();
		}

		if (v2 === void 0) {
			v2 = new Vector3();
		}

		if (v3 === void 0) {
			v3 = new Vector3();
		}

		Curve.call(this);
		this.type = 'CubicBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	}

	CubicBezierCurve3.prototype = Object.create(Curve.prototype);
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector3();
		}

		var point = optionalTarget;
		var v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2,
				v3 = this.v3;
		point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
		return point;
	};

	CubicBezierCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);
		return this;
	};

	CubicBezierCurve3.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
		return data;
	};

	CubicBezierCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);
		return this;
	};

	function LineCurve(v1, v2) {
		if (v1 === void 0) {
			v1 = new Vector2();
		}

		if (v2 === void 0) {
			v2 = new Vector2();
		}

		Curve.call(this);
		this.type = 'LineCurve';
		this.v1 = v1;
		this.v2 = v2;
	}

	LineCurve.prototype = Object.create(Curve.prototype);
	LineCurve.prototype.constructor = LineCurve;
	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector2();
		}

		var point = optionalTarget;

		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}

		return point;
	}; // Line curve is linear, so we can overwrite default getPointAt


	LineCurve.prototype.getPointAt = function (u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	};

	LineCurve.prototype.getTangent = function (t, optionalTarget) {
		var tangent = optionalTarget || new Vector2();
		tangent.copy(this.v2).sub(this.v1).normalize();
		return tangent;
	};

	LineCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	};

	LineCurve.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	};

	LineCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	};

	function LineCurve3(v1, v2) {
		if (v1 === void 0) {
			v1 = new Vector3();
		}

		if (v2 === void 0) {
			v2 = new Vector3();
		}

		Curve.call(this);
		this.type = 'LineCurve3';
		this.v1 = v1;
		this.v2 = v2;
	}

	LineCurve3.prototype = Object.create(Curve.prototype);
	LineCurve3.prototype.constructor = LineCurve3;
	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector3();
		}

		var point = optionalTarget;

		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}

		return point;
	}; // Line curve is linear, so we can overwrite default getPointAt


	LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	};

	LineCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	};

	LineCurve3.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	};

	LineCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	};

	function QuadraticBezierCurve(v0, v1, v2) {
		if (v0 === void 0) {
			v0 = new Vector2();
		}

		if (v1 === void 0) {
			v1 = new Vector2();
		}

		if (v2 === void 0) {
			v2 = new Vector2();
		}

		Curve.call(this);
		this.type = 'QuadraticBezierCurve';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}

	QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector2();
		}

		var point = optionalTarget;
		var v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
		return point;
	};

	QuadraticBezierCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	};

	QuadraticBezierCurve.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	};

	QuadraticBezierCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	};

	function QuadraticBezierCurve3(v0, v1, v2) {
		if (v0 === void 0) {
			v0 = new Vector3();
		}

		if (v1 === void 0) {
			v1 = new Vector3();
		}

		if (v2 === void 0) {
			v2 = new Vector3();
		}

		Curve.call(this);
		this.type = 'QuadraticBezierCurve3';
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	}

	QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector3();
		}

		var point = optionalTarget;
		var v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2;
		point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
		return point;
	};

	QuadraticBezierCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		return this;
	};

	QuadraticBezierCurve3.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		return data;
	};

	QuadraticBezierCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		return this;
	};

	function SplineCurve(points) {
		if (points === void 0) {
			points = [];
		}

		Curve.call(this);
		this.type = 'SplineCurve';
		this.points = points;
	}

	SplineCurve.prototype = Object.create(Curve.prototype);
	SplineCurve.prototype.constructor = SplineCurve;
	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function (t, optionalTarget) {
		if (optionalTarget === void 0) {
			optionalTarget = new Vector2();
		}

		var point = optionalTarget;
		var points = this.points;
		var p = (points.length - 1) * t;
		var intPoint = Math.floor(p);
		var weight = p - intPoint;
		var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
		var p1 = points[intPoint];
		var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
		var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
		point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
		return point;
	};

	SplineCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);
		this.points = [];

		for (var i = 0, l = source.points.length; i < l; i++) {
			var point = source.points[i];
			this.points.push(point.clone());
		}

		return this;
	};

	SplineCurve.prototype.toJSON = function () {
		var data = Curve.prototype.toJSON.call(this);
		data.points = [];

		for (var i = 0, l = this.points.length; i < l; i++) {
			var point = this.points[i];
			data.points.push(point.toArray());
		}

		return data;
	};

	SplineCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);
		this.points = [];

		for (var i = 0, l = json.points.length; i < l; i++) {
			var point = json.points[i];
			this.points.push(new Vector2().fromArray(point));
		}

		return this;
	};

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {
		Curve.call(this);
		this.type = 'CurvePath';
		this.curves = [];
		this.autoClose = false; // Automatically closes the path
	}

	CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
		constructor: CurvePath,
		add: function add(curve) {
			this.curves.push(curve);
		},
		closePath: function closePath() {
			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[0].getPoint(0);
			var endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		},
		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
		getPoint: function getPoint(t) {
			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					var diff = curveLengths[i] - d;
					var curve = this.curves[i];
					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		},
		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
		getLength: function getLength() {
			var lens = this.getCurveLengths();
			return lens[lens.length - 1];
		},
		// cacheLengths must be recalculated.
		updateArcLengths: function updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		},
		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
		getCurveLengths: function getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			var lengths = [];
			var sums = 0;

			for (var i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		},
		getSpacedPoints: function getSpacedPoints(divisions) {
			if (divisions === void 0) {
				divisions = 40;
			}

			var points = [];

			for (var i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		},
		getPoints: function getPoints(divisions) {
			if (divisions === void 0) {
				divisions = 12;
			}

			var points = [];
			var last;

			for (var i = 0, curves = this.curves; i < curves.length; i++) {
				var curve = curves[i];
				var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				var pts = curve.getPoints(resolution);

				for (var j = 0; j < pts.length; j++) {
					var point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		},
		copy: function copy(source) {
			Curve.prototype.copy.call(this, source);
			this.curves = [];

			for (var i = 0, l = source.curves.length; i < l; i++) {
				var curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		},
		toJSON: function toJSON() {
			var data = Curve.prototype.toJSON.call(this);
			data.autoClose = this.autoClose;
			data.curves = [];

			for (var i = 0, l = this.curves.length; i < l; i++) {
				var curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		},
		fromJSON: function fromJSON(json) {
			Curve.prototype.fromJSON.call(this, json);
			this.autoClose = json.autoClose;
			this.curves = [];

			for (var i = 0, l = json.curves.length; i < l; i++) {
				var curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		}
	});

	function Path(points) {
		CurvePath.call(this);
		this.type = 'Path';
		this.currentPoint = new Vector2();

		if (points) {
			this.setFromPoints(points);
		}
	}

	Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
		constructor: Path,
		setFromPoints: function setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (var i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		},
		moveTo: function moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		},
		lineTo: function lineTo(x, y) {
			var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		},
		quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
			var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		},
		bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		},
		splineThru: function splineThru(pts
		/*Array of Vector*/
		) {
			var npts = [this.currentPoint.clone()].concat(pts);
			var curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		},
		arc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		},
		absarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		},
		ellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		},
		absellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			var lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		},
		copy: function copy(source) {
			CurvePath.prototype.copy.call(this, source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		},
		toJSON: function toJSON() {
			var data = CurvePath.prototype.toJSON.call(this);
			data.currentPoint = this.currentPoint.toArray();
			return data;
		},
		fromJSON: function fromJSON(json) {
			CurvePath.prototype.fromJSON.call(this, json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}
	});

	function Shape(points) {
		Path.call(this, points);
		this.uuid = MathUtils.generateUUID();
		this.type = 'Shape';
		this.holes = [];
	}

	Shape.prototype = Object.assign(Object.create(Path.prototype), {
		constructor: Shape,
		getPointsHoles: function getPointsHoles(divisions) {
			var holesPts = [];

			for (var i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		},
		// get points of shape and holes (keypoints based on segments parameter)
		extractPoints: function extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		},
		copy: function copy(source) {
			Path.prototype.copy.call(this, source);
			this.holes = [];

			for (var i = 0, l = source.holes.length; i < l; i++) {
				var hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		},
		toJSON: function toJSON() {
			var data = Path.prototype.toJSON.call(this);
			data.uuid = this.uuid;
			data.holes = [];

			for (var i = 0, l = this.holes.length; i < l; i++) {
				var hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		},
		fromJSON: function fromJSON(json) {
			Path.prototype.fromJSON.call(this, json);
			this.uuid = json.uuid;
			this.holes = [];

			for (var i = 0, l = json.holes.length; i < l; i++) {
				var hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		}
	});

	function Light(color, intensity) {
		if (intensity === void 0) {
			intensity = 1;
		}

		Object3D.call(this);
		this.type = 'Light';
		this.color = new Color(color);
		this.intensity = intensity;
	}

	Light.prototype = Object.assign(Object.create(Object3D.prototype), {
		constructor: Light,
		isLight: true,
		copy: function copy(source) {
			Object3D.prototype.copy.call(this, source);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		},
		toJSON: function toJSON(meta) {
			var data = Object3D.prototype.toJSON.call(this, meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}
	});

	function HemisphereLight(skyColor, groundColor, intensity) {
		Light.call(this, skyColor, intensity);
		this.type = 'HemisphereLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.groundColor = new Color(groundColor);
	}

	HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: HemisphereLight,
		isHemisphereLight: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		}
	});

	function LightShadow(camera) {
		this.camera = camera;
		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.mapSize = new Vector2(512, 512);
		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();
		this.autoUpdate = true;
		this.needsUpdate = false;
		this._frustum = new Frustum();
		this._frameExtents = new Vector2(1, 1);
		this._viewportCount = 1;
		this._viewports = [new Vector4(0, 0, 1, 1)];
	}

	Object.assign(LightShadow.prototype, {
		_projScreenMatrix: new Matrix4(),
		_lightPositionWorld: new Vector3(),
		_lookTarget: new Vector3(),
		getViewportCount: function getViewportCount() {
			return this._viewportCount;
		},
		getFrustum: function getFrustum() {
			return this._frustum;
		},
		updateMatrices: function updateMatrices(light) {
			var shadowCamera = this.camera,
					shadowMatrix = this.matrix,
					projScreenMatrix = this._projScreenMatrix,
					lookTarget = this._lookTarget,
					lightPositionWorld = this._lightPositionWorld;
			lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
			shadowCamera.position.copy(lightPositionWorld);
			lookTarget.setFromMatrixPosition(light.target.matrixWorld);
			shadowCamera.lookAt(lookTarget);
			shadowCamera.updateMatrixWorld();
			projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(projScreenMatrix);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		},
		getViewport: function getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		},
		getFrameExtents: function getFrameExtents() {
			return this._frameExtents;
		},
		copy: function copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		},
		toJSON: function toJSON() {
			var object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}
	});

	function SpotLightShadow() {
		LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
		this.focus = 1;
	}

	SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
		constructor: SpotLightShadow,
		isSpotLightShadow: true,
		updateMatrices: function updateMatrices(light) {
			var camera = this.camera;
			var fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			LightShadow.prototype.updateMatrices.call(this, light);
		}
	});

	function SpotLight(color, intensity, distance, angle, penumbra, decay) {
		Light.call(this, color, intensity);
		this.type = 'SpotLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.target = new Object3D();
		Object.defineProperty(this, 'power', {
			get: function get() {
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;
			},
			set: function set(power) {
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;
			}
		});
		this.distance = distance !== undefined ? distance : 0;
		this.angle = angle !== undefined ? angle : Math.PI / 3;
		this.penumbra = penumbra !== undefined ? penumbra : 0;
		this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();
	}

	SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: SpotLight,
		isSpotLight: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}
	});

	function PointLightShadow() {
		LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
		this._frameExtents = new Vector2(4, 2);
		this._viewportCount = 6;
		this._viewports = [// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//	xzXZ
		//	 y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction
		// positive X
		new Vector4(2, 1, 1, 1), // negative X
		new Vector4(0, 1, 1, 1), // positive Z
		new Vector4(3, 1, 1, 1), // negative Z
		new Vector4(1, 1, 1, 1), // positive Y
		new Vector4(3, 0, 1, 1), // negative Y
		new Vector4(1, 0, 1, 1)];
		this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
		this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
	}

	PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
		constructor: PointLightShadow,
		isPointLightShadow: true,
		updateMatrices: function updateMatrices(light, viewportIndex) {
			if (viewportIndex === void 0) {
				viewportIndex = 0;
			}

			var camera = this.camera,
					shadowMatrix = this.matrix,
					lightPositionWorld = this._lightPositionWorld,
					lookTarget = this._lookTarget,
					projScreenMatrix = this._projScreenMatrix;
			lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
			camera.position.copy(lightPositionWorld);
			lookTarget.copy(camera.position);
			lookTarget.add(this._cubeDirections[viewportIndex]);
			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
			projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(projScreenMatrix);
		}
	});

	function PointLight(color, intensity, distance, decay) {
		Light.call(this, color, intensity);
		this.type = 'PointLight';
		Object.defineProperty(this, 'power', {
			get: function get() {
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;
			},
			set: function set(power) {
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / (4 * Math.PI);
			}
		});
		this.distance = distance !== undefined ? distance : 0;
		this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();
	}

	PointLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: PointLight,
		isPointLight: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}
	});

	function OrthographicCamera(left, right, top, bottom, near, far) {
		if (left === void 0) {
			left = -1;
		}

		if (right === void 0) {
			right = 1;
		}

		if (top === void 0) {
			top = 1;
		}

		if (bottom === void 0) {
			bottom = -1;
		}

		if (near === void 0) {
			near = 0.1;
		}

		if (far === void 0) {
			far = 2000;
		}

		Camera.call(this);
		this.type = 'OrthographicCamera';
		this.zoom = 1;
		this.view = null;
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
		this.near = near;
		this.far = far;
		this.updateProjectionMatrix();
	}

	OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
		constructor: OrthographicCamera,
		isOrthographicCamera: true,
		copy: function copy(source, recursive) {
			Camera.prototype.copy.call(this, source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		},
		setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		},
		clearViewOffset: function clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		},
		updateProjectionMatrix: function updateProjectionMatrix() {
			var dx = (this.right - this.left) / (2 * this.zoom);
			var dy = (this.top - this.bottom) / (2 * this.zoom);
			var cx = (this.right + this.left) / 2;
			var cy = (this.top + this.bottom) / 2;
			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		},
		toJSON: function toJSON(meta) {
			var data = Object3D.prototype.toJSON.call(this, meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}
	});

	function DirectionalLightShadow() {
		LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
	}

	DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
		constructor: DirectionalLightShadow,
		isDirectionalLightShadow: true,
		updateMatrices: function updateMatrices(light) {
			LightShadow.prototype.updateMatrices.call(this, light);
		}
	});

	function DirectionalLight(color, intensity) {
		Light.call(this, color, intensity);
		this.type = 'DirectionalLight';
		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();
		this.target = new Object3D();
		this.shadow = new DirectionalLightShadow();
	}

	DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: DirectionalLight,
		isDirectionalLight: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}
	});

	function AmbientLight(color, intensity) {
		Light.call(this, color, intensity);
		this.type = 'AmbientLight';
	}

	AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: AmbientLight,
		isAmbientLight: true
	});

	function RectAreaLight(color, intensity, width, height) {
		Light.call(this, color, intensity);
		this.type = 'RectAreaLight';
		this.width = width !== undefined ? width : 10;
		this.height = height !== undefined ? height : 10;
	}

	RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: RectAreaLight,
		isRectAreaLight: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.width = source.width;
			this.height = source.height;
			return this;
		},
		toJSON: function toJSON(meta) {
			var data = Light.prototype.toJSON.call(this, meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}
	});

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	var SphericalHarmonics3 = /*#__PURE__*/function () {
		function SphericalHarmonics3() {
			Object.defineProperty(this, 'isSphericalHarmonics3', {
				value: true
			});
			this.coefficients = [];

			for (var i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		var _proto = SphericalHarmonics3.prototype;

		_proto.set = function set(coefficients) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		};

		_proto.zero = function zero() {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3
		;

		_proto.getAt = function getAt(normal, target) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z;
			var coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		;

		_proto.getIrradianceAt = function getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z;
			var coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274

			return target;
		};

		_proto.add = function add(sh) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		};

		_proto.addScaledSH = function addScaledSH(sh, s) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		};

		_proto.scale = function scale(s) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		};

		_proto.lerp = function lerp(sh, alpha) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		};

		_proto.equals = function equals(sh) {
			for (var i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		};

		_proto.copy = function copy(sh) {
			return this.set(sh.coefficients);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			var coefficients = this.coefficients;

			for (var i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var coefficients = this.coefficients;

			for (var i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]
		;

		SphericalHarmonics3.getBasisAt = function getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		};

		return SphericalHarmonics3;
	}();

	function LightProbe(sh, intensity) {
		Light.call(this, undefined, intensity);
		this.type = 'LightProbe';
		this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
	}

	LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
		constructor: LightProbe,
		isLightProbe: true,
		copy: function copy(source) {
			Light.prototype.copy.call(this, source);
			this.sh.copy(source.sh);
			return this;
		},
		fromJSON: function fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		},
		toJSON: function toJSON(meta) {
			var data = Light.prototype.toJSON.call(this, meta);
			data.object.sh = this.sh.toArray();
			return data;
		}
	});

	function MaterialLoader(manager) {
		Loader.call(this, manager);
		this.textures = {};
	}

	MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: MaterialLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		},
		parse: function parse(json) {
			var textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			var material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.skinning !== undefined) material.skinning = json.skinning;
			if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
			if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (var name in json.uniforms) {
					var uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (var key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				var normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			return material;
		},
		setTextures: function setTextures(value) {
			this.textures = value;
			return this;
		}
	});

	var LoaderUtils = {
		decodeText: function decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			var s = '';

			for (var i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		},
		extractUrlBase: function extractUrlBase(url) {
			var index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		}
	};

	function InstancedBufferGeometry() {
		BufferGeometry.call(this);
		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;
	}

	InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
		constructor: InstancedBufferGeometry,
		isInstancedBufferGeometry: true,
		copy: function copy(source) {
			BufferGeometry.prototype.copy.call(this, source);
			this.instanceCount = source.instanceCount;
			return this;
		},
		clone: function clone() {
			return new this.constructor().copy(this);
		},
		toJSON: function toJSON() {
			var data = BufferGeometry.prototype.toJSON.call(this);
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}
	});

	function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
		if (typeof normalized === 'number') {
			meshPerAttribute = normalized;
			normalized = false;
			console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
		}

		BufferAttribute.call(this, array, itemSize, normalized);
		this.meshPerAttribute = meshPerAttribute || 1;
	}

	InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
		constructor: InstancedBufferAttribute,
		isInstancedBufferAttribute: true,
		copy: function copy(source) {
			BufferAttribute.prototype.copy.call(this, source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		},
		toJSON: function toJSON() {
			var data = BufferAttribute.prototype.toJSON.call(this);
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}
	});

	function BufferGeometryLoader(manager) {
		Loader.call(this, manager);
	}

	BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: BufferGeometryLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		},
		parse: function parse(json) {
			var interleavedBufferMap = {};
			var arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				var interleavedBuffers = json.interleavedBuffers;
				var interleavedBuffer = interleavedBuffers[uuid];
				var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				var array = getTypedArray(interleavedBuffer.type, buffer);
				var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				var arrayBuffers = json.arrayBuffers;
				var arrayBuffer = arrayBuffers[uuid];
				var ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			var index = json.data.index;

			if (index !== undefined) {
				var typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			var attributes = json.data.attributes;

			for (var key in attributes) {
				var attribute = attributes[key];
				var bufferAttribute = void 0;

				if (attribute.isInterleavedBufferAttribute) {
					var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					var _typedArray = getTypedArray(attribute.type, attribute.array);

					var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				geometry.setAttribute(key, bufferAttribute);
			}

			var morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (var _key in morphAttributes) {
					var attributeArray = morphAttributes[_key];
					var array = [];

					for (var i = 0, il = attributeArray.length; i < il; i++) {
						var _attribute = attributeArray[i];

						var _bufferAttribute = void 0;

						if (_attribute.isInterleavedBufferAttribute) {
							var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute.data);

							_bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute.itemSize, _attribute.offset, _attribute.normalized);
						} else {
							var _typedArray2 = getTypedArray(_attribute.type, _attribute.array);

							_bufferAttribute = new BufferAttribute(_typedArray2, _attribute.itemSize, _attribute.normalized);
						}

						if (_attribute.name !== undefined) _bufferAttribute.name = _attribute.name;
						array.push(_bufferAttribute);
					}

					geometry.morphAttributes[_key] = array;
				}
			}

			var morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (var _i = 0, n = groups.length; _i !== n; ++_i) {
					var group = groups[_i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			var boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				var center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}
	});

	var ObjectLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(ObjectLoader, _Loader);

		function ObjectLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = ObjectLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				var json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				var metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		};

		_proto.parse = function parse(json, onLoad) {
			var animations = this.parseAnimations(json.animations);
			var shapes = this.parseShapes(json.shapes);
			var geometries = this.parseGeometries(json.geometries, shapes);
			var images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			var textures = this.parseTextures(json.textures, images);
			var materials = this.parseMaterials(json.materials, textures);
			var object = this.parseObject(json.object, geometries, materials, animations);
			var skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				var hasImages = false;

				for (var uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		};

		_proto.parseShapes = function parseShapes(json) {
			var shapes = {};

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		};

		_proto.parseSkeletons = function parseSkeletons(json, object) {
			var skeletons = {};
			var bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		};

		_proto.parseGeometries = function parseGeometries(json, shapes) {
			var geometries = {};
			var geometryShapes;

			if (json !== undefined) {
				var bufferGeometryLoader = new BufferGeometryLoader();

				for (var i = 0, l = json.length; i < l; i++) {
					var geometry = void 0;
					var data = json[i];

					switch (data.type) {
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
							geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
							geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':
							geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.detail);
							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':
							geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
							break;

						case 'TubeGeometry':
						case 'TubeBufferGeometry':
							// This only works for built-in curves (e.g. CatmullRomCurve3).
							// User defined curves or instances of CurvePath will not be deserialized.
							geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':
							geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':
							geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':
							geometryShapes = [];

							for (var j = 0, jl = data.shapes.length; j < jl; j++) {
								var shape = shapes[data.shapes[j]];
								geometryShapes.push(shape);
							}

							geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
							break;

						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':
							geometryShapes = [];

							for (var _j = 0, _jl = data.shapes.length; _j < _jl; _j++) {
								var _shape = shapes[data.shapes[_j]];
								geometryShapes.push(_shape);
							}

							var extrudePath = data.options.extrudePath;

							if (extrudePath !== undefined) {
								data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
							}

							geometry = new Geometries[data.type](geometryShapes, data.options);
							break;

						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
							break;

						default:
							console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
							continue;
					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		};

		_proto.parseMaterials = function parseMaterials(json, textures) {
			var cache = {}; // MultiMaterial

			var materials = {};

			if (json !== undefined) {
				var loader = new MaterialLoader();
				loader.setTextures(textures);

				for (var i = 0, l = json.length; i < l; i++) {
					var data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						var array = [];

						for (var j = 0; j < data.materials.length; j++) {
							var material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		};

		_proto.parseAnimations = function parseAnimations(json) {
			var animations = {};

			if (json !== undefined) {
				for (var i = 0; i < json.length; i++) {
					var data = json[i];
					var clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		};

		_proto.parseImages = function parseImages(json, onLoad) {
			var scope = this;
			var images = {};
			var loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					var url = image;
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				var manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (var i = 0, il = json.length; i < il; i++) {
					var image = json[i];
					var url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (var j = 0, jl = url.length; j < jl; j++) {
							var currentUrl = url[j];
							var deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						var _deserializedImage = deserializeImage(image.url);

						if (_deserializedImage !== null) {
							images[image.uuid] = _deserializedImage;
						}
					}
				}
			}

			return images;
		};

		_proto.parseTextures = function parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			var textures = {};

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					var texture = void 0;
					var image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		};

		_proto.parseObject = function parseObject(data, geometries, materials, animations) {
			var object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					var array = [];

					for (var i = 0, l = name.length; i < l; i++) {
						var uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			var geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						}
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					var count = data.count;
					var instanceMatrix = data.instanceMatrix;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				var children = data.children;

				for (var i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, animations));
				}
			}

			if (data.animations !== undefined) {
				var objectAnimations = data.animations;

				for (var _i = 0; _i < objectAnimations.length; _i++) {
					var uuid = objectAnimations[_i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				var levels = data.levels;

				for (var l = 0; l < levels.length; l++) {
					var level = levels[l];
					var child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		};

		_proto.bindSkeletons = function bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					var skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */
		;

		_proto.setTexturePath = function setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		};

		return ObjectLoader;
	}(Loader);

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	function ImageBitmapLoader(manager) {
		if (typeof createImageBitmap === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
		}

		if (typeof fetch === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
		}

		Loader.call(this, manager);
		this.options = {
			premultiplyAlpha: 'none'
		};
	}

	ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: ImageBitmapLoader,
		isImageBitmapLoader: true,
		setOptions: function setOptions(options) {
			this.options = options;
			return this;
		},
		load: function load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			var fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, scope.options);
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}
	});

	function ShapePath() {
		this.type = 'ShapePath';
		this.color = new Color();
		this.subPaths = [];
		this.currentPath = null;
	}

	Object.assign(ShapePath.prototype, {
		moveTo: function moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		},
		lineTo: function lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		},
		quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		},
		bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		},
		splineThru: function splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		},
		toShapes: function toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				var shapes = [];

				for (var i = 0, l = inSubpaths.length; i < l; i++) {
					var _tmpPath = inSubpaths[i];

					var _tmpShape = new Shape();

					_tmpShape.curves = _tmpPath.curves;
					shapes.push(_tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				var polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				var inside = false;

				for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					var edgeLowPt = inPolygon[p];
					var edgeHighPt = inPolygon[q];
					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			var isClockWise = ShapeUtils.isClockWise;
			var subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			var solid, tmpPath, tmpShape;
			var shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			var holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (var i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				var ambiguous = false;
				var toChange = [];

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
					var sho = newShapeHoles[_sIdx];

					for (var hIdx = 0; hIdx < sho.length; hIdx++) {
						var ho = sho[hIdx];
						var hole_unassigned = true;

						for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (_sIdx !== s2Idx) toChange.push({
									froms: _sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[_sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			var tmpHoles;

			for (var _i = 0, il = newShapes.length; _i < il; _i++) {
				tmpShape = newShapes[_i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[_i];

				for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		}
	});

	var Font = /*#__PURE__*/function () {
		function Font(data) {
			Object.defineProperty(this, 'isFont', {
				value: true
			});
			this.type = 'Font';
			this.data = data;
		}

		var _proto = Font.prototype;

		_proto.generateShapes = function generateShapes(text, size) {
			if (size === void 0) {
				size = 100;
			}

			var shapes = [];
			var paths = createPaths(text, size, this.data);

			for (var p = 0, pl = paths.length; p < pl; p++) {
				Array.prototype.push.apply(shapes, paths[p].toShapes());
			}

			return shapes;
		};

		return Font;
	}();

	function createPaths(text, size, data) {
		var chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988

		var scale = size / data.resolution;
		var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
		var paths = [];
		var offsetX = 0,
				offsetY = 0;

		for (var i = 0; i < chars.length; i++) {
			var char = chars[i];

			if (char === '\n') {
				offsetX = 0;
				offsetY -= line_height;
			} else {
				var ret = createPath(char, scale, offsetX, offsetY, data);
				offsetX += ret.offsetX;
				paths.push(ret.path);
			}
		}

		return paths;
	}

	function createPath(char, scale, offsetX, offsetY, data) {
		var glyph = data.glyphs[char] || data.glyphs['?'];

		if (!glyph) {
			console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
			return;
		}

		var path = new ShapePath();
		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if (glyph.o) {
			var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

			for (var i = 0, l = outline.length; i < l;) {
				var action = outline[i++];

				switch (action) {
					case 'm':
						// moveTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.moveTo(x, y);
						break;

					case 'l':
						// lineTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.lineTo(x, y);
						break;

					case 'q':
						// quadraticCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
						break;

					case 'b':
						// bezierCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						cpx2 = outline[i++] * scale + offsetX;
						cpy2 = outline[i++] * scale + offsetY;
						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
						break;
				}
			}
		}

		return {
			offsetX: glyph.ha * scale,
			path: path
		};
	}

	function FontLoader(manager) {
		Loader.call(this, manager);
	}

	FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: FontLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				var json;

				try {
					json = JSON.parse(text);
				} catch (e) {
					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
					json = JSON.parse(text.substring(65, text.length - 2));
				}

				var font = scope.parse(json);
				if (onLoad) onLoad(font);
			}, onProgress, onError);
		},
		parse: function parse(json) {
			return new Font(json);
		}
	});

	var _context;

	var AudioContext = {
		getContext: function getContext() {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function setContext(value) {
			_context = value;
		}
	};

	function AudioLoader(manager) {
		Loader.call(this, manager);
	}

	AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
		constructor: AudioLoader,
		load: function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					var bufferCopy = buffer.slice(0);
					var context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}
	});

	function HemisphereLightProbe(skyColor, groundColor, intensity) {
		LightProbe.call(this, undefined, intensity);
		var color1 = new Color().set(skyColor);
		var color2 = new Color().set(groundColor);
		var sky = new Vector3(color1.r, color1.g, color1.b);
		var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

		var c0 = Math.sqrt(Math.PI);
		var c1 = c0 * Math.sqrt(0.75);
		this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
		this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
	}

	HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
		constructor: HemisphereLightProbe,
		isHemisphereLightProbe: true,
		copy: function copy(source) {
			// modifying colors not currently supported
			LightProbe.prototype.copy.call(this, source);
			return this;
		},
		toJSON: function toJSON(meta) {
			var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

			return data;
		}
	});

	function AmbientLightProbe(color, intensity) {
		LightProbe.call(this, undefined, intensity);
		var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

		this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
	}

	AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
		constructor: AmbientLightProbe,
		isAmbientLightProbe: true,
		copy: function copy(source) {
			// modifying color not currently supported
			LightProbe.prototype.copy.call(this, source);
			return this;
		},
		toJSON: function toJSON(meta) {
			var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

			return data;
		}
	});

	var _eyeRight = new Matrix4();

	var _eyeLeft = new Matrix4();

	function StereoCamera() {
		this.type = 'StereoCamera';
		this.aspect = 1;
		this.eyeSep = 0.064;
		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = false;
		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = false;
		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};
	}

	Object.assign(StereoCamera.prototype, {
		update: function update(camera) {
			var cache = this._cache;
			var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSepHalf = cache.eyeSep / 2;
				var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				var ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
				var xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}
	});

	var Clock = /*#__PURE__*/function () {
		function Clock(autoStart) {
			this.autoStart = autoStart !== undefined ? autoStart : true;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		var _proto = Clock.prototype;

		_proto.start = function start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		};

		_proto.stop = function stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		};

		_proto.getElapsedTime = function getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		};

		_proto.getDelta = function getDelta() {
			var diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				var newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		};

		return Clock;
	}();

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	var _position$2 = /*@__PURE__*/new Vector3();

	var _quaternion$3 = /*@__PURE__*/new Quaternion();

	var _scale$1 = /*@__PURE__*/new Vector3();

	var _orientation = /*@__PURE__*/new Vector3();

	var AudioListener = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(AudioListener, _Object3D);

		function AudioListener() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'AudioListener';
			_this.context = AudioContext.getContext();
			_this.gain = _this.context.createGain();

			_this.gain.connect(_this.context.destination);

			_this.filter = null;
			_this.timeDelta = 0; // private

			_this._clock = new Clock();
			return _this;
		}

		var _proto = AudioListener.prototype;

		_proto.getInput = function getInput() {
			return this.gain;
		};

		_proto.removeFilter = function removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		};

		_proto.getFilter = function getFilter() {
			return this.filter;
		};

		_proto.setFilter = function setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		};

		_proto.getMasterVolume = function getMasterVolume() {
			return this.gain.gain.value;
		};

		_proto.setMasterVolume = function setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Object3D.prototype.updateMatrixWorld.call(this, force);

			var listener = this.context.listener;
			var up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

			_orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				var endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
				listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
			}
		};

		return AudioListener;
	}(Object3D);

	var Audio = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Audio, _Object3D);

		function Audio(listener) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Audio';
			_this.listener = listener;
			_this.context = listener.context;
			_this.gain = _this.context.createGain();

			_this.gain.connect(listener.getInput());

			_this.autoplay = false;
			_this.buffer = null;
			_this.detune = 0;
			_this.loop = false;
			_this.loopStart = 0;
			_this.loopEnd = 0;
			_this.offset = 0;
			_this.duration = undefined;
			_this.playbackRate = 1;
			_this.isPlaying = false;
			_this.hasPlaybackControl = true;
			_this.source = null;
			_this.sourceType = 'empty';
			_this._startedAt = 0;
			_this._progress = 0;
			_this._connected = false;
			_this.filters = [];
			return _this;
		}

		var _proto = Audio.prototype;

		_proto.getOutput = function getOutput() {
			return this.gain;
		};

		_proto.setNodeSource = function setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		};

		_proto.setMediaElementSource = function setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		};

		_proto.setMediaStreamSource = function setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		};

		_proto.setBuffer = function setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		};

		_proto.play = function play(delay) {
			if (delay === void 0) {
				delay = 0;
			}

			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			var source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		};

		_proto.pause = function pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		};

		_proto.stop = function stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		};

		_proto.connect = function connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		};

		_proto.disconnect = function disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		};

		_proto.getFilters = function getFilters() {
			return this.filters;
		};

		_proto.setFilters = function setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		};

		_proto.setDetune = function setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		};

		_proto.getDetune = function getDetune() {
			return this.detune;
		};

		_proto.getFilter = function getFilter() {
			return this.getFilters()[0];
		};

		_proto.setFilter = function setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		};

		_proto.setPlaybackRate = function setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		};

		_proto.getPlaybackRate = function getPlaybackRate() {
			return this.playbackRate;
		};

		_proto.onEnded = function onEnded() {
			this.isPlaying = false;
		};

		_proto.getLoop = function getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		};

		_proto.setLoop = function setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		};

		_proto.setLoopStart = function setLoopStart(value) {
			this.loopStart = value;
			return this;
		};

		_proto.setLoopEnd = function setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		};

		_proto.getVolume = function getVolume() {
			return this.gain.gain.value;
		};

		_proto.setVolume = function setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		};

		return Audio;
	}(Object3D);

	var _position$3 = /*@__PURE__*/new Vector3();

	var _quaternion$4 = /*@__PURE__*/new Quaternion();

	var _scale$2 = /*@__PURE__*/new Vector3();

	var _orientation$1 = /*@__PURE__*/new Vector3();

	var PositionalAudio = /*#__PURE__*/function (_Audio) {
		_inheritsLoose(PositionalAudio, _Audio);

		function PositionalAudio(listener) {
			var _this;

			_this = _Audio.call(this, listener) || this;
			_this.panner = _this.context.createPanner();
			_this.panner.panningModel = 'HRTF';

			_this.panner.connect(_this.gain);

			return _this;
		}

		var _proto = PositionalAudio.prototype;

		_proto.getOutput = function getOutput() {
			return this.panner;
		};

		_proto.getRefDistance = function getRefDistance() {
			return this.panner.refDistance;
		};

		_proto.setRefDistance = function setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		};

		_proto.getRolloffFactor = function getRolloffFactor() {
			return this.panner.rolloffFactor;
		};

		_proto.setRolloffFactor = function setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		};

		_proto.getDistanceModel = function getDistanceModel() {
			return this.panner.distanceModel;
		};

		_proto.setDistanceModel = function setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		};

		_proto.getMaxDistance = function getMaxDistance() {
			return this.panner.maxDistance;
		};

		_proto.setMaxDistance = function setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		};

		_proto.setDirectionalCone = function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Audio.prototype.updateMatrixWorld.call(this, force);

			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

			_orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

			var panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				var endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
			} else {
				panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
				panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
			}
		};

		return PositionalAudio;
	}(Audio);

	var AudioAnalyser = /*#__PURE__*/function () {
		function AudioAnalyser(audio, fftSize) {
			if (fftSize === void 0) {
				fftSize = 2048;
			}

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		var _proto = AudioAnalyser.prototype;

		_proto.getFrequencyData = function getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		};

		_proto.getAverageFrequency = function getAverageFrequency() {
			var value = 0;
			var data = this.getFrequencyData();

			for (var i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		};

		return AudioAnalyser;
	}();

	function PropertyMixer(binding, typeName, valueSize) {
		this.binding = binding;
		this.valueSize = valueSize;
		var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch (typeName) {
			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;
				this.buffer = new Float64Array(valueSize * 6);
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select; // Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types

				mixFunctionAdditive = this._select;
				setIdentity = this._setAdditiveIdentityOther;
				this.buffer = new Array(valueSize * 5);
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;
				this.buffer = new Float64Array(valueSize * 5);
		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;
		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;
		this.useCount = 0;
		this.referenceCount = 0;
	}

	Object.assign(PropertyMixer.prototype, {
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride;
			var currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (var i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				var mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		},
		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive: function accumulateAdditive(weight) {
			var buffer = this.buffer,
					stride = this.valueSize,
					offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		},
		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function apply(accuIndex) {
			var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
					weight = this.cumulativeWeight,
					weightAdditive = this.cumulativeWeightAdditive,
					binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				var originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (var i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		},
		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function saveOriginalState() {
			var binding = this.binding;
			var buffer = this.buffer,
					stride = this.valueSize,
					originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (var i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		},
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function restoreOriginalState() {
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		},
		_setAdditiveIdentityNumeric: function _setAdditiveIdentityNumeric() {
			var startIndex = this._addIndex * this.valueSize;
			var endIndex = startIndex + this.valueSize;

			for (var i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		},
		_setAdditiveIdentityQuaternion: function _setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		},
		_setAdditiveIdentityOther: function _setAdditiveIdentityOther() {
			var startIndex = this._origIndex * this.valueSize;
			var targetIndex = this._addIndex * this.valueSize;

			for (var i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		},
		// mix functions
		_select: function _select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (var i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		},
		_slerp: function _slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		},
		_slerpAdditive: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		},
		_lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
			var s = 1 - t;

			for (var i = 0; i !== stride; ++i) {
				var j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		},
		_lerpAdditive: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (var i = 0; i !== stride; ++i) {
				var j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}
	});

	// Characters [].:/ are reserved for track binding syntax.
	var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	var _supportedObjectNames = ['material', 'materials', 'bones'];

	function Composite(targetGroup, path, optionalParsedPath) {
		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_(path, parsedPath);
	}

	Object.assign(Composite.prototype, {
		getValue: function getValue(array, offset) {
			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		},
		setValue: function setValue(array, offset) {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		},
		bind: function bind() {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		},
		unbind: function unbind() {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}
	});

	function PropertyBinding(rootNode, path, parsedPath) {
		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
		this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
		this.rootNode = rootNode;
	}

	Object.assign(PropertyBinding, {
		Composite: Composite,
		create: function create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: function sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		},
		parseTrackName: function parseTrackName(trackName) {
			var matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		},
		findNode: function findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				var bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				var searchNodeSubtree = function searchNodeSubtree(children) {
					for (var i = 0; i < children.length; i++) {
						var childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						var result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				var subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		}
	});
	Object.assign(PropertyBinding.prototype, {
		// prototype, continued
		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function _getValue_unavailable() {},
		_setValue_unavailable: function _setValue_unavailable() {},
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
		GetterByBindingType: [function getValue_direct(buffer, offset) {
			buffer[offset] = this.node[this.propertyName];
		}, function getValue_array(buffer, offset) {
			var source = this.resolvedProperty;

			for (var i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}, function getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}, function getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		}],
		SetterByBindingTypeAndVersioning: [[// Direct
		function setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}, function setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		}], [// EntireArray
		function setValue_array(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}, function setValue_array_setNeedsUpdate(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		}, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		}], [// ArrayElement
		function setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		}], [// HasToFromArray
		function setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}]],
		getValue: function getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
		},
		setValue: function getValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		},
		// create getter / setter pair for a property in the scene graph
		bind: function bind() {
			var targetObject = this.node;
			var parsedPath = this.parsedPath;
			var objectName = parsedPath.objectName;
			var propertyName = parsedPath.propertyName;
			var propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (var i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			var nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				var nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			var versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			var bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		},
		unbind: function unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}
	}); // DECLARE ALIAS AFTER assign prototype

	Object.assign(PropertyBinding.prototype, {
		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue
	});

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	function AnimationObjectGroup() {
		this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones

		this._objects = Array.prototype.slice.call(arguments);
		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for (var i = 0, n = arguments.length; i !== n; ++i) {
			indices[arguments[i].uuid] = i;
		}

		this._paths = []; // inside: string

		this._parsedPaths = []; // inside: { we don't care, here }

		this._bindings = []; // inside: Array< PropertyBinding >

		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		var scope = this;
		this.stats = {
			objects: {
				get total() {
					return scope._objects.length;
				},

				get inUse() {
					return this.total - scope.nCachedObjects_;
				}

			},

			get bindingsPerObject() {
				return scope._bindings.length;
			}

		};
	}

	Object.assign(AnimationObjectGroup.prototype, {
		isAnimationObjectGroup: true,
		add: function add() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
			var knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid;
				var index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					var firstActiveIndex = --nCachedObjects,
							lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (var _j = 0, _m = nBindings; _j !== _m; ++_j) {
						var bindingsForPath = bindings[_j],
								lastCached = bindingsForPath[firstActiveIndex];
						var binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[_j], parsedPaths[_j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		},
		remove: function remove() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
			var nCachedObjects = this.nCachedObjects_;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid,
						index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					var lastCachedIndex = nCachedObjects++,
							firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						var bindingsForPath = bindings[j],
								firstActive = bindingsForPath[lastCachedIndex],
								binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		},
		// remove & forget
		uncache: function uncache() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
			var nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid,
						index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						var firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex],
								lastIndex = --nObjects,
								lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {
							var bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex],
									last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						var _lastIndex = --nObjects,
								_lastObject = objects[_lastIndex];

						if (_lastIndex > 0) {
							indicesByUUID[_lastObject.uuid] = index;
						}

						objects[index] = _lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (var _j2 = 0, _m2 = nBindings; _j2 !== _m2; ++_j2) {
							var _bindingsForPath = bindings[_j2];
							_bindingsForPath[index] = _bindingsForPath[_lastIndex];

							_bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		},
		// Internal interface used by befriended PropertyBinding.Composite:
		subscribe_: function subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			var indicesByPath = this._bindingsIndicesByPath;
			var index = indicesByPath[path];
			var bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
				var object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		},
		unsubscribe_: function unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[path];

			if (index !== undefined) {
				var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[lastBindingsIndex],
						lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}
	});

	var AnimationAction = /*#__PURE__*/function () {
		function AnimationAction(mixer, clip, localRoot, blendMode) {
			if (localRoot === void 0) {
				localRoot = null;
			}

			if (blendMode === void 0) {
				blendMode = clip.blendMode;
			}

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			var tracks = clip.tracks,
					nTracks = tracks.length,
					interpolants = new Array(nTracks);
			var interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (var i = 0; i !== nTracks; ++i) {
				var interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		var _proto = AnimationAction.prototype;

		_proto.play = function play() {
			this._mixer._activateAction(this);

			return this;
		};

		_proto.stop = function stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		};

		_proto.reset = function reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		};

		_proto.isRunning = function isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called
		;

		_proto.isScheduled = function isScheduled() {
			return this._mixer._isActiveAction(this);
		};

		_proto.startAt = function startAt(time) {
			this._startTime = time;
			return this;
		};

		_proto.setLoop = function setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		;

		_proto.setEffectiveWeight = function setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled
		;

		_proto.getEffectiveWeight = function getEffectiveWeight() {
			return this._effectiveWeight;
		};

		_proto.fadeIn = function fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		};

		_proto.fadeOut = function fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		};

		_proto.crossFadeFrom = function crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		};

		_proto.crossFadeTo = function crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		};

		_proto.stopFading = function stopFading() {
			var weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		;

		_proto.setEffectiveTimeScale = function setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused
		;

		_proto.getEffectiveTimeScale = function getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		};

		_proto.setDuration = function setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		};

		_proto.syncWith = function syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		};

		_proto.halt = function halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		};

		_proto.warp = function warp(startTimeScale, endTimeScale, duration) {
			var mixer = this._mixer,
					now = mixer.time,
					timeScale = this.timeScale;
			var interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		};

		_proto.stopWarping = function stopWarping() {
			var timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors
		;

		_proto.getMixer = function getMixer() {
			return this._mixer;
		};

		_proto.getClip = function getClip() {
			return this._clip;
		};

		_proto.getRoot = function getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna
		;

		_proto._update = function _update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			var startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				var timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			var weight = this._updateWeight(time);

			if (weight > 0) {
				var _interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (var j = 0, m = _interpolants.length; j !== m; ++j) {
							_interpolants[j].evaluate(clipTime);

							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (var _j = 0, _m = _interpolants.length; _j !== _m; ++_j) {
							_interpolants[_j].evaluate(clipTime);

							propertyMixers[_j].accumulate(accuIndex, weight);
						}

				}
			}
		};

		_proto._updateWeight = function _updateWeight(time) {
			var weight = 0;

			if (this.enabled) {
				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					var interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		};

		_proto._updateTimeScale = function _updateTimeScale(time) {
			var timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				var interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					var interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		};

		_proto._updateTime = function _updateTime(deltaTime) {
			var duration = this._clip.duration;
			var loop = this.loop;
			var time = this.time + deltaTime;
			var loopCount = this._loopCount;
			var pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					var loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					var pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							var atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		};

		_proto._setEndings = function _setEndings(atStart, atEnd, pingPong) {
			var settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		};

		_proto._scheduleFading = function _scheduleFading(duration, weightNow, weightThen) {
			var mixer = this._mixer,
					now = mixer.time;
			var interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		};

		return AnimationAction;
	}();

	function AnimationMixer(root) {
		this._root = root;

		this._initMemoryManager();

		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;
	}

	AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: AnimationMixer,
		_bindAction: function _bindAction(action, prototypeAction) {
			var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName;
			var bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (var i = 0; i !== nTracks; ++i) {
				var track = tracks[i],
						trackName = track.name;
				var binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		},
		_activateAction: function _activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					var rootUuid = (action._localRoot || this._root).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				var bindings = action._propertyBindings; // increment reference counts / sort out state

				for (var i = 0, n = bindings.length; i !== n; ++i) {
					var binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		},
		_deactivateAction: function _deactivateAction(action) {
			if (this._isActiveAction(action)) {
				var bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (var i = 0, n = bindings.length; i !== n; ++i) {
					var binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		},
		// Memory manager
		_initMemoryManager: function _initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			var scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		},
		// Memory management for AnimationAction objects
		_isActiveAction: function _isActiveAction(action) {
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		},
		_addInactiveAction: function _addInactiveAction(action, clipUuid, rootUuid) {
			var actions = this._actions,
					actionsByClip = this._actionsByClip;
			var actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				var knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		},
		_removeInactiveAction: function _removeInactiveAction(action) {
			var actions = this._actions,
					lastInactiveAction = actions[actions.length - 1],
					cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[clipUuid],
					knownActionsForClip = actionsForClip.knownActions,
					lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
					byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		},
		_removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(action) {
			var bindings = action._propertyBindings;

			for (var i = 0, n = bindings.length; i !== n; ++i) {
				var binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		},
		_lendAction: function _lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			var actions = this._actions,
					prevIndex = action._cacheIndex,
					lastActiveIndex = this._nActiveActions++,
					firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		},
		_takeBackAction: function _takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			var actions = this._actions,
					prevIndex = action._cacheIndex,
					firstInactiveIndex = --this._nActiveActions,
					lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		},
		// Memory management for PropertyMixer objects
		_addInactiveBinding: function _addInactiveBinding(binding, rootUuid, trackName) {
			var bindingsByRoot = this._bindingsByRootAndName,
					bindings = this._bindings;
			var bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		},
		_removeInactiveBinding: function _removeInactiveBinding(binding) {
			var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[rootUuid],
					lastInactiveBinding = bindings[bindings.length - 1],
					cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		},
		_lendBinding: function _lendBinding(binding) {
			var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
					lastActiveIndex = this._nActiveBindings++,
					firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		},
		_takeBackBinding: function _takeBackBinding(binding) {
			var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
					firstInactiveIndex = --this._nActiveBindings,
					lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		},
		// Memory management of Interpolants for weight and time scale
		_lendControlInterpolant: function _lendControlInterpolant() {
			var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants++;
			var interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		},
		_takeBackControlInterpolant: function _takeBackControlInterpolant(interpolant) {
			var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
					firstInactiveIndex = --this._nActiveControlInterpolants,
					lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		},
		_controlInterpolantsResultBuffer: new Float32Array(1),
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function clipAction(clip, optionalRoot, blendMode) {
			var root = optionalRoot || this._root,
					rootUuid = root.uuid;
			var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			var clipUuid = clipObject !== null ? clipObject.uuid : clip;
			var actionsForClip = this._actionsByClip[clipUuid];
			var prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				var existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		},
		// get an existing action
		existingAction: function existingAction(clip, optionalRoot) {
			var root = optionalRoot || this._root,
					rootUuid = root.uuid,
					clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
					clipUuid = clipObject ? clipObject.uuid : clip,
					actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		},
		// deactivates all previously scheduled actions
		stopAllAction: function stopAllAction() {
			var actions = this._actions,
					nActions = this._nActiveActions;

			for (var i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		},
		// advance the time and update apply the animation
		update: function update(deltaTime) {
			deltaTime *= this.timeScale;
			var actions = this._actions,
					nActions = this._nActiveActions,
					time = this.time += deltaTime,
					timeDirection = Math.sign(deltaTime),
					accuIndex = this._accuIndex ^= 1; // run active actions

			for (var i = 0; i !== nActions; ++i) {
				var action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			var bindings = this._bindings,
					nBindings = this._nActiveBindings;

			for (var _i = 0; _i !== nBindings; ++_i) {
				bindings[_i].apply(accuIndex);
			}

			return this;
		},
		// Allows you to seek to a specific time in an animation.
		setTime: function setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (var i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		},
		// return this mixer's root target object
		getRoot: function getRoot() {
			return this._root;
		},
		// free all resources specific to a particular clip
		uncacheClip: function uncacheClip(clip) {
			var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				var actionsToRemove = actionsForClip.knownActions;

				for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
					var action = actionsToRemove[i];

					this._deactivateAction(action);

					var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		},
		// free all resources specific to a particular root target object
		uncacheRoot: function uncacheRoot(root) {
			var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

			for (var clipUuid in actionsByClip) {
				var actionByRoot = actionsByClip[clipUuid].actionByRoot,
						action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (var trackName in bindingByName) {
					var binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		},
		// remove a targeted clip from the cache
		uncacheAction: function uncacheAction(clip, optionalRoot) {
			var action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		}
	});

	var Uniform = /*#__PURE__*/function () {
		function Uniform(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		var _proto = Uniform.prototype;

		_proto.clone = function clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		};

		return Uniform;
	}();

	function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
		InterleavedBuffer.call(this, array, stride);
		this.meshPerAttribute = meshPerAttribute || 1;
	}

	InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
		constructor: InstancedInterleavedBuffer,
		isInstancedInterleavedBuffer: true,
		copy: function copy(source) {
			InterleavedBuffer.prototype.copy.call(this, source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		},
		clone: function clone(data) {
			var ib = InterleavedBuffer.prototype.clone.call(this, data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		},
		toJSON: function toJSON(data) {
			var json = InterleavedBuffer.prototype.toJSON.call(this, data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}
	});

	function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;
		this.version = 0;
	}

	Object.defineProperty(GLBufferAttribute.prototype, 'needsUpdate', {
		set: function set(value) {
			if (value === true) this.version++;
		}
	});
	Object.assign(GLBufferAttribute.prototype, {
		isGLBufferAttribute: true,
		setBuffer: function setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		},
		setType: function setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		},
		setItemSize: function setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		},
		setCount: function setCount(count) {
			this.count = count;
			return this;
		}
	});

	function Raycaster(origin, direction, near, far) {
		this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;
		this.camera = null;
		this.layers = new Layers();
		this.params = {
			Mesh: {},
			Line: {
				threshold: 1
			},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		};
		Object.defineProperties(this.params, {
			PointCloud: {
				get: function get() {
					console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
					return this.Points;
				}
			}
		});
	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function _intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				_intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	Object.assign(Raycaster.prototype, {
		set: function set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		},
		setFromCamera: function setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		},
		intersectObject: function intersectObject(object, recursive, optionalTarget) {
			var intersects = optionalTarget || [];

			_intersectObject(object, this, intersects, recursive);

			intersects.sort(ascSort);
			return intersects;
		},
		intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {
			var intersects = optionalTarget || [];

			if (Array.isArray(objects) === false) {
				console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
				return intersects;
			}

			for (var i = 0, l = objects.length; i < l; i++) {
				_intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		}
	});

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	var Spherical = /*#__PURE__*/function () {
		function Spherical(radius, phi, theta) {
			if (radius === void 0) {
				radius = 1;
			}

			if (phi === void 0) {
				phi = 0;
			}

			if (theta === void 0) {
				theta = 0;
			}

			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		var _proto = Spherical.prototype;

		_proto.set = function set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS
		;

		_proto.makeSafe = function makeSafe() {
			var EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		};

		_proto.setFromVector3 = function setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		};

		_proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
			}

			return this;
		};

		return Spherical;
	}();

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	var Cylindrical = /*#__PURE__*/function () {
		function Cylindrical(radius, theta, y) {
			this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane

			this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y !== undefined ? y : 0; // height above the x-z plane

			return this;
		}

		var _proto = Cylindrical.prototype;

		_proto.set = function set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		};

		_proto.setFromVector3 = function setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		};

		_proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		};

		return Cylindrical;
	}();

	var _vector$8 = /*@__PURE__*/new Vector2();

	var Box2 = /*#__PURE__*/function () {
		function Box2(min, max) {
			Object.defineProperty(this, 'isBox2', {
				value: true
			});
			this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
			this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
		}

		var _proto = Box2.prototype;

		_proto.set = function set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points) {
			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		};

		_proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
			var halfSize = _vector$8.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		};

		_proto.getCenter = function getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getCenter() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		};

		_proto.getSize = function getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getSize() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		};

		_proto.expandByPoint = function expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		};

		_proto.expandByVector = function expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		};

		_proto.expandByScalar = function expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		};

		_proto.containsBox = function containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		};

		_proto.getParameter = function getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			if (target === undefined) {
				console.warn('THREE.Box2: .getParameter() target is now required');
				target = new Vector2();
			}

			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		};

		_proto.intersectsBox = function intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		};

		_proto.clampPoint = function clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .clampPoint() target is now required');
				target = new Vector2();
			}

			return target.copy(point).clamp(this.min, this.max);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			var clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		};

		_proto.intersect = function intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		};

		_proto.union = function union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		};

		_proto.equals = function equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		};

		return Box2;
	}();

	var _startP = /*@__PURE__*/new Vector3();

	var _startEnd = /*@__PURE__*/new Vector3();

	var Line3 = /*#__PURE__*/function () {
		function Line3(start, end) {
			this.start = start !== undefined ? start : new Vector3();
			this.end = end !== undefined ? end : new Vector3();
		}

		var _proto = Line3.prototype;

		_proto.set = function set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		};

		_proto.getCenter = function getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .getCenter() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		};

		_proto.delta = function delta(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .delta() target is now required');
				target = new Vector3();
			}

			return target.subVectors(this.end, this.start);
		};

		_proto.distanceSq = function distanceSq() {
			return this.start.distanceToSquared(this.end);
		};

		_proto.distance = function distance() {
			return this.start.distanceTo(this.end);
		};

		_proto.at = function at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .at() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		};

		_proto.closestPointToPointParameter = function closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			var startEnd2 = _startEnd.dot(_startEnd);

			var startEnd_startP = _startEnd.dot(_startP);

			var t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = MathUtils.clamp(t, 0, 1);
			}

			return t;
		};

		_proto.closestPointToPoint = function closestPointToPoint(point, clampToLine, target) {
			var t = this.closestPointToPointParameter(point, clampToLine);

			if (target === undefined) {
				console.warn('THREE.Line3: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		};

		_proto.equals = function equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		};

		return Line3;
	}();

	function ImmediateRenderObject(material) {
		Object3D.call(this);
		this.material = material;

		this.render = function ()
		/* renderCallback */
		{};

		this.hasPositions = false;
		this.hasNormals = false;
		this.hasColors = false;
		this.hasUvs = false;
		this.positionArray = null;
		this.normalArray = null;
		this.colorArray = null;
		this.uvArray = null;
		this.count = 0;
	}

	ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	var _vector$9 = /*@__PURE__*/new Vector3();

	var SpotLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(SpotLightHelper, _Object3D);

		function SpotLightHelper(light, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			var geometry = new BufferGeometry();
			var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
				var p1 = i / l * Math.PI * 2;
				var p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			var material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			_this.cone = new LineSegments(geometry, material);

			_this.add(_this.cone);

			_this.update();

			return _this;
		}

		var _proto = SpotLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		};

		_proto.update = function update() {
			this.light.updateMatrixWorld();
			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$9.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$9);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		};

		return SpotLightHelper;
	}(Object3D);

	var _vector$a = /*@__PURE__*/new Vector3();

	var _boneMatrix = /*@__PURE__*/new Matrix4();

	var _matrixWorldInv = /*@__PURE__*/new Matrix4();

	var SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(SkeletonHelper, _LineSegments);

		function SkeletonHelper(object) {
			var _this;

			var bones = getBoneList(object);
			var geometry = new BufferGeometry();
			var vertices = [];
			var colors = [];
			var color1 = new Color(0, 0, 1);
			var color2 = new Color(0, 1, 0);

			for (var i = 0; i < bones.length; i++) {
				var bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'SkeletonHelper';
			_this.isSkeletonHelper = true;
			_this.root = object;
			_this.bones = bones;
			_this.matrix = object.matrixWorld;
			_this.matrixAutoUpdate = false;
			return _this;
		}

		var _proto = SkeletonHelper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var bones = this.bones;
			var geometry = this.geometry;
			var position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (var i = 0, j = 0; i < bones.length; i++) {
				var bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$a.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$a.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;

			_LineSegments.prototype.updateMatrixWorld.call(this, force);
		};

		return SkeletonHelper;
	}(LineSegments);

	function getBoneList(object) {
		var boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (var i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	var PointLightHelper = /*#__PURE__*/function (_Mesh) {
		_inheritsLoose(PointLightHelper, _Mesh);

		function PointLightHelper(light, sphereSize, color) {
			var _this;

			var geometry = new SphereGeometry(sphereSize, 4, 2);
			var material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			_this = _Mesh.call(this, geometry, material) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.color = color;
			_this.type = 'PointLightHelper';
			_this.matrix = _this.light.matrixWorld;
			_this.matrixAutoUpdate = false;

			_this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/


			return _this;
		}

		var _proto = PointLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.geometry.dispose();
			this.material.dispose();
		};

		_proto.update = function update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/

		};

		return PointLightHelper;
	}(Mesh);

	var _vector$b = /*@__PURE__*/new Vector3();

	var _color1 = /*@__PURE__*/new Color();

	var _color2 = /*@__PURE__*/new Color();

	var HemisphereLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(HemisphereLightHelper, _Object3D);

		function HemisphereLightHelper(light, size, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			var geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			_this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (_this.color === undefined) _this.material.vertexColors = true;
			var position = geometry.getAttribute('position');
			var colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));

			_this.add(new Mesh(geometry, _this.material));

			_this.update();

			return _this;
		}

		var _proto = HemisphereLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		};

		_proto.update = function update() {
			var mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				var colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (var i = 0, l = colors.count; i < l; i++) {
					var color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
		};

		return HemisphereLightHelper;
	}(Object3D);

	var GridHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(GridHelper, _LineSegments);

		function GridHelper(size, divisions, color1, color2) {
			var _this;

			if (size === void 0) {
				size = 10;
			}

			if (divisions === void 0) {
				divisions = 10;
			}

			if (color1 === void 0) {
				color1 = 0x444444;
			}

			if (color2 === void 0) {
				color2 = 0x888888;
			}

			color1 = new Color(color1);
			color2 = new Color(color2);
			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;
			var vertices = [],
					colors = [];

			for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				var color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'GridHelper';
			return _this;
		}

		return GridHelper;
	}(LineSegments);

	var PolarGridHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(PolarGridHelper, _LineSegments);

		function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
			var _this;

			if (radius === void 0) {
				radius = 10;
			}

			if (radials === void 0) {
				radials = 16;
			}

			if (circles === void 0) {
				circles = 8;
			}

			if (divisions === void 0) {
				divisions = 64;
			}

			if (color1 === void 0) {
				color1 = 0x444444;
			}

			if (color2 === void 0) {
				color2 = 0x888888;
			}

			color1 = new Color(color1);
			color2 = new Color(color2);
			var vertices = [];
			var colors = []; // create the radials

			for (var i = 0; i <= radials; i++) {
				var v = i / radials * (Math.PI * 2);
				var x = Math.sin(v) * radius;
				var z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				var color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (var _i = 0; _i <= circles; _i++) {
				var _color = _i & 1 ? color1 : color2;

				var r = radius - radius / circles * _i;

				for (var j = 0; j < divisions; j++) {
					// first vertex
					var _v = j / divisions * (Math.PI * 2);

					var _x = Math.sin(_v) * r;

					var _z = Math.cos(_v) * r;

					vertices.push(_x, 0, _z);
					colors.push(_color.r, _color.g, _color.b); // second vertex

					_v = (j + 1) / divisions * (Math.PI * 2);
					_x = Math.sin(_v) * r;
					_z = Math.cos(_v) * r;
					vertices.push(_x, 0, _z);
					colors.push(_color.r, _color.g, _color.b);
				}
			}

			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'PolarGridHelper';
			return _this;
		}

		return PolarGridHelper;
	}(LineSegments);

	var _v1$6 = /*@__PURE__*/new Vector3();

	var _v2$3 = /*@__PURE__*/new Vector3();

	var _v3$1 = /*@__PURE__*/new Vector3();

	var DirectionalLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(DirectionalLightHelper, _Object3D);

		function DirectionalLightHelper(light, size, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			if (size === undefined) size = 1;
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			var material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			_this.lightPlane = new Line(geometry, material);

			_this.add(_this.lightPlane);

			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			_this.targetLine = new Line(geometry, material);

			_this.add(_this.targetLine);

			_this.update();

			return _this;
		}

		var _proto = DirectionalLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		};

		_proto.update = function update() {
			_v1$6.setFromMatrixPosition(this.light.matrixWorld);

			_v2$3.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3$1.subVectors(_v2$3, _v1$6);

			this.lightPlane.lookAt(_v2$3);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2$3);
			this.targetLine.scale.z = _v3$1.length();
		};

		return DirectionalLightHelper;
	}(Object3D);

	var _vector$c = /*@__PURE__*/new Vector3();

	var _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	var CameraHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(CameraHelper, _LineSegments);

		function CameraHelper(camera) {
			var _this;

			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			var vertices = [];
			var colors = [];
			var pointMap = {}; // colors

			var colorFrustum = new Color(0xffaa00);
			var colorCone = new Color(0xff0000);
			var colorUp = new Color(0x00aaff);
			var colorTarget = new Color(0xffffff);
			var colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'CameraHelper';
			_this.camera = camera;
			if (_this.camera.updateProjectionMatrix) _this.camera.updateProjectionMatrix();
			_this.matrix = camera.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.pointMap = pointMap;

			_this.update();

			return _this;
		}

		var _proto = CameraHelper.prototype;

		_proto.update = function update() {
			var geometry = this.geometry;
			var pointMap = this.pointMap;
			var w = 1,
					h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		};

		return CameraHelper;
	}(LineSegments);

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector$c.set(x, y, z).unproject(camera);

		var points = pointMap[point];

		if (points !== undefined) {
			var position = geometry.getAttribute('position');

			for (var i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector$c.x, _vector$c.y, _vector$c.z);
			}
		}
	}

	var _box$3 = /*@__PURE__*/new Box3();

	var BoxHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(BoxHelper, _LineSegments);

		function BoxHelper(object, color) {
			var _this;

			if (color === void 0) {
				color = 0xffff00;
			}

			var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			var positions = new Float32Array(8 * 3);
			var geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			_this = _LineSegments.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.object = object;
			_this.type = 'BoxHelper';
			_this.matrixAutoUpdate = false;

			_this.update();

			return _this;
		}

		var _proto = BoxHelper.prototype;

		_proto.update = function update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box$3.setFromObject(this.object);
			}

			if (_box$3.isEmpty()) return;
			var min = _box$3.min;
			var max = _box$3.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		};

		_proto.setFromObject = function setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		};

		_proto.copy = function copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		};

		return BoxHelper;
	}(LineSegments);

	var Box3Helper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(Box3Helper, _LineSegments);

		function Box3Helper(box, color) {
			var _this;

			if (color === void 0) {
				color = 0xffff00;
			}

			var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			var geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			_this = _LineSegments.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.box = box;
			_this.type = 'Box3Helper';

			_this.geometry.computeBoundingSphere();

			return _this;
		}

		var _proto = Box3Helper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);

			_LineSegments.prototype.updateMatrixWorld.call(this, force);
		};

		return Box3Helper;
	}(LineSegments);

	var PlaneHelper = /*#__PURE__*/function (_Line) {
		_inheritsLoose(PlaneHelper, _Line);

		function PlaneHelper(plane, size, hex) {
			var _this;

			if (size === void 0) {
				size = 1;
			}

			if (hex === void 0) {
				hex = 0xffff00;
			}

			var color = hex;
			var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			_this = _Line.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.type = 'PlaneHelper';
			_this.plane = plane;
			_this.size = size;
			var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			var geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();

			_this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));

			return _this;
		}

		var _proto = PlaneHelper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);

			_Line.prototype.updateMatrixWorld.call(this, force);
		};

		return PlaneHelper;
	}(Line);

	var _axis = /*@__PURE__*/new Vector3();

	var _lineGeometry, _coneGeometry;

	var ArrowHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(ArrowHelper, _Object3D);

		function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
			var _this;

			_this = _Object3D.call(this) || this; // dir is assumed to be normalized

			_this.type = 'ArrowHelper';
			if (dir === undefined) dir = new Vector3(0, 0, 1);
			if (origin === undefined) origin = new Vector3(0, 0, 0);
			if (length === undefined) length = 1;
			if (color === undefined) color = 0xffff00;
			if (headLength === undefined) headLength = 0.2 * length;
			if (headWidth === undefined) headWidth = 0.2 * headLength;

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			_this.position.copy(origin);

			_this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			_this.line.matrixAutoUpdate = false;

			_this.add(_this.line);

			_this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			_this.cone.matrixAutoUpdate = false;

			_this.add(_this.cone);

			_this.setDirection(dir);

			_this.setLength(length, headLength, headWidth);

			return _this;
		}

		var _proto = ArrowHelper.prototype;

		_proto.setDirection = function setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				var radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		};

		_proto.setLength = function setLength(length, headLength, headWidth) {
			if (headLength === undefined) headLength = 0.2 * length;
			if (headWidth === undefined) headWidth = 0.2 * headLength;
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		};

		_proto.setColor = function setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		};

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source, false);

			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		};

		return ArrowHelper;
	}(Object3D);

	var AxesHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(AxesHelper, _LineSegments);

		function AxesHelper(size) {
			var _this;

			if (size === void 0) {
				size = 1;
			}

			var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'AxesHelper';
			return _this;
		}

		return AxesHelper;
	}(LineSegments);

	var _floatView = new Float32Array(1);

	var _int32View = new Int32Array(_floatView.buffer);

	var DataUtils = {
		// Converts float32 to float16 (stored as uint16 value).
		toHalfFloat: function toHalfFloat(val) {
			// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */
			_floatView[0] = val;
			var x = _int32View[0];
			var bits = x >> 16 & 0x8000;
			/* Get the sign */

			var m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			var e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		}
	};

	var _ENCODINGS;
	var LOD_MIN = 4;
	var LOD_MAX = 8;
	var SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	var MAX_SAMPLES = 20;
	var ENCODINGS = (_ENCODINGS = {}, _ENCODINGS[LinearEncoding] = 0, _ENCODINGS[sRGBEncoding] = 1, _ENCODINGS[RGBEEncoding] = 2, _ENCODINGS[RGBM7Encoding] = 3, _ENCODINGS[RGBM16Encoding] = 4, _ENCODINGS[RGBDEncoding] = 5, _ENCODINGS[GammaEncoding] = 6, _ENCODINGS);
	var backgroundMaterial = new MeshBasicMaterial({
		side: BackSide,
		depthWrite: false,
		depthTest: false
	});
	var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);

	var _flatCamera = /*@__PURE__*/new OrthographicCamera();

	var _createPlanes2 = /*@__PURE__*/_createPlanes(),
			_lodPlanes = _createPlanes2._lodPlanes,
			_sizeLods = _createPlanes2._sizeLods,
			_sigmas = _createPlanes2._sigmas;

	var _clearColor = /*@__PURE__*/new Color();

	var _oldTarget = null; // Golden Ratio

	var PHI = (1 + Math.sqrt(5)) / 2;
	var INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	var _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 */

	function convertLinearToRGBE(color) {
		var maxComponent = Math.max(color.r, color.g, color.b);
		var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
		color.multiplyScalar(Math.pow(2.0, -fExp));
		var alpha = (fExp + 128.0) / 255.0;
		return alpha;
	}

	var PMREMGenerator = /*#__PURE__*/function () {
		function PMREMGenerator(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		var _proto = PMREMGenerator.prototype;

		_proto.fromScene = function fromScene(scene, sigma, near, far) {
			if (sigma === void 0) {
				sigma = 0;
			}

			if (near === void 0) {
				near = 0.1;
			}

			if (far === void 0) {
				far = 100;
			}

			_oldTarget = this._renderer.getRenderTarget();

			var cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		;

		_proto.fromEquirectangular = function fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		;

		_proto.fromCubemap = function fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		;

		_proto.compileCubemapShader = function compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		;

		_proto.compileEquirectangularShader = function compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		;

		_proto.dispose = function dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (var i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface
		;

		_proto._cleanup = function _cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		};

		_proto._fromTexture = function _fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			var cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		};

		_proto._allocateTargets = function _allocateTargets(texture) {
			// warning: null texture is valid
			var params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			var cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		};

		_proto._compileMaterial = function _compileMaterial(material) {
			var tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		};

		_proto._sceneToCubeUV = function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			var fov = 90;
			var aspect = 1;
			var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			var upSign = [1, -1, 1, 1, 1, 1];
			var forwardSign = [1, 1, 1, -1, -1, -1];
			var renderer = this._renderer;
			var originalAutoClear = renderer.autoClear;
			var outputEncoding = renderer.outputEncoding;
			var toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			var useSolidColor = false;
			var background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background).convertSRGBToLinear();
					scene.background = null;
					var alpha = convertLinearToRGBE(backgroundMaterial.color);
					backgroundMaterial.opacity = alpha;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();

				var _alpha = convertLinearToRGBE(backgroundMaterial.color);

				backgroundMaterial.opacity = _alpha;
				useSolidColor = true;
			}

			for (var i = 0; i < 6; i++) {
				var col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
		};

		_proto._textureToCubeUV = function _textureToCubeUV(texture, cubeUVRenderTarget) {
			var renderer = this._renderer;

			if (texture.isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
			var mesh = new Mesh(_lodPlanes[0], material);
			var uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!texture.isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
			uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		};

		_proto._applyPMREM = function _applyPMREM(cubeUVRenderTarget) {
			var renderer = this._renderer;
			var autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (var i = 1; i < TOTAL_LODS; i++) {
				var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		;

		_proto._blur = function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			var pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		};

		_proto._halfBlur = function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			var renderer = this._renderer;
			var blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			var STANDARD_DEVIATIONS = 3;
			var blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			var blurUniforms = blurMaterial.uniforms;
			var pixels = _sizeLods[lodIn] - 1;
			var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			var sigmaPixels = sigmaRadians / radiansPerPixel;
			var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn("sigmaRadians, " + sigmaRadians + ", is too large and will clip, as it requested " + samples + " samples when the maximum is set to " + MAX_SAMPLES);
			}

			var weights = [];
			var sum = 0;

			for (var i = 0; i < MAX_SAMPLES; ++i) {
				var _x = i / sigmaPixels;

				var weight = Math.exp(-_x * _x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (var _i = 0; _i < weights.length; _i++) {
				weights[_i] = weights[_i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;
			blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			var outputSize = _sizeLods[lodOut];
			var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		};

		return PMREMGenerator;
	}();

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		var _lodPlanes = [];
		var _sizeLods = [];
		var _sigmas = [];
		var lod = LOD_MAX;

		for (var i = 0; i < TOTAL_LODS; i++) {
			var sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			var sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			var texelSize = 1.0 / (sizeLod - 1);
			var min = -texelSize / 2;
			var max = 1 + texelSize / 2;
			var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			var cubeFaces = 6;
			var vertices = 6;
			var positionSize = 3;
			var uvSize = 2;
			var faceIndexSize = 1;
			var position = new Float32Array(positionSize * vertices * cubeFaces);
			var uv = new Float32Array(uvSize * vertices * cubeFaces);
			var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (var face = 0; face < cubeFaces; face++) {
				var x = face % 3 * 2 / 3 - 1;
				var y = face > 2 ? 0 : -1;
				var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				var fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			var planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes: _lodPlanes,
			_sizeLods: _sizeLods,
			_sigmas: _sigmas
		};
	}

	function _createRenderTarget(params) {
		var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		var weights = new Float32Array(maxSamples);
		var poleAxis = new Vector3(0, 1, 0);
		var shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		var texelSize = new Vector2(1, 1);
		var shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		var shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
		);
	}

	function Face4(a, b, c, d, normal, color, materialIndex) {
		console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
		return new Face3(a, b, c, normal, color, materialIndex);
	}
	var LineStrip = 0;
	var LinePieces = 1;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials) {
		if (materials === void 0) {
			materials = [];
		}

		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Object.assign(Path.prototype, {
		fromPoints: function fromPoints(points) {
			console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
			return this.setFromPoints(points);
		}
	}); //

	function ClosedSplineCurve3(points) {
		console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
		this.closed = true;
	}
	ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

	function SplineCurve3(points) {
		console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
	}
	SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

	function Spline(points) {
		console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
	}
	Spline.prototype = Object.create(CatmullRomCurve3.prototype);
	Object.assign(Spline.prototype, {
		initFromArray: function initFromArray()
		/* a */
		{
			console.error('THREE.Spline: .initFromArray() has been removed.');
		},
		getControlPointsArray: function getControlPointsArray()
		/* optionalTarget */
		{
			console.error('THREE.Spline: .getControlPointsArray() has been removed.');
		},
		reparametrizeByArcLength: function reparametrizeByArcLength()
		/* samplingCoef */
		{
			console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
		}
	}); //

	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Object.assign(Loader.prototype, {
		extractUrlBase: function extractUrlBase(url) {
			console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
			return LoaderUtils.extractUrlBase(url);
		}
	});
	Loader.Handlers = {
		add: function add()
		/* regex, loader */
		{
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function get()
		/* file */
		{
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Object.assign(Box2.prototype, {
		center: function center(optionalTarget) {
			console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
			return this.getCenter(optionalTarget);
		},
		empty: function empty() {
			console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
			return this.isEmpty();
		},
		isIntersectionBox: function isIntersectionBox(box) {
			console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		size: function size(optionalTarget) {
			console.warn('THREE.Box2: .size() has been renamed to .getSize().');
			return this.getSize(optionalTarget);
		}
	});
	Object.assign(Box3.prototype, {
		center: function center(optionalTarget) {
			console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
			return this.getCenter(optionalTarget);
		},
		empty: function empty() {
			console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
			return this.isEmpty();
		},
		isIntersectionBox: function isIntersectionBox(box) {
			console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		isIntersectionSphere: function isIntersectionSphere(sphere) {
			console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
			return this.intersectsSphere(sphere);
		},
		size: function size(optionalTarget) {
			console.warn('THREE.Box3: .size() has been renamed to .getSize().');
			return this.getSize(optionalTarget);
		}
	});
	Object.assign(Sphere.prototype, {
		empty: function empty() {
			console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
			return this.isEmpty();
		}
	});

	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	};

	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Object.assign(MathUtils, {
		random16: function random16() {
			console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
			return Math.random();
		},
		nearestPowerOfTwo: function nearestPowerOfTwo(value) {
			console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
			return MathUtils.floorPowerOfTwo(value);
		},
		nextPowerOfTwo: function nextPowerOfTwo(value) {
			console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
			return MathUtils.ceilPowerOfTwo(value);
		}
	});
	Object.assign(Matrix3.prototype, {
		flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
			console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
			return this.toArray(array, offset);
		},
		multiplyVector3: function multiplyVector3(vector) {
			console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
			return vector.applyMatrix3(this);
		},
		multiplyVector3Array: function multiplyVector3Array()
		/* a */
		{
			console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
		},
		applyToBufferAttribute: function applyToBufferAttribute(attribute) {
			console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
			return attribute.applyMatrix3(this);
		},
		applyToVector3Array: function applyToVector3Array()
		/* array, offset, length */
		{
			console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
		},
		getInverse: function getInverse(matrix) {
			console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
			return this.copy(matrix).invert();
		}
	});
	Object.assign(Matrix4.prototype, {
		extractPosition: function extractPosition(m) {
			console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
			return this.copyPosition(m);
		},
		flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
			console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
			return this.toArray(array, offset);
		},
		getPosition: function getPosition() {
			console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
			return new Vector3().setFromMatrixColumn(this, 3);
		},
		setRotationFromQuaternion: function setRotationFromQuaternion(q) {
			console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
			return this.makeRotationFromQuaternion(q);
		},
		multiplyToArray: function multiplyToArray() {
			console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
		},
		multiplyVector3: function multiplyVector3(vector) {
			console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		multiplyVector4: function multiplyVector4(vector) {
			console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		multiplyVector3Array: function multiplyVector3Array()
		/* a */
		{
			console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
		},
		rotateAxis: function rotateAxis(v) {
			console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
			v.transformDirection(this);
		},
		crossVector: function crossVector(vector) {
			console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		translate: function translate() {
			console.error('THREE.Matrix4: .translate() has been removed.');
		},
		rotateX: function rotateX() {
			console.error('THREE.Matrix4: .rotateX() has been removed.');
		},
		rotateY: function rotateY() {
			console.error('THREE.Matrix4: .rotateY() has been removed.');
		},
		rotateZ: function rotateZ() {
			console.error('THREE.Matrix4: .rotateZ() has been removed.');
		},
		rotateByAxis: function rotateByAxis() {
			console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
		},
		applyToBufferAttribute: function applyToBufferAttribute(attribute) {
			console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
			return attribute.applyMatrix4(this);
		},
		applyToVector3Array: function applyToVector3Array()
		/* array, offset, length */
		{
			console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
		},
		makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {
			console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
			return this.makePerspective(left, right, top, bottom, near, far);
		},
		getInverse: function getInverse(matrix) {
			console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
			return this.copy(matrix).invert();
		}
	});

	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	};

	Object.assign(Quaternion.prototype, {
		multiplyVector3: function multiplyVector3(vector) {
			console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
			return vector.applyQuaternion(this);
		},
		inverse: function inverse() {
			console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
			return this.invert();
		}
	});
	Object.assign(Ray.prototype, {
		isIntersectionBox: function isIntersectionBox(box) {
			console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		isIntersectionPlane: function isIntersectionPlane(plane) {
			console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
			return this.intersectsPlane(plane);
		},
		isIntersectionSphere: function isIntersectionSphere(sphere) {
			console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
			return this.intersectsSphere(sphere);
		}
	});
	Object.assign(Triangle.prototype, {
		area: function area() {
			console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
			return this.getArea();
		},
		barycoordFromPoint: function barycoordFromPoint(point, target) {
			console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
			return this.getBarycoord(point, target);
		},
		midpoint: function midpoint(target) {
			console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
			return this.getMidpoint(target);
		},
		normal: function normal(target) {
			console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
			return this.getNormal(target);
		},
		plane: function plane(target) {
			console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
			return this.getPlane(target);
		}
	});
	Object.assign(Triangle, {
		barycoordFromPoint: function barycoordFromPoint(point, a, b, c, target) {
			console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
			return Triangle.getBarycoord(point, a, b, c, target);
		},
		normal: function normal(a, b, c, target) {
			console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
			return Triangle.getNormal(a, b, c, target);
		}
	});
	Object.assign(Shape.prototype, {
		extractAllPoints: function extractAllPoints(divisions) {
			console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
			return this.extractPoints(divisions);
		},
		extrude: function extrude(options) {
			console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
			return new ExtrudeGeometry(this, options);
		},
		makeGeometry: function makeGeometry(options) {
			console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
			return new ShapeGeometry(this, options);
		}
	});
	Object.assign(Vector2.prototype, {
		fromAttribute: function fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		distanceToManhattan: function distanceToManhattan(v) {
			console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
			return this.manhattanDistanceTo(v);
		},
		lengthManhattan: function lengthManhattan() {
			console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		}
	});
	Object.assign(Vector3.prototype, {
		setEulerFromRotationMatrix: function setEulerFromRotationMatrix() {
			console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
		},
		setEulerFromQuaternion: function setEulerFromQuaternion() {
			console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
		},
		getPositionFromMatrix: function getPositionFromMatrix(m) {
			console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
			return this.setFromMatrixPosition(m);
		},
		getScaleFromMatrix: function getScaleFromMatrix(m) {
			console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
			return this.setFromMatrixScale(m);
		},
		getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {
			console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
			return this.setFromMatrixColumn(matrix, index);
		},
		applyProjection: function applyProjection(m) {
			console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
			return this.applyMatrix4(m);
		},
		fromAttribute: function fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		distanceToManhattan: function distanceToManhattan(v) {
			console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
			return this.manhattanDistanceTo(v);
		},
		lengthManhattan: function lengthManhattan() {
			console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		}
	});
	Object.assign(Vector4.prototype, {
		fromAttribute: function fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		lengthManhattan: function lengthManhattan() {
			console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		}
	}); //

	Object.assign(Object3D.prototype, {
		getChildByName: function getChildByName(name) {
			console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
			return this.getObjectByName(name);
		},
		renderDepth: function renderDepth() {
			console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
		},
		translate: function translate(distance, axis) {
			console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
			return this.translateOnAxis(axis, distance);
		},
		getWorldRotation: function getWorldRotation() {
			console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
		},
		applyMatrix: function applyMatrix(matrix) {
			console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
			return this.applyMatrix4(matrix);
		}
	});
	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function get() {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function set(value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function get() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function set() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});
	Object.assign(Mesh.prototype, {
		setDrawMode: function setDrawMode() {
			console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
		}
	});
	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function get() {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function set() {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});
	Object.defineProperties(LOD.prototype, {
		objects: {
			get: function get() {
				console.warn('THREE.LOD: .objects has been renamed to .levels.');
				return this.levels;
			}
		}
	});
	Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
		get: function get() {
			console.warn('THREE.Skeleton: useVertexTexture has been removed.');
		},
		set: function set() {
			console.warn('THREE.Skeleton: useVertexTexture has been removed.');
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	};

	Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
		get: function get() {
			console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
			return this.arcLengthDivisions;
		},
		set: function set(value) {
			console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
			this.arcLengthDivisions = value;
		}
	}); //

	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function set() {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function set() {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function set() {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function get() {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function get() {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function set()
			/* value */
			{
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});
	Object.assign(BufferAttribute.prototype, {
		setDynamic: function setDynamic(value) {
			console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
			this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
			return this;
		},
		copyIndicesArray: function copyIndicesArray()
		/* indices */
		{
			console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
		},
		setArray: function setArray()
		/* array */
		{
			console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
		}
	});
	Object.assign(BufferGeometry.prototype, {
		addIndex: function addIndex(index) {
			console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
			this.setIndex(index);
		},
		addAttribute: function addAttribute(name, attribute) {
			console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

			if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
				console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
				return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
			}

			if (name === 'index') {
				console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
				this.setIndex(attribute);
				return this;
			}

			return this.setAttribute(name, attribute);
		},
		addDrawCall: function addDrawCall(start, count, indexOffset) {
			if (indexOffset !== undefined) {
				console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
			}

			console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
			this.addGroup(start, count);
		},
		clearDrawCalls: function clearDrawCalls() {
			console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
			this.clearGroups();
		},
		computeOffsets: function computeOffsets() {
			console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
		},
		removeAttribute: function removeAttribute(name) {
			console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
			return this.deleteAttribute(name);
		},
		applyMatrix: function applyMatrix(matrix) {
			console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
			return this.applyMatrix4(matrix);
		}
	});
	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function get() {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function get() {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});
	Object.defineProperties(InstancedBufferGeometry.prototype, {
		maxInstancedCount: {
			get: function get() {
				console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
				return this.instanceCount;
			},
			set: function set(value) {
				console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
				this.instanceCount = value;
			}
		}
	});
	Object.defineProperties(Raycaster.prototype, {
		linePrecision: {
			get: function get() {
				console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
				return this.params.Line.threshold;
			},
			set: function set(value) {
				console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
				this.params.Line.threshold = value;
			}
		}
	});
	Object.defineProperties(InterleavedBuffer.prototype, {
		dynamic: {
			get: function get() {
				console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function set(value) {
				console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
				this.setUsage(value);
			}
		}
	});
	Object.assign(InterleavedBuffer.prototype, {
		setDynamic: function setDynamic(value) {
			console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
			this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
			return this;
		},
		setArray: function setArray()
		/* array */
		{
			console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
		}
	}); //

	Object.assign(ExtrudeGeometry.prototype, {
		getArrays: function getArrays() {
			console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
		},
		addShapeList: function addShapeList() {
			console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
		},
		addShape: function addShape() {
			console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
		}
	}); //

	Object.assign(Scene.prototype, {
		dispose: function dispose() {
			console.error('THREE.Scene: .dispose() has been removed.');
		}
	}); //

	Object.defineProperties(Uniform.prototype, {
		dynamic: {
			set: function set() {
				console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
			}
		},
		onUpdate: {
			value: function value() {
				console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
				return this;
			}
		}
	}); //

	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function get() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function set() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function get() {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function set() {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function get() {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function get() {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function set(value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function get() {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function set(value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		}
	});
	Object.defineProperties(MeshPhongMaterial.prototype, {
		metal: {
			get: function get() {
				console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
				return false;
			},
			set: function set() {
				console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
			}
		}
	});
	Object.defineProperties(MeshPhysicalMaterial.prototype, {
		transparency: {
			get: function get() {
				console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
				return this.transmission;
			},
			set: function set(value) {
				console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
				this.transmission = value;
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function get() {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function set(value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	Object.assign(WebGLRenderer.prototype, {
		clearTarget: function clearTarget(renderTarget, color, depth, stencil) {
			console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
			this.setRenderTarget(renderTarget);
			this.clear(color, depth, stencil);
		},
		animate: function animate(callback) {
			console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
			this.setAnimationLoop(callback);
		},
		getCurrentRenderTarget: function getCurrentRenderTarget() {
			console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
			return this.getRenderTarget();
		},
		getMaxAnisotropy: function getMaxAnisotropy() {
			console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
			return this.capabilities.getMaxAnisotropy();
		},
		getPrecision: function getPrecision() {
			console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
			return this.capabilities.precision;
		},
		resetGLState: function resetGLState() {
			console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
			return this.state.reset();
		},
		supportsFloatTextures: function supportsFloatTextures() {
			console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
			return this.extensions.get('OES_texture_float');
		},
		supportsHalfFloatTextures: function supportsHalfFloatTextures() {
			console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
			return this.extensions.get('OES_texture_half_float');
		},
		supportsStandardDerivatives: function supportsStandardDerivatives() {
			console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
			return this.extensions.get('OES_standard_derivatives');
		},
		supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {
			console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
			return this.extensions.get('WEBGL_compressed_texture_s3tc');
		},
		supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {
			console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
			return this.extensions.get('WEBGL_compressed_texture_pvrtc');
		},
		supportsBlendMinMax: function supportsBlendMinMax() {
			console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
			return this.extensions.get('EXT_blend_minmax');
		},
		supportsVertexTextures: function supportsVertexTextures() {
			console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
			return this.capabilities.vertexTextures;
		},
		supportsInstancedArrays: function supportsInstancedArrays() {
			console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
			return this.extensions.get('ANGLE_instanced_arrays');
		},
		enableScissorTest: function enableScissorTest(boolean) {
			console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
			this.setScissorTest(boolean);
		},
		initMaterial: function initMaterial() {
			console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
		},
		addPrePlugin: function addPrePlugin() {
			console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
		},
		addPostPlugin: function addPostPlugin() {
			console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
		},
		updateShadowMap: function updateShadowMap() {
			console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
		},
		setFaceCulling: function setFaceCulling() {
			console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
		},
		allocTextureUnit: function allocTextureUnit() {
			console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
		},
		setTexture: function setTexture() {
			console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
		},
		setTexture2D: function setTexture2D() {
			console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
		},
		setTextureCube: function setTextureCube() {
			console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
		},
		getActiveMipMapLevel: function getActiveMipMapLevel() {
			console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
			return this.getActiveMipmapLevel();
		}
	});
	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function get() {
				return this.shadowMap.enabled;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function get() {
				return this.shadowMap.type;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set()
			/* value */
			{
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set()
			/* cullFace */
			{
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Object.defineProperties(Audio.prototype, {
		load: {
			value: function value(file) {
				console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
				var scope = this;
				var audioLoader = new AudioLoader();
				audioLoader.load(file, function (buffer) {
					scope.setBuffer(buffer);
				});
				return this;
			}
		},
		startTime: {
			set: function set() {
				console.warn('THREE.Audio: .startTime is now .play( delay ).');
			}
		}
	});

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	}; //


	var GeometryUtils = {
		merge: function merge(geometry1, geometry2, materialIndexOffset) {
			console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
			var matrix;

			if (geometry2.isMesh) {
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
			}

			geometry1.merge(geometry2, matrix, materialIndexOffset);
		},
		center: function center(geometry) {
			console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
			return geometry.center();
		}
	};
	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		var loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		var texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		var loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		var texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	var SceneUtils = {
		createMultiMaterialObject: function createMultiMaterialObject()
		/* geometry, materials */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function detach()
		/* child, parent, scene */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function attach()
		/* child, scene, parent */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.Face3 = Face3;
	exports.Face4 = Face4;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GeometryUtils = GeometryUtils;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricBufferGeometry = ParametricGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.Spline = Spline;
	exports.SplineCurve = SplineCurve;
	exports.SplineCurve3 = SplineCurve3;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextBufferGeometry = TextGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
(function (global){(function (){
/** Miew - 3D Molecular Viewer v0.9.0+20230822.103925.6b542ed Copyright (c) 2015-2023 EPAM Systems, Inc. */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('lodash'), require('three')) :
  typeof define === 'function' && define.amd ? define(['lodash', 'three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Miew = factory(global._, global.THREE));
}(this, (function (_, THREE) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n['default'] = e;
    return Object.freeze(n);
  }

  var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
  var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var arrayLikeToArray = _arrayLikeToArray;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  var unsupportedIterableToArray = _unsupportedIterableToArray;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  var __assign = (undefined && undefined.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var defaults = {
      lines: 12,
      length: 7,
      width: 5,
      radius: 10,
      scale: 1.0,
      corners: 1,
      color: '#000',
      fadeColor: 'transparent',
      animation: 'spinner-line-fade-default',
      rotate: 0,
      direction: 1,
      speed: 1,
      zIndex: 2e9,
      className: 'spinner',
      top: '50%',
      left: '50%',
      shadow: '0 0 1px transparent',
      position: 'absolute',
  };
  var Spinner = /** @class */ (function () {
      function Spinner(opts) {
          if (opts === void 0) { opts = {}; }
          this.opts = __assign(__assign({}, defaults), opts);
      }
      /**
       * Adds the spinner to the given target element. If this instance is already
       * spinning, it is automatically removed from its previous target by calling
       * stop() internally.
       */
      Spinner.prototype.spin = function (target) {
          this.stop();
          this.el = document.createElement('div');
          this.el.className = this.opts.className;
          this.el.setAttribute('role', 'progressbar');
          css(this.el, {
              position: this.opts.position,
              width: 0,
              zIndex: this.opts.zIndex,
              left: this.opts.left,
              top: this.opts.top,
              transform: "scale(" + this.opts.scale + ")",
          });
          if (target) {
              target.insertBefore(this.el, target.firstChild || null);
          }
          drawLines(this.el, this.opts);
          return this;
      };
      /**
       * Stops and removes the Spinner.
       * Stopped spinners may be reused by calling spin() again.
       */
      Spinner.prototype.stop = function () {
          if (this.el) {
              if (typeof requestAnimationFrame !== 'undefined') {
                  cancelAnimationFrame(this.animateId);
              }
              else {
                  clearTimeout(this.animateId);
              }
              if (this.el.parentNode) {
                  this.el.parentNode.removeChild(this.el);
              }
              this.el = undefined;
          }
          return this;
      };
      return Spinner;
  }());
  /**
   * Sets multiple style properties at once.
   */
  function css(el, props) {
      for (var prop in props) {
          el.style[prop] = props[prop];
      }
      return el;
  }
  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
      return typeof color == 'string' ? color : color[idx % color.length];
  }
  /**
   * Internal method that draws the individual lines.
   */
  function drawLines(el, opts) {
      var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
      var shadow = 'none';
      if (opts.shadow === true) {
          shadow = '0 2px 4px #000'; // default shadow
      }
      else if (typeof opts.shadow === 'string') {
          shadow = opts.shadow;
      }
      var shadows = parseBoxShadow(shadow);
      for (var i = 0; i < opts.lines; i++) {
          var degrees = ~~(360 / opts.lines * i + opts.rotate);
          var backgroundLine = css(document.createElement('div'), {
              position: 'absolute',
              top: -opts.width / 2 + "px",
              width: (opts.length + opts.width) + 'px',
              height: opts.width + 'px',
              background: getColor(opts.fadeColor, i),
              borderRadius: borderRadius,
              transformOrigin: 'left',
              transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
          });
          var delay = i * opts.direction / opts.lines / opts.speed;
          delay -= 1 / opts.speed; // so initial animation state will include trail
          var line = css(document.createElement('div'), {
              width: '100%',
              height: '100%',
              background: getColor(opts.color, i),
              borderRadius: borderRadius,
              boxShadow: normalizeShadow(shadows, degrees),
              animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
          });
          backgroundLine.appendChild(line);
          el.appendChild(backgroundLine);
      }
  }
  function parseBoxShadow(boxShadow) {
      var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
      var shadows = [];
      for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
          var shadow = _a[_i];
          var matches = shadow.match(regex);
          if (matches === null) {
              continue; // invalid syntax
          }
          var x = +matches[2];
          var y = +matches[5];
          var xUnits = matches[4];
          var yUnits = matches[7];
          if (x === 0 && !xUnits) {
              xUnits = yUnits;
          }
          if (y === 0 && !yUnits) {
              yUnits = xUnits;
          }
          if (xUnits !== yUnits) {
              continue; // units must match to use as coordinates
          }
          shadows.push({
              prefix: matches[1] || '',
              x: x,
              y: y,
              xUnits: xUnits,
              yUnits: yUnits,
              end: matches[8],
          });
      }
      return shadows;
  }
  /**
   * Modify box-shadow x/y offsets to counteract rotation
   */
  function normalizeShadow(shadows, degrees) {
      var normalized = [];
      for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
          var shadow = shadows_1[_i];
          var xy = convertOffset(shadow.x, shadow.y, degrees);
          normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
      }
      return normalized.join(', ');
  }
  function convertOffset(x, y, degrees) {
      var radians = degrees * Math.PI / 180;
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      return [
          Math.round((x * cos + y * sin) * 1000) / 1000,
          Math.round((-x * sin + y * cos) * 1000) / 1000,
      ];
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  //----------------------------------------------------------------------------
  // Timer
  var Timer = /*#__PURE__*/function () {
    function Timer() {
      classCallCheck(this, Timer);

      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }

    createClass(Timer, [{
      key: "start",
      value: function start() {
        this.startTime = Timer.now();
        this.oldTime = this.startTime;
        this.running = true;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.getElapsedTime();
        this.running = false;
      }
    }, {
      key: "getElapsedTime",
      value: function getElapsedTime() {
        this.update();
        return this.elapsedTime;
      }
    }, {
      key: "update",
      value: function update() {
        var delta = 0;

        if (this.running) {
          var newTime = Timer.now();
          delta = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += delta;
        }

        return delta;
      }
    }]);

    return Timer;
  }();

  Timer.now = function () {
    var p = typeof window !== 'undefined' && window.performance;
    return p && p.now ? p.now.bind(p) : Date.now;
  }();

  var now = Timer.now;

  function createElement(tag, id, css) {
    var element = document.createElement(tag);
    element.id = id;
    element.style.cssText = css;
    return element;
  }

  var Stats = /*#__PURE__*/function () {
    function Stats() {
      classCallCheck(this, Stats);

      this.domElement = createElement('div', 'stats', 'padding:8px');
      this._text = createElement('p', 'fps', 'margin:0;color:silver;font-size:large');
      this.domElement.appendChild(this._text);
      this._startTime = now();
      this._prevTime = this._startTime;
      this._deltas = new Array(20);
      this._index = 0;
      this._total = 0.0;
      this._count = 0;
    }

    createClass(Stats, [{
      key: "end",
      value: function end() {
        var time = now();
        var delta = time - this._startTime;

        if (this._count < this._deltas.length) {
          this._count++;
        } else {
          this._total -= this._deltas[this._index];
        }

        this._total += delta;
        this._deltas[this._index] = delta;
        this._index = (this._index + 1) % this._deltas.length;
        this.ms = this._total / this._count;
        this.fps = 1000 / this.ms;

        if (time > this._prevTime + 1000) {
          this._text.textContent = this.fps.toPrecision(2);
          this._prevTime = time;
        }

        return time;
      }
    }, {
      key: "update",
      value: function update() {
        this._startTime = this.end();
      }
    }, {
      key: "show",
      value: function show(on) {
        if (on === undefined) {
          on = true;
        }

        this.domElement.style.display = on ? 'block' : 'none';
      }
    }]);

    return Stats;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  });

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  var isNativeFunction = _isNativeFunction;

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  var isNativeReflectConstruct = _isNativeReflectConstruct;

  var construct = createCommonjsModule(function (module) {
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      module.exports = _construct = Reflect.construct;
    } else {
      module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  module.exports = _construct;
  });

  var wrapNativeSuper = createCommonjsModule(function (module) {
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  module.exports = _wrapNativeSuper;
  });

  /**
   * This class introduces the simplest event system.
   */

  function isUndefOrEqual(param, value) {
    return !param || param === value;
  }
  /**
   * Creates empty dispatcher.
   *
   * @exports EventDispatcher
   * @constructor
   */


  function EventDispatcher() {
    this._handlers = {};
  }
  /**
   * Binds callback on specific event type. Optional `context` parameter
   * could be used as 'this' for the `callback`.
   * @param {string}   type       Event name.
   * @param {function} callback   Callback function.
   * @param {Object}   [context] 'This' object for the callback.
   */


  EventDispatcher.prototype.addEventListener = function (type, callback, context) {
    var handlers = this._handlers[type];

    if (!handlers) {
      this._handlers[type] = [];
      handlers = this._handlers[type];
    }

    var params = [callback, context];

    function _checkPar(par) {
      return par[0] === params[0] && par[1] === params[1];
    }

    if (___default['default'].find(handlers, _checkPar) === undefined) {
      handlers.push(params);
    }
  };
  /**
   * Removes a previously-bound callback function from an object.
   * If no `context` is specified, all versions of the `callback` with different
   * contexts will be removed.
   * If no `callback` is specified, all callbacks of the `type` will be removed.
   * If no `type` is specified, callbacks for all events will be removed.
   * @param {?string}  [type]      Event type.
   * @param {function} [callback]  Callback function.
   * @param {Object}   [context]  'This' object for the callback.
   */


  EventDispatcher.prototype.removeEventListener = function (type, callback, context) {
    var self = this;

    ___default['default'].forEach(self._handlers, function (handler, ev) {
      ___default['default'].remove(handler, function (values) {
        return isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self);
      });
    });

    this._handlers = ___default['default'].omitBy(self._handlers, function (handler) {
      return handler.length === 0;
    });
  };
  /**
   * Makes all the callbacks for the specific `event` to trigger.
   * @param {Object} event      Event.
   * @param {string} event.type Type of the event.
   */


  EventDispatcher.prototype.dispatchEvent = function (event) {
    var self = this;

    ___default['default'].forEach(this._handlers[event.type], function (callback) {
      var context = callback[1] || self;
      callback[0].apply(context, [event]);
    });
  };

  /**
   * This module contains class for logging.
   * Returns an instance of a logger that have already been created.
   * Allows users to log messages for five different levels,
   * enable console output and catch signal on each message.
   */
  var priorities = {
    debug: 0,
    info: 1,
    report: 2,
    warn: 3,
    error: 4
  };
  /**
   * Create new Logger.
   *
   * @exports Logger
   * @extends EventDispatcher
   * @constructor
   */

  function Logger() {
    EventDispatcher.call(this);
    /** Boolean flag that toggles output to browser console.
     * @type {boolean}
     */

    this.console = false;
    this._priority = priorities.warn;
  }

  Logger.prototype = Object.create(EventDispatcher.prototype);
  Logger.prototype.constructor = Logger;
  /**
   * Create new clean instance of the logger.
   * @returns {Logger}
   */

  Logger.prototype.instantiate = function () {
    return new Logger();
  };

  function verify(number) {
    if (!___default['default'].isNumber(number)) {
      throw new Error('Wrong log level specified!');
    }

    return number;
  }
  /**
   * @property {string} current threshold for signals and console output.
   * @name Logger#level
   */


  Object.defineProperty(Logger.prototype, 'level', {
    get: function get() {
      var _this = this;

      return ___default['default'].findKey(priorities, function (value) {
        return value === _this._priority;
      });
    },
    set: function set(level) {
      this._priority = verify(priorities[level]);
    }
  });
  /**
   * Returns the list of all possible level values.
   * @returns {Array}
   */

  Logger.prototype.levels = function () {
    return Object.keys(priorities);
  };
  /**
   * Add new message with specified level.
   * @param {string} level - level of the message, must be one of the
   * {'debug' | 'info' | 'report' | 'warn' | 'error'}
   * @param {string} message
   */


  Logger.prototype.message = function (level, message) {
    var priority = verify(priorities[level]);

    this._message(priority, message);
  };
  /**
   * Shortcut for message('debug', ...);
   * @param message
   */


  Logger.prototype.debug = function (message) {
    this._message(priorities.debug, message);
  };
  /**
   * Shortcut for message('info', ...);
   * @param message
   */


  Logger.prototype.info = function (message) {
    this._message(priorities.info, message);
  };
  /**
   * Shortcut for message('report', ...);
   * @param message
   */


  Logger.prototype.report = function (message) {
    this._message(priorities.report, message);
  };
  /**
   * Shortcut for message('warn', ...);
   * @param message
   */


  Logger.prototype.warn = function (message) {
    this._message(priorities.warn, message);
  };
  /**
   * Shortcut for message('error', ...);
   * @param message
   */


  Logger.prototype.error = function (message) {
    this._message(priorities.error, message);
  };
  /**
   * Add new message with specified priority.
   * @param {number} priority - priority of the message
   * @param {string} message
   * @private
   */


  Logger.prototype._message = function (priority, message) {
    if (priority < this._priority) {
      return;
    }

    var level = ___default['default'].findKey(priorities, function (value) {
      return value === priority;
    });

    message = String(message);

    if (this.console) {
      var output = "miew:".concat(level, ": ").concat(message);

      if (level === 'error') {
        console.error(output); // NOSONAR
      } else if (level === 'warn') {
        console.warn(output); // NOSONAR
      } else {
        console.log(output); // NOSONAR
      }
    }

    this.dispatchEvent({
      type: 'message',
      level: level,
      message: message
    });
  };

  var logger = new Logger();

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var browserType = {
    DEFAULT: 0,
    SAFARI: 1
  }; //----------------------------------------------------------------------------
  // Query string

  /**
   * Escape only dangerous chars in a query string component, use a plus instead of a space.
   *
   * [RFC 3986](https://tools.ietf.org/html/rfc3986) allows the following chars in the query (see 3.4):
   *
   *       A-Z a-z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ / ?
   *
   * For query string elements we need to escape ampersand, equal sign, and plus,
   * but encodeURIComponent() function encodes anything except for the following:
   *
   *       A-Z a-z 0-9 - _ . ~ ! ' ( ) *
   *
   * @param {string} text - key or value to encode
   * @param {string} excludeExp - regexp for symbols to exclude from encoding
   * @returns {string} encoded string
   */

  function encodeQueryComponent(text, excludeExp) {
    var encode = function encode(code) {
      return String.fromCharCode(parseInt(code.substr(1), 16));
    };

    return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, '+');
  }
  /**
   * Unescape dangerous chars in a query string component.
   *
   * @param {string} text - encoded key or value
   * @returns {string} decoded string
   * @see {@link encodeQueryComponent}
   */


  function decodeQueryComponent(text) {
    return decodeURIComponent(text.replace(/\+/g, ' '));
  }
  /**
   * Parse URL and extract an array of parameters.
   * @param {string?} url - URL or query string to parse
   * @returns {Array} array of (key, value) pairs.
   */


  function getUrlParameters(url) {
    url = url || window.location.search;
    var query = url.substring(url.indexOf('?') + 1);
    var search = /([^&=]+)=?([^&]*)/g;
    var result = [];
    var match;

    while ((match = search.exec(query)) !== null) {
      // eslint-disable-line no-cond-assign
      result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
    }

    return result;
  }
  /**
   * Parse URL and extract an array of parameters as a hash.
   * @param {string?} url - URL or query string to parse
   * @returns {Object}
   */


  function getUrlParametersAsDict(url) {
    var result = {};
    var a = getUrlParameters(url);

    for (var i = 0; i < a.length; ++i) {
      var _a$i = slicedToArray(a[i], 2),
          key = _a$i[0],
          value = _a$i[1];

      result[key] = value;
    }

    return result;
  }

  function resolveURL(str) {
    if (typeof URL !== 'undefined') {
      try {
        if (typeof window !== 'undefined') {
          return new URL(str, window.location).href;
        }

        return new URL(str).href;
      } catch (error) {// IE 11 has a URL object with no constructor available so just try a different approach instead
      }
    }

    if (typeof document !== 'undefined') {
      var anchor = document.createElement('a');
      anchor.href = str;
      return anchor.href;
    }

    return str;
  }
  /**
   * Generates regular expression object that includes all symbols
   * listed in the argument
   * @param symbolStr {string} - String containing characters list.
   * @returns {RegExp} - Regular expression.
   */


  function generateRegExp(symbolStr) {
    var symbolList = [];

    for (var i = 0, n = symbolStr.length; i < n; ++i) {
      symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16);
    }

    var listStr = symbolList.join('|');
    return new RegExp("%(?:".concat(listStr, ")"), 'gi');
  } //----------------------------------------------------------------------------
  // Create HTML element


  function createElement$1(tag, attrs, content) {
    var element = document.createElement(tag);
    var i;
    var n;

    if (attrs) {
      var keys = Object.keys(attrs);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        element.setAttribute(key, attrs[key]);
      }
    }

    if (content) {
      if (!(content instanceof Array)) {
        content = [content];
      }

      for (i = 0, n = content.length; i < n; ++i) {
        var child = content[i];

        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        } else if (child instanceof HTMLElement) {
          element.appendChild(child);
        }
      }
    }

    return element;
  } //----------------------------------------------------------------------------
  // Easy inheritance

  /**
   * Derive the class from the base.
   * @param cls {function} - Class (constructor) to derive.
   * @param base {function} - Class (constructor) to derive from.
   * @param members {object=} - Optional instance members to add.
   * @param statics {object=} - Optional static class members to add.
   * @returns {function} Original class.
   */


  function deriveClass(cls, base, members, statics) {
    cls.prototype = ___default['default'].assign(Object.create(base.prototype), {
      constructor: cls
    }, members);

    if (statics) {
      ___default['default'].assign(cls, statics);
    }

    return cls;
  } //----------------------------------------------------------------------------
  // Deep prototyping


  function deriveDeep(obj, needZeroOwnProperties) {
    var res = obj;
    var i;
    var n;

    if (obj instanceof Array) {
      res = new Array(obj.length);

      for (i = 0, n = obj.length; i < n; ++i) {
        res[i] = deriveDeep(obj[i]);
      }
    } else if (obj instanceof Object) {
      res = Object.create(obj);
      var keys = Object.keys(obj);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        var value = obj[key];
        var copy = deriveDeep(value);

        if (copy !== value) {
          res[key] = copy;
        }
      }

      if (needZeroOwnProperties && Object.keys(res).length > 0) {
        res = Object.create(res);
      }
    }

    return res;
  } //----------------------------------------------------------------------------
  // Colors


  function hexColor(color) {
    var hex = "0000000".concat(color.toString(16)).substr(-6);
    return "#".concat(hex);
  } //----------------------------------------------------------------------------
  // Debug tracing


  function DebugTracer(namespace) {
    var enabled = false;

    this.enable = function (on) {
      enabled = on;
    };

    var indent = 0;
    var methods = Object.keys(namespace);

    function wrap(method_, name_) {
      return function () {
        var spaces = DebugTracer.spaces.substr(0, indent * 2);

        if (enabled) {
          logger.debug("".concat(spaces + name_, " {"));
        }

        indent++;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = method_.apply(this, args); // eslint-disable-line no-invalid-this

        indent--;

        if (enabled) {
          logger.debug("".concat(spaces, "} // ").concat(name_));
        }

        return result;
      };
    }

    for (var i = 0, n = methods.length; i < n; ++i) {
      var name = methods[i];
      var method = namespace[name];

      if (method instanceof Function && name !== 'constructor') {
        namespace[name] = wrap(method, name);
      }
    }
  }

  DebugTracer.spaces = '                                                                                          ';

  var OutOfMemoryError = /*#__PURE__*/function (_Error) {
    inherits(OutOfMemoryError, _Error);

    var _super = _createSuper(OutOfMemoryError);

    function OutOfMemoryError(message) {
      var _this;

      classCallCheck(this, OutOfMemoryError);

      _this = _super.call(this);
      _this.name = 'OutOfMemoryError';
      _this.message = message;
      return _this;
    }

    return OutOfMemoryError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function allocateTyped(TypedArrayName, size) {
    var result = null;

    try {
      result = new TypedArrayName(size);
    } catch (e) {
      if (e instanceof RangeError) {
        throw new OutOfMemoryError(e.message);
      } else {
        throw e;
      }
    }

    return result;
  } //----------------------------------------------------------------------------
  // Float array conversion


  function bytesToBase64(
  /** ArrayBuffer */
  buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';

    for (var i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }

    return window.btoa(binary);
  }

  function bytesFromBase64(
  /** string */
  str) {
    var binary = window.atob(str);
    var bytes = new Uint8Array(binary.length);

    for (var i = 0; i < bytes.length; ++i) {
      bytes[i] = binary[i].charCodeAt(0);
    }

    return bytes.buffer;
  }

  function arrayToBase64(
  /** number[] */
  array,
  /** function */
  TypedArrayClass) {
    return bytesToBase64(new TypedArrayClass(array).buffer);
  }

  function arrayFromBase64(
  /** string */
  str,
  /** function */
  TypedArrayClass) {
    return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
  } // NOTE: this is 1-level comparison


  function compareOptionsWithDefaults(opts, defOpts) {
    var optsStr = [];

    if (defOpts && opts) {
      var keys = Object.keys(opts);

      for (var p = 0; p < keys.length; ++p) {
        var key = keys[p];
        var value = opts[key]; // TODO add processing for tree structure

        if (!(value instanceof Object) && typeof defOpts[key] !== 'undefined' && defOpts[key] !== value) {
          optsStr.push("".concat(key, ":").concat(value));
        }
      }

      if (optsStr.length > 0) {
        return "!".concat(optsStr.join());
      }
    }

    return '';
  }

  function isAlmostPlainObject(o) {
    if (___default['default'].isPlainObject(o)) {
      return true;
    }

    var proto = o && Object.getPrototypeOf(o);
    return !!proto && !proto.hasOwnProperty('constructor') && isAlmostPlainObject(proto);
  }
  /**
   * Build an object that contains properties (and subproperties) of `src` different from those
   * in `dst`. Objects are parsed recursively, other values (including arrays) are compared for
   * equality using `_.isEqual()`.
   * @param {!object} src - a new object to compare, may contain changed or new properties
   * @param {!object} dst - an old reference object
   */


  function objectsDiff(src, dst) {
    var diff = {};

    ___default['default'].forIn(src, function (srcValue, key) {
      var dstValue = dst[key];

      if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
        var deepDiff = objectsDiff(srcValue, dstValue);

        if (!___default['default'].isEmpty(deepDiff)) {
          diff[key] = deepDiff;
        }
      } else if (!___default['default'].isEqual(srcValue, dstValue)) {
        diff[key] = srcValue;
      }
    });

    return diff;
  }

  function forInRecursive(object, callback) {
    function iterateThrough(obj, prefix) {
      ___default['default'].forIn(obj, function (value, key) {
        var newPref = prefix + (prefix.length > 0 ? '.' : '');

        if (value instanceof Object) {
          iterateThrough(value, newPref + key);
        } else if (value !== undefined) {
          callback(value, newPref + key);
        }
      });
    }

    iterateThrough(object, '');
  }

  function enquoteString(value) {
    if (___default['default'].isString(value)) {
      return "\"".concat(value.replace(/"/g, '\\"'), "\"");
    }

    return value;
  }

  function unquoteString(value) {
    if (!___default['default'].isString(value)) {
      return value;
    }

    if (value[0] === '"' && value[value.length - 1] === '"') {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\"/g, '"');
    }

    if (value[0] === "'" && value[value.length - 1] === "'") {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\'/g, "'");
    }

    throw new SyntaxError('Incorrect string format, can\'t unqute it');
  }

  function getFileExtension(fileName) {
    return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity);
  }

  function splitFileName(fileName) {
    var ext = getFileExtension(fileName);
    var name = fileName.slice(0, fileName.length - ext.length);
    return [name, ext];
  }

  function dataUrlToBlob(url) {
    var parts = url.split(/[:;,]/);
    var partsCount = parts.length;

    if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
      return new Blob([bytesFromBase64(parts[partsCount - 1])]);
    }

    return null;
  }

  function getBrowser() {
    if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') === -1 && navigator.userAgent.indexOf('FxiOS') === -1) {
      return browserType.SAFARI;
    }

    return browserType.DEFAULT;
  }

  function shotOpen(url) {
    if (typeof window !== 'undefined') {
      window.open().document.write("<body style=\"margin:0\"><img src=\"".concat(url, "\" /></body>"));
    }
  }

  function shotDownload(dataUrl, filename) {
    if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
      return;
    }

    if (!filename) {
      filename = ['screenshot-', +new Date(), '.png'].join('');
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function download(data, filename, type) {
    var blobData = new Blob([data]);

    if (!filename) {
      filename = ['data', +new Date()].join('');
    }

    if (!type) {
      filename += blobData.type || '.bin';
    } else {
      filename += ".".concat(type);
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(blobData, filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(blobData);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function copySubArrays(src, dst, indices, itemSize) {
    for (var i = 0, n = indices.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        dst[i * itemSize + j] = src[indices[i] * itemSize + j];
      }
    }
  }

  function shallowCloneNode(node) {
    var newNode = node.cloneNode(true);
    newNode.worldPos = node.worldPos; // .style property is readonly, so "newNode.style = node.style;" won't work (and we don't need it, right?)

    return newNode;
  }

  var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
  var enquoteHelper = ['"', '', '"']; // verify and correct if needed selctor identifier

  function correctSelectorIdentifier(value) {
    if (unquotedStringRE.test(value)) {
      return value;
    } // quote incorrect identifier


    enquoteHelper[1] = value;
    return enquoteHelper.join('');
  }
  /**
   * Concatenates two TypedArray. Doesn't check null refs o type equality
   * Attention! It must be use very rarely because requires memory reallocation every time. Use MergeTypedArraysUnsafe to
   * unite array of subarrays.
   * @param{TypedArray} first  - destination array
   * @param{TypedArray} second - source array
   * @returns{TypedArray} resulting concatenated array
   */


  function concatTypedArraysUnsafe(first, second) {
    var result = new first.constructor(first.length + second.length);
    result.set(first);
    result.set(second, first.length);
    return result;
  }
  /**
   * Merges array of TypedArray into TypedArray. Doesn't check null refs o type equality
   * @param{array} array  - source array of subarrays
   * @returns{TypedArray} resulting merged array
   */


  function mergeTypedArraysUnsafe(array) {
    if (array.length <= 0) {
      return null;
    } // count the size


    var size = array.reduce(function (acc, cur) {
      return acc + cur.length;
    }, 0); // create combined array

    var result = new array[0].constructor(size);

    for (var i = 0, start = 0; i < array.length; i++) {
      var count = array[i].length;
      result.set(array[i], start);
      start += count;
    }

    return result;
  } //----------------------------------------------------------------------------
  // Exports


  var utils = {
    browserType: browserType,
    encodeQueryComponent: encodeQueryComponent,
    decodeQueryComponent: decodeQueryComponent,
    getUrlParameters: getUrlParameters,
    getUrlParametersAsDict: getUrlParametersAsDict,
    resolveURL: resolveURL,
    generateRegExp: generateRegExp,
    createElement: createElement$1,
    deriveClass: deriveClass,
    deriveDeep: deriveDeep,
    hexColor: hexColor,
    DebugTracer: DebugTracer,
    OutOfMemoryError: OutOfMemoryError,
    allocateTyped: allocateTyped,
    bytesFromBase64: bytesFromBase64,
    bytesToBase64: bytesToBase64,
    arrayFromBase64: arrayFromBase64,
    arrayToBase64: arrayToBase64,
    compareOptionsWithDefaults: compareOptionsWithDefaults,
    objectsDiff: objectsDiff,
    forInRecursive: forInRecursive,
    enquoteString: enquoteString,
    unquoteString: unquoteString,
    getBrowser: getBrowser,
    shotOpen: shotOpen,
    shotDownload: shotDownload,
    copySubArrays: copySubArrays,
    shallowCloneNode: shallowCloneNode,
    correctSelectorIdentifier: correctSelectorIdentifier,
    getFileExtension: getFileExtension,
    splitFileName: splitFileName,
    download: download,
    concatTypedArraysUnsafe: concatTypedArraysUnsafe,
    mergeTypedArraysUnsafe: mergeTypedArraysUnsafe
  };

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var JobHandle = /*#__PURE__*/function (_EventDispatcher) {
    inherits(JobHandle, _EventDispatcher);

    var _super = _createSuper$1(JobHandle);

    function JobHandle() {
      var _this;

      classCallCheck(this, JobHandle);

      _this = _super.call(this);
      _this._shouldCancel = false;
      return _this;
    }

    createClass(JobHandle, [{
      key: "cancel",
      value: function cancel() {
        this._shouldCancel = true;
        this.dispatchEvent({
          type: 'cancel'
        });
      }
    }, {
      key: "shouldCancel",
      value: function shouldCancel() {
        return this._shouldCancel;
      } // slaves use this to notify master about their events
      // master routes these notifications to a single event slot

    }, {
      key: "notify",
      value: function notify(event) {
        this.dispatchEvent({
          type: 'notification',
          slaveEvent: event
        });
      }
    }]);

    return JobHandle;
  }(EventDispatcher);

  var VERSION = 0; //----------------------------------------------------------------------------
  // DEFAULT SETTINGS
  //----------------------------------------------------------------------------

  /**
   * Polygonal complexity settings.
   *
   * @typedef PolyComplexity
   * @property {number} poor
   * @property {number} low
   * @property {number} medium
   * @property {number} high
   * @property {number} ultra
   */

  /**
   * @alias SettingsObject
   * @namespace
   */

  var defaults$1 = {
    /**
     * Default options for all available modes.
     * Use {@link Mode.id} as a dictionary key to access mode options.
     *
     * Usually you don't need to override these settings. You may specify mode options as a parameter during
     * {@link Mode} construction.
     *
     * @memberof SettingsObject#
     * @type {Object.<string, object>}
     *
     * @property {LinesModeOptions} LN - Lines mode options.
     * @property {LicoriceModeOptions} LC - Licorice mode options.
     * @property {BallsAndSticksModeOptions} BS - Balls and Sticks mode options.
     * @property {VanDerWaalsModeOptions} VW - Van der Waals mode options.
     * @property {TraceModeOptions} TR - Trace mode options.
     * @property {TubeModeOptions} TU - Tube mode options.
     * @property {CartoonModeOptions} CA - Cartoon mode options.
     * @property {QuickSurfaceModeOptions} QS - Contact Surface mode options.
     * @property {IsoSurfaceSASModeOptions} SA - Solvent Accessible Surface mode options.
     * @property {IsoSurfaceSESModeOptions} SE - Solvent Excluded Surface mode options.
     * @property {ContactSurfaceModeOptions} CS - Contact Surface mode options.
     * @property {TextModeOptions} TX - Text mode options.
     * @property {VolumeDensityModeOptions} VD - Volume Density mode options.
     */
    modes: {
      //----------------------------------------------------------------------------
      // BALLS AND STICKS
      //----------------------------------------------------------------------------

      /**
       * Balls and Sticks mode options.
       *
       * @typedef BallsAndSticksModeOptions
       *
       * @property {number} atom - Sphere radius as a fraction of Van der Waals atom radius.
       * @property {number} bond - Cylinder radius in angstroms.
       * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
       *   available space.
       * @property {boolean} multibond - Toggles rendering of multiple ordered bonds.
       * @property {number} aromrad - Minor radius of a torus for aromatic loops.
       * @property {boolean} showarom - Toggles rendering of aromatic loops.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      BS: {
        atom: 0.23,
        bond: 0.15,
        space: 0.5,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // VAN DER WAALS
      //----------------------------------------------------------------------------

      /**
       * Van der Waals mode options.
       *
       * @typedef VanDerWaalsModeOptions
       *
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      VW: {
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 8,
          high: 16,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // LINES
      //----------------------------------------------------------------------------

      /**
       * Lines mode options.
       *
       * @typedef LinesModeOptions
       *
       * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
       * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
       * @property {number} offsarom - Offset between bonds and aromatic cycle.
       * @property {number} chunkarom - Number of pieces in a-loop arc, corresponding to atom.
       * @property {number} atom - Collision radius for atoms picking.
       * @property {number} lineWidth - Line width in pixels (not used in thin lines).
       */
      LN: {
        multibond: true,
        showarom: true,
        offsarom: 0.2,
        chunkarom: 10,
        atom: 0.23,
        lineWidth: 2
      },
      //----------------------------------------------------------------------------
      // LICORICE
      //----------------------------------------------------------------------------

      /**
       * Licorice mode options.
       *
       * @typedef LicoriceModeOptions
       *
       * @property {number} bond - Bond cylinder radius.
       * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
       *   available space.
       * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
       * @property {number} aromrad - Minor radius of a torus for aromatic loops.
       * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
       * @property {PolyComplexity} polyComplexity - Poly complexity values for render modes.
       */
      LC: {
        bond: 0.20,
        space: 0.0,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      //----------------------------------------------------------------------------
      // SURFACE SAS
      //----------------------------------------------------------------------------

      /**
       * Solvent Accessible Surface mode options.
       *
       * @typedef IsoSurfaceSASModeOptions
       *
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {number} probeRadius - Radius of the probe.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      SA: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      //----------------------------------------------------------------------------
      // SURFACE SES
      //----------------------------------------------------------------------------

      /**
       * Solvent Excluded Surface mode options.
       *
       * @typedef IsoSurfaceSESModeOptions
       *
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {number} probeRadius - Radius of the probe.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      SE: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      //----------------------------------------------------------------------------
      // QUICK SURFACE
      //----------------------------------------------------------------------------

      /**
       * Quick Surface mode options.
       *
       * @typedef QuickSurfaceModeOptions
       *
       * @property {number} isoValue - Isovalue of the surface to extract.
       * @property {number} scale - Radius scale for the surface being built.
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} gaussLim - Gauss lim for coloring the bigger the value, the smoother our colors are.
       * @property {PolyComplexity} gridSpacing - Poly complexity values for render modes. In this case the value
       *   corresponds to the grid density.
       */
      QS: {
        isoValue: 0.5,
        gaussLim: {
          poor: 1.5,
          low: 2.0,
          medium: 2.5,
          high: 3.0,
          ultra: 4.0
        },
        scale: 1.0,
        wireframe: false,
        gridSpacing: {
          poor: 2,
          low: 1.5,
          medium: 1,
          high: 0.5,
          ultra: 0.25
        },
        subset: '',
        zClip: false
      },
      //----------------------------------------------------------------------------
      // CONTACT SURFACE
      //----------------------------------------------------------------------------

      /**
       * Contact Surface mode options.
       *
       * @typedef ContactSurfaceModeOptions
       *
       * @property {number} isoValue - Isovalue of the surface to extract.
       * @property {number} probeRadius - Probe radius.
       * @property {number} probePositions
       * @property {boolean} zClip - Flag, that toggles z-clipping.
       * @property {string} subset - Only parts of surface close to selected atoms will be visible.
       *   Empty string means whole surface is visible.
       * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
       * @property {PolyComplexity} polyComplexity - Radius scale for the surface being built.
       *   Poly complexity values for render modes. In this case the value corresponds to the grid density.
       */
      CS: {
        probeRadius: 1.4,
        isoValue: 1.5,
        wireframe: false,
        probePositions: 30,
        polyComplexity: {
          poor: 0.5,
          low: 1.0,
          medium: 1.5,
          high: 1.75,
          ultra: 2.0
        },
        subset: '',
        zClip: false
      },
      //----------------------------------------------------------------------------
      // TRACE
      //----------------------------------------------------------------------------

      /**
       * Trace mode options.
       *
       * @typedef TraceModeOptions
       *
       * @property {number} radius - Cylinder radius.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      TR: {
        radius: 0.30,
        polyComplexity: {
          poor: 12,
          low: 16,
          medium: 32,
          high: 64,
          ultra: 64
        }
      },
      //----------------------------------------------------------------------------
      // TUBE
      //----------------------------------------------------------------------------

      /**
       * Tube mode options.
       *
       * @typedef TubeModeOptions
       *
       * @property {number} radius - Cylinder radius.
       * @property {number} tension - Tension for interpolation.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
       */
      TU: {
        radius: 0.30,
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      //----------------------------------------------------------------------------
      // CARTOON
      //----------------------------------------------------------------------------

      /**
       * Cartoon mode options.
       *
       * @typedef CartoonModeOptions
       *
       * @property {number} radius - Standard tube radius.
       * @property {number} depth - Height of the secondary structure ribbon.
       * @property {number} tension - Tension for interpolation.
       * @proprety {object} ss - Secondary structure parameters.
       * @proprety {object} ss.helix - Options for helices render.
       * @proprety {number} ss.helix.width - Width of the secondary structure ribbon.
       * @proprety {number} ss.helix.arrow - Secondary structure's arrow width.
       * @proprety {object} ss.strand - Options for strands render.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       * polyComplexity must be even for producing symmetric arrows.
       * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
       */
      CA: {
        radius: 0.30,
        depth: 0.25,
        ss: {
          helix: {
            width: 1.0,
            arrow: 2.0
          },
          strand: {
            width: 1.0,
            arrow: 2.0
          }
        },
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      //----------------------------------------------------------------------------
      // TEXT
      //----------------------------------------------------------------------------

      /**
       * Text mode options.
       *
       * @typedef TextModeOptions
       *
       * @property {string} template - Format string for building output text.
       * @property {string} horizontalAlign - Text alignment ('left', 'right', 'center').
       * @property {string} verticalAlign - Vertical text box alignment ('top', 'bottom', 'middle').
       * @property {number} dx - Text offset x in angstroms.
       * @property {number} dy - Text offset y in angstroms.
       * @property {number} dz - Text offset z in angstroms.
       * @property {string} fg - Color rule for foreground.
       * @property {string} bg - Color rule for background.
       * @property {boolean} showBg - Flag, that toggles background rendering.
       *
       */
      TX: {
        template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
        horizontalAlign: 'center',
        verticalAlign: 'middle',
        dx: 0,
        dy: 0,
        dz: 1,
        fg: 'none',
        bg: '0x202020',
        showBg: true
      },
      //----------------------------------------------------------------------------
      // VOLUME DENSITY
      //----------------------------------------------------------------------------

      /**
       * Volume density mode options.
       *
       * @typedef VolumeDensityModeOptions
       *
       * @property {number} kSigma - Noise threshold coefficient.
       * @property {boolean} frame - flag, that turns on box frame painting.
       * @property {boolean} isoMode - flag, that turns on IsoSurface mode instead of Volume Rendering.
       * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
       */
      VD: {
        kSigma: 1.0,
        kSigmaMed: 2.0,
        kSigmaMax: 4.0,
        frame: true,
        isoMode: false,
        polyComplexity: {
          poor: 2,
          low: 3,
          medium: 4,
          high: 8,
          ultra: 10
        }
      }
    },

    /**
     * Default options for all available colorers.
     * Use {@link Colorer.id} as a dictionary key to access colorer options.
     *
     * Usually you don't need to override these settings. You may specify colorer options as a parameter during
     * {@link Colorer} construction.
     *
     * Not all colorers have options.
     *
     * @memberof SettingsObject#
     * @type {Object.<string, object>}
     *
     * @property {ElementColorerOptions} EL - Element colorer options.
     * @property {SequenceColorerOptions} SQ - Sequence colorer options.
     * @property {MoleculeColorerOptions} MO - Molecule colorer options.
     * @property {UniformColorerOptions} UN - Uniform colorer options.
     * @property {ConditionalColorerOptions} CO - Conditional colorer options.
     * @property {TemperatureColorerOptions} TM - Temperature colorer options.
     * @property {OccupancyColorerOptions} OC - Occupancy colorer options.
     * @property {HydrophobicityColorerOptions} HY - Hydrophobicity colorer options.
     */
    colorers: {
      /**
       * Element colorer options.
       *
       * @typedef ElementColorerOptions
       *
       * @property {number} carbon - Carbon color or -1 to use default.
       */
      EL: {
        carbon: -1
      },

      /**
       * Uniform colorer options.
       *
       * @typedef UniformColorerOptions
       *
       * @property {number} color - Single color to paint with.
       */
      UN: {
        color: 0xFFFFFF
      },

      /**
       * Conditional colorer options.
       *
       * @typedef ConditionalColorerOptions
       *
       * @property {string} subset - Selector string.
       * @property {number} color - Color of selected atoms.
       * @property {number} baseColor - Color of other atoms.
       */
      CO: {
        subset: 'charged',
        color: 0xFF0000,
        baseColor: 0xFFFFFF
      },

      /**
       * Carbon colorer options.
       *
       * @typedef CarbonColorerOptions
       *
       * @property {number} color - Single color to paint carbons
       * @property {number} factor - Color factor for not carbon atoms.
       */
      CB: {
        color: 0x909090,
        factor: 0.6
      },

      /**
       * Sequence colorer options.
       *
       * @typedef SequenceColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      SQ: {
        gradient: 'rainbow'
      },

      /**
       * Temperature colorer options.
       *
       * @typedef TemperatureColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       * @property {number} min - Minimal temperature.
       * @property {number} max - Maximal temperature.
       */
      TM: {
        gradient: 'temp',
        min: 5,
        max: 40
      },

      /**
       * Occupancy colorer options.
       *
       * @typedef OccupancyColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      OC: {
        gradient: 'reds'
      },

      /**
       * Hydrophobicity colorer options.
       *
       * @typedef HydrophobicityColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      HY: {
        gradient: 'blue-red'
      },

      /**
       * Molecule colorer options.
       *
       * @typedef MoleculeColorerOptions
       *
       * @property {string} gradient - Name of gradient to use.
       */
      MO: {
        gradient: 'rainbow'
      }
    },

    /*
     * Use antialiasing in WebGL.
     * @type {boolean}
     */
    antialias: true,

    /*
     * Camera field of view in degrees.
     * @type {number}
     */
    camFov: 45.0,

    /*
     * Camera near plane distance.
     * @type {number}
     */
    camNear: 0.5,

    /*
     * Camera far plane distance.
     * @type {number}
     */
    camFar: 100.0,
    camDistance: 2.5,
    radiusToFit: 1.0,

    /**
     * @type {number}
     * @instance
     */
    fogNearFactor: 0.5,
    // [0, 1]

    /**
     * @type {number}
     * @instance
     */
    fogFarFactor: 1,
    // [0, 1]
    fogAlpha: 1.0,
    fogColor: 0x000000,
    fogColorEnable: false,

    /**
     * Palette used for molecule coloring.
     * @type {string}
     */
    palette: 'JM',

    /*
     * Geometry resolution.
     * @type {string}
     */
    resolution: 'medium',
    autoResolution: false
    /* true */
    ,
    autoPreset: true,
    preset: 'default',
    // TODO: remove 'preset' from settings, implement autodetection
    presets: {
      // Default
      "default": [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      empty: [],
      // Wireframe
      wire: [{
        mode: 'LN',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      // Small molecules
      small: [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      // Proteins, nucleic acids etc.
      macro: [{
        mode: 'CA',
        colorer: 'SS',
        selector: 'not hetatm',
        material: 'SF'
      }, {
        mode: 'BS',
        colorer: 'EL',
        selector: 'hetatm and not water',
        material: 'SF'
      }]
    },
    objects: {
      line: {
        color: 0xFFFFFFFF,
        dashSize: 0.3,
        gapSize: 0.05
      }
    },
    //----------------------------------------------------------------------------
    bg: {
      color: 0x202020,
      transparent: false
    },
    draft: {
      clipPlane: false,
      clipPlaneFactor: 0.5,
      clipPlaneSpeed: 0.00003
    },

    /*
       * Separate group for plugins.
       * Each plugin handles its field by itself.
       */
    plugins: {},

    /**
     * @type {boolean}
     * @instance
     */
    axes: true,

    /**
     * @type {boolean}
     * @instance
     */
    fog: true,

    /**
     * @type {boolean}
     * @instance
     */
    fps: true,

    /**
     * Switch using of z-sprites for sphere and cylinder geometry
     * @type {boolean}
     * @instance
     */
    zSprites: true,
    isoSurfaceFakeOpacity: true,

    /**
     * @type {boolean}
     * @instance
     */
    suspendRender: true,
    nowater: false,

    /**
     * @type {boolean}
     * @instance
     */
    autobuild: true,

    /**
     * Anti-aliasing.
     * @type {boolean}
     * @instance
     */
    fxaa: true,

    /**
     * Outline depths
     * @type {boolean}
     * @instance
     */
    outline: {
      on: false,
      color: 0x000000,
      threshold: 0.1,
      thickness: 1
    },

    /**
     * Ambient Occlusion special effect.
     * @type {boolean}
     * @instance
     */
    ao: false,

    /**
     * Shadows options.
     *
     * @property {boolean} shadowMap - enable/disable.
     * @property {string} basic/percentage-closer filtering/non-uniform randomizing pcf.
     * @property {number} radius for percentage-closer filtering.
     */
    shadow: {
      on: false,
      type: 'random'
      /* basic, pcf, random */
      ,
      radius: 1.0
    },

    /**
     * Auto-rotation with constant speed.
     * @type {number}
     * @instance
     */
    autoRotation: 0.0,

    /**
     * Set maximum fps for animation.
     * @type {number}
     * @instance
     */
    maxfps: 30,

    /**
     * Set fbx output precision.
     * @type {number}
     * @instance
     */
    fbxprec: 4,

    /**
     * Auto-rotation axis.
     *
     * - true:  complex auto-rotation is about vertical axis
     * - false: rotation axis is defined by last user rotation
     *
     * @type {boolean}
     * @instance
     */
    autoRotationAxisFixed: true,

    /**
     * Enable zooming with mouse wheel or pinch gesture.
     * @type {boolean}
     * @instance
     */
    zooming: true,

    /**
     * Enable picking atoms & residues with left mouse button or touch.
     * @type {boolean}
     * @instance
     */
    picking: true,

    /**
     * Set picking mode ('atom', 'residue', 'chain', 'molecule').
     * @type {string}
     * @instance
     */
    pick: 'atom',

    /**
     * Make "component" and "fragment" editing modes available.
     * @type {boolean}
     * @instance
     */
    editing: false,

    /**
     * Detect aromatic loops.
     * @type {boolean}
     * @instance
     */
    aromatic: false,

    /**
     * Load only one biological unit from all those described in PDB file.
     * @type {boolean}
     * @instance
     */
    singleUnit: true,

    /**
     * Set stereo mode ('NONE', 'SIMPLE', 'DISTORTED', 'ANAGLYPH', 'WEBVR').
     * @type {string}
     * @instance
     */
    stereo: 'NONE',

    /**
     * Enable smooth transition between views
     * @type {boolean}
     * @instance
     */
    interpolateViews: true,

    /**
     * Set transparency mode ('standard', 'prepass').
     * @type {string}
     * @instance
     */
    transparency: 'prepass',

    /**
     * Mouse translation speed.
     * @type {number}
     * @instance
     */
    translationSpeed: 2,
    debug: {
      example: 3.5,
      text: 'hello!',
      good: true,
      ssaoKernelRadius: 0.7,
      ssaoFactor: 0.7,
      stereoBarrel: 0.25
    },
    use: {
      multiFile: false
    }
  }; //----------------------------------------------------------------------------
  // SETTINGS CLASS
  //----------------------------------------------------------------------------

  function Settings() {
    EventDispatcher.call(this);
    this.old = null;
    this.now = {};
    this._changed = {};
    this.reset();
  }

  utils.deriveClass(Settings, EventDispatcher, {
    defaults: defaults$1,
    set: function set(path, value) {
      if (___default['default'].isString(path)) {
        var oldValue = ___default['default'].get(this.now, path);

        if (oldValue !== value) {
          ___default['default'].set(this.now, path, value);

          this._notifyChange(path, value);
        }
      } else {
        var diff = utils.objectsDiff(path, this.now);

        if (!___default['default'].isEmpty(diff)) {
          ___default['default'].merge(this.now, diff);

          this._notifyChanges(diff);
        }
      }
    },
    get: function get(path, defaultValue) {
      return ___default['default'].get(this.now, path, defaultValue);
    },
    reset: function reset() {
      var diff = utils.objectsDiff(defaults$1, this.now);
      this.now = ___default['default'].cloneDeep(defaults$1);
      this.old = null;

      this._notifyChanges(diff);

      this._changed = {};
    },
    checkpoint: function checkpoint() {
      this.old = ___default['default'].cloneDeep(this.now);
      this._changed = {};
    },
    _notifyChange: function _notifyChange(path, value) {
      this._changed[path] = true;
      this.dispatchEvent({
        type: "change:".concat(path),
        value: value
      });
    },
    _notifyChanges: function _notifyChanges(diff) {
      var _this = this;

      utils.forInRecursive(diff, function (deepValue, deepPath) {
        _this._notifyChange(deepPath, deepValue);
      });
    },
    changed: function changed() {
      if (!this.old) {
        return [];
      }

      var old = this.old,
          now = this.now;

      var keys = ___default['default'].filter(Object.keys(this._changed), function (key) {
        return ___default['default'].get(old, key) !== ___default['default'].get(now, key);
      });

      return keys;
    },
    applyDiffs: function applyDiffs(diffs) {
      if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
        throw new Error('Settings version does not match!');
      } // VERSION shouldn't be presented inside settings structure


      delete diffs.VERSION;
      this.reset();
      this.set(diffs);
    },
    getDiffs: function getDiffs(versioned) {
      var diffs = utils.objectsDiff(this.now, defaults$1);

      if (versioned) {
        diffs.VERSION = VERSION;
      }

      return diffs;
    },
    setPluginOpts: function setPluginOpts(plugin, opts) {
      defaults$1.plugins[plugin] = ___default['default'].cloneDeep(opts);
      this.now.plugins[plugin] = ___default['default'].cloneDeep(opts);
    }
  });
  var settings = new Settings();

  var repIndex = 0;

  function asBoolean(value) {
    return !(!value || value === '0' || ___default['default'].isString(value) && value.toLowerCase() === 'false');
  }

  var adapters = {
    string: String,
    number: Number,
    "boolean": asBoolean
  }; // Level 1 assignment symbol

  var cL1Ass = '=';
  var cOptsSep = '!'; // Level 2 (options) assignment symbol

  var cL2Ass = ':'; // Level 2 (options) separator symbol

  var cLSep = ',';
  var cCommonIgnoreSymbols = '$;@/?';
  /**
   * We may (and should) leave as is for better readability:
   *
   *        $ , ; : @ / ?
   */

  /**
   * Generate regular expression for symbols excluded for first level encryption
   */

  function getLevel1ExcludedExpr() {
    var cLevel1Ignores = ':,';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
  }
  /**
   * Generate regular expression for symbols excluded for first level encryption
   * (options, etc, ..)
   */


  function getLevel2ExcludedExpr() {
    var cLevel2Ignores = ' ';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
  }

  var cL1ExclExpr = getLevel1ExcludedExpr();

  function encodeQueryComponentL1(value) {
    return utils.encodeQueryComponent(value, cL1ExclExpr);
  }

  var cL2ExclExpr = getLevel2ExcludedExpr();

  function encodeQueryComponentL2(value) {
    return utils.encodeQueryComponent(value, cL2ExclExpr);
  }

  function ensureRepList(opts) {
    var reps = opts.reps;

    if (!reps) {
      var presets = settings.now.presets;
      var preset = opts.preset || settings.now.preset;
      reps = presets[preset];

      if (!reps) {
        logger.warn("Unknown preset \"".concat(preset, "\""));

        var _Object$keys = Object.keys(presets);

        var _Object$keys2 = slicedToArray(_Object$keys, 1);

        preset = _Object$keys2[0];
        reps = presets[preset]; // fall back to any preset
      }

      opts.preset = preset;
      opts.reps = utils.deriveDeep(reps, true);
    }
  }

  function ensureRepAssign(opts, prop, value) {
    ensureRepList(opts);
    var rep = opts.reps[repIndex]; // prop specified twice therefore start new rep by cloning the current

    if (rep.hasOwnProperty(prop)) {
      repIndex = opts.reps.length;
      opts.reps[repIndex] = utils.deriveDeep(rep, true);
    }

    if (value !== undefined) {
      opts.reps[repIndex][prop] = value;
    }
  }

  function addObject(opts, params, options) {
    if (opts._objects === undefined) {
      opts._objects = [];
    }

    var _options = slicedToArray(options, 2),
        type = _options[0],
        newOpts = _options[1];

    var newObj = {
      type: type,
      params: params
    };

    if (newOpts !== undefined) {
      newObj.opts = newOpts;
    }

    opts._objects[opts._objects.length] = newObj;
  }

  function parseParams(str, params) {
    var sep = str.indexOf(',');

    if (sep >= 0) {
      params.push(str.substr(sep + 1).split(','));
      return str.substr(0, sep);
    } // keep this untouched if no params were extracted


    return str;
  }

  function extractArgs(input, defaultsDict, params) {
    if (input) {
      var bang = input.indexOf(cOptsSep);
      var inputVal = parseParams(input.substr(0, bang >= 0 ? bang : undefined), params);

      if (bang >= 0) {
        var args = input.substr(bang + 1).split(cLSep);
        input = inputVal;

        if (defaultsDict) {
          var defaults = defaultsDict[input];
          var opts = utils.deriveDeep(defaults, true);
          args.forEach(function (arg) {
            var pair = arg.split(cL2Ass, 2);
            var key = decodeURIComponent(pair[0]);
            var value = decodeURIComponent(pair[1]);

            var adapter = adapters[_typeof_1(___default['default'].get(defaults, key))];

            if (adapter) {
              ___default['default'].set(opts, key, adapter(value));
            } else {
              logger.warn("Unknown argument \"".concat(key, "\" for option \"").concat(input, "\""));
            }
          });

          if (Object.keys(opts).length > 0) {
            input = [input, opts];
          }
        }
      } else {
        input = inputVal;
      }
    }

    return input;
  }

  var actions = {
    l: 'load',
    load: String,
    t: 'type',
    type: String,
    v: 'view',
    view: String,
    u: 'unit',
    unit: Number,
    menu: asBoolean,
    // Commands
    o: 'object',
    object: function object(value, opts) {
      var params = [];
      var options = extractArgs(value, settings.defaults.objects, params);

      if (!Array.isArray(options)) {
        options = [options];
      }

      addObject(opts, params[0], options);
    },
    p: 'preset',
    preset: function preset(value, opts) {
      opts.preset = value;
      opts.reps = null;
      ensureRepList(opts);
    },
    r: 'rep',
    rep: function rep(value, opts) {
      ensureRepList(opts);
      repIndex = Number(value); // clamp the index to one greater than the last

      repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length; // create a new rep if it is adjacent to the existing ones

      if (repIndex === opts.reps.length) {
        // if there is no rep to derive from, derive from the first rep of the default
        opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings.defaults.presets["default"][0], true);
      }
    },
    s: 'select',
    select: function select(value, opts) {
      ensureRepAssign(opts, 'selector', value);
    },
    m: 'mode',
    mode: function mode(value, opts) {
      ensureRepAssign(opts, 'mode', extractArgs(value, settings.defaults.modes));
    },
    c: 'color',
    color: function color(value, opts) {
      ensureRepAssign(opts, 'colorer', extractArgs(value, settings.defaults.colorers));
    },
    mt: 'material',
    material: function material(value, opts) {
      ensureRepAssign(opts, 'material', extractArgs(value, settings.defaults.materials));
    },
    dup: function dup(value, opts) {
      ensureRepList(opts);
      var reps = opts.reps;
      var rep = reps[repIndex];
      repIndex = reps.length;
      reps[repIndex] = utils.deriveDeep(rep, true);
    },
    // Settings shortcuts
    ar: 'autoResolution'
  };

  function _fromArray(entries) {
    repIndex = 0;
    var opts = {};

    for (var i = 0, n = entries.length; i < n; ++i) {
      var
      /** string[] */
      entry = entries[i];
      var
      /** string? */
      key = entry[0];
      var
      /** string? */
      value = entry[1];
      var
      /** function|string? */
      action = actions[key]; // unwind shortcuts and aliases

      while (___default['default'].isString(action)) {
        key = action;
        action = actions[key];
      } // either set a property or use specialized parser


      if (!action) {
        var adapter = adapters[_typeof_1(___default['default'].get(settings.defaults, key))];

        if (adapter) {
          ___default['default'].set(opts, "settings.".concat(key), adapter(value));
        } else {
          logger.warn("Unknown option \"".concat(key, "\""));
        }
      } else if (___default['default'].isFunction(action)) {
        var result = action(value, opts);

        if (result !== undefined) {
          opts[key] = result;
        }
      }
    }

    return opts;
  }

  function fromAttr(attr) {
    return _fromArray(utils.getUrlParameters("?".concat(attr || '')));
  }

  function fromURL(url) {
    return _fromArray(utils.getUrlParameters(url));
  }

  function _processOptsForURL(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
    });
    return str.join(cLSep);
  }

  function _processArgsForURL(args) {
    if (!___default['default'].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0]).concat(cOptsSep).concat(_processOptsForURL(args[1]));
  }

  function _processObjForURL(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default['default'].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += ",".concat(objOpts.params.join(','));
    }

    if (objOpts.opts) {
      res += cOptsSep + _processOptsForURL(objOpts.opts);
    }

    return res;
  }

  function toURL(opts) {
    var stringList = [];
    var idx = 0;

    function checkAndAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        if (___default['default'].isEmpty(repList[i])) {
          continue;
        }

        checkAndAdd('r', i);
        checkAndAdd('s', repList[i].selector);
        checkAndAdd('m', _processArgsForURL(repList[i].mode));
        checkAndAdd('c', _processArgsForURL(repList[i].colorer));
        checkAndAdd('mt', _processArgsForURL(repList[i].material));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('o', _processObjForURL(objList[i]));
      }
    }

    checkAndAdd('l', opts.load);
    checkAndAdd('u', opts.unit);
    checkAndAdd('p', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    checkAndAdd('v', opts.view);
    utils.forInRecursive(opts.settings, function (value, key) {
      // I heard these lines in the whispers of the Gods
      // Handle preset setting in reps
      if (key === 'preset') {
        return;
      }

      checkAndAdd(key, value);
    });
    var url = '';

    if (typeof window !== 'undefined') {
      var _window = window,
          location = _window.location;
      url = "".concat(location.protocol, "//").concat(location.host).concat(location.pathname);
    }

    if (stringList.length > 0) {
      url += "?".concat(stringList.join('&'));
    }

    return url;
  }

  function _processOptsForScript(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = "".concat(key, "=").concat(utils.enquoteString(value));
    });
    return str.join(' ');
  }

  function _processArgsForScript(args) {
    if (!___default['default'].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0], " ").concat(_processOptsForScript(args[1]));
  }

  function _processObjForScript(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default['default'].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += " ".concat(objOpts.params.map(utils.enquoteString).join(' '));
    }

    if (objOpts.opts) {
      res += " ".concat(_processOptsForScript(objOpts.opts));
    }

    return res;
  }

  function _processRepsForScript(rep, index) {
    var repString = [];
    var strIdx = 0;

    function localAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        repString[strIdx++] = prefix + value;
      }
    }

    if (___default['default'].isEmpty(rep)) {
      return null;
    }

    localAdd('', index);
    localAdd('s=', utils.enquoteString(rep.selector));
    localAdd('m=', _processArgsForScript(rep.mode));
    localAdd('c=', _processArgsForScript(rep.colorer));
    localAdd('mt=', _processArgsForScript(rep.material));
    return repString.join(' ');
  }

  function toScript(opts) {
    var commandsList = [];
    var idx = 0;

    function checkAndAdd(command, value, saveQuotes) {
      if (value !== null && value !== undefined) {
        var quote = typeof value === 'string' && saveQuotes ? '"' : '';
        commandsList[idx++] = "".concat(command, " ").concat(quote).concat(value).concat(quote).trim();
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        checkAndAdd('rep', _processRepsForScript(repList[i], i));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('', _processObjForScript(objList[i]));
      }
    }

    checkAndAdd('set', 'autobuild false');
    checkAndAdd('load', opts.load, true);
    checkAndAdd('unit', opts.unit);
    checkAndAdd('preset', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    utils.forInRecursive(opts.settings, function (value, key) {
      // I heard these lines in the whispers of the Gods
      // Handle preset setting in reps
      if (key === 'preset') {
        return;
      }

      checkAndAdd("set ".concat(key), value, true);
    });
    checkAndAdd('view', opts.view);
    checkAndAdd('set', 'autobuild true');
    return commandsList.join('\n');
  }

  var options = {
    fromURL: fromURL,
    fromAttr: fromAttr,
    adapters: adapters,
    toURL: toURL,
    toScript: toScript
  };

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;

  /**
   * Atom measurements.
   *
   * @param {Residue} residue    - (required) Residue containing the atom
   * @param {string} name        - (required) Name, unique in the residue
   * @param {Element} type       - (required) Chemical element reference
   * @param {THREE.Vector3} position - Registered coordinates
   *
   * @param {number} role        - Role of atom inside monomer: Lead and wing are particularity interesting
   * @param {boolean} het        - Non-standard residue indicator
   *
   * @param {number} serial      - Serial number, unique in the model
   * @param {string} location    - Alternative location indicator (usually space or A-Z)
   * @param {number} occupancy   - Occupancy percentage, from 0 to 1
   * @param {number} temperature - Temperature
   * @param {number} charge      - Charge
   *
   * @exports Atom
   * @constructor
   */
  var Atom = /*#__PURE__*/function () {
    function Atom(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
      classCallCheck(this, Atom);

      this.index = -1;
      this.residue = residue;
      this.name = name;
      this.element = type;
      this.position = position;
      this.role = role;
      this.mask = 1 | 0;
      this.het = het;
      this.serial = serial;
      this.location = (location || ' ').charCodeAt(0);
      this.occupancy = occupancy || 1;
      this.temperature = temperature;
      this.charge = charge;
      this.hydrogenCount = -1; // explicitly invalid

      this.radicalCount = 0;
      this.valence = -1; // explicitly invalid

      this.bonds = [];
      this.flags = 0x0000;

      if (type.name === 'H') {
        this.flags |= Atom.Flags.HYDROGEN;
      } else if (type.name === 'C') {
        this.flags |= Atom.Flags.CARBON;
      }
    }

    createClass(Atom, [{
      key: "isHet",
      value: function isHet() {
        return this.het;
      }
    }, {
      key: "isHydrogen",
      value: function isHydrogen() {
        return this.element.number === 1;
      }
    }, {
      key: "getVisualName",
      value: function getVisualName() {
        var name = this.name;

        if (name.length > 0) {
          return name;
        }

        return this.element.name.trim();
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "getFullName",
      value: function getFullName() {
        var name = '';

        if (this.residue !== null) {
          if (this.residue._chain !== null) {
            name += "".concat(this.residue._chain.getName(), ".");
          }

          name += "".concat(this.residue._sequence, ".");
        }

        name += this.name;
        return name;
      }
      /**
       * Enumeration of atom flag values.
       *
       * @enum {number}
       * @readonly
       */

    }]);

    return Atom;
  }();

  defineProperty(Atom, "Flags", {
    CARBON: 0x0001,
    // OXYGEN: 0x0002,
    // NITROGEN: 0x0004,
    HYDROGEN: 0x0008,

    /** Non-polar hydrogen (it is also a HYDROGEN) */
    NONPOLARH: 0x1008
  });

  var Element = function Element(number, name, fullName, weight, radius, radiusBonding, hValency) {
    classCallCheck(this, Element);

    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  };

  defineProperty(Element, "Constants", {
    /* eslint-disable no-magic-numbers */
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(Element, "Role", {
    /* eslint-disable no-magic-numbers */
    N: Element.Constants.U1,
    CA: Element.Constants.Lead,
    C: Element.Constants.U2,
    O: Element.Constants.Wing,
    SG: Element.Constants.U18
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(Element, "ByAtomicNumber", [
  /* eslint-disable no-magic-numbers */
  null, new Element(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]), new Element(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]), new Element(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]), new Element(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]), new Element(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]), new Element(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]), new Element(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]), new Element(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]), new Element(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]), new Element(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]), new Element(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]), new Element(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]), new Element(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]), new Element(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]), new Element(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]), new Element(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]), new Element(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]), new Element(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]), new Element(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]), new Element(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]), new Element(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]), new Element(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]), new Element(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]), new Element(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]), new Element(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]), new Element(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]), new Element(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]), new Element(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]), new Element(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]), new Element(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]), new Element(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]), new Element(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]), new Element(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]), new Element(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]), new Element(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]), new Element(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]), new Element(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]), new Element(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]), new Element(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]), new Element(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]), new Element(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]), new Element(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]), new Element(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]), new Element(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]), new Element(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]), new Element(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]), new Element(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]), new Element(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]), new Element(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]), new Element(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]), new Element(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]), new Element(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]), new Element(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]), new Element(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]), new Element(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]), new Element(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]), new Element(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]), new Element(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]), new Element(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]), new Element(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]), new Element(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]), new Element(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]), new Element(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]), new Element(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]), new Element(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]), new Element(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]), new Element(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]), new Element(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]), new Element(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]), new Element(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]), new Element(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]), new Element(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]), new Element(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]), new Element(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]), new Element(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]), new Element(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]), new Element(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]), new Element(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]), new Element(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]), new Element(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]), new Element(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]), new Element(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]), new Element(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]), new Element(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]), new Element(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]), new Element(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]), new Element(87, 'FR', 'Francium', 223, 1.7, 2, [1]), new Element(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]), new Element(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]), new Element(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]), new Element(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]), new Element(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]), new Element(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]), new Element(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]), new Element(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]), new Element(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]), new Element(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]), new Element(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]), new Element(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]), new Element(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]), new Element(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]), new Element(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]), new Element(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]), new Element(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]), new Element(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]), new Element(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]), new Element(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]), new Element(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]), new Element(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])
  /* eslint-enable no-magic-numbers */
  ]);

  defineProperty(Element, "ByName", {
    // Duplicate atomic numbers (isotopes)

    /* eslint-disable no-magic-numbers */
    D: new Element(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
    T: new Element(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
    /* eslint-enable no-magic-numbers */
    // All regular elements will be added later, automatically

  });

  (function () {
    var byAtomicNumber = Element.ByAtomicNumber;
    var byName = Element.ByName;

    for (var i = 0, n = byAtomicNumber.length; i < n; ++i) {
      var element = byAtomicNumber[i];

      if (element) {
        byName[element.name] = element;
      }
    }
  })(); // find atom type by chemical element (or create if missing)


  Element.getByName = function (element) {
    var type = Element.ByName[element];

    if (!type) {
      type = Element.ByName[element] = new Element(0, element, 'Unknown', 0, 1.0, 0.01, [0]);
    }

    return type;
  };

  var cBondTypes = {
    /** Was generated manually */
    UNKNOWN: 0,

    /** Simple covalent bond */
    COVALENT: 1,

    /** Aromatic bond */
    AROMATIC: 2
  };

  function getAtomPos(atom) {
    return atom.position;
  }
  /**
   * Bond between atoms.
   *
   * @param {Atom} left     - The first atom.
   * @param {Atom} right    - The second atom.
   * @param {number} order - Order of current bond.
   * @param {number} type - Bond type.
   * @param {boolean} fixed - Indicator of a pre-specified connection (in contrast with guessed one).
   *
   * @exports Bond
   * @constructor
   */


  var Bond = /*#__PURE__*/function () {
    function Bond(left, right, order, type, fixed) {
      classCallCheck(this, Bond);

      this._left = left;
      this._right = right;
      this._fixed = fixed;
      this._index = -1;

      if (left > right) {
        throw new Error('In a bond atom indices must be in increasing order');
      }

      this._order = order;
      this._type = type;
    }

    createClass(Bond, [{
      key: "getLeft",
      value: function getLeft() {
        return this._left;
      }
    }, {
      key: "getRight",
      value: function getRight() {
        return this._right;
      }
    }, {
      key: "getOrder",
      value: function getOrder() {
        return this._order;
      }
    }, {
      key: "calcLength",
      value: function calcLength() {
        return this._left.position.distanceTo(this._right.position);
      }
    }, {
      key: "_forEachNeighbour",
      value: function _forEachNeighbour(currAtom, process) {
        var bonds = currAtom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
        }
      }
    }, {
      key: "forEachLevelOne",
      value: function forEachLevelOne(process) {
        var left = this._left;
        var right = this._right;

        this._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          process(atom);
        });

        this._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          process(atom);
        });
      }
    }, {
      key: "forEachLevelTwo",
      value: function forEachLevelTwo(process) {
        // TODO refactor this piece of an art?
        var left = this._left;
        var right = this._right;
        var self = this;

        self._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === left) {
              return;
            }

            process(l2Atom);
          });
        });

        self._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === right) {
              return;
            }

            process(l2Atom);
          });
        });
      }
    }, {
      key: "_fixDir",
      value: function _fixDir(refPoint, currDir, posGetter) {
        // count atoms to the right and to the left of the current plane
        var rightCount = 0;
        var leftCount = 0;
        var tmpVec = refPoint.clone();

        function checkDir(atom) {
          tmpVec.copy(posGetter(atom));
          tmpVec.sub(refPoint);
          var dotProd = currDir.dot(tmpVec);

          if (dotProd > 0) {
            ++rightCount;
          } else {
            ++leftCount;
          }
        }

        function checkCarbon(atom) {
          if (atom.element.name === 'C') {
            checkDir(atom);
          }
        } // count all atoms to the left and right of our plane, start from level 1 and carbons


        var stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];

        for (var stageId = 0; stageId < stages.length; ++stageId) {
          stages[stageId][0].call(this, stages[stageId][1]);

          if (leftCount > rightCount) {
            return currDir.multiplyScalar(-1);
          }

          if (leftCount < rightCount) {
            return currDir;
          }
        }

        return currDir;
      }
    }, {
      key: "calcNormalDir",
      value: function calcNormalDir(posGetter) {
        var left = this._left;
        var right = this._right;
        var first = left;
        var second = right;
        posGetter = posGetter === undefined ? getAtomPos : posGetter;

        if (left.bonds.length > right.bonds.length) {
          first = right;
          second = left;
        }

        var third = first;
        var maxNeibs = 0;
        var _second = second,
            bonds = _second.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var another = bonds[i]._left;

          if (bonds[i]._left === second) {
            another = bonds[i]._right;
          }

          if (another.bonds.length > maxNeibs && another !== first) {
            third = another;
            maxNeibs = another.bonds.length;
          }
        }

        var secondPos = posGetter(second);
        var firstV = posGetter(first).clone().sub(secondPos);
        var secondV = posGetter(third).clone().sub(secondPos);
        secondV.crossVectors(firstV, secondV);

        if (secondV.lengthSq() < 0.0001) {
          secondV.set(0, 1, 0);
        }

        firstV.normalize();
        secondV.normalize();
        firstV.crossVectors(secondV, firstV);

        if (firstV.lengthSq() < 0.0001) {
          firstV.set(0, 1, 0);
        }

        firstV.normalize();
        return this._fixDir(secondPos, firstV, posGetter);
      }
    }]);

    return Bond;
  }();

  defineProperty(Bond, "BondType", cBondTypes);

  Bond.prototype.BondType = cBondTypes;

  var cNucleicControlNames = ['C3\'', 'C3*', 'P', 'H5T', 'H3T'];
  var cNucleicWing1Names = ['OP1', 'O1P'];
  var cNucleicWing2Names = ['OP2', 'O2P'];
  var cCylinderSource = ['C3\'', 'C3*', 'C1', 'C1\'', 'C1*', 'P'];
  var cCylinderTarget = [{
    types: ['A', 'DA', 'G', 'DG'],
    atoms: ['N1']
  }, {
    types: ['C', 'DC'],
    atoms: ['N3']
  }, {
    types: ['T', 'DT', 'U', 'DU'],
    atoms: ['O4']
  }];
  /**
   * Residue instance.
   *
   * @param {Chain} chain      - Chain this residue belongs to.
   * @param {ResidueType} type - Generic residue instance type.
   * @param {number} sequence  - Sequence ID.
   * @param {string} icode     - One character insertion code (usually space or A-Z).
   *
   * @exports Residue
   * @constructor
   */

  var Residue = /*#__PURE__*/function () {
    function Residue(chain, type, sequence, icode) {
      classCallCheck(this, Residue);

      this._chain = chain;
      this._component = null;
      this._type = type;
      this._sequence = sequence;
      this._icode = icode;
      this._mask = 1 | 0;
      this._index = -1;
      this._atoms = [];
      this._secondary = null;
      this._firstAtom = null;
      this._leadAtom = null;
      this._wingAtom = null;
      this._lastAtom = null;
      this._controlPoint = null;
      this._midPoint = null;
      this._wingVector = null;
      this._cylinders = null;
      this._isValid = true;
      this._het = false;
      this._molecule = null;
      this.temperature = null;
      this.occupancy = null;
    } // Getters and setters


    createClass(Residue, [{
      key: "getChain",
      value: function getChain() {
        return this._chain;
      }
    }, {
      key: "getMolecule",
      value: function getMolecule() {
        return this._molecule;
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._type;
      }
    }, {
      key: "getSequence",
      value: function getSequence() {
        return this._sequence;
      }
    }, {
      key: "getSecondary",
      value: function getSecondary() {
        return this._secondary;
      }
    }, {
      key: "getICode",
      value: function getICode() {
        return this._icode;
      } // Other methods

    }, {
      key: "addAtom",
      value: function addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
        var atom = new Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);

        var complex = this._chain.getComplex();

        complex.addAtom(atom);

        this._atoms.push(atom);

        this._het = this._het || het;
        return atom;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (process(atoms[i])) {
            break;
          }
        }
      }
    }, {
      key: "_findAtomByName",
      value: function _findAtomByName(name) {
        var res = null;
        this.forEachAtom(function (atom) {
          if (atom.name === name) {
            res = atom;
            return true;
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_findFirstAtomInList",
      value: function _findFirstAtomInList(names) {
        var res = null;

        for (var i = 0; i < names.length; ++i) {
          res = this._findAtomByName(names[i]);

          if (res !== null) {
            return res;
          }
        }

        return res;
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          mask &= atoms[i].mask;
        }

        this._mask = mask;
      }
    }, {
      key: "getCylinderTargetList",
      value: function getCylinderTargetList() {
        var type = this._type._name;

        for (var i = 0, n = cCylinderTarget.length; i < n; ++i) {
          for (var j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
            if (type === cCylinderTarget[i].types[j]) {
              return cCylinderTarget[i].atoms;
            }
          }
        }

        return null;
      }
    }, {
      key: "_detectLeadWing",
      value: function _detectLeadWing(dst, next, getAtomPosition) {
        var leadAtom = this._findFirstAtomInList(cNucleicControlNames);

        var wingStart = this._findFirstAtomInList(cNucleicWing1Names);

        var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);

        if (wingStart === null && next !== null) {
          wingStart = next._findFirstAtomInList(cNucleicWing1Names);
        }

        if (wingEnd === null && next !== null) {
          wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
        }

        if (leadAtom === null || wingStart === null || wingEnd === null) {
          return;
        }

        dst._leadAtom = leadAtom;
        dst._controlPoint = getAtomPosition(leadAtom);
        dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
        dst._isValid = true;

        var cylSource = this._findFirstAtomInList(cCylinderSource);

        var targetList = this.getCylinderTargetList();
        var cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;

        if (cylSource === null || cylTarget === null) {
          return;
        }

        dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
      }
    }, {
      key: "calcWing",
      value: function calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
        var vectorA = currLeadPos.clone().sub(prevLeadPos);
        var vectorB = prevLeadPos.clone().sub(prevWingPos);
        vectorB.crossVectors(vectorA, vectorB);
        vectorB.crossVectors(vectorA, vectorB).normalize();

        if (prevWing !== null && prevWing.length() > 0.0001) {
          var needToNegate = vectorB.length() > 0.0001 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;

          if (needToNegate) {
            vectorB.negate();
          }
        }

        return vectorB;
      }
    }, {
      key: "_innerFinalize",
      value: function _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
        var bFirstInChain = prev === null;
        var lp = getAtomPosition(this._leadAtom);
        var currLeadPos = new THREE.Vector3(lp.x, lp.y, lp.z);

        if (chainAsNucleic) {
          this._detectLeadWing(dst, nextRes, getAtomPosition);

          return;
        }

        if (bFirstInChain) {
          // for first one in chain
          dst._midPoint = getAtomPosition(this._firstAtom).clone();
        } else {
          var prevLeadPos = prev._controlPoint; // lead point of previous monomer

          dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
          dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
        }

        dst._controlPoint = currLeadPos;
      }
    }, {
      key: "_finalize2",
      value: function _finalize2(prev, next, asNucleic) {
        // Should be called AFTER first finalize
        this._innerFinalize(prev, prev, next, this, asNucleic, function (atom) {
          return atom.position;
        });
      }
    }, {
      key: "isConnected",
      value: function isConnected(anotherResidue) {
        if (this._chain !== anotherResidue._chain) {
          return false;
        }

        if (this === anotherResidue) {
          return true;
        }

        var res = false;
        this.forEachAtom(function (atom) {
          var bonds = atom.bonds;

          for (var i = 0, n = bonds.length; i < n; ++i) {
            var bond = bonds[i];

            if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
              res = true;
              return true;
            }
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var self = this;

        var _this$_atoms = slicedToArray(this._atoms, 1);

        this._firstAtom = _this$_atoms[0];
        this._lastAtom = this._atoms[this._atoms.length - 1];
        this._leadAtom = null;
        this._wingAtom = null;
        var tempCount = 0;
        var temperature = 0; // average temperature

        var occupCount = 0;
        var occupancy = 0; // average occupancy

        this.forEachAtom(function (a) {
          if (self._leadAtom === null) {
            if (a.role === Element.Constants.Lead) {
              self._leadAtom = a;
            }
          }

          if (self._wingAtom === null) {
            if (a.role === Element.Constants.Wing) {
              self._wingAtom = a;
            }
          }

          if (a.temperature) {
            temperature += a.temperature;
            tempCount++;
          }

          if (a.occupancy) {
            occupancy += a.occupancy;
            occupCount++;
          }

          return self._leadAtom !== null && self._wingAtom !== null;
        });

        if (tempCount > 0) {
          this.temperature = temperature / tempCount;
        }

        if (occupCount > 0) {
          this.occupancy = occupancy / occupCount;
        } // Still try to make monomer look valid


        if (this._leadAtom === null || this._wingAtom === null) {
          this._isValid = false;
        }

        if (this._leadAtom === null) {
          this._leadAtom = this._firstAtom;
        }

        if (this._wingAtom === null) {
          this._wingAtom = this._lastAtom;
        }
      }
    }]);

    return Residue;
  }();

  /**
   * Residue type.
   *
   * Predefined acid or created with HET, HETNAM, etc.
   *
   * @param {string} name            - Short name, either standard (ALA, MET, etc.) or non-standard one.
   * @param {string} fullName        - Full residue name.
   * @param {string} letterCode      - 1-letter symbol.
   *
   * @exports ResidueType
   * @constructor
   */
  var ResidueType = /*#__PURE__*/function () {
    function ResidueType(name, fullName, letterCode) {
      classCallCheck(this, ResidueType);

      this._name = name;
      this._fullName = fullName;
      this.letterCode = letterCode;
      this.flags = 0x0000;
    }

    createClass(ResidueType, [{
      key: "getName",
      value: function getName() {
        return this._name;
      } // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

    }]);

    return ResidueType;
  }(); // Flag combinations


  defineProperty(ResidueType, "StandardTypes", {
    /* eslint-disable no-magic-numbers */
    ALA: new ResidueType('ALA', 'Alanine', 'A'),
    ARG: new ResidueType('ARG', 'Arginine', 'R'),
    ASN: new ResidueType('ASN', 'Asparagine', 'N'),
    ASP: new ResidueType('ASP', 'Aspartic Acid', 'D'),
    CYS: new ResidueType('CYS', 'Cysteine', 'C'),
    GLN: new ResidueType('GLN', 'Glutamine', 'Q'),
    GLU: new ResidueType('GLU', 'Glutamic Acid', 'E'),
    GLY: new ResidueType('GLY', 'Glycine', 'G'),
    HIS: new ResidueType('HIS', 'Histidine', 'H'),
    ILE: new ResidueType('ILE', 'Isoleucine', 'I'),
    LEU: new ResidueType('LEU', 'Leucine', 'L'),
    LYS: new ResidueType('LYS', 'Lysine', 'K'),
    MET: new ResidueType('MET', 'Methionine', 'M'),
    PHE: new ResidueType('PHE', 'Phenylalanine', 'F'),
    PRO: new ResidueType('PRO', 'Proline', 'P'),
    PYL: new ResidueType('PYL', 'Pyrrolysine', 'O'),
    SEC: new ResidueType('SEC', 'Selenocysteine', 'U'),
    SER: new ResidueType('SER', 'Serine', 'S'),
    THR: new ResidueType('THR', 'Threonine', 'T'),
    TRP: new ResidueType('TRP', 'Tryptophan', 'W'),
    TYR: new ResidueType('TYR', 'Tyrosine', 'Y'),
    VAL: new ResidueType('VAL', 'Valine', 'V'),
    A: new ResidueType('A', 'Adenine', 'A'),
    C: new ResidueType('C', 'Cytosine', 'C'),
    G: new ResidueType('G', 'Guanine', 'G'),
    I: new ResidueType('I', 'Inosine', 'I'),
    T: new ResidueType('T', 'Thymine', 'T'),
    U: new ResidueType('U', 'Uracil', 'U'),
    DA: new ResidueType('DA', 'Adenine', 'A'),
    DC: new ResidueType('DC', 'Cytosine', 'C'),
    DG: new ResidueType('DG', 'Guanine', 'G'),
    DI: new ResidueType('DI', 'Inosine', 'I'),
    DT: new ResidueType('DT', 'Thymine', 'T'),
    DU: new ResidueType('DU', 'Uracil', 'U'),
    '+A': new ResidueType('+A', 'Adenine', 'A'),
    '+C': new ResidueType('+C', 'Cytosine', 'C'),
    '+G': new ResidueType('+G', 'Guanine', 'G'),
    '+I': new ResidueType('+I', 'Inosine', 'I'),
    '+T': new ResidueType('+T', 'Thymine', 'T'),
    '+U': new ResidueType('+U', 'Uracil', 'U'),
    WAT: new ResidueType('WAT', 'Water', ''),
    H2O: new ResidueType('H2O', 'Water', ''),
    HOH: new ResidueType('HOH', 'Water', ''),
    DOD: new ResidueType('DOD', 'Water', ''),
    UNK: new ResidueType('UNK', 'Unknown', ''),
    UNL: new ResidueType('UNL', 'Unknown Ligand', '')
    /* eslint-enable no-magic-numbers */

  });

  defineProperty(ResidueType, "Flags", {
    // Amino acids

    /** Amino acid residue */
    PROTEIN: 0x0001,

    /** Basic amino acid residue */
    BASIC: 0x0002,

    /** Acidic amino acid residue */
    ACIDIC: 0x0004,

    /** Polar uncharged side chain amino acid residue */
    POLAR: 0x0008,

    /** Non-polar hydrophobic side chain amino acid residue */
    NONPOLAR: 0x0010,

    /** Aromatic amino acid residue */
    AROMATIC: 0x0020,
    // Nucleic acids

    /** Nucleic residue */
    NUCLEIC: 0x0100,

    /** Purine nucleic residue */
    PURINE: 0x0200,

    /** Pyrimidine nucleic residue */
    PYRIMIDINE: 0x0400,

    /** DNA */
    DNA: 0x0800,

    /** RNA */
    RNA: 0x1000,

    /** Water */
    WATER: 0x10000
  });

  function _addFlag(flag, list) {
    for (var i = 0, n = list.length; i < n; ++i) {
      var res = ResidueType.StandardTypes[list[i]];

      if (res) {
        res.flags |= flag;
      }
    }
  }

  var Flags = ResidueType.Flags;

  _addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD']);

  _addFlag(Flags.PROTEIN, ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLY', 'GLU', 'GLN', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'PYL', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL']);

  _addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS']);

  _addFlag(Flags.ACIDIC, ['ASP', 'GLU']);

  _addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR']);

  _addFlag(Flags.NONPOLAR, ['ALA', 'ILE', 'LEU', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'GLY']);

  _addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR']);

  _addFlag(Flags.NUCLEIC, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I', 'C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I']);

  _addFlag(Flags.PYRIMIDINE, ['C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU']);

  _addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U']); // Table of kdHydrophobicity


  var hydro = {
    ILE: 4.5,
    VAL: 4.2,
    LEU: 3.8,
    PHE: 2.8,
    CYS: 2.5,
    MET: 1.9,
    ALA: 1.8,
    GLY: -0.4,
    THR: -0.7,
    SER: -0.8,
    TRP: -0.9,
    TYR: -1.3,
    PRO: -1.6,
    HIS: -3.2,
    GLU: -3.5,
    GLN: -3.5,
    ASP: -3.5,
    ASN: -3.5,
    LYS: -3.9,
    ARG: -4.5
  };

  function _addParam(param, list) {
    var keys = Object.keys(list);

    for (var i = 0, n = keys.length; i < n; ++i) {
      var key = keys[i];
      var value = list[key];
      ResidueType.StandardTypes[key][param] = value;
    }
  }

  _addParam('hydrophobicity', hydro);

  /**
   * Residues in chain are either amino acid either nucleic acid (and water)
   * There might be some modified/mutated residues, which type could not be determined by their name (nucleic or amino); In this
   * case firstly program definites the chain type (by well-known residues) and then definites modified/mutated residues
   */

  var ChainType = {
    UNKNOWN: 0,
    PROTEIN: 1,
    NUCLEIC: 2
  };
  /**
   * Residue chain.
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   * @param {string} name - One character identifier (usually space, A-Z, 0-9, or a-z).
   *
   * @exports Chain
   * @constructor
   */

  var Chain = /*#__PURE__*/function () {
    function Chain(complex, name) {
      classCallCheck(this, Chain);

      this._complex = complex;
      this._name = name;
      this._mask = 1 | 0;
      this._index = -1;
      this._residues = [];
      this.minSequence = Number.POSITIVE_INFINITY;
      this.maxSequence = Number.NEGATIVE_INFINITY;
    }

    createClass(Chain, [{
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "_determineType",
      value: function _determineType() {
        var residues = this._residues;
        var _ResidueType$Flags = ResidueType.Flags,
            PROTEIN = _ResidueType$Flags.PROTEIN,
            NUCLEIC = _ResidueType$Flags.NUCLEIC;
        this.type = ChainType.UNKNOWN;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var flags = residues[i]._type.flags;

          if ((flags & NUCLEIC) !== 0) {
            this.type = ChainType.NUCLEIC;
            break;
          } else if ((flags & PROTEIN) !== 0) {
            this.type = ChainType.PROTEIN;
            break;
          }
        }
      }
      /**
       * Finds thre residue with specified sequence number and inserion code
       * @param {Number} seqNum sequence number
       * @param {string} iCode insertion code
       * @returns {*} Residue or null if not found
       */

    }, {
      key: "findResidue",
      value: function findResidue(seqNum, iCode) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i];

          if (res._sequence === seqNum && res._icode === iCode) {
            return [res, i];
          }
        }

        return null;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._determineType();

        var residues = this._residues;
        var prev = null;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var next = i + 1 < n ? residues[i + 1] : null;
          var curr = residues[i]; // TODO: skip invalid residues

          {
              // eslint-disable-line no-constant-condition
              curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);

              prev = curr;
            }
        } // fix very first wing


        if (residues.length > 1 && residues[1]._wingVector) {
          var p = residues[1]._wingVector;
          residues[0]._wingVector = new THREE.Vector3(p.x, p.y, p.z);
        } else if (residues.length > 0) {
          residues[0]._wingVector = new THREE.Vector3(1, 0, 0);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var residues = this._residues;
        var prev = null;
        var prevData = null;
        var frameRes = frameData._residues;
        var n = residues.length;

        function getAtomPos(atom) {
          return frameData.getAtomPos(atom.index);
        }

        for (var i = 0; i < n; ++i) {
          var curr = residues[i];
          var currData = frameRes[curr._index];
          var nextRes = i + 1 < n ? residues[i + 1] : null;

          curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos);

          prev = curr;
          prevData = currData;
        }

        frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new THREE.Vector3(1, 0, 0);
      }
      /**
       * Create a new residue.
       *
       * @param {string} name - Residue name.
       * @param {number} sequence - Residue sequence number.
       * @param {string} iCode - Insertion code.
       * @returns {Residue} - Newly created residue instance.
       */

    }, {
      key: "addResidue",
      value: function addResidue(name, sequence, iCode) {
        var type = this._complex.getResidueType(name);

        if (type === null) {
          type = this._complex.addResidueType(name);
        }

        var residue = new Residue(this, type, sequence, iCode);

        this._complex.addResidue(residue);

        this._residues.push(residue);

        if (type.flags & (ResidueType.Flags.NUCLEIC | ResidueType.Flags.PROTEIN)) {
          if (this.maxSequence < sequence) {
            this.maxSequence = sequence;
          }

          if (this.minSequence > sequence) {
            this.minSequence = sequence;
          }
        }

        return residue;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this._mask = mask;
      }
    }]);

    return Chain;
  }();

  var _StructuralElement$ge;
  /** An element of protein secondary structure. */

  var StructuralElement = /*#__PURE__*/function () {
    /**
     * Create a secondary structural element of the specified type.
     *
     * @param {StructuralElement.Type} type Secondary structure type.
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     */
    function StructuralElement(type, init, term) {
      classCallCheck(this, StructuralElement);

      /**
       * Secondary structure type.
       * @type {StructuralElement.Type}
       */
      this.type = type;
      /**
       * Generic secondary structure type.
       * @type {StructuralElement.Generic}
       */

      this.generic = StructuralElement.genericByType[this.type] || 'loop';
      /**
       * Initial residue.
       * @type Residue
       */

      this.init = init;
      /**
       * Terminal residue.
       * @type Residue
       */

      this.term = term;
    }
    /**
     * An internal method for making a final pass over the complex to set all required references.
     *
     * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
     * Just copying it as-is right now and hoping for the best.
     *
     * @param {object} serialAtomMap A dictionary of atoms
     * @param {object} residueHash A dictionary of hashed residues to check.
     * @param {Complex} complex The molecular complex this element belongs to.
     */


    createClass(StructuralElement, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        if (this.init instanceof Residue && this.term instanceof Residue) {
          return;
        } // Link all intermediate residues to this structural element


        var start = complex.splitUnifiedSerial(this.init);
        var end = complex.splitUnifiedSerial(this.term);

        for (var chainId = start.chain; chainId <= end.chain; chainId++) {
          for (var serialId = start.serial; serialId <= end.serial; serialId++) {
            for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
              var hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);

              if (residueHash[hashCode]) {
                residueHash[hashCode]._secondary = this;
              }
            }
          }
        } // Replace unfined serials by objects


        this.init = residueHash[this.init];
        this.term = residueHash[this.term];
      }
    }]);

    return StructuralElement;
  }();
  /**
   * Specific type of a secondary structural element.
   * @enum {string}
   * @see StructuralElement.Generic
   */


  StructuralElement.Type = {
    /** A strand of a [beta-sheet](https://en.wikipedia.org/wiki/Beta_sheet). */
    STRAND: 'E',

    /** An isolated beta-bridge (too small for a beta-sheet). */
    BRIDGE: 'B',

    /** A [3/10 helix](https://en.wikipedia.org/wiki/310_helix) (hydrogen bonding is 3 residues apart). */
    HELIX_310: 'G',

    /** An [alpha-helix](https://en.wikipedia.org/wiki/Alpha_helix) (hydrogen bonding is 4 residues apart). */
    HELIX_ALPHA: 'H',

    /** A [pi-helix](https://en.wikipedia.org/wiki/Pi_helix) (hydrogen bonding is 5 residues apart). */
    HELIX_PI: 'I',

    /** A generic helix of unspecified bonding distance. */
    HELIX: 'X',

    /** An isolated 3/10-like helical turn. */
    TURN_310: '3',

    /** An isolated alpha-like helical turn. */
    TURN_ALPHA: '4',

    /** An isolated pi-like helical turn. */
    TURN_PI: '5',

    /** An isolated helical [turn](https://en.wikipedia.org/wiki/Turn_(biochemistry)) of unspecified bonding distance. */
    TURN: 'T',

    /** A bend (a region of high curvature). */
    BEND: 'S',

    /** Just a protein section with no particular conformation. */
    COIL: 'C'
  };
  /**
   * Generic type of a secondary structural element.
   * @enum {string}
   * @see StructuralElement.Type
   */

  StructuralElement.Generic = {
    /** A strand of a sheet. */
    STRAND: 'strand',

    /** A helix. */
    HELIX: 'helix',

    /** Just a protein section with no particular conformation. */
    LOOP: 'loop'
  };
  var StructuralElementType = StructuralElement.Type;
  var StructuralElementGeneric = StructuralElement.Generic;
  /**
   * A mapping from specific types to generic ones.
   * @type {Object<StructuralElement.Type, StructuralElement.Generic>}
   */

  StructuralElement.genericByType = (_StructuralElement$ge = {}, defineProperty(_StructuralElement$ge, StructuralElementType.STRAND, StructuralElementGeneric.STRAND), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_310, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_ALPHA, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_PI, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX, StructuralElementGeneric.HELIX), _StructuralElement$ge);

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var StructuralElementType$1 = StructuralElement.Type;
  var typeByPDBHelixClass = {
    1: StructuralElementType$1.HELIX_ALPHA,
    3: StructuralElementType$1.HELIX_PI,
    5: StructuralElementType$1.HELIX_310
  };
  /**
   * Helical secondary structure of a protein.
   * @extends StructuralElement
   */

  var Helix = /*#__PURE__*/function (_StructuralElement) {
    inherits(Helix, _StructuralElement);

    var _super = _createSuper$2(Helix);

    /**
     * Create a helix.
     *
     * @param {number} helixClass A helix class according to the
     *   [PDB Format](http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX).
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     * @param {number} serial Serial number of the helix (see PDB Format).
     * @param {string} name Helix identifier (see PDB Format).
     * @param {string} comment Comment about this helix (see PDB Format).
     * @param {number} length Length of this helix, in residues (see PDB Format).
     */
    function Helix(helixClass, init, term, serial, name, comment, length) {
      var _this;

      classCallCheck(this, Helix);

      _this = _super.call(this, typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX, init, term);
      /**
       * Serial number of the helix (see PDB Format).
       * @type {number}
       */

      _this.serial = serial;
      /**
       * Helix identifier (see PDB Format).
       * @type {string}
       */

      _this.name = name;
      /**
       * Comment about this helix (see PDB Format).
       * @type {string}
       */

      _this.comment = comment;
      /**
       * Length of this helix, in residues (see PDB Format).
       * @type {number}
       */

      _this.length = length;
      return _this;
    }

    return Helix;
  }(StructuralElement);

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  var superPropBase = _superPropBase;

  var get = createCommonjsModule(function (module) {
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  module.exports = _get;
  });

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A single strand of a sheet in a protein secondary structure.
   * @extends StructuralElement
   */

  var Strand = /*#__PURE__*/function (_StructuralElement) {
    inherits(Strand, _StructuralElement);

    var _super = _createSuper$3(Strand);

    /**
     * Create a strand.
     *
     * @param {Sheet} sheet Parent sheet this strand belongs to.
     * @param {Residue} init Initial residue.
     * @param {Residue} term Terminal residue.
     * @param {number} sense Sense of strand with respect to previous strand in the sheet.
     *   - 0 if the first strand,
     *   - 1 if parallel, and
     *   - -1 if anti-parallel.
     * @param {Atom} atomCur Atom in current strand (see PDB Format).
     * @param {Atom} atomPrev Atom in previous strand (see PDB Format).
     */
    function Strand(sheet, init, term, sense, atomCur, atomPrev) {
      var _this;

      classCallCheck(this, Strand);

      _this = _super.call(this, StructuralElement.Type.STRAND, init, term);
      /**
       * Parent sheet this strand belongs to.
       * @type {Sheet}
       */

      _this.sheet = sheet;
      /**
       * Sense of strand with respect to previous strand in the sheet.
       * - 0 if the first strand,
       * - 1 if parallel, and
       * - -1 if anti-parallel.
       * @type {number}
       */

      _this.sense = sense;
      /**
       * Atom in current strand (see PDB Format).
       * @type {Atom}
       */

      _this.atomCur = atomCur;
      /**
       * Atom in previous strand (see PDB Format).
       * @type {Atom}
       */

      _this.atomPrev = atomPrev;
      return _this;
    }
    /**
     * An internal method for making a final pass over the complex to set all required references.
     *
     * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
     * Just copying it as-is right now and hoping for the best.
     *
     * @param {object} serialAtomMap A dictionary of atoms
     * @param {object} residueHash A dictionary of hashed residues to check.
     * @param {Complex} complex The molecular complex this element belongs to.
     *
     * @override
     */


    createClass(Strand, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        get(getPrototypeOf(Strand.prototype), "_finalize", this).call(this, serialAtomMap, residueHash, complex);

        var as = this.atomCur;

        if (as !== null && !Number.isNaN(as)) {
          this.atomCur = serialAtomMap[as];
        }

        as = this.atomPrev;

        if (as !== null && !Number.isNaN(as)) {
          this.atomPrev = serialAtomMap[as];
        }
      }
    }]);

    return Strand;
  }(StructuralElement);

  /**
   * Sheet secondary structure of a protein.
   *
   * @param {string} name -
   * @param {number} width -
   *
   * @exports Sheet
   * @constructor
   */

  var Sheet = /*#__PURE__*/function () {
    function Sheet(name, width) {
      classCallCheck(this, Sheet);

      this._name = name;
      this._width = width;
      this._strands = [];
    } // Getters and setters


    createClass(Sheet, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this._width;
      }
    }, {
      key: "addStrand",
      value: function addStrand(strand) {
        this._strands.push(strand);

        this._width = this._strands.length;
      }
    }, {
      key: "addEmptyStrand",
      value: function addEmptyStrand() {
        this._strands.push(new Strand(null, null, null, null, null, null));
      }
    }, {
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        var s = this._strands;

        for (var i = 0, n = s.length; i < n; ++i) {
          s[i]._finalize(serialAtomMap, residueHash, complex);
        }

        if (!this._width) {
          this._width = s.length;
        }

        if (s.length !== this._width) {
          throw new Error("Sheet ".concat(this._name, " is inconsistent."));
        }
      }
    }]);

    return Sheet;
  }();

  /**
   * Atom measurements.
   *
   * @param {string} id              - SGroup id
   * @param {string} name            - Name of the group
   * @param {THREE.Vector3} position - Registered coordinates
   * @param {array} atoms            - Atoms group consists of
   * @param {object} saveNode        - XML node from file for saving
   *
   * @exports SGroup
   * @constructor
   */

  var SGroup = /*#__PURE__*/function () {
    function SGroup(id, name, position, atoms, saveNode) {
      classCallCheck(this, SGroup);

      this._id = id;
      this._name = name;
      this._position = position || new THREE.Vector3();
      this._atoms = atoms || [];
      this._charge = 0; // default group charge

      this._repeat = 1; // how many times group repeated: always > 0

      this._center = null;
      this.xmlNodeRef = saveNode || null;
    }
    /**
     * Get atom full name.
     * @returns {string} Atom full name.
     */


    createClass(SGroup, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this._position;
      }
    }, {
      key: "getCentralPoint",
      value: function getCentralPoint() {
        return this._center;
      }
    }, {
      key: "_rebuildSGroupOnAtomChange",
      value: function _rebuildSGroupOnAtomChange() {
        var nLimon = 100000000;

        if (this._center === null) {
          return; // nothing to do if we are not relative
        }

        var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);

        for (var j = 0, n = this._atoms.length; j < n; j++) {
          var aPos = this._atoms[j].position;
          bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
          bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
        }

        this._center.addVectors(bLow, bHight);

        this._center.multiplyScalar(0.5);
      }
    }]);

    return SGroup;
  }();

  /* eslint-disable */
  // DO NOT EDIT! Automatically generated from .jison

  /* parser generated by jison 0.4.18 */

  /*
    Returns a Parser object of the following structure:

    Parser: {
      yy: {}
    }

    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),

          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },

          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }


    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }


    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
      }

      return _o;
    },
        $V0 = [1, 4],
        $V1 = [1, 5],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 8],
        $V5 = [1, 9],
        $V6 = [1, 11],
        $V7 = [1, 12],
        $V8 = [5, 7, 8, 11],
        $V9 = [1, 17],
        $Va = [1, 22],
        $Vb = [1, 20],
        $Vc = [1, 21],
        $Vd = [5, 7, 8, 11, 19];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "Program": 3,
        "Expression": 4,
        "EOF": 5,
        "Selector": 6,
        "OR": 7,
        "AND": 8,
        "NOT": 9,
        "(": 10,
        ")": 11,
        "SELECTOR": 12,
        "NAMED_SELECTOR": 13,
        "SELECTOR_RANGED": 14,
        "RangeList": 15,
        "SELECTOR_NAMED": 16,
        "NameList": 17,
        "Range": 18,
        ",": 19,
        "NUMBER": 20,
        ":": 21,
        "Name": 22,
        "IDENTIFIER": 23,
        "STRING": 24,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        7: "OR",
        8: "AND",
        9: "NOT",
        10: "(",
        11: ")",
        12: "SELECTOR",
        13: "NAMED_SELECTOR",
        14: "SELECTOR_RANGED",
        16: "SELECTOR_NAMED",
        19: ",",
        20: "NUMBER",
        21: ":",
        23: "IDENTIFIER",
        24: "STRING"
      },
      productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return $$[$0 - 1];

          case 3:
            this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
            break;

          case 4:
            this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
            break;

          case 5:
            this.$ = yy.keyword('not')($$[$0]);
            break;

          case 6:
            this.$ = $$[$0 - 1];
            break;

          case 7:
            this.$ = yy.keyword($$[$0])();
            break;

          case 8:
            this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
            break;

          case 9:
          case 10:
            this.$ = yy.keyword($$[$0 - 1])($$[$0]);
            break;

          case 11:
            this.$ = new yy.RangeList($$[$0]);
            break;

          case 12:
          case 16:
            this.$ = $$[$0 - 2].append($$[$0]);
            break;

          case 13:
            this.$ = new yy.Range(Number($$[$0]));
            break;

          case 14:
            this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
            break;

          case 15:
            this.$ = new yy.ValueList($$[$0]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        1: [3]
      }, {
        5: [1, 10],
        7: $V6,
        8: $V7
      }, o($V8, [2, 2]), {
        4: 13,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 14,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 7]), o($V8, [2, 8]), {
        15: 15,
        18: 16,
        20: $V9
      }, {
        17: 18,
        20: $Va,
        22: 19,
        23: $Vb,
        24: $Vc
      }, {
        1: [2, 1]
      }, {
        4: 23,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 24,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 5]), {
        7: $V6,
        8: $V7,
        11: [1, 25]
      }, o($V8, [2, 9], {
        19: [1, 26]
      }), o($Vd, [2, 11]), o($Vd, [2, 13], {
        21: [1, 27]
      }), o($V8, [2, 10], {
        19: [1, 28]
      }), o($Vd, [2, 15]), o($Vd, [2, 17]), o($Vd, [2, 18]), o($Vd, [2, 19]), o([5, 7, 11], [2, 3], {
        8: $V7
      }), o($V8, [2, 4]), o($V8, [2, 6]), {
        18: 29,
        20: $V9
      }, {
        20: [1, 30]
      }, {
        20: $Va,
        22: 31,
        23: $Vb,
        24: $Vc
      }, o($Vd, [2, 12]), o($Vd, [2, 14]), o($Vd, [2, 16])],
      defaultActions: {
        10: [2, 1]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            tstack = [],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = tstack.pop() || lexer.lex() || EOF;

          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token;
              token = tstack.pop();
            }

            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          "case-insensitive": true
        },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

          switch ($avoiding_name_collisions) {
            case 0:
              /* skip whitespace */
              break;

            case 1:
              return 20;

            case 2:
              return 7;

            case 3:
              return 8;

            case 4:
              return 9;

            case 5:
              return 12;

            case 6:
              return 16;

            case 7:
              return 14;

            case 8:
              return 10;

            case 9:
              return 11;

            case 10:
              return 19;

            case 11:
              return 21;

            case 12:
              return '<=';

            case 13:
              return '>=';

            case 14:
              return '<';

            case 15:
              return '>';

            case 16:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
              return 24;

            case 17:
              return 13;

            case 18:
              return 23;

            case 19:
              return 5;

            case 20:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  var SelectionParser = {
    parser: parser
  };
  var SelectionParser_1 = SelectionParser.parser;

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var Range = /*#__PURE__*/function () {
    function Range(min, max) {
      classCallCheck(this, Range);

      this.min = min;
      this.max = typeof max === 'undefined' ? min : max;
    }

    createClass(Range, [{
      key: "includes",
      value: function includes(value) {
        return this.min <= value && value <= this.max;
      }
    }, {
      key: "toString",
      value: function toString() {
        var min = this.min,
            max = this.max;
        return min === max ? String(min) : [min, max].join(':');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.min, this.max];
      }
    }]);

    return Range;
  }(); // ////////////////////////////////////////////////////////////////////////////


  var List = /*#__PURE__*/function () {
    function List(arg) {
      classCallCheck(this, List);

      if (arg instanceof this.constructor) {
        return arg;
      }

      if (arg instanceof Array) {
        this._values = arg.slice(0);
      } else if (arg) {
        this._values = [arg];
      } else {
        this._values = [];
      }
    }

    createClass(List, [{
      key: "append",
      value: function append(value) {
        var values = this._values;
        values[values.length] = value;
        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        var values = this._values;
        var index = values.indexOf(value);

        if (index >= 0) {
          values.splice(index, 1);
        }

        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._values.join(',');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var values = this._values;
        var result = [];

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];
          result[i] = value.toJSON ? value.toJSON() : value;
        }

        return result;
      }
    }]);

    return List;
  }(); //----------------------------------------------------------------------------


  var RangeList = /*#__PURE__*/function (_List) {
    inherits(RangeList, _List);

    var _super = _createSuper$4(RangeList);

    function RangeList() {
      classCallCheck(this, RangeList);

      return _super.apply(this, arguments);
    }

    createClass(RangeList, [{
      key: "includes",
      value: function includes(value) {
        var list = this._values;

        for (var i = 0, n = list.length; i < n; ++i) {
          if (list[i].includes(value)) {
            return true;
          }
        }

        return false;
      }
    }]);

    return RangeList;
  }(List); //----------------------------------------------------------------------------


  var valuesArray = [];

  var ValueList = /*#__PURE__*/function (_List2) {
    inherits(ValueList, _List2);

    var _super2 = _createSuper$4(ValueList);

    function ValueList(arg, upperOnly) {
      var _this;

      classCallCheck(this, ValueList);

      var list = _this = _super2.call(this, arg);

      if (upperOnly) {
        _this.upperOnly = true;
        var values = list._values;

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];

          if (typeof value === 'string') {
            values[i] = value.toUpperCase();
          }
        }
      } else {
        _this.upperOnly = false;
      }

      return possibleConstructorReturn(_this, list);
    }

    createClass(ValueList, [{
      key: "includes",
      value: function includes(value) {
        // we do not convert to upper case here for perfomance reasons
        // if list is upper case only, value must be converted before it is sent up to  here
        return this._values.indexOf(value) !== -1;
      }
    }, {
      key: "toString",
      value: function toString() {
        // Quote values that are not correct identifiers
        var values = this._values;
        valuesArray.length = 0;

        for (var i = 0, n = values.length; i < n; ++i) {
          valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]));
        }

        return valuesArray.join(',');
      }
    }, {
      key: "_validate",
      value: function _validate(value) {
        return this.upperOnly && typeof value === 'string' ? value.toUpperCase() : value;
      }
    }, {
      key: "append",
      value: function append(value) {
        get(getPrototypeOf(ValueList.prototype), "append", this).call(this, this._validate(value));

        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        get(getPrototypeOf(ValueList.prototype), "remove", this).call(this, this._validate(value));

        return this;
      }
    }]);

    return ValueList;
  }(List);

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /** Base class for atom selectors. */

  var Selector = /*#__PURE__*/function () {
    function Selector() {
      classCallCheck(this, Selector);
    }

    createClass(Selector, [{
      key: "toString",
      value: function toString() {
        return this.keyword;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name];
      }
    }]);

    return Selector;
  }();

  Selector.prototype.name = 'Error';
  Selector.prototype.keyword = 'error';
  /** Base class for list-based atom selectors. */

  var ListSelector = /*#__PURE__*/function (_Selector) {
    inherits(ListSelector, _Selector);

    var _super = _createSuper$5(ListSelector);

    function ListSelector(list) {
      var _this;

      classCallCheck(this, ListSelector);

      _this = _super.call(this);
      _this.list = list;
      return _this;
    }

    createClass(ListSelector, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.keyword, " ").concat(this.list);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.list.toJSON()];
      }
    }]);

    return ListSelector;
  }(Selector);

  var RangeListSelector = /*#__PURE__*/function (_ListSelector) {
    inherits(RangeListSelector, _ListSelector);

    var _super2 = _createSuper$5(RangeListSelector);

    function RangeListSelector(arg) {
      classCallCheck(this, RangeListSelector);

      return _super2.call(this, new RangeList(arg));
    }

    return RangeListSelector;
  }(ListSelector);

  var ValueListSelector = /*#__PURE__*/function (_ListSelector2) {
    inherits(ValueListSelector, _ListSelector2);

    var _super3 = _createSuper$5(ValueListSelector);

    function ValueListSelector(arg, caseSensitive) {
      classCallCheck(this, ValueListSelector);

      return _super3.call(this, new ValueList(arg, !caseSensitive));
    }

    return ValueListSelector;
  }(ListSelector);

  var NoneSelector = /*#__PURE__*/function (_Selector2) {
    inherits(NoneSelector, _Selector2);

    var _super4 = _createSuper$5(NoneSelector);

    function NoneSelector() {
      classCallCheck(this, NoneSelector);

      return _super4.apply(this, arguments);
    }

    createClass(NoneSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return false;
      }
    }]);

    return NoneSelector;
  }(Selector);

  NoneSelector.prototype.name = 'None';
  NoneSelector.prototype.keyword = 'none';

  var AllSelector = /*#__PURE__*/function (_Selector3) {
    inherits(AllSelector, _Selector3);

    var _super5 = _createSuper$5(AllSelector);

    function AllSelector() {
      classCallCheck(this, AllSelector);

      return _super5.apply(this, arguments);
    }

    createClass(AllSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return true;
      }
    }]);

    return AllSelector;
  }(Selector);

  AllSelector.prototype.name = 'All';
  AllSelector.prototype.keyword = 'all';

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  // Operators
  //----------------------------------------------------------------------------

  var none = new NoneSelector();

  var PrefixOperator = /*#__PURE__*/function (_Selector) {
    inherits(PrefixOperator, _Selector);

    var _super = _createSuper$6(PrefixOperator);

    function PrefixOperator(rhs) {
      var _this;

      classCallCheck(this, PrefixOperator);

      _this = _super.call(this);
      _this.rhs = rhs || none;
      return _this;
    }

    createClass(PrefixOperator, [{
      key: "toString",
      value: function toString() {
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.rhs.toJSON()];
      }
    }]);

    return PrefixOperator;
  }(Selector);

  PrefixOperator.prototype.priority = 1;

  var InfixOperator = /*#__PURE__*/function (_Selector2) {
    inherits(InfixOperator, _Selector2);

    var _super2 = _createSuper$6(InfixOperator);

    function InfixOperator(lhs, rhs) {
      var _this2;

      classCallCheck(this, InfixOperator);

      _this2 = _super2.call(this);
      _this2.lhs = lhs || none;
      _this2.rhs = rhs || none;
      return _this2;
    }

    createClass(InfixOperator, [{
      key: "toString",
      value: function toString() {
        var lhs = this.lhs.priority && this.lhs.priority > this.priority ? "(".concat(this.lhs, ")") : this.lhs;
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(lhs, " ").concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
      }
    }]);

    return InfixOperator;
  }(Selector);

  InfixOperator.prototype.priority = 1000;

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var keywords = {}; //----------------------------------------------------------------------------
  // Named selectors
  //----------------------------------------------------------------------------

  function defineSelector(name, SelectorClass) {
    var keyword = name.toLowerCase();
    SelectorClass.prototype.keyword = keyword;
    SelectorClass.prototype.name = name;

    var factory = function factory() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return construct(SelectorClass, args);
    };

    factory.SelectorClass = SelectorClass;
    keywords[keyword] = factory;
    return SelectorClass;
  }

  defineSelector('Serial', /*#__PURE__*/function (_RangeListSelector) {
    inherits(SerialSelector, _RangeListSelector);

    var _super = _createSuper$7(SerialSelector);

    function SerialSelector() {
      classCallCheck(this, SerialSelector);

      return _super.apply(this, arguments);
    }

    createClass(SerialSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.serial);
      }
    }]);

    return SerialSelector;
  }(RangeListSelector));
  defineSelector('Name', /*#__PURE__*/function (_ValueListSelector) {
    inherits(NameSelector, _ValueListSelector);

    var _super2 = _createSuper$7(NameSelector);

    function NameSelector() {
      classCallCheck(this, NameSelector);

      return _super2.apply(this, arguments);
    }

    createClass(NameSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.name);
      }
    }]);

    return NameSelector;
  }(ValueListSelector));
  defineSelector('AltLoc', /*#__PURE__*/function (_ValueListSelector2) {
    inherits(AltLocSelector, _ValueListSelector2);

    var _super3 = _createSuper$7(AltLocSelector);

    function AltLocSelector() {
      classCallCheck(this, AltLocSelector);

      return _super3.apply(this, arguments);
    }

    createClass(AltLocSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(String.fromCharCode(atom.location));
      }
    }]);

    return AltLocSelector;
  }(ValueListSelector));
  defineSelector('Elem', /*#__PURE__*/function (_ValueListSelector3) {
    inherits(ElemSelector, _ValueListSelector3);

    var _super4 = _createSuper$7(ElemSelector);

    function ElemSelector() {
      classCallCheck(this, ElemSelector);

      return _super4.apply(this, arguments);
    }

    createClass(ElemSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.element.name);
      }
    }]);

    return ElemSelector;
  }(ValueListSelector));
  defineSelector('Residue', /*#__PURE__*/function (_ValueListSelector4) {
    inherits(ResidueSelector, _ValueListSelector4);

    var _super5 = _createSuper$7(ResidueSelector);

    function ResidueSelector() {
      classCallCheck(this, ResidueSelector);

      return _super5.apply(this, arguments);
    }

    createClass(ResidueSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._type._name);
      }
    }]);

    return ResidueSelector;
  }(ValueListSelector));
  defineSelector('Sequence', /*#__PURE__*/function (_RangeListSelector2) {
    inherits(SequenceSelector, _RangeListSelector2);

    var _super6 = _createSuper$7(SequenceSelector);

    function SequenceSelector() {
      classCallCheck(this, SequenceSelector);

      return _super6.apply(this, arguments);
    }

    createClass(SequenceSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._sequence);
      }
    }]);

    return SequenceSelector;
  }(RangeListSelector));
  defineSelector('ICode', /*#__PURE__*/function (_ValueListSelector5) {
    inherits(ICodeSelector, _ValueListSelector5);

    var _super7 = _createSuper$7(ICodeSelector);

    function ICodeSelector(arg) {
      classCallCheck(this, ICodeSelector);

      return _super7.call(this, arg, true);
    }

    createClass(ICodeSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._icode);
      }
    }]);

    return ICodeSelector;
  }(ValueListSelector));
  defineSelector('ResIdx', /*#__PURE__*/function (_RangeListSelector3) {
    inherits(ResIdxSelector, _RangeListSelector3);

    var _super8 = _createSuper$7(ResIdxSelector);

    function ResIdxSelector() {
      classCallCheck(this, ResIdxSelector);

      return _super8.apply(this, arguments);
    }

    createClass(ResIdxSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._index);
      }
    }]);

    return ResIdxSelector;
  }(RangeListSelector));
  defineSelector('Chain', /*#__PURE__*/function (_ValueListSelector6) {
    inherits(ChainSelector, _ValueListSelector6);

    var _super9 = _createSuper$7(ChainSelector);

    function ChainSelector(arg) {
      classCallCheck(this, ChainSelector);

      return _super9.call(this, arg, true);
    }

    createClass(ChainSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._chain._name);
      }
    }]);

    return ChainSelector;
  }(ValueListSelector));
  defineSelector('Hetatm', /*#__PURE__*/function (_Selector) {
    inherits(HetatmSelector, _Selector);

    var _super10 = _createSuper$7(HetatmSelector);

    function HetatmSelector() {
      classCallCheck(this, HetatmSelector);

      return _super10.apply(this, arguments);
    }

    createClass(HetatmSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return atom.het;
      }
    }]);

    return HetatmSelector;
  }(Selector));
  defineSelector('PolarH', /*#__PURE__*/function (_Selector2) {
    inherits(PolarHSelector, _Selector2);

    var _super11 = _createSuper$7(PolarHSelector);

    function PolarHSelector() {
      classCallCheck(this, PolarHSelector);

      return _super11.apply(this, arguments);
    }

    createClass(PolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.HYDROGEN;
      }
    }]);

    return PolarHSelector;
  }(Selector));
  defineSelector('NonPolarH', /*#__PURE__*/function (_Selector3) {
    inherits(NonPolarHSelector, _Selector3);

    var _super12 = _createSuper$7(NonPolarHSelector);

    function NonPolarHSelector() {
      classCallCheck(this, NonPolarHSelector);

      return _super12.apply(this, arguments);
    }

    createClass(NonPolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.NONPOLARH;
      }
    }]);

    return NonPolarHSelector;
  }(Selector));
  defineSelector('All', AllSelector);
  defineSelector('None', NoneSelector);
  var NULL_SELECTOR = keywords.none(); //----------------------------------------------------------------------------
  // Named operators
  //----------------------------------------------------------------------------

  function defineOperator(name, priority, OperatorClass) {
    OperatorClass.prototype.priority = priority;
    return defineSelector(name, OperatorClass);
  }

  defineOperator('Not', 1, /*#__PURE__*/function (_PrefixOperator) {
    inherits(NotOperator, _PrefixOperator);

    var _super13 = _createSuper$7(NotOperator);

    function NotOperator() {
      classCallCheck(this, NotOperator);

      return _super13.apply(this, arguments);
    }

    createClass(NotOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return !this.rhs.includesAtom(atom);
      }
    }]);

    return NotOperator;
  }(PrefixOperator));
  defineOperator('And', 2, /*#__PURE__*/function (_InfixOperator) {
    inherits(AndOperator, _InfixOperator);

    var _super14 = _createSuper$7(AndOperator);

    function AndOperator() {
      classCallCheck(this, AndOperator);

      return _super14.apply(this, arguments);
    }

    createClass(AndOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
      }
    }]);

    return AndOperator;
  }(InfixOperator));
  defineOperator('Or', 3, /*#__PURE__*/function (_InfixOperator2) {
    inherits(OrOperator, _InfixOperator2);

    var _super15 = _createSuper$7(OrOperator);

    function OrOperator() {
      classCallCheck(this, OrOperator);

      return _super15.apply(this, arguments);
    }

    createClass(OrOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
      }
    }]);

    return OrOperator;
  }(InfixOperator)); //----------------------------------------------------------------------------
  // Flag selectors
  //----------------------------------------------------------------------------

  function byResidueTypeFlag(flag, name) {
    return defineSelector(name, /*#__PURE__*/function (_Selector4) {
      inherits(_class, _Selector4);

      var _super16 = _createSuper$7(_class);

      function _class() {
        classCallCheck(this, _class);

        return _super16.apply(this, arguments);
      }

      createClass(_class, [{
        key: "includesAtom",
        value: function includesAtom(atom) {
          return (atom.residue._type.flags & flag) !== 0;
        }
      }]);

      return _class;
    }(Selector));
  }

  byResidueTypeFlag(ResidueType.Flags.PROTEIN, 'Protein');
  byResidueTypeFlag(ResidueType.Flags.BASIC, 'Basic');
  byResidueTypeFlag(ResidueType.Flags.ACIDIC, 'Acidic');
  byResidueTypeFlag(ResidueType.Flags.BASIC | ResidueType.Flags.ACIDIC, 'Charged');
  byResidueTypeFlag(ResidueType.Flags.POLAR, 'Polar');
  byResidueTypeFlag(ResidueType.Flags.NONPOLAR, 'NonPolar');
  byResidueTypeFlag(ResidueType.Flags.AROMATIC, 'Aromatic');
  byResidueTypeFlag(ResidueType.Flags.NUCLEIC, 'Nucleic');
  byResidueTypeFlag(ResidueType.Flags.PURINE, 'Purine');
  byResidueTypeFlag(ResidueType.Flags.PYRIMIDINE, 'Pyrimidine');
  byResidueTypeFlag(ResidueType.Flags.WATER, 'Water'); //----------------------------------------------------------------------------

  var selectors = Object.create(keywords);
  selectors.Selector = Selector;
  selectors.RangeListSelector = RangeListSelector;
  selectors.ValueListSelector = ValueListSelector;
  selectors.Range = Range;
  selectors.RangeList = RangeList;
  selectors.ValueList = ValueList;
  selectors.PrefixOperator = PrefixOperator;
  selectors.InfixOperator = InfixOperator;
  selectors.Context = Object.create({});

  selectors.GetSelector = function (key) {
    if (!selectors.Context.hasOwnProperty(key)) {
      var exc = {
        message: "selector ".concat(key, " is not registered")
      };
      throw exc;
    }

    return selectors.Context[key] || NULL_SELECTOR;
  };

  selectors.ClearContext = function () {
    Object.keys(selectors.Context).forEach(function (k) {
      delete selectors.Context[k];
    });
  };

  selectors.keyword = function (key) {
    return keywords[key.toLowerCase()] || keywords.none;
  };

  selectors.parse = function (str) {
    var res = {};

    try {
      res.selector = SelectionParser_1.parse(str);
    } catch (e) {
      res.selector = NULL_SELECTOR;
      res.error = e.message;
    }

    return res;
  };

  SelectionParser_1.yy = selectors;
  SelectionParser_1.yy.parseError = SelectionParser_1.parseError; // workaround for incorrect JISON parser generator for AMD module

  /**
   * Basic biological unit class.
   *
   * @exports BiologicalUnit
   * @constructor
   */

  var BiologicalUnit = /*#__PURE__*/function () {
    function BiologicalUnit(complex) {
      classCallCheck(this, BiologicalUnit);

      this._complex = complex;
      this._selector = selectors.keyword('All')();
      this._boundaries = {
        boundingBox: new THREE.Box3(),
        boundingSphere: new THREE.Sphere()
      };
    }

    createClass(BiologicalUnit, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        var atoms = this._complex._atoms;
        var n = atoms.length;
        var selector = this._selector;
        var boundingBox = this._boundaries.boundingBox;
        boundingBox.makeEmpty();

        if (n === 1) {
          boundingBox.expandByPoint(atoms[0].position);
          var bbc = new THREE.Vector3();
          boundingBox.getCenter(bbc);
          var s = 2 * atoms[0].element.radius;
          boundingBox.setFromCenterAndSize(bbc, new THREE.Vector3(s, s, s));
        } else {
          for (var i = 0; i < n; ++i) {
            if (selector.includesAtom(atoms[i])) {
              boundingBox.expandByPoint(atoms[i].position);
            }
          }
        } // Build bounding sphere


        var radiusSquared = 0.0;
        var center = new THREE.Vector3();
        boundingBox.getCenter(center);

        if (n === 1) {
          this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
        } else {
          for (var _i = 0; _i < n; ++_i) {
            if (!selector.includesAtom(atoms[_i])) {
              continue;
            }

            var pos = atoms[_i].position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return [];
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this._selector;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._boundaries;
      }
    }, {
      key: "finalize",
      value: function finalize() {}
    }]);

    return BiologicalUnit;
  }();

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Biological assembly.
   *
   * @exports Assembly
   * @constructor
   */

  var Assembly = /*#__PURE__*/function (_BiologicalUnit) {
    inherits(Assembly, _BiologicalUnit);

    var _super = _createSuper$8(Assembly);

    function Assembly(complex) {
      var _this;

      classCallCheck(this, Assembly);

      _this = _super.call(this, complex);
      _this.chains = [];
      _this.matrices = [];
      return _this;
    }

    createClass(Assembly, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        get(getPrototypeOf(Assembly.prototype), "computeBoundaries", this).call(this); // fix up the boundaries


        var matrices = this.matrices;
        var oldCenter = this._boundaries.boundingSphere.center;
        var oldRad = this._boundaries.boundingSphere.radius;
        var boundingBox = this._boundaries.boundingBox = new THREE.Box3();
        boundingBox.makeEmpty();

        for (var i = 0, n = matrices.length; i < n; ++i) {
          boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i]));
        }

        var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
        var center = new THREE.Vector3();
        boundingBox.getCenter(center);
        this._boundaries.boundingSphere = new THREE.Sphere().set(center, newRad);
        boundingBox.max.addScalar(oldRad);
        boundingBox.min.subScalar(oldRad);
      }
      /**
       * Mark a chain as belonging to this biological assembly.
       * @param {string} chain - chain identifier, usually a single letter
       */

    }, {
      key: "addChain",
      value: function addChain(chain) {
        this.chains[this.chains.length] = chain;
      }
      /**
       * Add a transformation matrix.
       * @param {THREE.Matrix4} matrix - transformation matrix
       */

    }, {
      key: "addMatrix",
      value: function addMatrix(matrix) {
        this.matrices[this.matrices.length] = matrix;
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.matrices;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this.chains.length > 0) {
          this._selector = selectors.keyword('Chain')(this.chains);
        } else {
          this._selector = selectors.keyword('None')();
        }
      }
    }]);

    return Assembly;
  }(BiologicalUnit);

  /**
   * This class represents connected component as a part of a complex.
   * WARNING! The whole component entity is build under the assumption that residues
   * are placed in the chains and complex in ascending order of indices
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   *
   * @exports Component
   * @constructor
   */
  var Component = /*#__PURE__*/function () {
    function Component(complex) {
      classCallCheck(this, Component);

      this._complex = complex;
      this._index = -1;
      this._residueIndices = [];
      this._cycles = [];
      this._subDivs = [];
      this._residueCount = 0;
    }

    createClass(Component, [{
      key: "getResidues",
      value: function getResidues() {
        return this._complex._residues;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residueCount;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._complex._residues;
        var resIdc = this._residueIndices;

        for (var idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
          for (var idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
            process(residues[idx]);
          }
        }
      }
    }, {
      key: "setSubDivs",
      value: function setSubDivs(subDivs) {
        this._subDivs = subDivs;
        var curr = 0;
        var resIdc = [];
        var resCnt = 0;

        for (var i = 0, n = subDivs.length; i < n; ++i) {
          if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
            var start = subDivs[curr].start;
            var end = subDivs[i].end;
            resIdc[resIdc.length] = {
              start: start,
              end: end
            };
            resCnt += end - start + 1;
            curr = i + 1;
          }
        }

        this._residueIndices = resIdc;
        this._residueCount = resCnt;
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._complex._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var bond = bonds[i];

          if (bond._left.residue._component === this) {
            process(bond);
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        this.forEachCycle(function (cycle) {
          cycle.update();
        });
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        this.forEachResidue(function (residue) {
          residue.forEachAtom(process);
        });
      }
    }, {
      key: "addCycle",
      value: function addCycle(cycle) {
        this._cycles.push(cycle);
      }
    }, {
      key: "forEachCycle",
      value: function forEachCycle(process) {
        var cycles = this._cycles;

        for (var i = 0, n = cycles.length; i < n; ++i) {
          process(cycles[i]);
        }
      }
    }, {
      key: "markResidues",
      value: function markResidues() {
        var self = this;
        self.forEachResidue(function (residue) {
          residue._component = self;
        });
      }
    }, {
      key: "_forEachSubChain",
      value: function _forEachSubChain(mask, process) {
        var residues = this._complex._residues;
        var subs = this._subDivs;

        for (var i = 0, n = subs.length; i < n; ++i) {
          for (var idx = subs[i].start, last = subs[i].end; idx <= last; ++idx) {
            var currRes = residues[idx];

            if (mask & currRes._mask && currRes._isValid) {
              var end = idx + 1;

              for (; end <= last; ++end) {
                var endRes = residues[end];

                if (!(mask & endRes._mask && endRes._isValid)) {
                  break;
                }
              }

              process(i, idx, end - 1);
              idx = end;
            }
          }
        }
      }
    }, {
      key: "getMaskedSequences",
      value: function getMaskedSequences(mask) {
        var subs = [];
        var idx = 0;

        this._forEachSubChain(mask, function (_subIdx, start, end) {
          subs[idx++] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }, {
      key: "getMaskedSubdivSequences",
      value: function getMaskedSubdivSequences(mask) {
        var subs = [];
        var currIdx = -1;
        var lastSubIdx = -1;
        var subDivs = this._subDivs;

        this._forEachSubChain(mask, function (subIdx, start, end) {
          if (lastSubIdx !== subIdx) {
            ++currIdx;
            subs[currIdx] = {
              arr: [],
              boundaries: subDivs[subIdx]
            };
            lastSubIdx = subIdx;
          }

          subs[currIdx].arr[subs[currIdx].arr.length] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }]);

    return Component;
  }();

  var cMaxPairsForHashCode = 32;
  var cHashTableSize = 1024 * 1024;
  var cNumbersPerPair = 4;
  var cMaxNeighbours = 14;
  var cInvalidVal = -1; // 89237 is a large simple number, can be used for pseudo random hash code create

  var cBigPrime = 89237;

  var AtomPairs = /*#__PURE__*/function () {
    function AtomPairs(maxPairsEstimate) {
      classCallCheck(this, AtomPairs);

      this.numPairs = 0;
      this.numMaxPairs = maxPairsEstimate;
      this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);

      for (var i = 0; i < maxPairsEstimate * cNumbersPerPair; i++) {
        this.intBuffer[i] = cInvalidVal;
      }

      this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);

      for (var _i = 0; _i < cHashTableSize * cMaxPairsForHashCode; _i++) {
        this.hashBuffer[_i] = cInvalidVal;
      }
    }
    /**
     * Destroy all pairs memory
     */


    createClass(AtomPairs, [{
      key: "destroy",
      value: function destroy() {
        this.intBuffer = null;
        this.hashBuffer = null;
      }
      /**
       * Add pair of atoms to collection
       * @param {number} indexA - Index of the 1st vertex.
       * @param {number} indexB - Index of the 2nd vertex.
       */

    }, {
      key: "addPair",
      value: function addPair(indexA, indexB) {
        var ia = indexA < indexB ? indexA : indexB;
        var ib = indexA > indexB ? indexA : indexB;
        var codeToAdd = ia + (ib << cMaxNeighbours);
        var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
        var j = hashCode * cMaxPairsForHashCode;
        var apI = 0;

        for (; apI < cMaxPairsForHashCode; apI++) {
          var code = this.hashBuffer[j + apI];

          if (code === cInvalidVal) {
            break;
          }

          if (code === codeToAdd) {
            return false;
          }
        } // add this new hash code


        if (apI >= cMaxPairsForHashCode) {
          throw new Error('addPair: increase cMaxPairsForHashCode');
        }

        this.hashBuffer[j + apI] = codeToAdd; // actually add

        if (this.numPairs >= this.numMaxPairs) {
          throw new Error('addPair: increase num pairs');
        }

        j = this.numPairs * cNumbersPerPair;
        this.intBuffer[j] = ia;
        this.intBuffer[j + 1] = ib;
        this.intBuffer[j + 2] = codeToAdd;
        this.numPairs++;
        return true;
      }
    }]);

    return AtomPairs;
  }();

  var cEstBondsMultiplier = 4;
  var cSpaceCode = 32;
  var cBondTolerance = 0.45;
  var cEpsilon = 0.001;
  /**
   * Get radius used for building bonds.
   *
   * @param {Atom} atom - Atom object.
   * @returns {number} special value for bonding radius for this atom
   */

  function _getBondingRadius(atom) {
    var element = atom.element;

    if (element) {
      return element.radiusBonding;
    }

    throw new Error('_getBondingRadius: Logic error.');
  }

  function _isAtomEligible(atom) {
    // build for all non-hetatm and for hetatm without bonds
    return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
  }
  /**
   * Bond between atoms.
   *
   * @param {Complex} complex molecular complex

   * @exports AutoBond
   * @constructor
   */


  var AutoBond = /*#__PURE__*/function () {
    function AutoBond(complex) {
      classCallCheck(this, AutoBond);

      this._complex = complex;
      this._maxRad = 1.8;

      var bBox = this._complex.getDefaultBoundaries().boundingBox;

      this._vBoxMin = bBox.min.clone();
      this._vBoxMax = bBox.max.clone();
      this._pairCollection = null;
    }
    /**
     * Add existing pairs of connectors (from pdb file after its reading)
     * @returns {number} 0
     */


    createClass(AutoBond, [{
      key: "_addExistingPairs",
      value: function _addExistingPairs() {
        var atoms = this._complex.getAtoms();

        var numAtoms = atoms.length;
        var aInd = 0;
        var collection = this._pairCollection;

        for (; aInd < numAtoms; aInd++) {
          var bonds = atoms[aInd].bonds;
          var numBondsForAtom = bonds.length;

          for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
            var bond = bonds[bInd];
            var indTo = bond._left.index;

            if (indTo === aInd) {
              collection.addPair(aInd, bond._right.index);
            }
          } // for (b) all bonds in atom

        } // for (a)


        return 0;
      }
    }, {
      key: "_findPairs",
      value: function _findPairs() {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var atoms = this._complex._atoms;
        var atomsNum = atoms.length;
        var self = this;
        var rA;
        var isHydrogenA;
        var posA;
        var locationA;
        var atomA;

        var processAtom = function processAtom(atomB) {
          if (isHydrogenA && atomB.isHydrogen()) {
            return;
          }

          var locationB = atomB.location;

          if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
            return;
          }

          var dist2 = posA.distanceToSquared(atomB.position);
          var rB = atomB.element.radiusBonding;
          var maxAcceptable =  rA + rB + cBondTolerance ;

          if (dist2 > maxAcceptable * maxAcceptable) {
            return;
          }

          if (dist2 < cEpsilon) {
            return;
          }

          self._pairCollection.addPair(atomA.index, atomB.index);
        };

        for (var i = 0; i < atomsNum; ++i) {
          atomA = atoms[i];

          if (!_isAtomEligible(atomA)) {
            continue;
          }

          rA = atomA.element.radiusBonding;
          isHydrogenA = atomA.isHydrogen();
          posA = atomA.position;
          locationA = atomA.location;
          vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
        }
      }
    }, {
      key: "_addPairs",
      value: function _addPairs() {
        var atoms = this._complex._atoms;

        for (var i = 0, k = 0; i < this._pairCollection.numPairs; i++, k += 4) {
          var iA = this._pairCollection.intBuffer[k];
          var iB = this._pairCollection.intBuffer[k + 1];

          this._addPair(atoms[iA], atoms[iB]);
        }
      }
    }, {
      key: "_addPair",
      value: function _addPair(atomA, atomB) {
        var bondsA = atomA.bonds;
        var indexA = atomA.index;
        var indexB = atomB.index;

        for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
          var bond = bondsA[j];

          if (bond._left.index === indexB || bond._right.index === indexB) {
            return;
          }
        }

        var left = indexA < indexB ? atomA : atomB;
        var right = indexA < indexB ? atomB : atomA;

        var newBond = this._complex.addBond(left, right, 0, Bond.BondType.UNKNOWN, false);

        bondsA.push(newBond);
        atomB.bonds.push(newBond);
      }
    }, {
      key: "build",
      value: function build() {

        this._buildInner();
      }
    }, {
      key: "_buildInner",
      value: function _buildInner() {
        var atoms = this._complex._atoms;

        if (atoms.length < 2) {
          return;
        }

        if (atoms[0].index < 0) {
          throw new Error('AutoBond: Atoms in complex were not indexed.');
        }

        this._calcBoundingBox();

        this._pairCollection = new AtomPairs(atoms.length * cEstBondsMultiplier);

        this._addExistingPairs();

        this._findPairs();

        this._addPairs();
      }
    }, {
      key: "_calcBoundingBox",
      value: function _calcBoundingBox() {
        var atoms = this._complex._atoms;
        var nAtoms = atoms.length;

        var maxRad = _getBondingRadius(atoms[0]);

        for (var i = 1; i < nAtoms; ++i) {
          maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
        }

        this._vBoxMax.addScalar(maxRad);

        this._vBoxMin.addScalar(-maxRad);

        this._maxRad = maxRad * 1.2;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._pairCollection) {
          this._pairCollection.destroy();
        }
      }
    }]);

    return AutoBond;
  }();

  var cCrossThresh = 0.1;
  var cAromaticType = Bond.BondType.AROMATIC;
  var cAromaticAtoms = [Element.ByName.C.number, Element.ByName.N.number // Element.ByName.O.number,
  // Element.ByName.S.number,
  ];
  /** Conditions for bonds:
     *   - Cross product with each subsequent bond to add is collinear and point to the same direction
     *   - Each pair of a adjacent bonds belong to not more than one cycle
     *   - If there is more than one candidates we try them in ascending order of angle values
     */

  var _coDirVectors = function () {
    var v1Tmp = new THREE.Vector3();
    var v2Tmp = new THREE.Vector3();
    var cp = new THREE.Vector3();
    return function (v1, v2) {
      v1Tmp.copy(v1).normalize();
      v2Tmp.copy(v2).normalize();
      cp.crossVectors(v1Tmp, v2Tmp);

      if (cp.length() > cCrossThresh) {
        return false;
      } // zero vector in out terms must be collinear to any


      return v1Tmp.dot(v2Tmp) >= 0;
    };
  }();

  function _insertAscending(arr, val) {
    var idx = 0;

    while (idx < arr.length && arr[idx] < val) {
      ++idx;
    }

    arr.splice(idx, 0, val);
  }

  function _anotherAtom(bond, currAtom) {
    return bond._left === currAtom ? bond._right : bond._left;
  }

  function _cosBetween(v1, v2) {
    var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
    return THREE.MathUtils.clamp(theta, -1, 1);
  }

  function _markAromatic(bond) {
    bond._type = cAromaticType;
  }

  var Cycle = /*#__PURE__*/function () {
    function Cycle(atomsList) {
      classCallCheck(this, Cycle);

      this.atoms = atomsList;
      this.update();
    }

    createClass(Cycle, [{
      key: "update",
      value: function update() {
        var atoms = this.atoms;
        var center = new THREE.Vector3();
        var nA = atoms.length;

        for (var j = 0; j < nA; ++j) {
          center.add(atoms[j].position);
        }

        center.multiplyScalar(1.0 / nA);
        this.center = center;
        this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var atoms = this.atoms;
        var nA = atoms.length;
        var currAtom = atoms[0];
        var nextAtom;

        function checkBond(bond) {
          if (bond._left === nextAtom || bond._right === nextAtom) {
            process(bond);
          }
        }

        for (var i = 0; i < nA; ++i) {
          nextAtom = atoms[(i + 1) % nA];
          currAtom.forEachBond(checkBond);
          currAtom = nextAtom;
        }
      }
    }]);

    return Cycle;
  }();

  function _isAromatic(bond) {
    return bond._type === cAromaticType;
  }

  function _isPossibleAromatic(bond) {
    if (bond.type === cAromaticType) {
      return true;
    }

    var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
    var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
    return rightIdx !== -1 && leftIdx !== -1;
  }

  function _checkCycleSimple(cycle) {
    return cycle.length > 3;
  }

  function _checkCycleComplex(cycle) {
    console.assert(cycle.length > 2);
    return true;
  }

  var AromaticLoopsMarker = /*#__PURE__*/function () {
    function AromaticLoopsMarker(complex) {
      classCallCheck(this, AromaticLoopsMarker);

      this._complex = complex;
      var bondsData = new Array(complex._bonds.length);
      var bondMarks = new Array(complex._bonds.length);

      for (var i = 0, n = bondsData.length; i < n; ++i) {
        bondsData[i] = [];
        bondMarks[i] = false;
      }

      this._bondsData = bondsData;
      this._bondMarks = bondMarks;

      this._resetCycles();
    }

    createClass(AromaticLoopsMarker, [{
      key: "_resetCycles",
      value: function _resetCycles() {
        this._cycles = [];
        this._currIdx = -1;
      }
    }, {
      key: "_haveSameCycle",
      value: function _haveSameCycle(bondsData, bond1, bond2) {
        var arr1 = bondsData[bond1._index];
        var arr2 = bondsData[bond2._index];
        var n1 = arr1.length;
        var n2 = arr2.length;
        var i1 = 0;
        var i2 = 0;

        while (i1 < n1 && i2 < n2) {
          if (arr1[i1] === arr2[i2]) {
            return true;
          }

          if (arr1[i1] > arr2[i2]) {
            ++i2;
          } else {
            ++i1;
          }
        }

        return false;
      }
    }, {
      key: "_tryBond",
      value: function _tryBond(prevBond, currRight, currDir) {
        var bondsOrder = [];
        var bondsData = this._bondsData;

        var currLeft = _anotherAtom(prevBond, currRight);

        var currVec = currRight.position.clone().sub(currLeft.position);
        var startAtomRef = this._currStart;
        var self = this;
        var bondMarks = this._bondMarks;
        var checkAromatic = this._checkBond;
        bondMarks[prevBond._index] = true;
        checkAromatic = checkAromatic === undefined ? _isAromatic : checkAromatic;
        currRight.forEachBond(function (newBond) {
          if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
            return;
          }

          var anotherAtom = _anotherAtom(newBond, currRight);

          var anotherVec = anotherAtom.position.clone().sub(currRight.position);
          var val = anotherAtom === startAtomRef ? -2.0 : 1 - _cosBetween(currVec, anotherVec);
          var newDir = anotherVec.cross(currVec);

          if (!_coDirVectors(newDir, currDir)) {
            return;
          }

          var idx = 0;

          while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
            ++idx;
          }

          bondsOrder.splice(idx, 0, {
            bond: newBond,
            val: val,
            dir: newDir
          });
        });

        for (var i = 0, n = bondsOrder.length; i < n; ++i) {
          var bond = bondsOrder[i].bond;
          var newRight = bond._left === currRight ? bond._right : bond._left;

          if (newRight === startAtomRef) {
            ++this._currIdx;

            this._cycles.push([currRight]);

            bondMarks[prevBond._index] = false;
            return true;
          }

          if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
            _insertAscending(bondsData[bond._index], this._currIdx);

            this._cycles[this._currIdx].push(currRight);

            bondMarks[prevBond._index] = false;
            return true;
          }
        }

        bondMarks[prevBond._index] = false;
        return false;
      }
    }, {
      key: "_startCycle",
      value: function _startCycle(bond) {
        // start from left to right
        this._currStart = bond._left;

        if (this._tryBond(bond, bond._right, new THREE.Vector3())) {
          _insertAscending(this._bondsData[bond._index], this._currIdx);

          this._cycles[this._currIdx].push(bond._left);
        }
      }
    }, {
      key: "_findLoops",
      value: function _findLoops(checkBond, checkCycle) {
        this._checkBond = checkBond;
        var complex = this._complex;
        var self = this;
        complex.forEachComponent(function (component) {
          self._resetCycles();

          component.forEachBond(function (bond) {
            if (checkBond(bond)) {
              self._startCycle(bond);
            }
          });
          var cycles = self._cycles;

          for (var i = 0, n = cycles.length; i < n; ++i) {
            var cycle = cycles[i];

            if (!checkCycle(cycle)) {
              continue;
            }

            var newCycle = new Cycle(cycle);
            newCycle.forEachBond(_markAromatic);
            component.addCycle(newCycle);
          }
        });
      }
    }, {
      key: "markCycles",
      value: function markCycles() {
        this._findLoops(_isAromatic, _checkCycleSimple);
      }
    }, {
      key: "detectCycles",
      value: function detectCycles() {
        this._findLoops(_isPossibleAromatic, _checkCycleComplex);
      }
    }]);

    return AromaticLoopsMarker;
  }();

  /**
   * Calculate min & max radius of a sphere slice between zMin & zMax
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {number} zMin - lower bound of the slice
   * @param {number} zMax - upper bound of the slice
   */

  function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
    var dzMin = zMin - center.z;
    var dzMax = zMax - center.z;
    var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0));
    var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0));
    var rMin = Math.min(rzMin, rzMax);
    var rMax;

    if (zMin <= center.z && zMax >= center.z) {
      // sphere's main diameter is inside slice
      rMax = radius;
    } else {
      rMax = Math.max(rzMin, rzMax);
    }

    return [rMin, rMax];
  }
  /**
   * Calculate min & max radius of a circle slice between yMin & yMax.
   *
   * To maintain analogy with _getSphereSliceRadiusRange we call radius what in fact is
   * half-width (along X axis) of the slice, i.e. 1D-sphere radius.
   *
   * @param {Vector3} center - center of the circle (z can be ignored)
   * @param {number} radius  - circle radius
   * @param {number} yMin - lower bound of the slice
   * @param {number} yMax - upper bound of the slice
   * @returns {Array} - array of two numbers (min & max radius, or half-width)
   */


  function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
    var dyMin = yMin - center.y;
    var dyMax = yMax - center.y;
    var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0));
    var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0));
    var rMin = Math.min(ryMin, ryMax);
    var rMax;

    if (yMin <= center.y && yMax >= center.y) {
      // slice's main diameter is inside slice
      rMax = radius;
    } else {
      rMax = Math.max(ryMin, ryMax);
    }

    return [rMin, rMax];
  }
  /**
   * VoxelWorld constructor
   *
   * @param {Box3} box - bounding box of the volume to be partitioned
   * @param {Vector3} vCellSizeHint - target voxel size (actual voxel size may differ from this)
   */


  var VoxelWorld = /*#__PURE__*/function () {
    function VoxelWorld(box, vCellSizeHint) {
      classCallCheck(this, VoxelWorld);

      this._box = box.clone();
      var size = new THREE.Vector3();
      box.getSize(size);
      this._count = size.clone().divide(vCellSizeHint).floor().max(new THREE.Vector3(1, 1, 1));
      this._last = this._count.clone().subScalar(1);
      this._cellSize = size.clone().divide(this._count);
      this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
      this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize)); // array of voxels, each element contains index of first atom in voxel

      var numVoxels = this._count.x * this._count.y * this._count.z;
      this._voxels = utils.allocateTyped(Int32Array, numVoxels);

      for (var i = 0; i < numVoxels; ++i) {
        this._voxels[i] = -1;
      } // array of atoms that stores multiple single-linked lists
      // two elements for each atom: Atom ref, index of next atom (in this array


      this._atoms = [];
    }
    /**
     * Add all atoms from a complex to voxel world
     *
     * @param {Complex} complex - complex
     */


    createClass(VoxelWorld, [{
      key: "addAtoms",
      value: function addAtoms(complex) {
        var self = this;
        var idx = this._atoms.length; // resize array of atoms

        this._atoms.length += 2 * complex.getAtomCount();
        complex.forEachAtom(function (atom) {
          // find which voxel contains this atom
          var voxelIdx = self._findVoxel(atom.position); // push current atom to the head of voxel's atom list


          self._atoms[idx] = atom;
          self._atoms[idx + 1] = self._voxels[voxelIdx];
          self._voxels[voxelIdx] = idx;
          idx += 2;
        });
      }
      /**
       * Get voxel that contains specified 3D point (we use clamp at the edges)
       *
       * @param {Vector3} point - a point in 3D
       * @returns {number} - index of voxel
       */

    }, {
      key: "_findVoxel",
      value: function _findVoxel(point) {
        var zero = VoxelWorld._zero;
        var voxel = VoxelWorld._voxel;
        voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
        return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
      }
      /**
       * Call a function for each atom in voxel
       *
       * @param {number} voxel - index of voxel
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "_forEachAtomInVoxel",
      value: function _forEachAtomInVoxel(voxel, process) {
        for (var i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
          process(this._atoms[i]);
        }
      }
      /**
       * Call a function for each voxel that is touched by given sphere. Callback also takes flag
       * isInside specifying whether voxel lies inside the sphere entirely.
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
       */

    }, {
      key: "_forEachVoxelWithinRadius",
      value: function _forEachVoxelWithinRadius(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange; // switch to a faster method unless cell size is much smaller than sphere radius

        if (radius / this._cellInnerR < 10) {
          this._forEachVoxelWithinRadiusSimple(center, radius, process);

          return;
        }

        var rRangeXY;
        var rRangeX;
        var xVal;
        var yVal;
        var zVal;
        var isInsideX;
        var isInsideY;
        var isInsideZ;
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
          rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
          yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
          yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
            rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
            xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
            xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
              process(x + this._count.x * (y + this._count.y * z), isInsideX && isInsideY && isInsideZ);
            }
          }
        }
      }
      /**
       * Call a function for each voxel that is touched by given sphere. Callback also takes flag
       * isInside specifying whether voxel lies inside the sphere entirely.
       * This is a version of method that doesn't try to "calculate" what voxels fall inside radius
       * but instead just checks all voxels inside sphere's bounding box. This should be faster
       * unless cell size is much smaller than sphere radius.
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
       */

    }, {
      key: "_forEachVoxelWithinRadiusSimple",
      value: function _forEachVoxelWithinRadiusSimple(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange;
        var vCenter = VoxelWorld._vCenter;
        var distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
        var distInside2 = -1.0;

        if (radius > this._cellOuterR) {
          distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
        } // calculate bounding box for the sphere


        xRange.set(center.x - radius, center.x + radius);
        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
        xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
        xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
        yRange.set(center.y - radius, center.y + radius);
        yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
        yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
        yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
        zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
        zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          var zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          vCenter.z = 0.5 * (zVal[0] + zVal[1]);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            var yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            vCenter.y = 0.5 * (yVal[0] + yVal[1]);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              var xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              vCenter.x = 0.5 * (xVal[0] + xVal[1]);
              var d2 = center.distanceToSquared(vCenter);

              if (d2 <= distTouch2) {
                process(x + this._count.x * (y + this._count.y * z), d2 <= distInside2);
              }
            }
          }
        }
      }
      /**
       * Call a function for each atom within given sphere
       *
       * @param {Vector3} center - center of the sphere
       * @param {number} radius  - sphere radius
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinRadius",
      value: function forEachAtomWithinRadius(center, radius, process) {
        var self = this;
        var r2 = radius * radius;

        self._forEachVoxelWithinRadius(center, radius, function (voxel, isInside) {
          if (isInside) {
            self._forEachAtomInVoxel(voxel, process);
          } else {
            self._forEachAtomInVoxel(voxel, function (atom) {
              if (center.distanceToSquared(atom.position) <= r2) {
                process(atom);
              }
            });
          }
        });
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms defined by mask
       *
       * @param {Complex} complex - complex
       * @param {number} mask - bit mask
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinDistFromMasked",
      value: function forEachAtomWithinDistFromMasked(complex, mask, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if ((atom.mask & mask) !== 0) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms defined by selector
       *
       * @param {Complex} complex - complex
       * @param {number} selector - selector
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "forEachAtomWithinDistFromSelected",
      value: function forEachAtomWithinDistFromSelected(complex, selector, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if (selector.includesAtom(atom)) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
      /**
       * Call a function for each atom of given complex within given distance from group of atoms
       *
       * @param {function} forEachAtom - enumerator of atoms in the group
       * @param {number} dist - distance
       * @param {function(Atom)} process - function to call
       */

    }, {
      key: "_forEachAtomWithinDistFromGroup",
      value: function _forEachAtomWithinDistFromGroup(forEachAtom, dist, process) {
        var self = this;
        var r2 = dist * dist;
        var voxels = [];
        var atoms = [];
        var idx = 0; // build "within radius" atom list for each voxel

        forEachAtom(function (atom) {
          self._forEachVoxelWithinRadius(atom.position, dist, function (voxel, isInside) {
            if (isInside) {
              // this voxel is inside circle -- no check will be required
              voxels[voxel] = -1;
            } else if (typeof voxels[voxel] === 'undefined') {
              // this voxel isn't covered yet -- start building list of atoms
              atoms.push(atom);
              atoms.push(-1);
              voxels[voxel] = idx;
              idx += 2;
            } else if (voxels[voxel] !== -1) {
              // this voxel has a list of atoms required for distance check -- add atom to the list
              atoms.push(atom);
              atoms.push(voxels[voxel]);
              voxels[voxel] = idx;
              idx += 2;
            }
          });
        });
        var voxel;

        var processIfWithin = function processIfWithin(atom) {
          if (typeof voxels[voxel] === 'undefined') {
            return;
          }

          idx = voxels[voxel];

          if (idx === -1) {
            // this voxel is fully covered
            process(atom);
            return;
          } // check distance to each atom within radius from this voxel


          for (; idx >= 0; idx = atoms[idx + 1]) {
            if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
              process(atom);
              break;
            }
          }
        }; // for each marked voxel


        for (voxel in voxels) {
          if (voxels.hasOwnProperty(voxel)) {
            self._forEachAtomInVoxel(voxel, processIfWithin);
          }
        }
      }
    }]);

    return VoxelWorld;
  }();

  defineProperty(VoxelWorld, "_zero", new THREE.Vector3(0, 0, 0));

  defineProperty(VoxelWorld, "_voxel", new THREE.Vector3());

  defineProperty(VoxelWorld, "_xRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_yRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_zRange", new THREE.Vector2());

  defineProperty(VoxelWorld, "_vCenter", new THREE.Vector3());

  var MINIMAL_DISTANCE = 0.5;
  var MIN_HBOND_ENERGY = -9.9;
  var MAX_HBOND_ENERGY = -0.5;
  var COUPLING_CONSTANT = -27.888; // = -332 * 0.42 * 0.2

  var MAX_COUPLING_DISTANCE = 5.0; // how far is the closest atom of a potential partner residue from CA atom

  var MAX_RESIDUES_THRESHOLD = 1000;

  var HBondInfo = /*#__PURE__*/function () {
    function HBondInfo(complex) {
      classCallCheck(this, HBondInfo);

      this._complex = complex;
      this._hbonds = []; // array of bond info for each residue

      if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
        this._buildVW(); // optimized version using voxel grid

      } else {
        this._build(); // test all pairs of residues

      }
    }

    createClass(HBondInfo, [{
      key: "isBond",
      value: function isBond(from, to) {
        if (this._hbonds[from]) {
          var _this$_hbonds$from$ac = slicedToArray(this._hbonds[from].acceptor, 2),
              acc0 = _this$_hbonds$from$ac[0],
              acc1 = _this$_hbonds$from$ac[1];

          if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
            return true;
          }

          if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "_build",
      value: function _build() {
        var self = this;

        for (var i = 0; i < this._complex._residues.length - 1; ++i) {
          var ri = this._complex._residues[i];

          if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            continue;
          } // get predecessor in chain


          var preri = null;

          if (i > 0 && this._complex._residues[i - 1].getType().flags & ResidueType.Flags.PROTEIN && ri._sequence === this._complex._residues[i - 1]._sequence + 1) {
            preri = this._complex._residues[i - 1];
          }

          for (var j = i + 1; j < this._complex._residues.length; ++j) {
            var rj = this._complex._residues[j];

            if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
              continue;
            } // get predecessor in chain


            var prerj = null;

            if (this._complex._residues[j - 1].getType().flags & ResidueType.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
              prerj = this._complex._residues[j - 1];
            }

            self._calcHBondEnergy(preri, ri, rj);

            if (j !== i + 1) {
              self._calcHBondEnergy(prerj, rj, ri);
            }
          }
        }
      }
    }, {
      key: "_buildVW",
      value: function _buildVW() {
        var self = this;
        var residues = this._complex._residues;
        var ri;
        var preri;

        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var pairs = new AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);

        function processAtom(atom) {
          var rj = atom.residue;

          if (rj._index === ri._index) {
            return;
          }

          if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            return;
          }

          if (!pairs.addPair(ri._index, rj._index)) {
            // we've seen this pair
            return;
          } // get predecessor in chain


          var prerj = rj._index > 0 ? residues[rj._index - 1] : null;

          if (prerj && ((prerj.getType().flags & ResidueType.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
            prerj = null;
          }

          self._calcHBondEnergy(preri, ri, rj);

          if (rj._index !== ri._index + 1) {
            self._calcHBondEnergy(prerj, rj, ri);
          }
        }

        for (var i = 0; i < residues.length - 1; ++i) {
          ri = residues[i];

          if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
            continue;
          } // get predecessor in chain


          preri = i > 0 ? residues[i - 1] : null;

          if (preri && ((preri.getType().flags & ResidueType.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
            preri = null;
          }

          vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_residueGetCO",
      value: function _residueGetCO(res) {
        var c = null;
        var o = null;
        res.forEachAtom(function (a) {
          if (a.name === 'C') {
            c = a.position;
          } else if (a.name === 'O') {
            o = a.position;
          }
        });
        return [c, o];
      } // TODO Support hydrogen defined in complex

    }, {
      key: "_residueGetNH",
      value: function _residueGetNH(prev, res) {
        var _this$_residueGetCO = this._residueGetCO(prev),
            _this$_residueGetCO2 = slicedToArray(_this$_residueGetCO, 2),
            c = _this$_residueGetCO2[0],
            o = _this$_residueGetCO2[1];

        var n;
        res.forEachAtom(function (a) {
          if (a.name === 'N') {
            n = a.position;
          }
        });

        if (c && o && n) {
          // calculate hydrogen position
          var h = c.clone();
          h.sub(o);
          h.multiplyScalar(1.0 / h.length());
          h.add(n);
          return [n, h];
        }

        return [null, null];
      }
    }, {
      key: "_calcHBondEnergy",
      value: function _calcHBondEnergy(predonor, donor, acceptor) {
        var result = 0;

        if (predonor === null) {
          return result;
        }

        if (donor.getType().getName() !== 'PRO') {
          var _this$_residueGetNH = this._residueGetNH(predonor, donor),
              _this$_residueGetNH2 = slicedToArray(_this$_residueGetNH, 2),
              n = _this$_residueGetNH2[0],
              h = _this$_residueGetNH2[1];

          var _this$_residueGetCO3 = this._residueGetCO(acceptor),
              _this$_residueGetCO4 = slicedToArray(_this$_residueGetCO3, 2),
              c = _this$_residueGetCO4[0],
              o = _this$_residueGetCO4[1];

          if (n === null || h === null || c === null || o === null) {
            return result;
          }

          var distanceHO = h.distanceTo(o);
          var distanceHC = h.distanceTo(c);
          var distanceNC = n.distanceTo(c);
          var distanceNO = n.distanceTo(o);

          if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
            result = MIN_HBOND_ENERGY;
          } else {
            result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
          } // DSSP compatibility mode:


          result = Math.round(result * 1000) / 1000;

          if (result < MIN_HBOND_ENERGY) {
            result = MIN_HBOND_ENERGY;
          }
        } // update donor


        if (typeof this._hbonds[donor._index] === 'undefined') {
          this._hbonds[donor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var donorInfo = this._hbonds[donor._index];

        if (donorInfo.acceptor.length < 2) {
          donorInfo.acceptor.push({
            residue: acceptor._index,
            energy: result
          });
        }

        if (donorInfo.acceptor.length > 1) {
          if (result < donorInfo.acceptor[0].energy) {
            donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
            donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
            donorInfo.acceptor[0].residue = acceptor._index;
            donorInfo.acceptor[0].energy = result;
          } else if (result < donorInfo.acceptor[1].energy) {
            donorInfo.acceptor[1].residue = acceptor._index;
            donorInfo.acceptor[1].energy = result;
          }
        } // update acceptor


        if (typeof this._hbonds[acceptor._index] === 'undefined') {
          this._hbonds[acceptor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var accInfo = this._hbonds[acceptor._index];

        if (accInfo.donor.length < 2) {
          accInfo.donor.push({
            residue: donor._index,
            energy: result
          });
        }

        if (accInfo.donor.length > 1) {
          if (result < accInfo.donor[0].energy) {
            accInfo.donor[1].residue = accInfo.donor[0].residue;
            accInfo.donor[1].energy = accInfo.donor[0].energy;
            accInfo.donor[0].residue = donor._index;
            accInfo.donor[0].energy = result;
          } else if (result < accInfo.donor[1].energy) {
            accInfo.donor[1].residue = donor._index;
            accInfo.donor[1].energy = result;
          }
        }

        return result;
      }
    }]);

    return HBondInfo;
  }();

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var BridgeType = Object.freeze({
    NO_BRIDGE: 0,
    PARALLEL: 1,
    ANTI_PARALLEL: 2
  });
  var HelixFlag = Object.freeze({
    START: 1,
    MIDDLE: 2,
    END: 3,
    START_AND_END: 4
  });
  var StructureType = Object.freeze({
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    TURN: 'T',
    BEND: 'S',
    LOOP: ' '
  });

  var SecondaryStructureMap = /*#__PURE__*/function () {
    function SecondaryStructureMap(complex) {
      classCallCheck(this, SecondaryStructureMap);

      this._complex = complex;

      this._build();
    }

    createClass(SecondaryStructureMap, [{
      key: "_build",
      value: function _build() {
        var self = this;
        this._hbonds = new HBondInfo(this._complex);
        this._ss = []; // DSSP map by residue
        // auxilliary data

        this._sheet = [];
        this._betaPartners = [];
        this._bend = [];

        for (var i = 0; i < this._complex.getResidues().length; ++i) {
          this._betaPartners[i] = [];
        }

        this._helixFlags = [];
        this._helixFlags[3] = [];
        this._helixFlags[4] = [];
        this._helixFlags[5] = []; // calculate peptide chain lengths

        this._chainLengths = [];

        for (var _i = 0; _i < this._complex._chains.length; ++_i) {
          var chain = this._complex._chains[_i].getResidues();

          var len = 0;

          for (; len < chain.length; ++len) {
            if ((chain[len].getType().flags & ResidueType.Flags.PROTEIN) === 0) {
              break;
            }
          }

          this._chainLengths[_i] = len;
        }

        this._buildBetaSheets();

        for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
          self._buildAlphaHelices(this._complex._chains[_i2].getResidues(), this._chainLengths[_i2], false);
        }
      }
    }, {
      key: "_buildAlphaHelices",
      value: function _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
        // Helix and Turn
        for (var stride = 3; stride <= 5; ++stride) {
          if (inResidues.length < stride) {
            break;
          }

          for (var i = 0; i + stride < chainLength; ++i) {
            if (this._hbonds.isBond(inResidues[i + stride]._index, inResidues[i]._index)
            /* && NoChainBreak(res[i], res[i + stride]) */
            ) {
                this._helixFlags[stride][inResidues[i + stride]._index] = HelixFlag.END;

                for (var j = i + 1; j < i + stride; ++j) {
                  if (typeof this._helixFlags[stride][inResidues[j]._index] === 'undefined') {
                    this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
                  }
                }

                if (this._helixFlags[stride][inResidues[i]._index] === HelixFlag.END) {
                  this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START_AND_END;
                } else {
                  this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START;
                }
              }
          }
        }

        for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
          var kappa = this._kappa(inResidues[_i3 - 2], inResidues[_i3], inResidues[_i3 + 2]);

          this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70;
        }

        for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
          if (this._isHelixStart(inResidues[_i4]._index, 4) && this._isHelixStart(inResidues[_i4 - 1]._index, 4)) {
            for (var _j = _i4; _j <= _i4 + 3; ++_j) {
              this._ss[inResidues[_j]._index] = StructureType.HELIX_ALPHA;
            }
          }
        }

        for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
          if (this._isHelixStart(inResidues[_i5]._index, 3) && this._isHelixStart(inResidues[_i5 - 1]._index, 3)) {
            var empty = true;

            for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
              empty = typeof this._ss[inResidues[_j2]._index] === 'undefined' || this._ss[inResidues[_j2]._index] === StructureType.HELIX_310;
            }

            if (empty) {
              for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
                this._ss[inResidues[_j3]._index] = StructureType.HELIX_310;
              }
            }
          }
        }

        for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
          if (this._isHelixStart(inResidues[_i6]._index, 5) && this._isHelixStart(inResidues[_i6 - 1]._index, 5)) {
            var _empty = true;

            for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
              _empty = typeof this._ss[inResidues[_j4]._index] === 'undefined' || this._ss[inResidues[_j4]._index] === StructureType.HELIX_PI || inPreferPiHelices && this._ss[inResidues[_j4]._index] === StructureType.HELIX_ALPHA;
            }

            if (_empty) {
              for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
                this._ss[inResidues[_j5]._index] = StructureType.HELIX_PI;
              }
            }
          }
        }

        for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
          if (typeof this._ss[inResidues[_i7]._index] === 'undefined') {
            var isTurn = false;

            for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
              for (var k = 1; k < _stride && !isTurn; ++k) {
                isTurn = _i7 >= k && this._isHelixStart(inResidues[_i7 - k]._index, _stride);
              }
            }

            if (isTurn) {
              this._ss[inResidues[_i7]._index] = StructureType.TURN;
            } else if (this._bend[inResidues[_i7]._index]) {
              this._ss[inResidues[_i7]._index] = StructureType.BEND;
            }
          }
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_cosinusAngle",
      value: function _cosinusAngle(p1, p2, p3, p4) {
        var v12 = p1.clone().sub(p2);
        var v34 = p3.clone().sub(p4);
        var result = 0;
        var x = v12.dot(v12) * v34.dot(v34);

        if (x > 0) {
          result = v12.dot(v34) / Math.sqrt(x);
        }

        return result;
      }
    }, {
      key: "_kappa",
      value: function _kappa(prevPrev, res, nextNext) {
        var curCA = this._residueGetCAlpha(res);

        var ppCA = this._residueGetCAlpha(prevPrev);

        var nnCA = this._residueGetCAlpha(nextNext);

        if (curCA === null || ppCA === null || nnCA === null) {
          return 180;
        }

        var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);

        var skap = Math.sqrt(1 - ckap * ckap);
        return Math.atan2(skap, ckap) * 180 / Math.PI;
      }
    }, {
      key: "_isHelixStart",
      value: function _isHelixStart(res, stride) {
        return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
      }
    }, {
      key: "_buildBetaSheets",
      value: function _buildBetaSheets() {
        // find bridges
        // check each chain against each other chain, and against itself
        var bridges = [];

        for (var a = 0; a < this._complex._chains.length; ++a) {
          var lenA = this._chainLengths[a];

          if (lenA <= 4) {
            continue;
          }

          var chainA = this._complex._chains[a].getResidues();

          for (var b = a; b < this._complex._chains.length; ++b) {
            var lenB = this._chainLengths[b];

            if (lenB <= 4) {
              continue;
            }

            var chainB = this._complex._chains[b].getResidues();

            for (var i = 1; i + 1 < lenA; ++i) {
              var ri = chainA[i];
              var j = 1;

              if (b === a) {
                j = i + 3; // check for self-bridges forward down the chain
              }

              for (; j + 1 < lenB; ++j) {
                var rj = chainB[j];

                var type = this._testBridge(chainA, i, chainB, j);

                if (type === BridgeType.NO_BRIDGE) {
                  continue;
                } // there is a bridge, try to attach it to previously found sequence


                var found = false;

                var _iterator = _createForOfIteratorHelper(bridges),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var bridge = _step.value;

                    if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                      continue;
                    }

                    if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.push(rj._index);
                      found = true;
                      break;
                    }

                    if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.unshift(rj._index);
                      found = true;
                      break;
                    }
                  } // this bridge cannot be attached anywhere, start a new sequence

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                if (!found) {
                  bridges.push({
                    type: type,
                    i: [ri._index],
                    chainI: ri.getChain()._index,
                    j: [rj._index],
                    chainJ: rj.getChain()._index
                  });
                }
              }
            }
          }
        } // extend ladders


        bridges.sort(function (a, b) {
          if (a.chainI < b.chainI || a.chainI === b.chainI && a.i[0] < b.i[0]) {
            return -1;
          }

          return 1;
        });

        for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
          for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
            var ibi = bridges[_i8].i[0];
            var iei = bridges[_i8].i[bridges[_i8].i.length - 1];
            var jbi = bridges[_i8].j[0];
            var jei = bridges[_i8].j[bridges[_i8].j.length - 1];
            var ibj = bridges[_j6].i[0];
            var iej = bridges[_j6].i[bridges[_j6].i.length - 1];
            var jbj = bridges[_j6].j[0];
            var jej = bridges[_j6].j[bridges[_j6].j.length - 1];

            if (bridges[_i8].type !== bridges[_j6].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
              continue;
            }

            var bulge = false;

            if (bridges[_i8].type === BridgeType.PARALLEL) {
              bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
            } else {
              bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
            }

            if (bulge) {
              bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i);

              if (bridges[_i8].type === BridgeType.PARALLEL) {
                bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j);
              } else {
                bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j);
              }

              bridges.splice(_j6--, 1);
            }
          }
        } // Sheet


        var ladderset = new Set();

        for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
          ladderset.add(bridges[_i9]);
        }

        var sheet = 1;
        var ladder = 0;

        while (ladderset.size > 0) {
          var _bridge = ladderset.values().next().value;
          ladderset["delete"](_bridge);
          var sheetset = new Set();
          sheetset.add(_bridge);
          var toMove = void 0;

          do {
            toMove = new Set();

            var _iterator2 = _createForOfIteratorHelper(sheetset.values()),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _a = _step2.value;

                var _iterator4 = _createForOfIteratorHelper(ladderset.values()),
                    _step4;

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _b = _step4.value;

                    if (this._areBridgesLinked(_a, _b)) {
                      toMove.add(_b);
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            var _iterator3 = _createForOfIteratorHelper(toMove.values()),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                _bridge = _step3.value;
                sheetset.add(_bridge);
                ladderset["delete"](_bridge);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } while (toMove.size > 0);

          var _iterator5 = _createForOfIteratorHelper(sheetset.values()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _bridge = _step5.value;
              _bridge.ladder = ladder;
              _bridge.sheet = sheet;
              _bridge.link = sheetset;
              ++ladder;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          ++sheet;
        }

        for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
          var _bridge2 = bridges[_i10]; // find out if any of the i and j set members already have
          // a bridge assigned, if so, we're assigning bridge 2

          var betai = 0;
          var betaj = 0;

          for (var l = 0; l < _bridge2.i.length; ++l) {
            if (this._betaPartners[_bridge2.i[l]][0]) {
              betai = 1;
              break;
            }
          }

          for (var _l = 0; _l < _bridge2.j.length; ++_l) {
            if (this._betaPartners[_bridge2.j[_l]][0]) {
              betaj = 1;
              break;
            }
          }

          var ss = StructureType.BRIDGE;

          if (_bridge2.i.length > 1) {
            ss = StructureType.STRAND;
          }

          if (_bridge2.type === BridgeType.PARALLEL) {
            var _j7 = 0;

            for (var k = 0; k < _bridge2.i.length; ++k) {
              this._betaPartners[_bridge2.i[k]][betai] = {
                residue: _bridge2.j[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }

            _j7 = 0;

            for (var _k = 0; _k < _bridge2.j.length; ++_k) {
              this._betaPartners[_bridge2.j[_k]][betaj] = {
                residue: _bridge2.i[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }
          } else {
            var _j8 = _bridge2.j.length - 1;

            for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
              this._betaPartners[_bridge2.i[_k2]][betai] = {
                residue: _bridge2.j[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }

            _j8 = _bridge2.i.length - 1;

            for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
              this._betaPartners[_bridge2.j[_k3]][betaj] = {
                residue: _bridge2.i[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }
          }

          for (var _k4 = _bridge2.i[0]; _k4 <= _bridge2.i[_bridge2.i.length - 1]; ++_k4) {
            if (this._ss[_k4] !== StructureType.STRAND) {
              this._ss[_k4] = ss;
              this._sheet[_k4] = _bridge2.sheet;
            }
          }

          for (var _k5 = _bridge2.j[0]; _k5 <= _bridge2.j[_bridge2.j.length - 1]; ++_k5) {
            if (this._ss[_k5] !== StructureType.STRAND) {
              this._ss[_k5] = ss;
              this._sheet[_k5] = _bridge2.sheet;
            }
          }
        }
      }
    }, {
      key: "_testBridge",
      value: function _testBridge(chainA, from, chainB, to) {
        var result = BridgeType.NO_BRIDGE;
        var a = chainA[from - 1]._index;
        var b = chainA[from]._index;
        var c = chainA[from + 1]._index;
        var d = chainB[to - 1]._index;
        var e = chainB[to]._index;
        var f = chainB[to + 1]._index;

        var isBond = this._hbonds.isBond.bind(this._hbonds);

        if (isBond(c, e) && isBond(e, a) || isBond(f, b) && isBond(b, d)) {
          result = BridgeType.PARALLEL;
        } else if (isBond(c, d) && isBond(f, a) || isBond(e, b) && isBond(b, e)) {
          result = BridgeType.ANTI_PARALLEL;
        }

        return result;
      } // return true if any of the residues in bridge a is identical to any of the residues in bridge b

    }, {
      key: "_areBridgesLinked",
      value: function _areBridgesLinked(a, b) {
        var ai = new Set(a.i);
        var aj = new Set(a.j);

        var _iterator6 = _createForOfIteratorHelper(b.i),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var i = _step6.value;

            if (ai.has(i) || aj.has(i)) {
              return true;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        var _iterator7 = _createForOfIteratorHelper(b.j),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _i11 = _step7.value;

            if (ai.has(_i11) || aj.has(_i11)) {
              return true;
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return false;
      }
    }, {
      key: "_hasChainBreak",
      value: function _hasChainBreak(from, to) {
        for (var i = from + 1; i <= to; ++i) {
          if (this._complex._residues[i]._sequence !== this._complex._residues[i - 1]._sequence + 1) {
            return true;
          }
        }

        return false;
      }
    }]);

    return SecondaryStructureMap;
  }();
  SecondaryStructureMap.StructureType = StructureType;

  var _helixClassMap, _loopMap;
  var VOXEL_SIZE = 5.0;
  var StructureType$1 = SecondaryStructureMap.StructureType;
  var StructuralElementType$2 = StructuralElement.Type; // see http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX

  var helixClassMap = (_helixClassMap = {}, defineProperty(_helixClassMap, StructureType$1.HELIX_ALPHA, 1), defineProperty(_helixClassMap, StructureType$1.HELIX_PI, 3), defineProperty(_helixClassMap, StructureType$1.HELIX_310, 5), _helixClassMap);
  var loopMap = (_loopMap = {}, defineProperty(_loopMap, StructureType$1.BRIDGE, StructuralElementType$2.BRIDGE), defineProperty(_loopMap, StructureType$1.TURN, StructuralElementType$2.TURN), defineProperty(_loopMap, StructureType$1.BEND, StructuralElementType$2.BEND), defineProperty(_loopMap, StructureType$1.LOOP, StructuralElementType$2.COIL), _loopMap);
  /**
   * The entire complex of the molecules under study.
   *
   * @exports Complex
   * @constructor
   */

  var Complex = /*#__PURE__*/function () {
    function Complex() {
      classCallCheck(this, Complex);

      this._chains = [];
      this._components = [];
      this._helices = [];
      this._sheets = [];
      this.structures = [];
      this._residueTypes = Object.create(ResidueType.StandardTypes);
      this._atoms = [];
      this._residues = [];
      this._bonds = [];
      this._sgroups = [];
      this._molecules = [];
      this._maskNeedsUpdate = false;
      this.metadata = {};
      this.symmetry = [];
      this.units = [new BiologicalUnit(this)];
      this._currentUnit = 0; // default biological unit is the asymmetric unit
    }

    createClass(Complex, [{
      key: "addAtom",
      value: function addAtom(atom) {
        var index = this._atoms.length;

        this._atoms.push(atom);

        return index;
      }
    }, {
      key: "addSheet",
      value: function addSheet(sheet) {
        var index = this._sheets.length;

        this._sheets.push(sheet);

        return index;
      }
    }, {
      key: "addHelix",
      value: function addHelix(helix) {
        var index = this._helices.length;

        this._helices.push(helix);

        return index;
      }
    }, {
      key: "getAtoms",
      value: function getAtoms() {
        return this._atoms;
      }
    }, {
      key: "getBonds",
      value: function getBonds() {
        return this._bonds;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "addResidue",
      value: function addResidue(residue) {
        var index = this._residues.length;

        this._residues.push(residue);

        return index;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        this.forEachChain(function (chain) {
          chain.updateToFrame(frameData);
        });
      }
    }, {
      key: "addResidueType",
      value: function addResidueType(resName) {
        var rt = this._residueTypes[resName] = new ResidueType(resName, 'Unknown', '');
        return rt;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "getSGroupCount",
      value: function getSGroupCount() {
        return this._sgroups.length;
      }
    }, {
      key: "getSGroups",
      value: function getSGroups() {
        return this._sgroups;
      }
      /*
         Extract atom by its fullname: #chainName#.#residueId#.#atomName#
         */

    }, {
      key: "getAtomByFullname",
      value: function getAtomByFullname(fullName) {
        var parts = fullName.split('.');

        if (parts.length !== 3) {
          return null;
        }

        var chainName = parts[0];
        var resId = parseInt(parts[1], 10);

        if (Number.isNaN(resId)) {
          return null;
        }

        var atomName = parts[2].toUpperCase();
        var currAtom = null;
        this.forEachChain(function (chain) {
          if (currAtom) {
            return;
          }

          if (chain._name.localeCompare(chainName) === 0) {
            chain.forEachResidue(function (residue) {
              if (currAtom) {
                return;
              }

              if (residue._sequence === resId) {
                residue.forEachAtom(function (atom) {
                  if (currAtom) {
                    return;
                  }

                  if (atomName.localeCompare(atom.name) === 0) {
                    currAtom = atom;
                  }
                });
              }
            });
          }
        });
        return currAtom;
      }
      /**
       * Create a new chain.
       *
       * @param {string} name - Chain name.
       * @returns {Chain} - Newly created chain.
       */

    }, {
      key: "addChain",
      value: function addChain(name) {
        var result = new Chain(this, name);

        this._chains.push(result);

        return result;
      }
    }, {
      key: "getChain",
      value: function getChain(name) {
        for (var i = 0, n = this._chains.length; i < n; ++i) {
          var chain = this._chains[i];

          if (chain.getName() === name) {
            return chain;
          }
        }

        return null;
      }
    }, {
      key: "getChainCount",
      value: function getChainCount() {
        return this._chains.length;
      }
    }, {
      key: "getMolecules",
      value: function getMolecules() {
        return this._molecules;
      }
    }, {
      key: "getMoleculeCount",
      value: function getMoleculeCount() {
        return this._molecules.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          process(atoms[i]);
        }
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "forEachChain",
      value: function forEachChain(process) {
        var chains = this._chains;

        for (var i = 0, n = chains.length; i < n; ++i) {
          process(chains[i]);
        }
      }
    }, {
      key: "forEachMolecule",
      value: function forEachMolecule(process) {
        var molecules = this._molecules;
        var n = molecules.length;

        for (var i = 0; i < n; ++i) {
          process(molecules[i]);
        }
      }
    }, {
      key: "forEachSGroup",
      value: function forEachSGroup(process) {
        var groups = this._sgroups;

        for (var i = 0, n = groups.length; i < n; ++i) {
          process(groups[i]);
        }
      }
    }, {
      key: "forEachComponent",
      value: function forEachComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "forEachVisibleComponent",
      value: function forEachVisibleComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "addBond",
      value: function addBond(left, right, order, type, fixed) {
        var bond = new Bond(left, right, order, type, fixed);

        this._bonds.push(bond);

        return bond;
      }
    }, {
      key: "getBondCount",
      value: function getBondCount() {
        return this._bonds.length;
      }
    }, {
      key: "getResidueType",
      value: function getResidueType(name) {
        return this._residueTypes[name] || null;
      }
    }, {
      key: "getUnifiedSerial",
      value: function getUnifiedSerial(chain, serial, iCode) {
        /* eslint-disable no-magic-numbers */
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        /* eslint-enable no-magic-numbers */

        return serial + iCode * maxSerial + chain * chainShift;
      }
    }, {
      key: "splitUnifiedSerial",
      value: function splitUnifiedSerial(uniSerial) {
        /* eslint-disable no-magic-numbers */
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        /* eslint-enable no-magic-numbers */

        var chainId = Math.floor(uniSerial / chainShift);
        var remnant = uniSerial - chainId * chainShift;
        var insCode = Math.floor(remnant / maxSerial);
        var ser = remnant - insCode * maxSerial;
        return {
          chain: chainId,
          serial: ser,
          iCode: insCode
        };
      }
    }, {
      key: "_fillCmpEdit",
      value: function _fillCmpEdit() {
        var self = this;
        var components = this._components;

        function addComp() {
          var comp = new Component(self);
          comp._index = components.length;
          components[comp._index] = comp;
          return comp;
        }

        this.forEachChain(function (chain) {
          var residues = chain._residues;
          var resCount = residues.length;

          if (resCount < 1) {
            return;
          }

          var comp = addComp();
          var currStart = residues[0]._index;

          for (var i = 0; i < resCount; ++i) {
            var currRes = residues[i];
            currRes._component = comp;
            var nextRes = i === resCount - 1 ? null : residues[i + 1];

            if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
              // the last condition is broken and incorrect
              // the refactoring of the Component is required in order to fix this issue
              comp.setSubDivs([{
                start: currStart,
                end: currRes._index
              }]);

              if (nextRes) {
                currStart = nextRes._index;
                comp = addComp();
              }
            }
          }
        });
      } // This function was added in the moment of despair
      // It was the dark times for miew

    }, {
      key: "_fillCmpNoedit",
      value: function _fillCmpNoedit() {
        var comp = new Component(this);
        comp._index = 0;
        var residues = this._residues;
        var resCount = residues.length;

        if (resCount === 0) {
          return;
        }

        var currSubDivs = [];
        var currStart = 0;

        for (var i = 0; i < resCount; ++i) {
          var currRes = residues[i];
          currRes._component = comp;
          var nextRes = i === resCount - 1 ? null : residues[i + 1];

          if (!nextRes || !currRes.isConnected(nextRes)) {
            // wrap up this interval
            currSubDivs[currSubDivs.length] = {
              start: currStart,
              end: i
            };

            if (nextRes) {
              currStart = i + 1;
            }
          }
        }

        comp.setSubDivs(currSubDivs);
        this._components[comp._index] = comp;
      }
      /**
       * Fill components information.
       * @param {boolean} enableEditing - Restructure Complex to enable per-component editing.
       */

    }, {
      key: "_fillComponents",
      value: function _fillComponents(enableEditing) {
        if (enableEditing) {
          this._fillCmpEdit();
        } else {
          this._fillCmpNoedit();
        }
      }
    }, {
      key: "getCurrentUnit",
      value: function getCurrentUnit() {
        return this._currentUnit;
      }
    }, {
      key: "getDefaultBoundaries",
      value: function getDefaultBoundaries() {
        return this.units[0].getBoundaries();
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this.units[this._currentUnit].getBoundaries();
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.units[this._currentUnit].getTransforms();
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this.units[this._currentUnit].getSelector();
      }
    }, {
      key: "resetCurrentUnit",
      value: function resetCurrentUnit() {
        this._currentUnit = 0;
        this.setCurrentUnit(1);
      }
    }, {
      key: "setCurrentUnit",
      value: function setCurrentUnit(newUnit) {
        if (newUnit !== null && newUnit !== undefined && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
          this._currentUnit = newUnit;
          return true;
        }

        return false;
      }
    }, {
      key: "_computeBounds",
      value: function _computeBounds() {
        var units = this.units;

        for (var i = 0, n = units.length; i < n; ++i) {
          units[i].computeBoundaries();
        }
      }
    }, {
      key: "onAtomPositionChanged",
      value: function onAtomPositionChanged() {
        this.forEachChain(function (a) {
          a._finalize();
        });
        this.forEachComponent(function (c) {
          c.update();
        }); // Update bounding sphere and box

        this._computeBounds();

        this._finalizeBonds();

        this.forEachSGroup(function (s) {
          s._rebuildSGroupOnAtomChange();
        });
      }
    }, {
      key: "update",
      value: function update() {
        if (this._maskNeedsUpdate) {
          this.updateStructuresMask();
          this._maskNeedsUpdate = false;
        }
      }
    }, {
      key: "_finalizeBonds",
      value: function _finalizeBonds() {
        var bonds = this.getBonds();
        var n = bonds.length;

        for (var i = 0; i < n; ++i) {
          bonds[i]._index = i;
        }
      }
      /**
       * Finalizes complex's inner data(i.e. after parsing).
       * @param {objects} opts - Build bonds automatically.
       * @param {boolean} opts.needAutoBonding     - Build bonds automatically.
       * @param {boolean} opts.detectAromaticLoops - Find/mark aromatic loops.
       * @param {boolean} opts.enableEditing       - Restructure Complex to enable per-component editing.
       * @param {Array<Atom>} [opts.serialAtomMap] - Array of atoms ordered by their serials.
       */

    }, {
      key: "finalize",
      value: function finalize(opts) {
        opts = opts || {}; // Put bonds into atoms

        var bonds = this._bonds;
        var i;
        var n; // remove invalid bonds

        for (i = bonds.length - 1; i >= 0; i--) {
          var bond = bonds[i];

          if (bond._left === null || bond._right === null) {
            bonds.splice(i, 1);
          } else {
            bond._left.bonds.push(bond);

            bond._right.bonds.push(bond);
          }
        }

        var residues = this._residues;

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._finalize();
        }

        this.forEachChain(function (a) {
          a._finalize();
        }); // WARNING! this MUST be done BEFORE computeBounds is called

        var units = this.units;

        for (i = 0, n = units.length; i < n; ++i) {
          units[i].finalize();
        } // try setting first biomolecule by defaults


        this.setCurrentUnit(1);
        var residueHash = {};

        for (i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i]; // This code is extremely dangerous for non-PDB formats

          residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
        }

        var structures = this.structures;

        for (i = 0, n = structures.length; i < n; ++i) {
          structures[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var helices = this._helices;

        for (i = 0, n = helices.length; i < n; ++i) {
          helices[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var sheets = this._sheets;

        for (i = 0, n = sheets.length; i < n; ++i) {
          sheets[i]._finalize(opts.serialAtomMap, residueHash, this);
        } // Update bounding sphere and box


        this._computeBounds();

        var atoms = this._atoms;

        for (i = 0, n = atoms.length; i < n; ++i) {
          var currAtom = atoms[i];
          currAtom.index = i;
        }

        if (opts.needAutoBonding) {
          var autoConnector = new AutoBond(this);
          autoConnector.build();
          autoConnector.destroy();
        }

        var chains = this._chains;

        for (i = 0, n = chains.length; i < n; ++i) {
          chains[i]._index = i;
        }

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._index = i;
        } // mark non-polar hydrogens


        for (i = 0, n = atoms.length; i < n; ++i) {
          var atom = atoms[i];

          if (atom.flags & Atom.Flags.HYDROGEN && atom.bonds.length === 1) {
            var _bond = atom.bonds[0];
            var other = _bond._left !== atom && _bond._left || _bond._right;

            if (other.flags & Atom.Flags.CARBON) {
              atom.flags |= Atom.Flags.NONPOLARH;
            }
          }
        }

        this._finalizeBonds();

        this._fillComponents(opts.enableEditing);

        var marker = new AromaticLoopsMarker(this);
        marker.markCycles();

        if (opts.detectAromaticLoops) {
          // TODO remove this condition clause, it is for debug purposes only!
          marker.detectCycles(); // TODO add conditional detection
        }

        this._finalizeMolecules();
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // add reference to molecule into residue
        for (var i = 0; i < this._molecules.length; i++) {
          var molecule = this._molecules[i];
          var count = molecule.residues.length;

          for (var j = 0; j < count; j++) {
            var residue = molecule.residues[j];
            residue._molecule = molecule;
          }
        }
      }
    }, {
      key: "updateStructuresMask",
      value: function updateStructuresMask() {
        var updater = function updater(structure) {
          return structure.collectMask();
        };

        this.forEachResidue(updater);
        this.forEachChain(updater);
        this.forEachMolecule(updater);
      }
    }, {
      key: "countAtomsByMask",
      value: function countAtomsByMask(mask) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if ((atom.mask & mask) !== 0) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "getNumAtomsBySelector",
      value: function getNumAtomsBySelector(selector) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom)) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "resetAtomMask",
      value: function resetAtomMask(mask) {
        this.forEachAtom(function (atom) {
          atom.mask = mask;
        });
      }
    }, {
      key: "markAtoms",
      value: function markAtoms(selector, mask) {
        var setMask = mask;
        var clearMask = ~setMask;
        var count = 0;
        var totalSelector = selectors.keyword('And')(selector, this.getSelector());
        this.forEachAtom(function (atom) {
          if (totalSelector.includesAtom(atom)) {
            atom.mask |= setMask;
            count++;
          } else {
            atom.mask &= clearMask;
          }
        });
        this._maskNeedsUpdate = true;
        return count;
      }
    }, {
      key: "markAtomsAdditionally",
      value: function markAtomsAdditionally(selector, mask) {
        var setMask = mask;
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
            atom.mask |= setMask;
            count++;
          }
        });
        return count;
      }
    }, {
      key: "clearAtomBits",
      value: function clearAtomBits(mask) {
        var clearMask = ~mask;
        this.forEachAtom(function (atom) {
          atom.mask &= clearMask;
        });

        var reseter = function reseter(a) {
          a._mask &= clearMask;
        };

        this.forEachAtom(reseter);
        this.forEachResidue(reseter);
        this.forEachChain(reseter);
        this.forEachMolecule(reseter);
      }
    }, {
      key: "getAtomNames",
      value: function getAtomNames() {
        if (this.hasOwnProperty('_atomNames')) {
          return this._atomNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.name] = 1;
        });
        this._atomNames = Object.keys(dict);
        return this._atomNames;
      }
    }, {
      key: "getElements",
      value: function getElements() {
        if (this.hasOwnProperty('_elements')) {
          return this._elements;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.element.name] = 1;
        });
        this._elements = Object.keys(dict);
        return this._elements;
      }
    }, {
      key: "getResidueNames",
      value: function getResidueNames() {
        if (this.hasOwnProperty('_residueNames')) {
          return this._residueNames;
        }

        var dict = {};
        this.forEachResidue(function (res) {
          dict[res._type._name] = 1;
        });
        this._residueNames = Object.keys(dict);
        return this._residueNames;
      }
    }, {
      key: "getChainNames",
      value: function getChainNames() {
        if (this.hasOwnProperty('_chainNames')) {
          return this._chainNames;
        }

        var dict = {};
        this.forEachChain(function (chain) {
          dict[chain._name] = 1;
        });
        this._chainNames = Object.keys(dict);
        return this._chainNames;
      }
    }, {
      key: "getAltLocNames",
      value: function getAltLocNames() {
        if (this.hasOwnProperty('_altlocNames')) {
          return this._altlocNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[String.fromCharCode(atom.location)] = 1;
        });
        this._altlocNames = Object.keys(dict);
        return this._altlocNames;
      }
    }, {
      key: "getVoxelWorld",
      value: function getVoxelWorld() {
        if (!this.hasOwnProperty('_voxelWorld')) {
          try {
            this._voxelWorld = new VoxelWorld(this.getDefaultBoundaries().boundingBox, new THREE.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));

            this._voxelWorld.addAtoms(this);
          } catch (e) {
            logger.warn('Unable to create voxel world');
            this._voxelWorld = null;
          }
        }

        return this._voxelWorld;
      }
      /**
       * Simple function to make unified routine procedure without code duplication.
       * @param {Array} srcArray   - Source chemical structure array (will be part of resulting chemical structure array).
       * @param {Array} dstArray   - Resulting chemical structure array.
       * @param {number} param     - Parameter for processor.
       * @param {function} functor - Processor for every element in array.
       */

    }, {
      key: "addElement",
      value: function addElement(srcArray, dstArray, param, functor) {
        var length = srcArray.length;

        for (var i = 0; i < length; ++i) {
          var elem = srcArray[i];
          functor(elem, param);
          dstArray.push(elem);
        }
      } // this function joins multiple complexes into one (this)
      // atom, bond, ... objects are reused -- so input complexes are no longer valid

    }, {
      key: "joinComplexes",
      value: function joinComplexes(complexes) {
        // clear target complex
        this._chains = [];
        this._components = [];
        this._helices = [];
        this._sheets = [];
        this.structures = [];
        this._atoms = [];
        this._residues = [];
        this._bonds = [];
        this._sgroups = [];
        var self = this;
        var atomBias = 0;
        var bondBias = 0;
        var residueBias = 0;
        var chainBias = 0;
        var componentBias = 0;

        function processAtom(atom, bias) {
          atom.serial += bias;
          atom.index += bias;
        }

        function processBond(bond, bias) {
          bond._index += bias;
        }

        function processResidue(residue, bias) {
          residue._index += bias;
        }

        function processChain(chain, bias) {
          chain._complex = self;
          chain._index += bias;
        }

        function processComponent(component, bias) {
          component._complex = self;
          component._index += bias;
        }
        /**
         * Simple function to do nothing.
         */


        function doNothing() {}

        for (var i = 0; i < complexes.length; ++i) {
          var c = complexes[i];
          this.addElement(c._atoms, this._atoms, atomBias, processAtom);
          this.addElement(c._bonds, this._bonds, bondBias, processBond);
          this.addElement(c._residues, this._residues, residueBias, processResidue);
          this.addElement(c._chains, this._chains, chainBias, processChain);
          this.addElement(c._sheets, this._sheets, 0, doNothing);
          this.addElement(c._helices, this._helices, 0, doNothing);
          this.addElement(c._sgroups, this._sgroups, 0, doNothing);
          this.addElement(c._components, this._components, componentBias, processComponent);
          this.addElement(c.structures, this.structures, 0, doNothing); // merge residue types

          for (var rt in c._residueTypes) {
            if (c._residueTypes.hasOwnProperty(rt)) {
              this._residueTypes[rt] = c._residueTypes[rt];
            }
          }

          atomBias += c._atoms.length;
          bondBias += c._bonds.length;
          residueBias += c._residues.length;
          chainBias += c._chains.length;
          componentBias += c._components.length;
        }

        this._computeBounds();
      }
      /**
       * Replace secondary structure with calculated one.
       *
       * DSSP algorithm implementation is used.
       *
       * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
       * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
       */

    }, {
      key: "dssp",
      value: function dssp() {
        var ssMap = new SecondaryStructureMap(this);
        var structures = this.structures = [];
        var helices = this._helices = [];
        var sheets = this._sheets = [];

        var getSheet = function getSheet(index) {
          var item = sheets[index];

          if (!item) {
            item = sheets[index] = new Sheet(String(index), 0);
          }

          return item;
        };

        var lastCode;
        var lastSheetIndex;
        var lastHelixIndex = 0;
        var curStructure = null;

        for (var i = 0, n = this._residues.length; i < n; ++i) {
          var curCode = ssMap._ss[i];
          var curResidue = this._residues[i];
          var curSheetIndex = ssMap._sheet[i]; // expand the last structure

          if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
            curResidue._secondary = curStructure;

            if (curStructure) {
              curStructure.term = curResidue;
            }

            if (curStructure instanceof Helix) {
              curStructure.length++;
            }

            continue;
          } // create a new structure


          var helixClass = helixClassMap[curCode];
          var loopType = loopMap[curCode];

          if (curCode === StructureType$1.STRAND) {
            var curSheet = getSheet(curSheetIndex);
            curStructure = new Strand(curSheet, curResidue, curResidue, 0, null, null);
            curSheet.addStrand(curStructure);
          } else if (helixClass !== undefined) {
            lastHelixIndex++;
            curStructure = new Helix(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), '', 1);
            helices.push(curStructure);
          } else if (loopType !== undefined) {
            curStructure = new StructuralElement(loopType, curResidue, curResidue);
          } else {
            curStructure = null;
          }

          if (curStructure) {
            structures.push(curStructure);
          }

          curResidue._secondary = curStructure;
          lastCode = curCode;
          lastSheetIndex = curSheetIndex;
        }

        this._sheets = sheets.filter(function (_sheet) {
          return true;
        }); // squeeze sheets array
      }
    }]);

    return Complex;
  }();

  Complex.prototype.id = 'Complex';
  Complex.prototype.name = '';

  function pow2ceil(v) {
    var p = 2;
    v = v - 1 >> 1;

    while (v) {
      p <<= 1;
      v >>= 1;
    }

    return p;
  }
  /**
   * Volume constructor
   *
   * @param {Object} type - Float32Array, Int8Array, etc...
   * @param {Object|Array} dimensions - number of data points on each axis (x, y, z)
   * @param {Box3} box - bounding box defining data place in metric space,
   *                     it's corners correspond to extreme data points
   * @param {Number} vecSize - dimension of the field data point (1 = scalar, 3 = 3D vector)
   * @param {Object} data - typed array of the same type as specified by the 1st parameter,
   *                        layout: point by point along X,
   *                                row by row along Y,
   *                                plane by plane along Z
   * @param {Number} volumeInfo - volume info values to define threshold to filter the noise
   */


  var Volume = /*#__PURE__*/function () {
    function Volume(type, dimensions, box, vecSize, data, volumeInfo) {
      classCallCheck(this, Volume);

      this._box = box.clone();
      this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
      this._volumeInfo = volumeInfo;

      if (dimensions instanceof Array) {
        var _dimensions = slicedToArray(dimensions, 3);

        this._dimX = _dimensions[0];
        this._dimY = _dimensions[1];
        this._dimZ = _dimensions[2];
      } else {
        this._dimX = dimensions.x;
        this._dimY = dimensions.y;
        this._dimZ = dimensions.z;
      }

      this._dimX = Math.max(Math.floor(this._dimX), 1);
      this._dimY = Math.max(Math.floor(this._dimY), 1);
      this._dimZ = Math.max(Math.floor(this._dimZ), 1);
      this._rowElements = this._dimVec * this._dimX;
      this._planeElements = this._rowElements * this._dimY;
      this._totalElements = this._planeElements * this._dimZ;
      this._data = data || utils.allocateTyped(type, this._totalElements); // override getter/setter for vector fields

      switch (this._dimVec) {
        case 1:
          break;

        case 2:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1]];
          };

          this.setValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
          };

          this.addValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
          };

          break;

        case 3:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
          };

          this.setValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
            this._data[idx + 2] = c;
          };

          this.addValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
            this._data[idx + 2] += c;
          };

          break;

        default:
          throw new Error('Volume: invalid vector dimension');
      }
    } // default getter assumes it's a scalar field


    createClass(Volume, [{
      key: "getValue",
      value: function getValue(x, y, z) {
        return this._data[x + y * this._rowElements + z * this._planeElements];
      } // default setter assumes it's a scalar field

    }, {
      key: "setValue",
      value: function setValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] = val;
      } // default adder assumes it's a scalar field

    }, {
      key: "addValue",
      value: function addValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] += val;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions() {
        return [this._dimX, this._dimY, this._dimZ];
      }
    }, {
      key: "getBox",
      value: function getBox() {
        return this._box;
      }
    }, {
      key: "getVolumeInfo",
      value: function getVolumeInfo() {
        return this._volumeInfo;
      }
    }, {
      key: "getCellSize",
      value: function getCellSize() {
        var boxSize = new THREE.Vector3();

        this._box.getSize(boxSize);

        var res = new THREE.Vector3();
        res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
        res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
        res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
        return res;
      }
    }, {
      key: "computeGradient",
      value: function computeGradient() {
        if (this._dimVec !== 1) {
          // gradient can only be computed for scalar fields
          return null;
        } // create a 3D vector field of gradients


        var gradient = new Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3); // calculate cell side lengths

        var vl = this.getCellSize(); // gradient axis scaling values and averaging factors, to correctly
        // calculate the gradient for volumes with irregular cell spacing

        var vs = new THREE.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z); // TODO Check for intended bug in VMD (min is zero)

        function clamp(val, min, max) {
          return Math.min(max, Math.max(min, val));
        }

        var xSize = this._dimX;
        var ySize = this._dimY;
        var zSize = this._dimZ;
        var volMap = this._data;

        function _voxelValue(x, y, z) {
          return volMap[z * xSize * ySize + y * xSize + x];
        }

        for (var zi = 0; zi < zSize; ++zi) {
          var zm = clamp(zi - 1, 0, zSize - 1);
          var zp = clamp(zi + 1, 0, zSize - 1);

          for (var yi = 0; yi < ySize; ++yi) {
            var ym = clamp(yi - 1, 0, ySize - 1);
            var yp = clamp(yi + 1, 0, ySize - 1);

            for (var xi = 0; xi < xSize; ++xi) {
              var xm = clamp(xi - 1, 0, xSize - 1);
              var xp = clamp(xi + 1, 0, xSize - 1); // Calculate the volume gradient at each grid cell.
              // Gradients are now stored unnormalized, since we need them in pure
              // form in order to draw field lines etc.  Shading code will now have
              // to do renormalization for itself on-the-fly.
              // XXX this gradient is only correct for orthogonal grids, since
              // we're using the array index offsets rather to calculate the gradient
              // rather than voxel coordinate offsets.  This will have to be
              // re-worked for non-orthogonal datasets.

              gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
            }
          }
        }

        return gradient;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        var data = this._data; // get min/max

        var min = data[0];
        var max = data[0];

        for (var i = 1; i < data.length; ++i) {
          min = Math.min(min, data[i]);
          max = Math.max(max, data[i]);
        }

        var d = 1.0 / (max - min);

        if (d === 0) {
          return;
        } // normalize


        for (var _i = 0; _i < data.length; ++_i) {
          data[_i] = d * (data[_i] - min);
        }
      }
    }, {
      key: "getTiledTextureStride",
      value: function getTiledTextureStride() {
        return [this._dimX + 2, this._dimY + 2];
      }
    }, {
      key: "buildTiledTexture",
      value: function buildTiledTexture() {
        var tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
        var width = tilesX * (this._dimX + 2) - 1;
        width = pow2ceil(width);
        tilesX = Math.floor(width / (this._dimX + 2));
        var tilesY = Math.ceil(this._dimZ / tilesX);
        var height = tilesY * (this._dimY + 2) - 1;
        height = pow2ceil(height);
        var data = new Uint8Array(width * height);
        var src;
        var dst;

        for (var tileRow = 0; tileRow < tilesY; ++tileRow) {
          // process each pixel row of this tile row
          for (var row = 0; row < this._dimY; ++row) {
            src = tileRow * tilesX * this._planeElements + row * this._rowElements;
            dst = width * (tileRow * (this._dimY + 2) + row); // copy a series of rows through several XY planes

            for (var t = 0; t < tilesX; ++t) {
              // copy one row of one XY plane
              for (var x = 0; x < this._dimX; ++x) {
                data[dst++] = 255.0 * this._data[src++];
              } // repeat last pixel of previous tile


              data[dst++] = 255.0 * this._data[src - 1];

              if (t < tilesX - 1) {
                // skip to the same row of next XY plane
                src += this._planeElements - this._rowElements; // repeat first pixel of next tile

                data[dst++] = 255.0 * this._data[src];
              }
            }
          }
        } // fill pixels between tile rows with copy of edge pixels


        for (var _tileRow = 0; _tileRow < tilesY; ++_tileRow) {
          // copy last pixel row of this tile row to the following pixel row of the texture
          src = width * (_tileRow * (this._dimY + 2) + this._dimY - 1);
          dst = src + width;

          for (var _x = 0; _x < width; ++_x) {
            data[dst++] = data[src++];
          }

          if (_tileRow < tilesY - 1) {
            // copy first pixel row of next tile row to the preceding pixel row of the texture
            src = width * (_tileRow + 1) * (this._dimY + 2);
            dst = src - width;

            for (var _x2 = 0; _x2 < width; ++_x2) {
              data[dst++] = data[src++];
            }
          }
        }

        var texture = new THREE.DataTexture(data, width, height, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter);
        texture.needsUpdate = true;
        return texture;
      }
      /* ********************************************************************************
       *
       * Methods that provide direct access to internal array (for better performance)
       *
       ******************************************************************************** */

    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getDirectIdx",
      value: function getDirectIdx(x, y, z) {
        return x * this._dimVec + y * this._rowElements + z * this._planeElements;
      }
    }, {
      key: "getStrideX",
      value: function getStrideX() {
        return this._dimVec;
      }
    }, {
      key: "getStrideY",
      value: function getStrideY() {
        return this._rowElements;
      }
    }, {
      key: "getStrideZ",
      value: function getStrideZ() {
        return this._planeElements;
      }
    }]);

    return Volume;
  }();

  Volume.prototype.id = 'Volume';

  /**
   * Residue Molecule.
   *
   * @param {Complex} complex - Molecular complex this Molecule belongs to.
   * @param {String} name - Molecule's name.
   * @param {Integer} index - Molecule's index in file.
   *
   * @exports Molecule
   * @constructor
   */
  var Molecule = /*#__PURE__*/function () {
    function Molecule(complex, name, index) {
      classCallCheck(this, Molecule);

      this.complex = complex;
      this.name = name || '';
      this.residues = [];
      this.mask = 1 | 0;
      this.index = index || -1; // start with 1
    }

    createClass(Molecule, [{
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this.mask = mask;
      }
    }]);

    return Molecule;
  }();

  var chem = {
    Atom: Atom,
    Element: Element,
    Bond: Bond,
    Residue: Residue,
    ResidueType: ResidueType,
    Chain: Chain,
    Helix: Helix,
    Strand: Strand,
    Sheet: Sheet,
    SGroup: SGroup,
    Assembly: Assembly,
    Complex: Complex,
    Volume: Volume,
    VoxelWorld: VoxelWorld,
    selectors: selectors,
    Molecule: Molecule
  };

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CSS2DObject = /*#__PURE__*/function (_THREE$Object3D) {
    inherits(CSS2DObject, _THREE$Object3D);

    var _super = _createSuper$9(CSS2DObject);

    function CSS2DObject(element) {
      var _this;

      classCallCheck(this, CSS2DObject);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._element = element;
      _this._element.style.position = 'absolute';

      _this.addEventListener('removed', function () {
        if (self._element.parentNode !== null) {
          self._element.parentNode.removeChild(self._element);
        }
      });

      return _this;
    }

    createClass(CSS2DObject, [{
      key: "getElement",
      value: function getElement() {
        return this._element;
      }
      /**
       * Sets label transparency.
       *
       * @param {number} transp    - in [0; 1] 1 means fully transparent
       */

    }, {
      key: "setTransparency",
      value: function setTransparency(transp) {
        var el = this.getElement();

        if (el === null) {
          return;
        }

        if (transp === 1.0) {
          el.style.display = 'none';
          return;
        }

        el.style.display = 'inline';
        var op = 1.0 - transp;
        var top = op.toString();
        var op100 = op * 100;
        el.style.opacity = top;
        el.style.filter = "alpha(opacity=".concat(op100, ")"); // IE fallback
      }
    }, {
      key: "clone",
      value: function clone() {
        var obj = new CSS2DObject(this._element);
        obj.copy(this);
        return obj;
      }
    }]);

    return CSS2DObject;
  }(THREE.Object3D);

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var RCGroup = /*#__PURE__*/function (_THREE$Group) {
    inherits(RCGroup, _THREE$Group);

    var _super = _createSuper$a(RCGroup);

    function RCGroup() {
      classCallCheck(this, RCGroup);

      return _super.apply(this, arguments);
    }

    createClass(RCGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (!this.visible) {
          return;
        }

        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          children[i].raycast(raycaster, intersects);
        }
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].enableSubset) {
            children[i].enableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].disableSubset) {
            children[i].disableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.children.length === 0;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].updateToFrame) {
            children[i].updateToFrame(frameData);
          }
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
          }
        }

        return totalSubset;
      }
    }]);

    return RCGroup;
  }(THREE.Group);

  var vertexScreenQuadShader = "uniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n";

  var fragmentScreenQuadFromTex = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform float opacity;\n\nvoid main() {\n  vec4 color = texture2D(srcTex, vUv);\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\n}\n";

  var fragmentScreenQuadFromTexWithDistortion = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform float coef;\n\nvoid main() {\n  vec2 uv = vUv * 2.0 - 1.0;\n  float r2 = dot(uv, uv);\n  vec2 tc = uv * (1.0 + coef * r2);\n  if (!all(lessThan(abs(tc), vec2(1.0))))\n    discard;\n  tc = 0.5 * (tc + 1.0);\n  gl_FragColor = texture2D(srcTex, tc);\n}\n";

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var LAYERS = {
    DEFAULT: 0,
    VOLUME: 1,
    TRANSPARENT: 2,
    PREPASS_TRANSPARENT: 3,
    VOLUME_BFPLANE: 4,
    COLOR_FROM_POSITION: 5,
    SHADOWMAP: 6
  };
  var SELECTION_LAYERS = [// These layers, that are used in the selection by ray casting
  LAYERS.DEFAULT, LAYERS.TRANSPARENT];

  THREE.Object3D.prototype.resetTransform = function () {
    this.position.set(0, 0, 0);
    this.quaternion.set(0, 0, 0, 1);
    this.scale.set(1, 1, 1);
  }; // update world matrix of this object and all its ancestors


  THREE.Object3D.prototype.updateMatrixWorldRecursive = function () {
    if (this.parent != null) {
      this.parent.updateMatrixWorldRecursive();
    }

    this.updateMatrixWorld();
  }; // add object to parent, saving objects' world transform


  THREE.Object3D.prototype.addSavingWorldTransform = function () {
    var _worldMatrixInverse = new THREE.Matrix4();

    return function (object) {
      if (object instanceof THREE.Object3D) {
        _worldMatrixInverse.copy(this.matrixWorld).invert();

        _worldMatrixInverse.multiply(object.matrixWorld);

        object.matrix.copy(_worldMatrixInverse);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
        this.add(object);
      }
    };
  }(); // render a tiny transparent quad in the center of the screen


  THREE.WebGLRenderer.prototype.renderDummyQuad = function () {
    var _material = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false
    });

    var _scene = new THREE.Scene();

    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.01, 0.01), _material);

    _scene.add(_quad);

    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function () {
      this.render(_scene, _camera);
    };
  }();

  THREE.WebGLRenderer.prototype.renderScreenQuad = function () {
    var _scene = new THREE.Scene();

    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1.0, 1.0));

    _scene.add(_quad);

    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function (material) {
      _quad.material = material;
      this.render(_scene, _camera);
    };
  }();

  THREE.Matrix4.prototype.isIdentity = function () {
    var identity = new THREE.Matrix4();
    return function () {
      return identity.equals(this);
    };
  }();

  THREE.Matrix4.prototype.applyToPointsArray = function (array, stride, w) {
    if (!array || !stride || stride < 3) {
      return array;
    }

    w = w || 0; // use point as normal by default

    var e = this.elements;

    for (var i = 0; i < array.length; i += stride) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      var persp = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      array[i] = (e[0] * x + e[4] * y + e[8] * z + e[12] * w) * persp;
      array[i + 1] = (e[1] * x + e[5] * y + e[9] * z + e[13] * w) * persp;
      array[i + 2] = (e[2] * x + e[6] * y + e[10] * z + e[14] * w) * persp;
    }

    return array;
  };

  var ScreenQuadMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(ScreenQuadMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$b(ScreenQuadMaterial);

    function ScreenQuadMaterial(params) {
      classCallCheck(this, ScreenQuadMaterial);

      if (params.uniforms === undefined) {
        params.uniforms = {};
      }

      params.uniforms.srcTex = {
        type: 't',
        value: null
      };
      params.vertexShader = vertexScreenQuadShader;
      params.transparent = false;
      params.depthTest = false;
      params.depthWrite = false;
      return _super.call(this, params);
    }

    return ScreenQuadMaterial;
  }(THREE.RawShaderMaterial);

  THREE.WebGLRenderer.prototype.renderScreenQuadFromTex = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        opacity: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTex,
      transparent: true
    });

    return function (srcTex, opacity) {
      _material.uniforms.srcTex.value = srcTex;
      _material.transparent = opacity < 1.0;
      _material.uniforms.opacity.value = opacity;
      this.renderScreenQuad(_material);
    };
  }();

  THREE.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        coef: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTexWithDistortion
    });

    return function (srcTex, coef) {
      _material.uniforms.srcTex.value = srcTex;
      _material.uniforms.coef.value = coef;
      this.renderScreenQuad(_material);
    };
  }();
  /**
   * @param {number} angle - Field of view in degrees.
   */


  THREE.PerspectiveCamera.prototype.setMinimalFov = function (angle) {
    if (this.aspect >= 1.0) {
      this.fov = angle;
    } else {
      this.fov = THREE.MathUtils.radToDeg(2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(angle) * 0.5) / this.aspect));
    }
  };
  /**
   * @param {THREE.PerspectiveCamera} camera - Base camera for this stereo camera.
   * @param {number} angle - Field of view in degrees.
   */


  THREE.StereoCamera.prototype.updateHalfSized = function (camera, angle) {
    var originalAspect = camera.aspect;
    var originalFov = camera.fov;
    camera.aspect = originalAspect / 2.0;
    camera.setMinimalFov(angle);
    camera.updateProjectionMatrix();
    this.update(camera);
    camera.aspect = originalAspect;
    camera.fov = originalFov;
    camera.updateProjectionMatrix();
  };
  /**
   * @param {number} radius - Radius of bounding sphere in angstroms to fit on screen.
   * @param {number} angle - Field of view in degrees.
   */


  THREE.PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
    this.position.z = radius / Math.sin(0.5 * THREE.MathUtils.degToRad(angle));
  };
  /**
   * @param {RCGroup} gfxObj - All objects on scene.
   * @param {THREE.PerspectiveCamera} camera - Camera used for rendering.
   * @param {number} clipPlane - Distance to clip plane.
   * @param {number} fogFarPlane - Distance to fog far plane.
   */


  THREE.Raycaster.prototype.intersectVisibleObject = function (gfxObj, camera, clipPlane, fogFarPlane) {
    var intersects = this.intersectObject(gfxObj, false);

    if (intersects.length === 0) {
      return null;
    } // find point closest to camera that doesn't get clipped by camera near plane or clipPlane (if it exists)


    var nearPlane = Math.min(camera.near, clipPlane);
    var i;
    var p = intersects[0];
    var v = new THREE.Vector3();

    for (i = 0; i < intersects.length; ++i) {
      p = intersects[i];
      v.copy(p.point);
      v.applyMatrix4(camera.matrixWorldInverse);

      if (v.z <= -nearPlane) {
        break;
      }
    }

    if (i === intersects.length) {
      return null;
    } // check that selected intersection point is not clipped by camera far plane or occluded by fog (if it exists)


    var farPlane = Math.min(camera.far, fogFarPlane);
    v.copy(p.point);
    v.applyMatrix4(camera.matrixWorldInverse);

    if (v.z <= -farPlane) {
      return null;
    }

    return p;
  };

  THREE.Matrix4.prototype.extractScale = function () {
    var _v = new THREE.Vector3();

    return function (scale) {
      if (scale === undefined) {
        logger.debug('extractScale(): new is too expensive operation to do it on-the-fly');
        scale = _v.clone();
      }

      var te = this.elements;
      scale.x = _v.set(te[0], te[1], te[2]).length();
      scale.y = _v.set(te[4], te[5], te[6]).length();
      scale.z = _v.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

      var det = this.determinant();

      if (det < 0) {
        scale.x = -scale.x;
      }

      return scale;
    };
  }();

  function _calcCylinderMatrix(posBegin, posEnd, radius) {
    var posCenter = posBegin.clone().lerp(posEnd, 0.5);
    var matScale = new THREE.Matrix4();
    matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
    var matRotHalf = new THREE.Matrix4();
    matRotHalf.makeRotationX(Math.PI / 2);
    var matRotLook = new THREE.Matrix4();
    var vUp = new THREE.Vector3(0, 1, 0);
    matRotLook.lookAt(posCenter, posEnd, vUp);
    matRotLook.multiply(matRotHalf);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(posCenter);
    return matRotLook;
  }

  function _calcChunkMatrix(eye, target, up, rad) {
    var matScale = new THREE.Matrix4();
    matScale.makeScale(rad.x, rad.y, 0);
    var matRotLook = new THREE.Matrix4();
    matRotLook.lookAt(eye, target, up);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(eye);
    return matRotLook;
  }

  function _groupHasGeometryToRender(group) {
    var hasGeoms = false;
    group.traverse(function (node) {
      if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
        hasGeoms = true;
      }
    });
    return hasGeoms;
  }

  function _buildDistorionMesh(widthSegments, heightSegements, coef) {
    // solve equation r_u = r_d * (1 + k * r_d^2)
    // for r_d using iterations
    // takes: r_u^2
    // returns: r_d / r_u  factor that can be used to distort point coords
    function calcInverseBarrel(r2) {
      var epsilon = 1e-5;
      var prevR2 = 0.0;
      var curR2 = r2;
      var dr = 1.0;

      while (Math.abs(curR2 - prevR2) > epsilon) {
        dr = 1.0 + coef * curR2;
        prevR2 = curR2;
        curR2 = r2 / (dr * dr);
      }

      return 1.0 / dr;
    }

    var geo = new THREE.PlaneBufferGeometry(2.0, 2.0, widthSegments, heightSegements);
    var pos = geo.getAttribute('position');

    for (var i = 0; i < pos.count; ++i) {
      var x = pos.array[3 * i];
      var y = pos.array[3 * i + 1];
      var c = calcInverseBarrel(x * x + y * y);
      pos.setXY(i, c * x, c * y);
    }

    return geo;
  }

  THREE.BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
    console.assert(this.itemSize === attribute.itemSize, 'false: BufferAttribute.copyAtList buffers have different item size.');
    var itemSize = this.itemSize;

    for (var i = 0, n = indexList.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
      }
    }

    return this;
  };

  function fillArray(array, value, startIndex, endIndex) {
    startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
    endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;

    for (var i = startIndex; i < endIndex; ++i) {
      array[i] = value;
    }
  }
  /** @param {THREE.Object3D} object - Parent object. */


  function removeChildren(object) {
    var children = object.children;

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];
      child.parent = null;
      child.dispatchEvent({
        type: 'removed'
      });
    }

    object.children = [];
  }

  function clearTree(object) {
    object.traverse(function (obj) {
      if (obj instanceof THREE.Mesh || obj instanceof THREE.LineSegments || obj instanceof THREE.Line) {
        obj.geometry.dispose();
      }
    });
    removeChildren(object);
  }

  function destroyObject(object) {
    clearTree(object);

    if (object.parent) {
      object.parent.remove(object);
    } else {
      object.dispatchEvent({
        type: 'removed'
      });
    }
  }

  function belongToSelectLayers(object) {
    for (var i = 0; i < SELECTION_LAYERS.length; i++) {
      if ((object.layers.mask >> SELECTION_LAYERS[i] & 1) === 1) {
        return true;
      }
    }

    return false;
  }

  function processObjRenderOrder(root, idMaterial) {
    // set renderOrder to 0 for Backdrop and to 1 in other cases to render Backdrop earlier all other materials
    var renderOrder = +(idMaterial !== 'BA');
    root.traverse(function (object) {
      if (object.isGroup) {
        object.renderOrder = renderOrder;
      }
    });
  }

  function applySelectionMaterial(geo) {
    geo.traverse(function (node) {
      if ('material' in node) {
        node.material = node.material.clone(true); // using z-offset to magically fix selection rendering artifact (on z-sprites)

        node.material.setValues({
          depthFunc: THREE.LessEqualDepth,
          overrideColor: true,
          fog: false,
          lights: false,
          shadowmap: false
        });
        node.material.setUberOptions({
          fixedColor: new THREE.Color(0xFFFF00),
          zOffset: -1e-6
        });
      }
    });
  }

  function getMiddlePoint(point1, point2, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.set(0, 0, 0);
    result.addScaledVector(point1, 0.5);
    result.addScaledVector(point2, 0.5);
    return result;
  } // Monkey-patch for "InstancedBufferGeometry.instanceCount becomes undefined after copy()"
  // https://github.com/mrdoob/three.js/issues/22151


  var _oldInstancedBufferGeometryCopy = THREE.InstancedBufferGeometry.prototype.copy;

  THREE.InstancedBufferGeometry.prototype.copy = function (source) {
    _oldInstancedBufferGeometryCopy.call(this, source);

    if (this.instanceCount === undefined) {
      this.instanceCount = Infinity;
    }
  };

  var gfxutils = {
    calcCylinderMatrix: _calcCylinderMatrix,
    calcChunkMatrix: _calcChunkMatrix,
    groupHasGeometryToRender: _groupHasGeometryToRender,
    buildDistorionMesh: _buildDistorionMesh,
    RCGroup: RCGroup,
    fillArray: fillArray,
    clearTree: clearTree,
    destroyObject: destroyObject,
    belongToSelectLayers: belongToSelectLayers,
    processObjRenderOrder: processObjRenderOrder,
    applySelectionMaterial: applySelectionMaterial,
    getMiddlePoint: getMiddlePoint,
    LAYERS: LAYERS
  };

  function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _defaultBoundaries = {
    boundingBox: new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
    boundingSphere: new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1)
  };

  var Visual = /*#__PURE__*/function (_gfxutils$RCGroup) {
    inherits(Visual, _gfxutils$RCGroup);

    var _super = _createSuper$c(Visual);

    function Visual(name, dataSource) {
      var _this;

      classCallCheck(this, Visual);

      _this = _super.call(this, name, dataSource);
      _this.name = name;
      _this._dataSource = dataSource;
      return _this;
    }

    createClass(Visual, [{
      key: "release",
      value: function release() {
        if (this.parent) {
          this.parent.remove(this);
        }
      }
    }, {
      key: "getDataSource",
      value: function getDataSource() {
        return this._dataSource;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return _defaultBoundaries;
      }
    }]);

    return Visual;
  }(gfxutils.RCGroup);

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function _ensureArray(x) {
    if (x === null || x === undefined || Array.isArray(x)) {
      return x;
    }

    return [x];
  }
  /** An indexed list of objects or classes. */


  var EntityList = /*#__PURE__*/function () {
    /**
     * Create a list of objects.
     * The objects can be indexed by one or more properties for the later retrieval.
     *
     * @param {!Array<Object>=} entities A list of objects to automatically register at creation time.
     * @param {!Array<string>=} indices A list of property names to use for case-insensitive indexing.
     *   By default, a single `.id` property is used.
     * @see EntityList#register
     */
    function EntityList() {
      var _this = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id'];

      classCallCheck(this, EntityList);

      this._list = [];
      this._dict = {};
      this._indices = toConsumableArray(indices);

      this._indices.forEach(function (index) {
        _this._dict[index] = {};
      });

      entities.forEach(function (entity) {
        return _this.register(entity);
      });
    }
    /**
     * Add a value to the end of a list.
     * The list will contain only one copy of the value.
     *
     * @param {!Array} list An array.
     * @param {*} value A value to add.
     * @see EntityList.unregisterFromList
     * @see EntityList.registerInDict
     */


    createClass(EntityList, [{
      key: "register",

      /**
       * Add an entity to this list.
       *
       * @param {!Object} entity An object or a class to register. The object must include all
       *   properties specified as indices on construction.
       * @see EntityList#unregister
       */
      value: function register(entity) {
        var _this2 = this;

        EntityList.registerInList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.registerInDict(_this2._dict[index], _ensureArray(entity[index]), entity);
        });
      }
      /**
       * Remove an entity from this list.
       *
       * @param {!Object} entity An object or a class to unregister. The object may be
       *   missing from the list but it must include all properties specified as indices
       *   on construction.
       * @see EntityList#register
       */

    }, {
      key: "unregister",
      value: function unregister(entity) {
        var _this3 = this;

        EntityList.unregisterFromList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.unregisterFromDict(_this3._dict[index], _ensureArray(entity[index]), entity);
        });
      }
      /**
       * An ordered list of all registered entities.
       * It is a read-only copy, use {@link EntityList#register} and {@link EntityList#unregister}
       * to modify it.
       *
       * @type {!Array<Object>}
       */

    }, {
      key: "keys",

      /**
       * Retrieve a list of keys for the index.
       *
       * @param {string=} index One of the indices specified during the list construction. If omitted,
       *   the first of the indices is used.
       * @returns {!Array<string>} An unordered list of keys in the index, i.e. particular property
       *   values for all registered entities.
       */
      value: function keys(index) {
        return Object.keys(this._dict[index || this._indices[0]]);
      }
      /**
       * Retrieve an entity by its key.
       *
       * @param {string} key A case-insensitive property value to look-up.
       * @param {string=} index One of the indices specified during the list construction. If omitted,
       *   the first of the indices is used.
       * @returns {Object=} An object registered in the index under the key. If there are multiple
       *   objects under the same key, the first one is returned.
       */

    }, {
      key: "get",
      value: function get(key, index) {
        var dict = this._dict[index || this._indices[0]];

        if (dict) {
          var values = dict[key && key.toLowerCase()];
          return values && values.length > 0 ? values[0] : undefined;
        }

        return undefined;
      }
    }, {
      key: "all",
      get: function get() {
        return toConsumableArray(this._list);
      }
      /**
       * The first registered entity.
       * Use it if you do not care which entity you are referring to.
       *
       * @type {Object=}
       */

    }, {
      key: "first",
      get: function get() {
        return this._list[0];
      }
    }], [{
      key: "registerInList",
      value: function registerInList(list, value) {
        if (!list.includes(value)) {
          list.push(value);
        }
      }
      /**
       * Remove a value from a list if it is there.
       *
       * @param {!Array} list An array.
       * @param {*} value A value to remove.
       * @see EntityList.registerInList
       */

    }, {
      key: "unregisterFromList",
      value: function unregisterFromList(list, value) {
        var pos = list.indexOf(value);

        if (pos !== -1) {
          list.splice(pos, 1);
        }
      }
      /**
       * Add a value to a dictionary.
       * The value may be stored under multiple different keys (aliases).
       * There might be multiples values stored under the same key.
       *
       * @param {!Object<string,*>} dict A dictionary.
       * @param {!Array<string>} keys An array of keys.
       * @param {*} value A value to add.
       * @see EntityList.unregisterFromDict
       * @see EntityList.registerInList
       */

    }, {
      key: "registerInDict",
      value: function registerInDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key] = dict[key] || [];

          if (!list.includes(value)) {
            list.push(value);
          }
        });
      }
      /**
       * Remove a value from a dictionary.
       * The value may be stored under multiple different keys (aliases).
       * There might be multiples values stored under the same key.
       *
       * @param {!Object<string,*>} dict A dictionary.
       * @param {!Array<string>} keys An array of keys.
       * @param {*} value A value to add.
       * @see EntityList.registerInDict
       */

    }, {
      key: "unregisterFromDict",
      value: function unregisterFromDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key];

          if (list) {
            var pos = list.indexOf(value);

            if (pos !== -1) {
              list.splice(pos, 1);
            }

            if (list.length === 0) {
              delete dict[key];
            }
          }
        });
      }
    }]);

    return EntityList;
  }();

  function makeContextDependent(prototype) {
    Object.defineProperties(prototype, {
      logger: {
        get: function get() {
          return this.context && this.context.logger ? this.context.logger : logger;
        }
      },
      settings: {
        get: function get() {
          return this.context && this.context.settings ? this.context.settings : settings;
        }
      }
    });
  }

  function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CollisionSphere = /*#__PURE__*/function () {
    function CollisionSphere(position, radius) {
      classCallCheck(this, CollisionSphere);

      this._position = position;
      this._radius = radius;
    }

    createClass(CollisionSphere, [{
      key: "raycast",
      value: function raycast(raycaster) {
        var sphere = CollisionSphere._sphere;
        sphere.set(this._position, this._radius);
        var p = new THREE.Vector3();

        if (raycaster.ray.intersectSphere(sphere, p)) {
          return {
            distance: raycaster.ray.origin.distanceTo(p),
            point: p
          };
        }

        return null;
      }
    }]);

    return CollisionSphere;
  }();

  defineProperty(CollisionSphere, "_sphere", new THREE.Sphere());

  var SphereCollisionGeo = function SphereCollisionGeo(base) {
    return /*#__PURE__*/function (_base) {
      inherits(_class, _base);

      var _super = _createSuper$d(_class);

      function _class(count) {
        var _this;

        classCallCheck(this, _class);

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));
        _this._objects = new Array(count);
        _this.boundingSphere = null;
        _this.boundingBox = null;
        return _this;
      }

      createClass(_class, [{
        key: "setSphere",
        value: function setSphere(idx, position, radius) {
          this._objects[idx] = new CollisionSphere(position, radius);
        }
      }, {
        key: "raycast",
        value: function raycast(raycaster, intersects) {
          // TODO raycast with bounding sphere? How to deal with updates?
          for (var i = 0, n = this._objects.length; i < n; ++i) {
            var inters = this._objects[i].raycast(raycaster);

            if (inters) {
              inters.chunkIdx = i;
              intersects.push(inters);
            }
          }
        }
      }, {
        key: "computeBoundingBox",
        value: function computeBoundingBox() {
          var objects = this._objects;
          var boundingBox = this.boundingBox;

          if (boundingBox === null) {
            this.boundingBox = boundingBox = new THREE.Box3();
          }

          boundingBox.makeEmpty();

          for (var i = 0, n = objects.length; i < n; ++i) {
            boundingBox.expandByPoint(objects[i]._position);
          }
        }
      }, {
        key: "computeBoundingSphere",
        value: function computeBoundingSphere() {
          this.computeBoundingBox();
          var objects = this._objects;
          var boundingBox = this.boundingBox; // Build bounding sphere

          var radiusSquared = 0.0;
          var center = new THREE.Vector3();
          boundingBox.getCenter(center);

          for (var i = 0, n = objects.length; i < n; ++i) {
            var pos = objects[i]._position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }

          this.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }]);

      return _class;
    }(base);
  };

  function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor = new THREE.Color();
  var OFFSET_SIZE = 4;
  var COLOR_SIZE = 3;
  var copySubArrays$1 = utils.copySubArrays;

  function setArrayXYZ(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  var InstancedSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(InstancedSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$e(InstancedSpheresGeometry);

    function InstancedSpheresGeometry(spheresCount, sphereComplexity, useZSprites) {
      var _this;

      classCallCheck(this, InstancedSpheresGeometry);

      _this = _super.call(this, spheresCount);
      _this._sphGeometry = useZSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new THREE.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);

      _this._init(spheresCount, _this._sphGeometry);

      return _this;
    }

    createClass(InstancedSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        setArrayXYZW(this._offsets, itemIdx * OFFSET_SIZE, itemPos.x, itemPos.y, itemPos.z, itemRad);
        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal) {
        tmpColor.set(colorVal);
        setArrayXYZ(this._colors, itemIdx * COLOR_SIZE, tmpColor.r, tmpColor.g, tmpColor.b);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('offset').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[chunkIndices[i]] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._sphGeometry);

        copySubArrays$1(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE);
        copySubArrays$1(this._colors, geom._colors, chunkIndices, COLOR_SIZE);
        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(spheresCount, sphereGeo) {
        this.copy(sphereGeo);
        this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE);
        this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);

        ___default['default'].fill(alpha, 1.0);

        this.setAttribute('offset', new THREE.InstancedBufferAttribute(this._offsets, OFFSET_SIZE, false, 1));
        this.setAttribute('color', new THREE.InstancedBufferAttribute(this._colors, COLOR_SIZE, false, 1));
        this.setAttribute('alphaColor', new THREE.InstancedBufferAttribute(alpha, 1, false, 1));
      }
    }]);

    return InstancedSpheresGeometry;
  }(SphereCollisionGeo(THREE.InstancedBufferGeometry));

  function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This class adds raycasting interface to indexed
   * THREE.BufferGeometry.
   * @constructor
   */

  var RaycastableBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(RaycastableBufferGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$f(RaycastableBufferGeometry);

    function RaycastableBufferGeometry() {
      classCallCheck(this, RaycastableBufferGeometry);

      return _super.apply(this, arguments);
    }

    createClass(RaycastableBufferGeometry, [{
      key: "uvIntersection",
      // This method was copied from three.js
      value: function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
        var barycoord = RaycastableBufferGeometry._barycoord;
        THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
        uv1.multiplyScalar(barycoord.x);
        uv2.multiplyScalar(barycoord.y);
        uv3.multiplyScalar(barycoord.z);
        uv1.add(uv2).add(uv3);
        return uv1.clone();
      }
    }, {
      key: "checkIntersection",
      value: function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
        var intersect = ray.intersectTriangle(pA, pB, pC, false, point);

        if (intersect === null) {
          return null;
        }

        return {
          point: point.clone()
        };
      }
    }, {
      key: "checkBufferGeometryIntersection",
      value: function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
        var vA = RaycastableBufferGeometry._vA;
        var vB = RaycastableBufferGeometry._vB;
        var vC = RaycastableBufferGeometry._vC;
        var intersectionPoint = RaycastableBufferGeometry._intersectionPoint;
        vA.fromBufferAttribute(position, a);
        vB.fromBufferAttribute(position, b);
        vC.fromBufferAttribute(position, c);
        var intersection = this.checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);

        if (intersection) {
          if (uv) {
            var uvA = RaycastableBufferGeometry._uvA;
            var uvB = RaycastableBufferGeometry._uvB;
            var uvC = RaycastableBufferGeometry._uvC;
            uvA.fromBufferAttribute(uv, a);
            uvB.fromBufferAttribute(uv, b);
            uvC.fromBufferAttribute(uv, c);
            intersection.uv = this.uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
          }

          var normal = new THREE.Vector3();
          THREE.Triangle.getNormal(vA, vB, vC, normal);
          intersection.face = new THREE.Face3(a, b, c, normal);
          intersection.faceIndex = a;
        }

        return intersection;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var ray = raycaster.ray;

        if (this.boundingSphere === null) {
          this.computeBoundingSphere();
        }

        if (raycaster.ray.intersectsSphere(this.boundingSphere) === false) {
          return;
        }

        if (this.boundingBox !== null) {
          if (ray.intersectsBox(this.boundingBox) === false) {
            return;
          }
        }

        var a;
        var b;
        var c;
        var index = this.index,
            _this$attributes = this.attributes,
            position = _this$attributes.position,
            uv = _this$attributes.uv;

        if (index === null) {
          return;
        } // indexed buffer geometry


        for (var i = 0, l = index.count; i < l; i += 3) {
          a = index.getX(i);
          b = index.getX(i + 1);
          c = index.getX(i + 2);
          var intersection = this.checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics

            intersects.push(intersection);
          }
        }
      }
    }]);

    return RaycastableBufferGeometry;
  }(THREE.BufferGeometry);

  defineProperty(RaycastableBufferGeometry, "_vA", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_vB", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_vC", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_uvA", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_uvB", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_uvC", new THREE.Vector2());

  defineProperty(RaycastableBufferGeometry, "_barycoord", new THREE.Vector3());

  defineProperty(RaycastableBufferGeometry, "_intersectionPoint", new THREE.Vector3());

  function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT = 65535;
  var VEC_SIZE = 3;
  var tmpColor$1 = new THREE.Color();
  /**
   * This class represents geometry which consists of separate chunks.
   * Each chunk has same index and similar geometry with equal points and faces count.
   * Each chunk has by default only one color.
   * @constructor
   */

  var ChunkedObjectsGeometry = /*#__PURE__*/function (_RaycastableBufferGeo) {
    inherits(ChunkedObjectsGeometry, _RaycastableBufferGeo);

    var _super = _createSuper$g(ChunkedObjectsGeometry);

    function ChunkedObjectsGeometry(chunkGeo, chunksCount) {
      var _this;

      classCallCheck(this, ChunkedObjectsGeometry);

      _this = _super.call(this);

      if (_this.constructor === ChunkedObjectsGeometry) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._chunkGeo = chunkGeo;

      _this._init(chunkGeo, chunksCount);

      return _this;
    }

    createClass(ChunkedObjectsGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('normal').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor$1.set(colorVal);
        var colors = this._colors;
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          var idx = i * VEC_SIZE;
          colors[idx] = tmpColor$1.r;
          colors[idx + 1] = tmpColor$1.g;
          colors[idx + 2] = tmpColor$1.b;
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          ___default['default'].fill(alphaArr, value, left, left + chunkSize);
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];

        get(getPrototypeOf(ChunkedObjectsGeometry.prototype), "raycast", this).call(this, raycaster, inters);

        var facesPerChunk = this._chunkGeo.index.count / 3;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('faceIndex')) {
            continue;
          }

          inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
          intersects.push(inters[i]);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE.BufferGeometry();

        this._init.call(geom, this._chunkGeo, instanceCount);

        var srcPos = this._positions;
        var srcNorm = this._normals;
        var srcColor = this._colors;
        var dstPos = geom._positions;
        var dstNorm = geom._normals;
        var dstColor = geom._colors;
        var chunkSize = this._chunkSize * VEC_SIZE;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var ptIdxBegin = chunkIndices[i] * chunkSize;
          var ptIdxEnd = ptIdxBegin + chunkSize;
          dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        }

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(chunkGeo, chunksCount) {
        var chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
        var chunkIndex = chunkGeo.index.array;
        var chunkIndexSize = chunkIndex.length;
        var pointsCount = this._chunkSize * chunksCount;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT;
        var indexSize = chunkIndexSize * chunksCount;
        var index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default['default'].fill(alpha, 1.0);

        for (var i = 0; i < chunksCount; ++i) {
          var offset = i * chunkIndexSize;
          var posOffset = i * chunkSize;
          index.set(chunkIndex, offset);

          for (var j = 0; j < chunkIndexSize; ++j) {
            index[offset + j] += posOffset;
          }
        }

        this.setIndex(new THREE.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE.BufferAttribute(this._positions, VEC_SIZE));
        this.setAttribute('normal', new THREE.BufferAttribute(this._normals, VEC_SIZE));
        this.setAttribute('color', new THREE.BufferAttribute(this._colors, VEC_SIZE));
        this.setAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
      }
    }]);

    return ChunkedObjectsGeometry;
  }(RaycastableBufferGeometry);

  function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$1 = 3;

  var SimpleSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(SimpleSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$h(SimpleSpheresGeometry);

    function SimpleSpheresGeometry(spheresCount, sphereComplexity) {
      var _this;

      classCallCheck(this, SimpleSpheresGeometry);

      var sphGeometry = new THREE.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
      _this = _super.call(this, spheresCount, sphGeometry, spheresCount);
      var normals = _this._normals;
      var geoNormals = sphGeometry.attributes.normal.array;
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$1);

      for (var i = 0; i < spheresCount; ++i) {
        normals.set(geoNormals, chunkSize * VEC_SIZE$1 * i);
      }

      return _this;
    }

    createClass(SimpleSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        var tmpPos = this._tmpPositions;
        var chunkSize = this._chunkSize;
        var geoPos = this._chunkPos;

        for (var i = 0; i < chunkSize; ++i) {
          var idx = i * 3;
          tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
          tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
          tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
        }

        this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$1);

        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }]);

    return SimpleSpheresGeometry;
  }(SphereCollisionGeo(ChunkedObjectsGeometry));

  function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$2 = 3;
  var centerPos = new THREE.Vector3();
  var tmpVector = new THREE.Vector3();
  var normMtx = new THREE.Matrix3();

  var Simple2CCylindersGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(Simple2CCylindersGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$i(Simple2CCylindersGeometry);

    function Simple2CCylindersGeometry(instanceCount, polyComplexity) {
      var _this;

      classCallCheck(this, Simple2CCylindersGeometry);

      var cylGeometry = new THREE.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, 2 * instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$2);
      return _this;
    }

    createClass(Simple2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2;
        var secondOffset = firstOffset + chunkSize * VEC_SIZE$2;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        centerPos.lerpVectors(botPos, topPos, 0.5);
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
        normMtx.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE$2;
          tmpVector.fromArray(geoPos, idx);
          tmpVector.applyMatrix4(mtx1);
          tmpVector.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, firstOffset); // now shift center to get another part of the cylinder


        centerPos.sub(botPos);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE$2;
          tmpArray[idx] += centerPos.x;
          tmpArray[idx + 1] += centerPos.y;
          tmpArray[idx + 2] += centerPos.z;
        }

        this._positions.set(tmpArray, secondOffset);

        for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
          idx = _i2 * VEC_SIZE$2;
          tmpVector.fromArray(geoNorm, idx);
          tmpVector.applyMatrix3(normMtx);
          tmpVector.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, firstOffset);

        this._normals.set(tmpArray, secondOffset);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var first = 2 * itemIdx;

        get(getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, first, colorVal1);

        var second = first + 1;

        get(getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, second, colorVal2);
      }
    }]);

    return Simple2CCylindersGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_POINTS_COUNT_16BIT = 65536;
  var PTS_PER_TRIANGLE = 3;

  var CylinderBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(CylinderBufferGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$j(CylinderBufferGeometry);

    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
      var _this;

      classCallCheck(this, CylinderBufferGeometry);

      _this = _super.call(this);
      var thetaStart = 0;
      var thetaLength = 2 * Math.PI;
      _this.type = 'CylinderBufferGeometry';
      _this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded
      };
      var hasTop = openEnded === false && radiusTop > 0;
      var hasBottom = openEnded === false && radiusBottom > 0;
      var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
      var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
      var heightHalf = height / 2;
      /* eslint-disable no-magic-numbers */

      var positions = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var normals = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var indices = new THREE.Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
      /* eslint-enable no-magic-numbers */

      var uvs = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
      console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'false: Cylinder Geometry has too many vertices (65536 max).');
      var currVtxIdx = 0;
      var currFaceIdx = 0;
      var tanTheta = -(radiusBottom - radiusTop) / height; // setup cylinder data

      for (var y = 0; y <= heightSegments; y++) {
        // faces
        if (y !== heightSegments) {
          for (var i = 0; i < radialSegments; i++) {
            var v1 = currVtxIdx + i;
            var v2 = currVtxIdx + radialSegments + i;
            var v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
            var v4 = currVtxIdx + (i + 1) % radialSegments;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
            currFaceIdx++;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
            currFaceIdx++;
          }
        } // vertices


        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (var x = 0; x < radialSegments; x++) {
          var u = x / radialSegments;
          var vx = radius * Math.sin(u * thetaLength + thetaStart);
          var vy = v * height - heightHalf;
          var vz = radius * Math.cos(u * thetaLength + thetaStart);
          var normal = new THREE.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
          positions.setXYZ(currVtxIdx, vx, vy, vz);
          normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
          uvs.setXY(currVtxIdx, u, v);
          ++currVtxIdx;
        }
      } // top cap


      if (hasTop) {
        var startTIdx = currVtxIdx;
        var lastIdx = currVtxIdx + radialSegments;

        for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
          var currSrcIdx = currVtxIdx - radialSegments;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
          normals.setXYZ(currVtxIdx, 0, 1, 0);
          uvs.setXY(currVtxIdx, 1, 1);
          var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        ++currVtxIdx;
      } // bottom cap


      if (hasBottom) {
        var startBIdx = currVtxIdx;
        var lastBIdx = currVtxIdx + radialSegments;

        for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
          var currSrcBIdx = fBIdx;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
          normals.setXYZ(currVtxIdx, 0, -1, 0);
          uvs.setXY(currVtxIdx, 0, 0);
          var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
      }

      _this.setIndex(indices);

      _this.setAttribute('position', positions);

      _this.setAttribute('normal', normals);

      _this.setAttribute('uv', uvs);

      return _this;
    }

    createClass(CylinderBufferGeometry, [{
      key: "clone",
      value: function clone() {
        var parameters = this.parameters;
        return new CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
      }
    }]);

    return CylinderBufferGeometry;
  }(THREE.BufferGeometry);

  function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor$2 = new THREE.Color();
  var invMatrix = new THREE.Matrix4();
  var OFFSET_SIZE$1 = 4;
  var COLOR_SIZE$1 = 3;
  var copySubArrays$2 = utils.copySubArrays;

  function setArrayXYZ$1(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$1(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function sortNumber(a, b) {
    return a - b;
  }

  function _prepareCylinderInfo(chunkIndices) {
    chunkIndices.sort(sortNumber);
    var chunksIdx = [];
    var cylinderInfo = [];

    for (var i = 0, n = chunkIndices.length; i < n; ++i) {
      var val = chunkIndices[i];
      var even = (val | 0) % 2 === 0;
      var newPar = {
        first: false,
        second: false
      };

      if (even) {
        newPar.first = true;
        newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;

        if (newPar.second) {
          ++i;
        }
      } else {
        newPar.second = true;
      }

      chunksIdx.push(Math.floor(val / 2));
      cylinderInfo.push(newPar);
    }

    return {
      indices: chunksIdx,
      cylinderInfo: cylinderInfo
    };
  }

  function _assignOpacity(cylinderInfo, color1, color2) {
    for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
      var info = cylinderInfo[i];

      if (!info.first) {
        color1[COLOR_SIZE$1 * i] = -0.5;
      }

      if (!info.second) {
        color2[COLOR_SIZE$1 * i] = -0.5;
      }
    }
  }

  var Instanced2CCylindersGeometry = /*#__PURE__*/function (_THREE$InstancedBuffe) {
    inherits(Instanced2CCylindersGeometry, _THREE$InstancedBuffe);

    var _super = _createSuper$k(Instanced2CCylindersGeometry);

    function Instanced2CCylindersGeometry(instanceCount, polyComplexity, useZSprites, openEnded) {
      var _this;

      classCallCheck(this, Instanced2CCylindersGeometry);

      _this = _super.call(this);
      _this._useZSprites = useZSprites;
      _this._cylGeometry = useZSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, openEnded);

      _this._init(instanceCount, _this._cylGeometry, _this._useZSprites);

      _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3);
      return _this;
    }

    createClass(Instanced2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        var me = matrix.elements;
        var mtxOffset = itemIdx * OFFSET_SIZE$1;

        this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);

        setArrayXYZW$1(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
        setArrayXYZW$1(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
        setArrayXYZW$1(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);

        if (this._useZSprites) {
          invMatrix.copy(matrix).invert();
          me = invMatrix.elements;
          setArrayXYZW$1(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
          setArrayXYZW$1(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
          setArrayXYZW$1(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
        }
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var colorIdx = itemIdx * COLOR_SIZE$1;
        tmpColor$2.set(colorVal1);
        setArrayXYZ$1(this._color1, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
        tmpColor$2.set(colorVal2);
        setArrayXYZ$1(this._color2, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        this._collisionGeo.computeBoundingSphere();

        this.boundingSphere = this._collisionGeo.boundingSphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        this._collisionGeo.computeBoundingBox();

        this.boundingBox = this._collisionGeo.boundingBox;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        this._collisionGeo.raycast(raycaster, intersects);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('matVector1').needsUpdate = true;
        this.getAttribute('matVector2').needsUpdate = true;
        this.getAttribute('matVector3').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('color2').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;

        if (this._useZSprites) {
          this.getAttribute('invmatVector1').needsUpdate = true;
          this.getAttribute('invmatVector2').needsUpdate = true;
          this.getAttribute('invmatVector3').needsUpdate = true;
        }

        this._collisionGeo.finishUpdate();
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var info = _prepareCylinderInfo(chunkIndices);

        var cylinderIndices = info.indices;
        var instanceCount = cylinderIndices.length;
        var geom = new THREE.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);

        copySubArrays$2(this._matVector1, geom._matVector1, cylinderIndices, OFFSET_SIZE$1);
        copySubArrays$2(this._matVector2, geom._matVector2, cylinderIndices, OFFSET_SIZE$1);
        copySubArrays$2(this._matVector3, geom._matVector3, cylinderIndices, OFFSET_SIZE$1);

        if (this._useZSprites) {
          copySubArrays$2(this._invmatVector1, geom._invmatVector1, cylinderIndices, OFFSET_SIZE$1);
          copySubArrays$2(this._invmatVector2, geom._invmatVector2, cylinderIndices, OFFSET_SIZE$1);
          copySubArrays$2(this._invmatVector3, geom._invmatVector3, cylinderIndices, OFFSET_SIZE$1);
        }

        copySubArrays$2(this._color1, geom._color1, cylinderIndices, COLOR_SIZE$1);
        copySubArrays$2(this._color2, geom._color2, cylinderIndices, COLOR_SIZE$1);

        _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "getGeoParams",
      value: function getGeoParams() {
        return this._cylGeometry.parameters;
      }
    }, {
      key: "_init",
      value: function _init(instanceCount, cylinderGeo, useZSprites) {
        this.copy(cylinderGeo);
        this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
        this._color1 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
        this._color2 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);

        ___default['default'].fill(alpha, 1.0);

        this.setAttribute('matVector1', new THREE.InstancedBufferAttribute(this._matVector1, OFFSET_SIZE$1, false, 1));
        this.setAttribute('matVector2', new THREE.InstancedBufferAttribute(this._matVector2, OFFSET_SIZE$1, false, 1));
        this.setAttribute('matVector3', new THREE.InstancedBufferAttribute(this._matVector3, OFFSET_SIZE$1, false, 1));
        this.setAttribute('color', new THREE.InstancedBufferAttribute(this._color1, COLOR_SIZE$1, false, 1));
        this.setAttribute('color2', new THREE.InstancedBufferAttribute(this._color2, COLOR_SIZE$1, false, 1));
        this.setAttribute('alphaColor', new THREE.InstancedBufferAttribute(this._alpha, 1, false, 1));

        if (useZSprites) {
          this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
          this.setAttribute('invmatVector1', new THREE.InstancedBufferAttribute(this._invmatVector1, OFFSET_SIZE$1, false, 1));
          this.setAttribute('invmatVector2', new THREE.InstancedBufferAttribute(this._invmatVector2, OFFSET_SIZE$1, false, 1));
          this.setAttribute('invmatVector3', new THREE.InstancedBufferAttribute(this._invmatVector3, OFFSET_SIZE$1, false, 1));
        }
      }
    }]);

    return Instanced2CCylindersGeometry;
  }(THREE.InstancedBufferGeometry);

  function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$3 = 3;
  var TRI_SIZE = 3;
  var tmpPrev = new THREE.Vector3();
  var tmpNext = new THREE.Vector3();
  var tmpRes = new THREE.Vector3();
  var simpleNormal = new THREE.Vector3(1.0, 0.0, 0.0);
  var normalOnCut = new THREE.Vector3();
  var nearRingPt = new THREE.Vector3();

  function _createExtrudedChunkGeometry(shape, ringsCount) {
    var geo = new THREE.BufferGeometry();
    var ptsCount = shape.length;
    var totalPts = ptsCount * ringsCount;
    var type = totalPts <= 65536 ? Uint16Array : Uint32Array;
    var facesPerChunk = (ringsCount - 1) * ptsCount * 2;
    var indices = new THREE.BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
    var currVtxIdx = 0;
    var currFaceIdx = 0;

    for (var y = 0; y < ringsCount; y++) {
      // faces
      if (y !== ringsCount - 1) {
        for (var i = 0; i < ptsCount; i++) {
          var v1 = currVtxIdx + i;
          var v2 = currVtxIdx + ptsCount + i;
          var v3 = currVtxIdx + ptsCount + (i + 1) % ptsCount;
          var v4 = currVtxIdx + (i + 1) % ptsCount;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
          currFaceIdx++;
        }
      }

      currVtxIdx += ptsCount;
    }

    geo.setIndex(indices);
    var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, VEC_SIZE$3));
    geo._positions = shape;
    return geo;
  }

  var ExtrudedObjectsGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(ExtrudedObjectsGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$l(ExtrudedObjectsGeometry);

    function ExtrudedObjectsGeometry(shape, ringsCount, chunksCount) {
      var _this;

      classCallCheck(this, ExtrudedObjectsGeometry);

      var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);

      _this = _super.call(this, chunkGeo, chunksCount);
      _this._ringsCount = ringsCount;
      var tmpShape = _this._tmpShape = [];

      for (var i = 0; i < shape.length; ++i) {
        tmpShape[i] = new THREE.Vector3();
      }

      return _this;
    }

    createClass(ExtrudedObjectsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, matrices) {
        var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var ptsCount = this._chunkGeo._positions.length;
        var ringsCount = this._ringsCount;
        var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$3;

        this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);

        if (hasSlope) {
          this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
        } else {
          this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
        }

        if (hasCut) {
          this._addCut(ptsCount, ringsCount, chunkStartIdx);
        }
      }
    }, {
      key: "_setPoints",
      value: function _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
        var tmpShape = this._tmpShape;
        var positions = this._positions;
        var shape = this._chunkGeo._positions;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i) {
          var mtx = matrices[i];

          for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
            tmpShape[j].copy(shape[j]).applyMatrix4(mtx).toArray(positions, vtxIdx);
          }
        }
      }
    }, {
      key: "_setBaseNormals",
      value: function _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
        var nPtsInRing = ptsCount * VEC_SIZE$3;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, false);
        }
      }
    }, {
      key: "_setSlopeNormals",
      value: function _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
        var normals = this._normals;
        var nPtsInRing = ptsCount * VEC_SIZE$3;
        var vtxIdx = chunkStartIdx; // First ring
        // In all cases, besides cut, second ring is coincident to first. So values of first ring's normals doesn't
        // matter (In the cut case special handler will be applied later and will set them to correct values)

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
          simpleNormal.toArray(normals, vtxIdx);
        } // second ring
        // If it isn't first Item we take normals' values from the last ring of the previous item (these rings are coincident)
        // else we count normals' values based on next ring information


        if (vtxIdx - 2 * nPtsInRing > 0) {
          for (var _j = 0; _j < ptsCount; ++_j, vtxIdx += VEC_SIZE$3) {
            tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
          }
        } else {
          this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);

          vtxIdx += nPtsInRing;
        } // other rings
        // we count normals' values based on previous ring information


        for (var i = 2; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
        }
      } // Counting normals:
      // - Slope
      //   Radius changes throught part => normals aren't parallel with the plane contains section points
      //   normal = vTangentInSectionPlane x vToSuchPointInPrevSection (all vectors are scaled for being 1 in length)
      // - No slope
      //   Radius doesn't change throught part => normals are parallel with the plane contains section points
      //   normal = vToPrevPointInSection + vToNextPointInSection (all vectors are scaled for being 1 in length)

    }, {
      key: "_countNormalsInRing",
      value: function _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
        var tmpShape = this._tmpShape;
        var normals = this._normals;
        tmpShape[0].fromArray(this._positions, vtxIdx);
        tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * VEC_SIZE$3);

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$3) {
          if (j < ptsCount - 1) {
            tmpShape[j + 1].fromArray(this._positions, vtxIdx + VEC_SIZE$3);
          }

          if (isSlope) {
            nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
            tmpPrev.subVectors(tmpShape[(j + ptsCount - 1) % ptsCount], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], nearRingPt).normalize();
            tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
          } else {
            tmpPrev.subVectors(tmpShape[j], tmpShape[(j + ptsCount - 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
          }
        }
      }
    }, {
      key: "_addCut",
      value: function _addCut(ptsCount, ringsCount, chunkStartIdx) {
        // Nothing to do if item is flat or only line
        if (ptsCount < 3 || ringsCount < 2) {
          return;
        }

        var positions = this._positions;
        var normals = this._normals;
        var tmpShape = this._tmpShape;
        var nPtsInRing = ptsCount * VEC_SIZE$3; // Normal to the cut plane is equal to cross product of two vectors which are lying in it

        tmpShape[0].fromArray(positions, chunkStartIdx);
        tmpShape[1].fromArray(positions, chunkStartIdx + VEC_SIZE$3);
        tmpShape[2].fromArray(positions, chunkStartIdx + 2 * VEC_SIZE$3);
        tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
        tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
        normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
        var vtxIdx = chunkStartIdx; // First and second rings normals' values are equal to value of normal to the cutting plane

        for (var j = 0; j < ptsCount * 2; ++j, vtxIdx += VEC_SIZE$3) {
          normalOnCut.toArray(normals, vtxIdx);
        }

        if (ringsCount > 2) {
          // Third ring points are coincident to first ring points, but have different normals. It makes sharp angle near cut
          for (var _j2 = 0; _j2 < ptsCount; ++_j2, vtxIdx += VEC_SIZE$3) {
            tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
          }
        }
      }
    }]);

    return ExtrudedObjectsGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT$1 = 65535;
  var VERTEX_PER_SEGMENT = 4;
  var POS_SIZE = 4;
  var DIR_SIZE = 3;
  var COL_SIZE = 3;
  var tmpColor$3 = new THREE.Color();
  var direction = new THREE.Vector3();

  function setArrayXYZ$2(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$2(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
    var start = startSegmentIdx * VERTEX_PER_SEGMENT;
    var end = start + segmentsCount * VERTEX_PER_SEGMENT;
    return arr.subarray(start * elemSize, end * elemSize);
  }
  /**
   * This class represents lines geometry which consists of screen-aligned narrow quad of variable width.
   *
   * @constructor
   *
   * @param {number}  segmentsCount   Number of segments per chunk.
   * collision geometry.
   */


  var ThickLinesGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    inherits(ThickLinesGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$m(ThickLinesGeometry);

    function ThickLinesGeometry(segmentsCount) {
      var _this;

      classCallCheck(this, ThickLinesGeometry);

      _this = _super.call(this);

      _this._initVertices(segmentsCount);

      return _this;
    }

    createClass(ThickLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;
        this.getAttribute('direction').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(segmentIdx, colorVal) {
        tmpColor$3.set(colorVal);
        var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
        idx += COL_SIZE;
        setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
      }
    }, {
      key: "setSegment",
      value: function setSegment(segmentIdx, pos1, pos2) {
        direction.subVectors(pos1, pos2);
        direction.normalize();
        var positions = this._positions;
        var directions = this._directions;
        var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
        var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
        setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(startSegIdx, endSegIdx, value) {
        var start = startSegIdx * VERTEX_PER_SEGMENT;
        var end = endSegIdx * VERTEX_PER_SEGMENT;

        ___default['default'].fill(this.alpha, value, end, start);

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubsetSegments",
      value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
        return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
      }
    }, {
      key: "getSubsetColors",
      value: function getSubsetColors(startSegmentIdx, segmentsCount) {
        return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
      }
    }, {
      key: "getSubsetOpacities",
      value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
        return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
      }
    }, {
      key: "getNumVertexPerSegment",
      value: function getNumVertexPerSegment() {
        return VERTEX_PER_SEGMENT;
      }
    }, {
      key: "getPositionSize",
      value: function getPositionSize() {
        return POS_SIZE;
      }
    }, {
      key: "setSegments",
      value: function setSegments(startSegmentIdx, positions) {
        var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;

        if (positions instanceof Array && positions.length === 2) {
          this._positions.set(positions[0], startPos);

          var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;

          this._directions.set(positions[1], startDir); // dirs are geo part of vertex

        } else {
          this._positions.set(positions, startPos);
        }
      }
    }, {
      key: "setColors",
      value: function setColors(startSegmentIdx, colors) {
        var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;

        this._colors.set(colors, start);
      }
    }, {
      key: "_initVertices",
      value: function _initVertices(segmentsCount) {
        this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
        var pointsCount = this._buffersSize;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT$1;
        this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
        this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default['default'].fill(alpha, 1.0);

        var index = this._index;
        var indexOffset = 0;
        var pointOffset = 0;

        for (var j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
          index[indexOffset] = pointOffset;
          index[indexOffset + 1] = pointOffset + 1;
          index[indexOffset + 2] = pointOffset + 3;
          index[indexOffset + 3] = pointOffset;
          index[indexOffset + 4] = pointOffset + 2;
          index[indexOffset + 5] = pointOffset + 3;
        }

        this.setIndex(new THREE.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE.BufferAttribute(this._positions, POS_SIZE));
        this.setAttribute('color', new THREE.BufferAttribute(this._colors, COL_SIZE));
        this.setAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
        this.setAttribute('direction', new THREE.BufferAttribute(this._directions, DIR_SIZE));
      }
    }]);

    return ThickLinesGeometry;
  }(THREE.BufferGeometry);

  function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This class represents geometry which consists lines. This can build bounding volumes
   * @constructor
   *
   * @param {number}  segmentsCount   Number of segments per chunk.
   */

  var LinesGeometry = /*#__PURE__*/function (_BaseLinesGeometry) {
    inherits(LinesGeometry, _BaseLinesGeometry);

    var _super = _createSuper$n(LinesGeometry);

    function LinesGeometry() {
      classCallCheck(this, LinesGeometry);

      return _super.apply(this, arguments);
    }

    createClass(LinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var boundingBox = this.boundingBox; // Build bounding sphere

        var radiusSquared = 0.0;
        var center = new THREE.Vector3();

        if (boundingBox) {
          boundingBox.getCenter(center);
        }

        var positions = this._positions;
        var sphere = this.boundingSphere || new THREE.Sphere();
        var size = this._positions.length;
        var pos = new THREE.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          pos.set(positions[i], positions[i + 1], positions[i + 2]);
          var lengthSquared = center.distanceToSquared(pos);

          if (radiusSquared < lengthSquared) {
            radiusSquared = lengthSquared;
          }
        }

        sphere.set(center, Math.sqrt(radiusSquared));
        this.boundingSphere = sphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var positions = this._positions;
        var box = new THREE.Box3();
        var size = this._positions.length;
        var tmpVec = new THREE.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          tmpVec.set(positions[i], positions[i + 1], positions[i + 2]);
          box.expandByPoint(tmpVec);
        }

        this.boundingBox = box;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }]);

    return LinesGeometry;
  }(ThickLinesGeometry);

  function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$4 = 3;
  var tmpVector$1 = new THREE.Vector3();
  var normMtx$1 = new THREE.Matrix3();

  var CylinderCollisionGeo = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    inherits(CylinderCollisionGeo, _ChunkedObjectsGeomet);

    var _super = _createSuper$o(CylinderCollisionGeo);

    function CylinderCollisionGeo(instanceCount, polyComplexity) {
      var _this;

      classCallCheck(this, CylinderCollisionGeo);

      var cylGeometry = new THREE.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$4);
      return _this;
    }

    createClass(CylinderCollisionGeo, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var itemOffset = chunkSize * itemIdx * VEC_SIZE$4;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        normMtx$1.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE$4;
          tmpVector$1.fromArray(geoPos, idx);
          tmpVector$1.applyMatrix4(mtx1);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, itemOffset);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE$4;
          tmpVector$1.fromArray(geoNorm, idx);
          tmpVector$1.applyMatrix3(normMtx$1);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, itemOffset);
      }
    }]);

    return CylinderCollisionGeo;
  }(ChunkedObjectsGeometry);

  function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD = 0.1;
  /**
   * This class represents geometry which consists of separate chunks.
   * Each chunk has same index and similar geometry with equal points and faces count.
   * Each chunk has by default only one color.
   * @constructor
   *
   * @param {number}  chunksCount     Total chunks count.
   * @param {number}  segmentsCount   Number of segments per chunk.
   * @param {boolean} enableCollision Enable or disable collision where each segment is
   *                                  a collidable cylinder.
   * collision geometry.
   */

  var ChunkedLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    inherits(ChunkedLinesGeometry, _LinesGeometry);

    var _super = _createSuper$p(ChunkedLinesGeometry);

    function ChunkedLinesGeometry(chunksCount, segmentsCount, enableCollision) {
      var _this;

      classCallCheck(this, ChunkedLinesGeometry);

      _this = _super.call(this, chunksCount * segmentsCount);

      _this._init(segmentsCount);

      _this._collisionGeo = enableCollision ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
      return _this;
    }

    createClass(ChunkedLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingSphere();
          this.boundingSphere = collisionGeo.boundingSphere;
          return;
        }

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingSphere", this).call(this);
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingBox();
          this.boundingBox = collisionGeo.boundingBox;
          return;
        }

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingBox", this).call(this);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var collisionGeo = this._collisionGeo;

        if (!collisionGeo) {
          return;
        }

        var segCount = this._chunkSize;

        this._collisionGeo.raycast(raycaster, intersects);

        for (var i = 0, n = intersects.length; i < n; ++i) {
          var chunkIdx = intersects[i].chunkIdx;

          if (chunkIdx === undefined) {
            continue;
          }

          chunkIdx = chunkIdx / segCount | 0;
          intersects[i].chunkIdx = chunkIdx;
        }
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setColor", this).call(this, i, colorVal);
        }
      }
    }, {
      key: "setSegment",
      value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
        var chunkSize = this._chunkSize;
        var idx = chunkIdx * chunkSize + segIdx;

        get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setSegment", this).call(this, idx, pos1, pos2);

        if (this._collisionGeo) {
          this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          get(getPrototypeOf(ChunkedLinesGeometry.prototype), "setOpacity", this).call(this, left, left + chunkSize - 1, value);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var chunkSize = this._chunkSize;
        var subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false);

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var startSegIdx = chunkIndices[i] * chunkSize;
          subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
          subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(chunkSize) {
        this._chunkSize = chunkSize;
      }
    }]);

    return ChunkedLinesGeometry;
  }(LinesGeometry);

  function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD$1 = 0.3;
  var tmpVector$2 = new THREE.Vector3();

  var TwoColorLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    inherits(TwoColorLinesGeometry, _LinesGeometry);

    var _super = _createSuper$q(TwoColorLinesGeometry);

    function TwoColorLinesGeometry(segmentsCount) {
      var _this;

      classCallCheck(this, TwoColorLinesGeometry);

      _this = _super.call(this, segmentsCount * 2);

      _this._init(segmentsCount);

      _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3);
      return _this;
    }

    createClass(TwoColorLinesGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos) {
        this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD$1);

        var offset = 2 * itemIdx; // there are two points per segment

        tmpVector$2.lerpVectors(botPos, topPos, 0.5);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset, botPos, tmpVector$2);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset + 1, tmpVector$2, topPos);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var offset = 2 * itemIdx; // there are two points per segment

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset, colorVal1);

        get(getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset + 1, colorVal2);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (this._collisionGeo) {
          this._collisionGeo.raycast(raycaster, intersects);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(segmentIndices) {
        var instanceCount = segmentIndices.length;
        var subset = new TwoColorLinesGeometry(instanceCount, false);

        for (var i = 0, n = instanceCount; i < n; ++i) {
          var startSegIdx = segmentIndices[i];
          subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1));
          subset.setColors(i, this.getSubsetColors(startSegIdx, 1));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(segmentsCount) {
        this._segCounts = segmentsCount * 2;
      }
    }]);

    return TwoColorLinesGeometry;
  }(LinesGeometry); // (???)parent = LinesGeometry.prototype;

  function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
  var vecCount = vectors.length;
  var tempPos1 = new THREE.Vector3();
  var tempPos2 = new THREE.Vector3();

  var CrossGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    inherits(CrossGeometry, _SphereCollisionGeo);

    var _super = _createSuper$r(CrossGeometry);

    function CrossGeometry(chunksCount) {
      classCallCheck(this, CrossGeometry);

      return _super.call(this, chunksCount, chunksCount, vecCount / 2 | 0, false);
    }

    createClass(CrossGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        this.setSphere(itemIdx, itemPos, itemRad);

        for (var i = 0; i < vecCount / 2; ++i) {
          var first = i * 2;
          tempPos1.x = itemPos.x + vectors[first].x * itemRad;
          tempPos1.y = itemPos.y + vectors[first].y * itemRad;
          tempPos1.z = itemPos.z + vectors[first].z * itemRad;
          var second = first + 1;
          tempPos2.x = itemPos.x + vectors[second].x * itemRad;
          tempPos2.y = itemPos.y + vectors[second].y * itemRad;
          tempPos2.z = itemPos.z + vectors[second].z * itemRad;
          this.setSegment(itemIdx, i, tempPos1, tempPos2);
        }
      }
    }]);

    return CrossGeometry;
  }(SphereCollisionGeo(ChunkedLinesGeometry));

  function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var POS_RAD_SIZE = 4;
  var COLOR_SIZE$2 = 3;
  var tmpColor$4 = new THREE.Color();
  /**
   * This is a base class for isosurface algorithms.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var IsoSurfaceGeometry = /*#__PURE__*/function (_RaycastableBufferGeo) {
    inherits(IsoSurfaceGeometry, _RaycastableBufferGeo);

    var _super = _createSuper$s(IsoSurfaceGeometry);

    function IsoSurfaceGeometry(spheresCount, opts) {
      var _this;

      classCallCheck(this, IsoSurfaceGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.zClip = _this._opts.zClip;
      _this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
      _this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$2);
      return _this;
    }

    createClass(IsoSurfaceGeometry, [{
      key: "setItem",
      value: function setItem(chunkIdx, pos, radius) {
        var posRad = this._posRad;
        var idx = POS_RAD_SIZE * chunkIdx;
        posRad[idx++] = pos.x;
        posRad[idx++] = pos.y;
        posRad[idx++] = pos.z;
        posRad[idx] = radius;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor$4.set(colorVal);
        var colors = this._colors;
        var idx = COLOR_SIZE$2 * chunkIdx;
        colors[idx++] = tmpColor$4.r;
        colors[idx++] = tmpColor$4.g;
        colors[idx] = tmpColor$4.b;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this._build();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity() {// not implemented
      }
    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return IsoSurfaceGeometry;
  }(RaycastableBufferGeometry);

  /**
   * Class for marching cube
   * Stores 8 points and 8 float values are stored together in linear array
   * Int values for has intersection or not - in integer32 linear array
   * Int values for bits flags - in integer32 linear array
   *
   */

  var IsoSurfaceMarchCube = /*#__PURE__*/function () {
    function IsoSurfaceMarchCube() {
      classCallCheck(this, IsoSurfaceMarchCube);

      this.pointsValuesLinear = null;
      this.hasIntersection = null;
      this.bitsInside = null;
    }

    createClass(IsoSurfaceMarchCube, [{
      key: "create",
      value: function create(numCellsPerSide) {
        var vx7000000 = 0x7000000;
        var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;

        if (n3 > vx7000000) {
          throw new Error('Too large cube dimension: lead to memory huge uasge');
        }

        this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
        this.hasIntersection = utils.allocateTyped(Int32Array, n3);
        this.bitsInside = utils.allocateTyped(Int32Array, n3);
        return 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.bitsInside = null;
        this.hasIntersection = null;
        this.pointsValuesLinear = null;
      }
    }]);

    return IsoSurfaceMarchCube;
  }();
  /* eslint-disable no-magic-numbers */


  IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];

  var edgeTable = [0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0];

  function _voxelGradientFast(v, point, grad) {
    var g = v.getValue(point.x, point.y, point.z);
    grad.set(g[0], g[1], g[2]);
  } // Helper class GridCell


  var GridCell = function GridCell() {
    classCallCheck(this, GridCell);

    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);

    for (var i = 0; i < this._arrSize; ++i) {
      this.p[i] = new THREE.Vector3();
      this.g[i] = new THREE.Vector3();
    }

    this.cubeIndex = 0;
  }; // Helper class Triangle


  var Triangle = function Triangle() {
    classCallCheck(this, Triangle);

    this.a = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.b = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.c = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
  };

  function createArray(arrSize) {
    var arr = new Array(arrSize);

    for (var i = 0; i < arrSize; ++i) {
      arr[i] = new THREE.Vector3();
    }

    return arr;
  }

  var IsoSurface = /*#__PURE__*/function () {
    function IsoSurface() {
      classCallCheck(this, IsoSurface);

      this._numTriangles = 0;
      this._numVertices = 0;
      this._position = [];
      this._normals = [];
      this._colors = null;
      this._indices = [];
      this._volumetricData = null;
      this._xAxis = new THREE.Vector3();
      this._yAxis = new THREE.Vector3();
      this._zAxis = new THREE.Vector3();
      this._xDir = new THREE.Vector3();
      this._yDir = new THREE.Vector3();
      this._zDir = new THREE.Vector3();
    }

    createClass(IsoSurface, [{
      key: "_prepareAxesAndDirs",
      value: function _prepareAxesAndDirs() {
        var volData = this._volumetricData;
        var cellSize = volData.getCellSize(); // calculate cell axes

        var xAxis = this._xAxis;
        var yAxis = this._yAxis;
        var zAxis = this._zAxis;
        var xDir = this._xDir;
        var yDir = this._yDir;
        var zDir = this._zDir;
        xAxis.set(cellSize.x, 0, 0);
        yAxis.set(0, cellSize.y, 0);
        zAxis.set(0, 0, cellSize.z);
        xDir.set(1, 0, 0);
        yDir.set(0, 1, 0);
        zDir.set(0, 0, 1); // flip normals if coordinate system is in the wrong handedness

        var tmp = new THREE.Vector3();
        tmp.crossVectors(xDir, yDir);

        if (tmp.dot(zDir) < 0) {
          xDir.negate();
          yDir.negate();
          zDir.negate();
        } // check that the grid is in the all-positive octant of the coordinate system


        if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
          return false;
        } // check that the grid is axis-aligned


        var notZero = function notZero(axe) {
          return Math.abs(axe) > Number.EPSILON;
        };

        return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
      }
    }, {
      key: "_vertexInterp",
      value: function _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
        var p1 = grid.p[ind1];
        var p2 = grid.p[ind2];
        var n1 = grid.g[ind1];
        var n2 = grid.g[ind2];
        var valP1 = grid.val[ind1];
        var valP2 = grid.val[ind2];
        var isoDiffP1 = isoLevel - valP1;
        var diffValP2P1 = valP2 - valP1;
        var mu = 0.0;

        if (Math.abs(diffValP2P1) > 0.0) {
          mu = isoDiffP1 / diffValP2P1;
        }

        mu = mu > 1.0 ? 1.0 : mu;
        vertex.lerpVectors(p1, p2, mu);
        normal.lerpVectors(n1, n2, mu);
      }
    }, {
      key: "_polygonize",
      value: function _polygonize(grid, isoLevel, triangles) {
        var cubeIndex = grid.cubeIndex;
        var i = 0;
        var arrSize = IsoSurface._arrSize;
        var firstIndices = IsoSurface._firstIndices;
        var secondIndices = IsoSurface._secondIndices;
        var vertexList = IsoSurface._vertexList;
        var normalList = IsoSurface._normalList;

        for (; i < arrSize; ++i) {
          if (edgeTable[cubeIndex] & 1 << i) {
            this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
          }
        }

        var triCount = 0;
        var triTblIdx = cubeIndex * 16;
        var triTable = IsoSurface._triTable;

        for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
          triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
          triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);
          triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
          triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
          ++triCount;
        }

        return triCount;
      }
    }, {
      key: "_doGridPosNorms",
      value: function _doGridPosNorms(isoValue, step, appendSimple) {
        var vol = this._volumetricData;

        var volData = this._volumetricData.getData();

        var dim = vol.getDimensions();
        var xSize = dim[0];
        var ySize = dim[1];
        var zSize = dim[2];
        var stepX = step * vol.getStrideX();
        var stepY = step * vol.getStrideY();
        var stepZ = step * vol.getStrideZ();
        var gc = new GridCell();
        var gcVal = gc.val;
        var gcValSize = gc.val.length;
        var additions = [new THREE.Vector3(0, 0, 0), // 0
        new THREE.Vector3(step, 0, 0), // 1
        new THREE.Vector3(step, step, 0), // 2
        new THREE.Vector3(0, step, 0), // 3
        new THREE.Vector3(0, 0, step), // 4
        new THREE.Vector3(step, 0, step), // 5
        new THREE.Vector3(step, step, step), // 6
        new THREE.Vector3(0, step, step) // 7
        ];
        var tmpTriCount = 5;
        var triangles = new Array(tmpTriCount);

        for (var j = 0; j < tmpTriCount; ++j) {
          triangles[j] = new Triangle();
        }

        var appendVertex;
        var self = this;
        var positions = this._position;
        var normals = this._normals;

        if (appendSimple) {
          // Special case for axis-aligned grid with positive unit vector normals
          appendVertex = function () {
            var axis = new THREE.Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
            return function (triVertex) {
              var vertex = triVertex.p.clone();
              vertex.multiply(axis);
              positions.push(vertex.add(self._origin));
              normals.push(triVertex.n.clone());
            };
          }();
        } else {
          appendVertex = function () {
            var posMtx = new THREE.Matrix3();
            posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
            var normMtx = new THREE.Matrix3();
            normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);
            return function (triVertex) {
              positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self._origin));
              normals.push(triVertex.n.clone().applyMatrix3(normMtx));
            };
          }();
        }

        var indices = this._indices;
        var globTriCount = 0;

        for (var z = 0; z < zSize - step; z += step) {
          for (var y = 0; y < ySize - step; y += step) {
            var idx = vol.getDirectIdx(0, y, z);

            for (var x = 0; x < xSize - step; x += step, idx += stepX) {
              /* eslint-disable no-multi-spaces */

              /* eslint-disable computed-property-spacing */
              gcVal[0] = volData[idx];
              gcVal[1] = volData[idx + stepX];
              gcVal[3] = volData[idx + stepY];
              gcVal[2] = volData[idx + stepX + stepY];
              gcVal[4] = volData[idx + stepZ];
              gcVal[5] = volData[idx + stepX + stepZ];
              gcVal[7] = volData[idx + stepY + stepZ];
              gcVal[6] = volData[idx + stepX + stepY + stepZ];
              /* eslint-enable no-multi-spaces */

              /* eslint-enable computed-property-spacing */
              // Determine the index into the edge table which
              // tells us which vertices are inside of the surface

              var cubeIndex = 0;
              var i = 0;

              for (; i < gcValSize; ++i) {
                if (gcVal[i] < isoValue) {
                  cubeIndex |= 1 << i;
                }
              }

              if (edgeTable[cubeIndex] === 0) {
                continue;
              }

              gc.cubeIndex = cubeIndex;

              for (i = 0; i < gcValSize; ++i) {
                gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);

                _voxelGradientFast(this._gradient, gc.p[i], gc.g[i]);
              } // calculate vertices and facets for this cube,
              // calculate normals by interpolating between the negated
              // normalized volume gradients for the 8 reference voxels


              var triCount = this._polygonize(gc, isoValue, triangles);

              globTriCount += triCount; // append triangles using different techniques

              for (i = 0; i < triCount; ++i) {
                indices.push(this._numTriangles * 3);
                indices.push(this._numTriangles * 3 + 1);
                indices.push(this._numTriangles * 3 + 2);
                ++this._numTriangles;
                appendVertex(triangles[i].a);
                appendVertex(triangles[i].b);
                appendVertex(triangles[i].c);
              }
            }
          }
        }

        return globTriCount;
      }
    }, {
      key: "compute",
      value: function compute(volData, origin, isoValue, step) {
        this._volumetricData = volData;
        this._origin = origin;
        this._gradient = volData.computeGradient();

        this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
      }
    }, {
      key: "_remapIndices",
      value: function _remapIndices(vertexMap, idcCount) {
        var indices = this._indices;
        var newIndices = utils.allocateTyped(Uint32Array, idcCount);

        for (var i = 0; i < idcCount; ++i) {
          indices[i] = vertexMap[indices[i]];
          newIndices[i] = indices[i];
        }

        this._indices = newIndices;
      }
    }, {
      key: "_remapVertices",
      value: function _remapVertices(vertices, normals, count) {
        var newPositions = utils.allocateTyped(Float32Array, count * 3);
        var newNormals = utils.allocateTyped(Float32Array, count * 3);

        for (var i = 0; i < count; ++i) {
          var pos = vertices[i];
          newPositions[i * 3] = pos.x;
          newPositions[i * 3 + 1] = pos.y;
          newPositions[i * 3 + 2] = pos.z;
          var norm = normals[i].normalize();
          newNormals[i * 3] = norm.x;
          newNormals[i * 3 + 1] = norm.y;
          newNormals[i * 3 + 2] = norm.z;
        }

        this._position = newPositions;
        this._normals = newNormals;
      }
    }, {
      key: "vertexFusion",
      value: function vertexFusion(offset, len) {
        var faceVer = this._indices.length;
        var vertices = this._position;
        var normals = this._normals;
        var oldVerCount = vertices.length | 0;

        if (faceVer === 0 || oldVerCount === 0) {
          return;
        }

        var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
        vMap[0] = 0;
        var newVer = 1;
        var i = 1;

        for (; i < oldVerCount; ++i) {
          var start = newVer - offset < 0 ? 0 : newVer - offset;
          var end = start + len > newVer ? newVer : start + len;
          var matchedIndex = -1;

          for (var j = start; j < end; ++j) {
            if (Math.abs(vertices[i] - vertices[j]) < Number.EPSILON) {
              matchedIndex = j;
              break;
            }
          }

          if (matchedIndex !== -1) {
            vMap[i] = matchedIndex;
          } else {
            vertices[newVer].copy(vertices[i]);
            normals[newVer].copy(normals[i]);
            vMap[i] = newVer;
            ++newVer;
          }
        }

        this._remapIndices(vMap, faceVer);

        this._remapVertices(vertices, normals, newVer);
      } // Assign per-vertex colors from a volumetric texture map (same dimensions as the original volumetric data).
      // Along with color dominating atom is determined for each vertex
      // and vertices with atom out of "visible" subset get filtered out.
      // XXX only handles orthogonal volumes currently

    }, {
      key: "setColorVolTex",
      value: function setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
        var i;
        var idx;
        var numVerts = this._position.length / 3;
        var vertices = this._position;
        var origin = this._origin;

        var dim = this._volumetricData.getDimensions();

        var xs = dim[0] - 1;
        var ys = dim[1] - 1;
        var zs = dim[2] - 1;
        var colorData = colorMap.getData();
        var strideX = colorMap.getStrideX();
        var strideY = colorMap.getStrideY();
        var strideZ = colorMap.getStrideZ();
        var atomWeightData;
        var atomStrideX;
        var atomStrideY;
        var atomStrideZ;

        if (visibilitySelector !== null) {
          atomWeightData = atomWeightMap.getData();
          atomStrideX = atomWeightMap.getStrideX();
          atomStrideY = atomWeightMap.getStrideY();
          atomStrideZ = atomWeightMap.getStrideZ();
        }

        var xInv = 1.0 / this._xAxis.x;
        var yInv = 1.0 / this._yAxis.y;
        var zInv = 1.0 / this._zAxis.z;
        var atomLookup = [];
        var atomWeights = [];
        var colors = utils.allocateTyped(Float32Array, numVerts * 3);

        function interp(mu, idx1, idx2, c) {
          c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
          c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
          c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
        }

        function collectWeight(ai, coefX, coefY, coefZ) {
          var a = atomMap[ai]; // atomWeightMap is a scalar field, so index into atom map should be the same

          if (a != null) {
            atomLookup[a.index] = a;
            var w = coefX * coefY * coefZ * atomWeightData[ai];

            if (typeof atomWeights[a.index] === 'undefined') {
              atomWeights[a.index] = w;
            } else {
              atomWeights[a.index] += w;
            }
          }
        }

        var vMap = utils.allocateTyped(Int32Array, numVerts);
        var newVerCount = 0;

        for (i = 0; i < numVerts; i++) {
          var ind = i * 3;
          var vx = (vertices[ind] - origin.x) * xInv;
          var vy = (vertices[ind + 1] - origin.y) * yInv;
          var vz = (vertices[ind + 2] - origin.z) * zInv;
          var x = Math.min(Math.max(vx, 0), xs) | 0;
          var y = Math.min(Math.max(vy, 0), ys) | 0;
          var z = Math.min(Math.max(vz, 0), zs) | 0;
          var mux = vx - x;
          var muy = vy - y;
          var muz = vz - z;

          if (visibilitySelector != null) {
            // collect atom weights
            atomLookup = [];
            atomWeights = [];
            idx = atomWeightMap.getDirectIdx(x, y, z);
            collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
            collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
            collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
            collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
            collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
            collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz); // find dominant atom

            var maxWeight = 0.0;
            var dominantIdx = -1;

            for (var atomIdx in atomWeights) {
              if (atomWeights[atomIdx] > maxWeight) {
                dominantIdx = atomIdx;
                maxWeight = atomWeights[atomIdx];
              }
            }

            if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
              // this vertex doesn't belong to visible subset and will be skipped
              vMap[i] = -1;
              continue;
            }
          }

          vMap[i] = newVerCount++; // color tri-linear interpolation

          var dx = x < xs ? strideX : 0;
          var dy = y < ys ? strideY : 0;
          var dz = z < zs ? strideZ : 0;
          var c0 = [0, 0, 0];
          var c1 = [0, 0, 0];
          var c2 = [0, 0, 0];
          var c3 = [0, 0, 0];
          idx = colorMap.getDirectIdx(x, y, z);
          interp(mux, idx, idx + dx, c0);
          interp(mux, idx + dy, idx + dx + dy, c1);
          interp(mux, idx + dz, idx + dx + dz, c2);
          interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
          var cz0 = [0, 0, 0];
          cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
          cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
          cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
          var cz1 = [0, 0, 0];
          cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
          cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
          cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
          colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
          colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
          colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
        }

        this._colors = colors;

        if (visibilitySelector != null) {
          // shift visible vertices towards beginning of array
          for (i = 0; i < numVerts; ++i) {
            var j = vMap[i];

            if (j < 0) {
              continue;
            } // assert: j <= i


            this._position[j * 3] = this._position[i * 3];
            this._position[j * 3 + 1] = this._position[i * 3 + 1];
            this._position[j * 3 + 2] = this._position[i * 3 + 2];
            this._normals[j * 3] = this._normals[i * 3];
            this._normals[j * 3 + 1] = this._normals[i * 3 + 1];
            this._normals[j * 3 + 2] = this._normals[i * 3 + 2];
            this._colors[j * 3] = this._colors[i * 3];
            this._colors[j * 3 + 1] = this._colors[i * 3 + 1];
            this._colors[j * 3 + 2] = this._colors[i * 3 + 2];
          } // rebuild index list


          var numTriangles = this._indices.length / 3;
          var newTriCount = 0;

          for (i = 0; i < numTriangles; ++i) {
            var i0 = vMap[this._indices[3 * i]];
            var i1 = vMap[this._indices[3 * i + 1]];
            var i2 = vMap[this._indices[3 * i + 2]];

            if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
              this._indices[3 * newTriCount] = i0;
              this._indices[3 * newTriCount + 1] = i1;
              this._indices[3 * newTriCount + 2] = i2;
              ++newTriCount;
            }
          } // shrink arrays to data size


          this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
          this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
          this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
          this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
        }
      }
    }, {
      key: "toMesh",
      value: function toMesh() {
        var geo = new THREE.BufferGeometry();
        geo.setIndex(new THREE.BufferAttribute(this._indices, 1));
        geo.setAttribute('position', new THREE.BufferAttribute(this._position, 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(this._normals, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(this._colors, 3));
        geo.computeBoundingSphere();
        return geo;
      }
    }]);

    return IsoSurface;
  }();

  defineProperty(IsoSurface, "_triTable", IsoSurfaceMarchCube.prototype.striIndicesMarchCube);

  defineProperty(IsoSurface, "_arrSize", 12);

  defineProperty(IsoSurface, "_firstIndices", [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]);

  defineProperty(IsoSurface, "_secondIndices", [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]);

  defineProperty(IsoSurface, "_vertexList", createArray(IsoSurface._arrSize));

  defineProperty(IsoSurface, "_normalList", createArray(IsoSurface._arrSize));

  function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * This is a base class for volumetric maps based isosurface algorithms.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var VolumeSurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    inherits(VolumeSurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$t(VolumeSurfaceGeometry);

    function VolumeSurfaceGeometry() {
      classCallCheck(this, VolumeSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(VolumeSurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        var params = this._opts;
        this.numVoxels = [128, 128, 128];
        this.xAxis = new THREE.Vector3(1.0, 0.0, 0.0);
        this.yAxis = new THREE.Vector3(0.0, 1.0, 0.0);
        this.zAxis = new THREE.Vector3(0.0, 0.0, 1.0);
        this.origin = new THREE.Vector3(0.0, 0.0, 0.0);
        this._visibilitySelector = params.visibilitySelector;

        this._calcSurface(params);
      }
    }, {
      key: "_findMinMax",
      value: function _findMinMax(posRadArray) {
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;
        var maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
        var minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];

        for (var i = 1; i < itemsCount; ++i) {
          var ind = i * itemSize;

          for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
            var tmpVal = posRadArray[ind + itemIdx];
            maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
            minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
          }
        }

        return {
          maxPosRad: maxPosRad,
          minPosRad: minPosRad
        };
      }
    }, {
      key: "_findNumVoxels",
      value: function _findNumVoxels(posRadArray, params) {
        var numVoxels = this.numVoxels;

        var minMaxValues = this._findMinMax(posRadArray);

        var minCoordRad = minMaxValues.minPosRad;
        var maxCoordRad = minMaxValues.maxPosRad; // minrad

        if (minCoordRad[3] > 4.0) {
          params.gridSpacing *= minCoordRad[3];
        }

        var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
        var padRad = gridPadding;
        padRad = 0.65 * Math.sqrt(4.0 / 3.0 * Math.PI * padRad * padRad * padRad);
        gridPadding = Math.max(gridPadding, padRad);
        var i = 0;

        for (; i < 3; ++i) {
          minCoordRad[i] -= gridPadding;
          maxCoordRad[i] += gridPadding;
        }

        for (i = 0; i < 3; ++i) {
          numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
        }

        this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
        this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
        this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;

        var _minCoordRad = slicedToArray(minCoordRad, 3);

        this.origin.x = _minCoordRad[0];
        this.origin.y = _minCoordRad[1];
        this.origin.z = _minCoordRad[2];
        return {
          bbox: minMaxValues,
          dim: numVoxels
        };
      }
    }, {
      key: "_makeSurface",
      value: function _makeSurface(surface, params) {
        var isoSurf = new IsoSurface();
        isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
        isoSurf.vertexFusion(9, 9); // normalization is included

        if (isoSurf._numTriangles > 0) {
          isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
          this.setIndex(new THREE.BufferAttribute(isoSurf._indices, 1));
          this.setAttribute('position', new THREE.BufferAttribute(isoSurf._position, 3));
          this.setAttribute('normal', new THREE.BufferAttribute(isoSurf._normals, 3));
          this.setAttribute('color', new THREE.BufferAttribute(isoSurf._colors, 3));
        } else {
          // geometry should have at least empty position attributes to be processed in wireframe mode by three.js
          this.setAttribute('position', new THREE.BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
        }
      }
    }, {
      key: "_calcSurface",
      value: function _calcSurface(params) {
        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };

        if (packedArrays.posRad.length === 0) {
          return;
        }

        var boundaries = this._findNumVoxels(packedArrays.posRad, params);

        var box = new THREE.Box3(this.origin, new THREE.Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));

        var surface = this._computeSurface(packedArrays, box, boundaries, params);

        this._makeSurface(surface, params);
      }
    }]);

    return VolumeSurfaceGeometry;
  }(IsoSurfaceGeometry);

  function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Volume$1 = chem.Volume;
  /**
   * This class implements 'quick' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var QuickSurfGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    inherits(QuickSurfGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$u(QuickSurfGeometry);

    function QuickSurfGeometry() {
      classCallCheck(this, QuickSurfGeometry);

      return _super.apply(this, arguments);
    }

    createClass(QuickSurfGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        // beware of shifting this multiple times!
        this._shiftByOrigin(packedArrays.posRad);

        var surface = {
          volMap: new Volume$1(Float32Array, this.numVoxels, box),
          volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
        };

        if (this._visibilitySelector != null) {
          surface.atomMap = [];
          surface.atomWeightMap = new Volume$1(Float32Array, this.numVoxels, box);
        }

        this.gaussdensity(surface, packedArrays, null, params);
        return surface;
      }
    }, {
      key: "gaussdensity",
      value: function gaussdensity(surface, packedArrays, atomicNum, params) {
        var numAtoms = packedArrays.posRad.length / 4;
        var posRad = packedArrays.posRad,
            colors = packedArrays.colors;
        var numVoxels = this.numVoxels;
        var radScale = params.radScale,
            gaussLim = params.gaussLim,
            gridSpacing = params.gridSpacing;
        var invIsoValue = 1.0 / params.isoValue;
        var invGridSpacing = 1.0 / gridSpacing;
        var maxVoxelX = numVoxels[0] - 1;
        var maxVoxelY = numVoxels[1] - 1;
        var maxVoxelZ = numVoxels[2] - 1; // TODO is densityMap and volTexMap initialized?

        var volMap = surface.volMap,
            volTexMap = surface.volTexMap;
        var volData = volMap.getData();
        var strideX = volMap.getStrideX();
        var volTexData = volTexMap.getData();
        var texStrideX = volTexMap.getStrideX();
        var atomWeightData;

        if (this._visibilitySelector != null) {
          atomWeightData = surface.atomWeightMap.getData();
        }

        var atomMap = surface.atomMap;

        for (var i = 0; i < numAtoms; ++i) {
          var ind = i * 4;
          var scaledRad = posRad[ind + 3] * radScale;
          var atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i];
          var radInv = 1 / (2 * scaledRad * scaledRad);
          var radLim = gaussLim * scaledRad;
          var radLim2 = radLim * radLim;
          radLim *= invGridSpacing;
          var tmp = posRad[ind] * invGridSpacing;
          var xMin = Math.max(tmp - radLim | 0, 0);
          var xMax = Math.min(tmp + radLim | 0, maxVoxelX);
          tmp = posRad[ind + 1] * invGridSpacing;
          var yMin = Math.max(tmp - radLim | 0, 0);
          var yMax = Math.min(tmp + radLim | 0, maxVoxelY);
          tmp = posRad[ind + 2] * invGridSpacing;
          var zMin = Math.max(tmp - radLim | 0, 0);
          var zMax = Math.min(tmp + radLim | 0, maxVoxelZ);
          var dz = zMin * gridSpacing - posRad[ind + 2];

          for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
            var dy = yMin * gridSpacing - posRad[ind + 1];

            for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
              var dy2dz2 = dy * dy + dz * dz;

              if (dy2dz2 >= radLim2) {
                continue;
              }

              var addr = volMap.getDirectIdx(xMin, y, z);
              var texAddr = volTexMap.getDirectIdx(xMin, y, z);
              var dx = xMin * gridSpacing - posRad[ind];

              for (var x = xMin; x <= xMax; ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
                var r2 = dx * dx + dy2dz2;
                var expVal = -r2 * radInv;
                var density = Math.exp(expVal) * atomicNumFactor; // store most relevant atom (with highest density)

                if (this._visibilitySelector != null && density > atomWeightData[addr]) {
                  // NOSONAR
                  atomWeightData[addr] = density; // we use same index into atom map and atomWeightMap

                  atomMap[addr] = packedArrays.atoms[i];
                }

                volData[addr] += density; // TODO check for volTexMap routine?

                density *= invIsoValue;
                var colInd = i * 3;
                volTexData[texAddr] += density * colors[colInd];
                volTexData[texAddr + 1] += density * colors[colInd + 1];
                volTexData[texAddr + 2] += density * colors[colInd + 2];
              }
            }
          }
        }
      }
    }, {
      key: "_shiftByOrigin",
      value: function _shiftByOrigin(posRadArray) {
        var originX = this.origin.x;
        var originY = this.origin.y;
        var originZ = this.origin.z;
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;

        for (var i = 0; i < itemsCount; ++i) {
          var ind = i * itemSize;
          posRadArray[ind] -= originX;
          posRadArray[ind + 1] -= originY;
          posRadArray[ind + 2] -= originZ;
        }
      }
    }]);

    return QuickSurfGeometry;
  }(VolumeSurfaceGeometry);

  /**
   * Modifed from SpatialHash
   *
   * Main differences are:
   * - Optimized grid size to ensure we only ever need to look +/-1 cell
   * - Aware of atomic radii and will only output atoms within rAtom + rExtra
   *   (see withinRadii method)
   *
   * (Uses rounding rather than bitshifting as consequence of arbitrary grid size)
   * @class
   * @param {Float32Array} posRad - x, y, z coordinates and radiuses
   * @param {Float32Array} min - xyz min coordinates
   * @param {Float32Array} max - xyz max coordinates
   * @param {number} maxDistance - max distance
   */

  function AVHash(posRad, min, max, maxDistance) {
    var itemSize = 4;
    var nAtoms = posRad.length / itemSize;
    var minX = min[0];
    var minY = min[1];
    var minZ = min[2];
    var maxX = max[0];
    var maxY = max[1];
    var maxZ = max[2];

    function hashFunc(w, minW) {
      return Math.floor((w - minW) / maxDistance);
    }

    var iDim = hashFunc(maxX, minX) + 1;
    var jDim = hashFunc(maxY, minY) + 1;
    var kDim = hashFunc(maxZ, minZ) + 1;
    var nCells = iDim * jDim * kDim;
    var jkDim = jDim * kDim;
    /* Get cellID for cartesian x,y,z */

    var cellID = function cellID(x, y, z) {
      return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
    };
    /* Initial building, could probably be optimized further */


    var preHash = [];
    var i;
    var cid;

    for (i = 0; i < nAtoms; i++) {
      var iIdx = itemSize * i;
      cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);

      if (preHash[cid] === undefined) {
        preHash[cid] = [i];
      } else {
        preHash[cid].push(i);
      }
    }

    var cellOffsets = utils.allocateTyped(Uint32Array, nCells);
    var cellLengths = utils.allocateTyped(Uint16Array, nCells);
    var data = utils.allocateTyped(Uint32Array, nAtoms);
    var offset = 0;
    var maxCellLength = 0;
    var j;

    for (i = 0; i < nCells; i++) {
      var start = cellOffsets[i] = offset;
      var subArray = preHash[i];

      if (subArray !== undefined) {
        for (j = 0; j < subArray.length; j++) {
          data[offset] = subArray[j];
          offset++;
        }
      }

      var cellLength = offset - start;
      cellLengths[i] = cellLength;

      if (cellLength > maxCellLength) {
        maxCellLength = cellLength;
      }
    } // Maximum number of neighbours we could ever produce (27 adjacent cells of equal population)


    this.neighbourListLength = 27 * maxCellLength + 1;
    /**
     * Populate the supplied out array with atom indices that are within rAtom + rExtra
     * of x,y,z
     *
     * -1 in out array indicates the end of the list
     *
     * @param  {number} x - x coordinate
     * @param  {number} y - y coordinate
     * @param  {number} z - z coordinate
     * @param  {number} rExtra - additional radius
     * @param  {Float32Array} out - pre-allocated output array
     * @return {undefined}
     */

    this.withinRadii = function (x, y, z, rExtra, out) {
      var outIdx = 0;
      var nearI = hashFunc(x, minX);
      var nearJ = hashFunc(y, minY);
      var nearK = hashFunc(z, minZ);
      var loI = Math.max(0, nearI - 1);
      var loJ = Math.max(0, nearJ - 1);
      var loK = Math.max(0, nearK - 1);
      var hiI = Math.min(iDim - 1, nearI + 1);
      var hiJ = Math.min(jDim - 1, nearJ + 1);
      var hiK = Math.min(kDim - 1, nearK + 1);

      for (i = loI; i <= hiI; ++i) {
        var iOffset = i * jkDim;

        for (j = loJ; j <= hiJ; ++j) {
          var jOffset = j * kDim;

          for (var k = loK; k <= hiK; ++k) {
            cid = iOffset + jOffset + k;
            var cellStart = cellOffsets[cid];
            var cellEnd = cellStart + cellLengths[cid];

            for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
              var atomIndex = data[dataIndex];
              var baseIndex = itemSize * atomIndex;
              var dx = posRad[baseIndex] - x;
              var dy = posRad[baseIndex + 1] - y;
              var dz = posRad[baseIndex + 2] - z;
              var rSum = posRad[baseIndex + 3] + rExtra;

              if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
                out[outIdx++] = data[dataIndex];
              }
            }
          }
        }
      } // Add terminator


      out[outIdx] = -1;
    };
  }

  function ContactSurface(packedArrays, boundaries, params, _indexList) {
    // Field generation method adapted from AstexViewer (Mike Hartshorn)
    // by Fred Ludlow.
    // Other parts based heavily on NGL (Alexander Rose) EDT Surface class
    //
    // Should work as a drop-in alternative to EDTSurface (though some of
    // the EDT paramters are not relevant in this method).
    var itemSize = 4;
    var posRad = packedArrays.posRad,
        colors = packedArrays.colors,
        atoms = packedArrays.atoms;
    var nAtoms = posRad.length / itemSize;
    var bbox = boundaries.bbox;
    var min = bbox.minPosRad;
    var max = bbox.maxPosRad;
    var r2; // Atom positions, expanded radii (squared)

    var maxRadius; // Parameters

    var probeRadius;
    var scaleFactor;
    var probePositions; // Cache last value for obscured test

    var lastClip = -1; // Grid params

    var dim;
    var grid;
    var volTex;
    var weights;
    var weightsMap = null;
    var atomMap = null;
    var visibilitySelector = null; // grid indices -> xyz coords

    var gridx;
    var gridy;
    var gridz; // Lookup tables:

    var sinTable;
    var cosTable; // Spatial Hash

    var hash; // Neighbour array to be filled by hash

    var neighbours; // Vectors for Torus Projection

    var mid = new THREE.Vector3(0.0, 0.0, 0.0);
    var n1 = new THREE.Vector3(0.0, 0.0, 0.0);
    var n2 = new THREE.Vector3(0.0, 0.0, 0.0);
    var ngTorus;

    function uniformArray(TypeName, n, a) {
      var array = utils.allocateTyped(TypeName, n);

      for (var innI = 0; innI < n; ++innI) {
        array[innI] = a;
      }

      return array;
    }

    function fillGridDim(a, start, step) {
      for (var innI = 0; innI < a.length; innI++) {
        a[innI] = start + step * innI;
      }
    }

    function initializeGrid() {
      scaleFactor = params.scaleFactor;
      dim = boundaries.dim;
      ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
      var gridSize = dim[0] * dim[1] * dim[2];
      grid = uniformArray(Float32Array, gridSize, -1001.0);
      volTex = utils.allocateTyped(Float32Array, gridSize * 3);
      weights = utils.allocateTyped(Float32Array, gridSize);

      if (visibilitySelector) {
        weightsMap = utils.allocateTyped(Float32Array, gridSize);
        atomMap = [];
      }

      gridx = utils.allocateTyped(Float32Array, dim[0]);
      gridy = utils.allocateTyped(Float32Array, dim[1]);
      gridz = utils.allocateTyped(Float32Array, dim[2]);
      fillGridDim(gridx, min[0], 1 / scaleFactor);
      fillGridDim(gridy, min[1], 1 / scaleFactor);
      fillGridDim(gridz, min[2], 1 / scaleFactor);
    }

    function initializeAngleTables() {
      var theta = 0.0;
      var step = 2 * Math.PI / probePositions;
      cosTable = utils.allocateTyped(Float32Array, probePositions);
      sinTable = utils.allocateTyped(Float32Array, probePositions);

      for (var innI = 0; innI < probePositions; innI++) {
        cosTable[innI] = Math.cos(theta);
        sinTable[innI] = Math.sin(theta);
        theta += step;
      }
    }

    function initializeHash() {
      hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
      neighbours = new Int32Array(hash.neighbourListLength);
    }

    function init() {
      probeRadius = params.probeRadius;
      scaleFactor = params.scaleFactor;
      probePositions = params.probePositions;
      visibilitySelector = params.visibilitySelector;
      r2 = utils.allocateTyped(Float32Array, nAtoms);
      maxRadius = 0;

      for (var innI = 0; innI < nAtoms; ++innI) {
        var rExt = posRad[innI * itemSize + 3] += probeRadius;

        if (rExt > maxRadius) {
          maxRadius = rExt;
        }

        r2[innI] = rExt * rExt;
      }

      initializeGrid();
      initializeAngleTables();
      initializeHash();
      lastClip = -1;
    }

    function singleAtomObscures(ai, innX, innY, innZ) {
      var innCI = itemSize * ai;
      var ra2 = r2[ai];
      var dx = posRad[innCI] - innX;
      var dy = posRad[innCI + 1] - innY;
      var dz = posRad[innCI + 2] - innZ;
      var d2 = dx * dx + dy * dy + dz * dz;
      return d2 < ra2;
    }

    function obscured(innX, innY, innZ, a, b) {
      // Is the point at x,y,z obscured by any of the atoms
      // specifeid by indices in neighbours. Ignore indices
      // a and b (these are the relevant atoms in projectPoints/Torii)
      // Cache the last clipped atom (as very often the same one in
      // subsequent calls)
      var ai;

      if (lastClip !== -1) {
        ai = lastClip;

        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          return ai;
        }

        lastClip = -1;
      }

      var ni = 0;
      ai = neighbours[ni];

      while (ai >= 0) {
        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          lastClip = ai;
          return ai;
        }

        ai = neighbours[++ni];
      }

      lastClip = -1;
      return -1;
    }

    function projectPoints() {
      // For each atom:
      //     Iterate over a subsection of the grid, for each point:
      //         If current value < 0.0, unvisited, set positive
      //
      //         In any case: Project this point onto surface of the atomic sphere
      //         If this projected point is not obscured by any other atom
      //             Calcualte delta distance and set grid value to minimum of
      //             itself and delta
      // Should we alias frequently accessed closure constiables??
      // Assume JS engine capable of optimizing this
      // anyway...
      var maxRad = 4.0;
      var sigma = maxRad / 3;
      var sigma2Inv = 1 / (2 * sigma * sigma);

      for (var innI = 0; innI < nAtoms; innI++) {
        var innCI = itemSize * innI;
        var ax = posRad[innCI];
        var ay = posRad[innCI + 1];
        var az = posRad[innCI + 2];
        var ar = posRad[innCI + 3];
        var ar2 = r2[innI];
        hash.withinRadii(ax, ay, az, ar, neighbours); // Number of grid points, round this up...

        var ng = Math.ceil(ar * scaleFactor); // Center of the atom, mapped to grid points (take floor)

        var iax = Math.floor(scaleFactor * (ax - min[0]));
        var iay = Math.floor(scaleFactor * (ay - min[1]));
        var iaz = Math.floor(scaleFactor * (az - min[2])); // Extents of grid to consider for this atom

        var minx = Math.max(0, iax - ng);
        var miny = Math.max(0, iay - ng);
        var minz = Math.max(0, iaz - ng); // Add two to these points:
        // - iax are floor'd values so this ensures coverage
        // - these are loop limits (exclusive)

        var maxx = Math.min(dim[0], iax + ng + 2);
        var maxy = Math.min(dim[1], iay + ng + 2);
        var maxz = Math.min(dim[2], iaz + ng + 2);
        var colIdx = innI * 3;
        var cr = colors[colIdx];
        var cg = colors[colIdx + 1];
        var cb = colors[colIdx + 2];

        for (var iz = minz; iz < maxz; iz++) {
          var dz = gridz[iz] - az;
          var zOffset = dim[1] * dim[0] * iz;

          for (var iy = miny; iy < maxy; iy++) {
            var dy = gridy[iy] - ay;
            var dzy2 = dz * dz + dy * dy;
            var zyOffset = zOffset + dim[0] * iy;

            for (var ix = minx; ix < maxx; ix++) {
              var idx = ix + zyOffset;
              var dx = gridx[ix] - ax;
              var d2 = dzy2 + dx * dx;

              if (d2 < ar2) {
                var w = Math.exp(-d2 * sigma2Inv);
                var cIdx = idx * 3;
                volTex[cIdx] += cr * w;
                volTex[cIdx + 1] += cg * w;
                volTex[cIdx + 2] += cb * w;
                weights[idx] += w;

                if (visibilitySelector !== null && w > weightsMap[idx]) {
                  weightsMap[idx] = w;
                  atomMap[idx] = atoms[innI];
                }

                if (grid[idx] < 0.0) {
                  // Unvisited, make positive
                  grid[idx] = -grid[idx];
                } // Project on to the surface of the sphere
                // sp is the projected point ( dx, dy, dz ) * ( ra / d )


                var d = Math.sqrt(d2);
                var ap = ar / d;
                var spx = dx * ap;
                var spy = dy * ap;
                var spz = dz * ap;
                spx += ax;
                spy += ay;
                spz += az;

                if (obscured(spx, spy, spz, innI, -1) === -1) {
                  var dd = ar - d;

                  if (dd < grid[idx]) {
                    grid[idx] = dd;
                  }
                }
              }
            }
          }
        }
      }
    }

    function normalToLine(out, p) {
      out.x = out.y = out.z = 1.0;

      if (p.x !== 0) {
        out.x = (p.y + p.z) / -p.x;
      } else if (p.y !== 0) {
        out.y = (p.x + p.z) / -p.y;
      } else if (p.z !== 0) {
        out.z = (p.x + p.y) / -p.z;
      }

      return out;
    }

    function projectTorus(a, b) {
      var aIdx = itemSize * a;
      var bIdx = itemSize * b;
      var xa = posRad[aIdx];
      var ya = posRad[aIdx + 1];
      var za = posRad[aIdx + 2];
      var r1 = posRad[aIdx + 3];
      var dx = mid.x = posRad[bIdx] - xa;
      var dy = mid.y = posRad[bIdx + 1] - ya;
      var dz = mid.z = posRad[bIdx + 2] - za;
      var innR2 = posRad[bIdx + 3];
      var d2 = dx * dx + dy * dy + dz * dz; // This check now redundant as already done in AVHash.withinRadii
      // if( d2 > (( r1 + r2 ) * ( r1 + r2 )) ){ return; }

      var d = Math.sqrt(d2); // Find angle between a->b vector and the circle
      // of their intersection by cosine rule

      var cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d); // distance along a->b at intersection

      var dmp = r1 * cosA;
      mid.normalize(); // Create normal to line

      normalToLine(n1, mid);
      n1.normalize(); // Cross together for second normal vector

      n2.crossVectors(mid, n1);
      n2.normalize(); // r is radius of circle of intersection

      var rInt = Math.sqrt(r1 * r1 - dmp * dmp);
      n1.multiplyScalar(rInt);
      n2.multiplyScalar(rInt);
      mid.multiplyScalar(dmp);
      mid.x += xa;
      mid.y += ya;
      mid.z += za;
      lastClip = -1;
      var ng = ngTorus;

      for (var innI = 0; innI < probePositions; innI++) {
        var cost = cosTable[innI];
        var sint = sinTable[innI];
        var px = mid.x + cost * n1.x + sint * n2.x;
        var py = mid.y + cost * n1.y + sint * n2.y;
        var pz = mid.z + cost * n1.z + sint * n2.z;

        if (obscured(px, py, pz, a, b) === -1) {
          // As above, iterate over our grid...
          // px, py, pz in grid coords
          var iax = Math.floor(scaleFactor * (px - min[0]));
          var iay = Math.floor(scaleFactor * (py - min[1]));
          var iaz = Math.floor(scaleFactor * (pz - min[2]));
          var minx = Math.max(0, iax - ng);
          var miny = Math.max(0, iay - ng);
          var minz = Math.max(0, iaz - ng);
          var maxx = Math.min(dim[0], iax + ng + 2);
          var maxy = Math.min(dim[1], iay + ng + 2);
          var maxz = Math.min(dim[2], iaz + ng + 2);

          for (var iz = minz; iz < maxz; iz++) {
            dz = pz - gridz[iz];
            var zOffset = dim[1] * dim[0] * iz;

            for (var iy = miny; iy < maxy; iy++) {
              dy = py - gridy[iy];
              var dzy2 = dz * dz + dy * dy;
              var zyOffset = zOffset + dim[0] * iy;

              for (var ix = minx; ix < maxx; ix++) {
                dx = px - gridx[ix];
                d2 = dzy2 + dx * dx;
                var idx = ix + zyOffset;
                var current = grid[idx];

                if (current > 0.0 && d2 < current * current) {
                  grid[idx] = Math.sqrt(d2);
                }
              }
            }
          }
        }
      }
    }

    function projectTorii() {
      for (var innI = 0; innI < nAtoms; innI++) {
        var innIdx = itemSize * innI;
        hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
        var ia = 0;
        var ni = neighbours[ia];

        while (ni >= 0) {
          if (innI < ni) {
            projectTorus(innI, ni);
          }

          ni = neighbours[++ia];
        }
      }
    }

    function fixNegatives() {
      for (var innI = 0, n = grid.length; innI < n; innI++) {
        if (grid[innI] < 0) grid[innI] = 0;
        var w = weights[innI];

        if (w > 0) {
          w = 1 / w;
          var innInnI = innI * 3;
          volTex[innInnI] *= w;
          volTex[innInnI + 1] *= w;
          volTex[innInnI + 2] *= w;
        }
      }
    }

    function getVolume() {
      // Basic steps are:
      // 1) Initialize
      // 2) Project points
      // 3) Project torii
      console.time('ContactSurface.getVolume');
      console.time('ContactSurface.init');
      init();
      console.timeEnd('ContactSurface.init');
      console.time('ContactSurface.projectPoints');
      projectPoints();
      console.timeEnd('ContactSurface.projectPoints');
      console.time('ContactSurface.projectTorii');
      projectTorii();
      console.timeEnd('ContactSurface.projectTorii');
      fixNegatives();
      console.timeEnd('ContactSurface.getVolume');
    }

    this.build = function () {
      // type and cutoff left in for compatibility with EDTSurface.getSurface
      // function signature
      getVolume();
      this.volTexMap = volTex;
      this.weightsMap = weightsMap;
      this.atomMap = atomMap;
      this.volMap = grid;
    };
  }

  function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$w(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Volume$2 = chem.Volume;
  /**
   * This class implements 'contact' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var ContactSurfaceGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    inherits(ContactSurfaceGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$v(ContactSurfaceGeometry);

    function ContactSurfaceGeometry() {
      classCallCheck(this, ContactSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(ContactSurfaceGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        var contactSurface = new ContactSurface(packedArrays, boundaries, params);
        contactSurface.build();
        var surface = {
          volMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
          volTexMap: new Volume$2(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
          atomMap: contactSurface.atomMap,
          atomWeightMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
        };
        return surface;
      }
    }]);

    return ContactSurfaceGeometry;
  }(VolumeSurfaceGeometry);

  /**
   * Class for colored atom. Need for atom structure clusterization
   *
   * @param {Vector3} vCenter   Center of atom
   * @param {number}  radiusAt  Radius of atom
   */

  var IsoSurfaceAtomColored = function IsoSurfaceAtomColored(vCenter, radiusAt) {
    classCallCheck(this, IsoSurfaceAtomColored);

    this.coord = new THREE.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0.0;
    this.colorZ = 0.0;
    this.atomType = 0;
    this.srcAtom = null;
  };

  /* jshint bitwise: false */

  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {number} numAtoms     - Number of atoms in molecule
   * @param {Element} atoms      - Array of atoms
   * @param {Vector3} vBoxMin     - Bounding box min
   * @param {Vector3} vBoxMax     - Bounding box max
   * @param {number} probeRadius     - Normals for output
   *
   */

  var IsosurfaceBuildNormals = /*#__PURE__*/function () {
    function IsosurfaceBuildNormals(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
      classCallCheck(this, IsosurfaceBuildNormals);

      this._numAtoms = numAtoms;
      this._atoms = atoms;
      this._vBoxMin = new THREE.Vector3();
      this._vBoxMax = new THREE.Vector3();

      this._vBoxMin.copy(vBoxMin);

      this._vBoxMax.copy(vBoxMax);

      this._probeRadius = probeRadius;
      this._atomsList = null;
      this._voxelList = null;
    }

    createClass(IsosurfaceBuildNormals, [{
      key: "createVoxels",
      value: function createVoxels() {
        var numAtomsRefs;
        var rad;
        var ATOM_VOXEL_REF_SCALE = 4.5;
        var numAtoms = this._numAtoms | 0;
        var atoms = this._atoms;
        var dx = this._vBoxMax.x - this._vBoxMin.x;
        var dy = this._vBoxMax.y - this._vBoxMin.y;
        var dz = this._vBoxMax.z - this._vBoxMin.z;
        var w = dx < dy ? dx : dy;
        w = dz < w ? dz : w;
        var maxRad = 0.0;
        var aveRad = 0.0;
        var i;

        for (i = 0; i < numAtoms; i++) {
          rad = (atoms[i].radius + this._probeRadius) * 2.0;
          maxRad = rad > maxRad ? rad : maxRad;
          aveRad += rad;
        }

        var numCells = Math.floor(w / maxRad);

        if (numCells < 2) {
          numCells = 2;
        }

        aveRad /= numAtoms;
        this._numCells = numCells;
        this._aveRad = aveRad;
        this._maxRad = maxRad;
        var side = numCells;
        var side2 = numCells * numCells;
        var side3 = numCells * numCells * numCells;
        var xScale = this._xScale = 1.0 / (this._vBoxMax.x - this._vBoxMin.x);
        var yScale = this._yScale = 1.0 / (this._vBoxMax.y - this._vBoxMin.y);
        var zScale = this._zScale = 1.0 / (this._vBoxMax.z - this._vBoxMin.z); // estimate number of individual atom refs in each voxel list

        var maxAtomsRefs = 0;
        var xNumVoxMult = xScale * numCells;
        var yNumVoxMult = yScale * numCells;
        var zNumVoxMult = zScale * numCells;

        for (i = 0; i < numAtoms; i++) {
          var radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var diaAffect = radAffect * 2.0;
          var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
          var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
          var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8); // avoid case numVox? == 0
          // also use loop i <=

          numVoxX++;
          numVoxY++;
          numVoxZ++;
          maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
        } // for (i)
        // maxAtomsRefs = numAtoms * MAX_ATOMS_IN_SINGLE_VOXEL;


        this._voxelList = utils.allocateTyped(Int32Array, side3);
        var atomsList = [];
        atomsList.length = maxAtomsRefs;

        if (this._voxelList === null || atomsList === null) {
          return 0 - 1;
        } // init voxel list


        for (i = 0; i < side3; i++) {
          this._voxelList[i] = -1;
        }

        numAtomsRefs = 0; // create voxel lists

        for (i = 0; i < numAtoms; i++) {
          // use multiplier 4 to locate this atom in different voxels
          rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
          var yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
          var zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
          var xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
          var yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
          var zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
          xIndMin = xIndMin >= 0 ? xIndMin : 0;
          yIndMin = yIndMin >= 0 ? yIndMin : 0;
          zIndMin = zIndMin >= 0 ? zIndMin : 0;
          xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
          yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
          zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;

          for (var z = zIndMin; z <= zIndMax; z++) {
            for (var y = yIndMin; y <= yIndMax; y++) {
              for (var x = xIndMin; x <= xIndMax; x++) {
                // add atom with index "i" to this voxel list
                var indVoxel = x + y * side + z * side2; // assert indVoxel >= 0
                // assert indVoxel < side3
                // add first

                if (this._voxelList[indVoxel] < 0) {
                  atomsList[numAtomsRefs * 2 + 0] = i;
                  atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
                  this._voxelList[indVoxel] = numAtomsRefs;
                  numAtomsRefs++; // assert numAtomsRefs < maxAtomsRefs - 1

                  continue;
                } // insert into head of list


                var indexNext = this._voxelList[indVoxel];
                this._voxelList[indVoxel] = numAtomsRefs;
                atomsList[numAtomsRefs * 2 + 0] = i;
                atomsList[numAtomsRefs * 2 + 1] = indexNext;
                numAtomsRefs++;
              } // for (x)

            } // for (y)

          } // for (z)

        } // for (i)
        // convert Array to Int32Array


        this._atomsList = Int32Array.from(atomsList);
        return 0;
      }
    }, {
      key: "destroyVoxels",
      value: function destroyVoxels() {
        this._atomsList = null;
        this._voxelList = null;
        this._atoms = null;
        this._vertices = null;
        this._vBoxMin = null;
        this._vBoxMax = null;
      }
      /**
       * Enumerate all atoms affecting specified point
       *
       * @param {Vector3}    point    - point in 3D
       * @param {func(atom)} process  - function to call for each atom
       */

    }, {
      key: "forEachRelatedAtom",
      value: function forEachRelatedAtom(point, process) {
        // find corresponding voxel
        var xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
        var yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
        var zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
        var indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells; // run through atoms affecting this voxel

        var atoms = this._atoms;

        for (var ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
          var indexAtom = this._atomsList[ref * 2];
          process(atoms[indexAtom]);
        }
      }
      /**
       * Get atom closest to specified point
       *
       * @param {Vector3} point  - point in 3D
       *
       * @returns {IsoSurfaceAtomColored} atom, or null if not found
       */

    }, {
      key: "getClosestAtom",
      value: function getClosestAtom(point) {
        var closest = null;
        var minDist2 = Number.MAX_VALUE;
        this.forEachRelatedAtom(point, function (atom) {
          var dist2 = point.distanceToSquared(atom.coord);

          if (dist2 < minDist2) {
            minDist2 = dist2;
            closest = atom;
          }
        });
        return closest;
      }
      /**
       * Build normals for isosurface, using atoms information
       *
       * @param {number} numVertices  - Number of vertices in final geometry (to render)
       * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
       * @param {Vector3} normals     - Normals for output
       *
       * @returns {number} 0, if success
       */

    }, {
      key: "buildNormals",
      value: function buildNormals(numVertices, vertices, normals) {
        var self = this;
        var numCloseAtoms = 0;
        var vx = 0;
        var vy = 0;
        var vz = 0;
        var dist2;
        var vNormalX = 0;
        var vNormalY = 0;
        var vNormalZ = 0;
        var koef = 0;
        var w = 0;
        var r25 = 2.5;
        var r01 = 0.1;
        var maxRadAffect = this._aveRad * r25;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var expScale = -this._aveRad * r01; // some stats
        // numSlowAtoms = 0;

        var gatherNormals = function gatherNormals(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          } // get weight for gaussian smoothing


          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = Math.exp(expScale * koef);
          vNormalX += dx * w;
          vNormalY += dy * w;
          vNormalZ += dz * w;
          numCloseAtoms++;
        };

        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          numCloseAtoms = 0;
          vNormalX = vNormalY = vNormalZ = 0.0;
          this.forEachRelatedAtom(vertices[i], gatherNormals);

          dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;

          if (numCloseAtoms > 0) {
            koef = 1.0 / Math.sqrt(dist2);
            vNormalX *= koef;
            vNormalY *= koef;
            vNormalZ *= koef;
          }

          normals[i].x = vNormalX;
          normals[i].y = vNormalY;
          normals[i].z = vNormalZ;
        } // for (i) all vertices


        return 0;
      }
      /**
       * Build vertex colors for isosurface, using atoms information
       *
       * @param {number} numVertices  - Number of vertices in final geometry (to render)
       * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
       * @param {Vector3} colors                - Colors for output
       * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
       *
       * @returns {number} 0, if success
       */

    }, {
      key: "buildColors",
      value: function buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
        var self = this;
        var vx = 0.0;
        var vy = 0.0;
        var vz = 0.0;
        var koef = 0.0;
        var w = 0.0;
        var KOEF_ADD = 0.8;
        var maxRadAffect = radiusColorSmoothness;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var colorsClose = [];
        var weights = [];
        var weightsSum = 0;

        var gatherColors = function gatherColors(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          var dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          } // get weight for gaussian smoothing


          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = 1.0 / (KOEF_ADD + koef);
          colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
          weights.push(w); // save weights for use

          weightsSum += w; // calc sum of weights fo further normalization
        }; // process all vertices, one by one


        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          colorsClose = [];
          weights = [];
          weightsSum = 0;
          this.forEachRelatedAtom(vertices[i], gatherColors); // normalized weighted sum of colors

          for (var j = 0; j < colorsClose.length; ++j) {
            var weightNormalized = weights[j] / weightsSum;
            colors[i].x += colorsClose[j][0] * weightNormalized;
            colors[i].y += colorsClose[j][1] * weightNormalized;
            colors[i].z += colorsClose[j][2] * weightNormalized;
          }
        } // for (i) all vertices


        return 0;
      }
    }]);

    return IsosurfaceBuildNormals;
  }();

  /**
   * Class for geometry (triangle mesh) representation
   *
   *
   * @param {number} maxNumVertices Maximum possible number of vertices in mesh
   * @param {number} maxNumTriangles Maximum possible number of triangles in mesh
   * @param {boolean} needVertexColors Obvious
   */

  var IsoSurfaceGeo = /*#__PURE__*/function () {
    function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
      classCallCheck(this, IsoSurfaceGeo);

      this._maxNumVertices = maxNumVertices;
      this._maxNumTriangles = maxNumTriangles;
      this._vertices = new Array(maxNumVertices);
      this._normals = new Array(maxNumVertices);
      this._colors = null;

      if (needVertexColors) {
        this._colors = new Array(maxNumVertices);
      }

      this._indices = new Array(maxNumTriangles * (1 + 2));
      this._numVertices = 0;
      this._numTriangles = 0;
      var i;

      for (i = 0; i < maxNumVertices; i++) {
        this._vertices[i] = new THREE.Vector3();
        this._normals[i] = new THREE.Vector3();
      }

      for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
        this._indices[i] = -1;
      }

      if (needVertexColors) {
        for (i = 0; i < maxNumVertices; i++) {
          this._colors[i] = new THREE.Vector3();
        }
      }
    }

    createClass(IsoSurfaceGeo, [{
      key: "destroy",
      value: function destroy() {
        this._vertices = null;
        this._normals = null;
        this._indices = null;
      }
    }]);

    return IsoSurfaceGeo;
  }();

  function _createSuper$w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$x(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var COLOR_SIZE$3 = 3;
  var HASH_SIZE = 32768;
  var Element$1 = chem.Element;
  /**
   * This class implements 'quick' isosurface geometry generation algorithm.
   * @param spheresCount - number of atoms/spheres
   * @param opts - geometry specific options
   * @constructor
   */

  var SSIsosurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    inherits(SSIsosurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$w(SSIsosurfaceGeometry);

    function SSIsosurfaceGeometry() {
      classCallCheck(this, SSIsosurfaceGeometry);

      return _super.apply(this, arguments);
    }

    createClass(SSIsosurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        // convert geoOut into arrays of positions, indices, normals
        this._innerBuild();

        var geoOut = this.getGeo();
        this.destroy();

        this._fromGeo(geoOut);
      }
    }, {
      key: "_fromGeo",
      value: function _fromGeo(geoOut) {
        var colors = null;
        var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);

        if (geoOut._colors !== null) {
          colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        }

        var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);

        for (var i = 0, j = 0; i < geoOut._numVertices; i++) {
          positions[j + 0] = geoOut._vertices[i].x;
          positions[j + 1] = geoOut._vertices[i].y;
          positions[j + 2] = geoOut._vertices[i].z;
          normals[j + 0] = geoOut._normals[i].x;
          normals[j + 1] = geoOut._normals[i].y;
          normals[j + 2] = geoOut._normals[i].z;
          j += 3;
        }

        if (colors !== null) {
          for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
            colors[_j + 0] = geoOut._colors[_i].x;
            colors[_j + 1] = geoOut._colors[_i].y;
            colors[_j + 2] = geoOut._colors[_i].z;
          }
        }

        var numTri3 = geoOut._numTriangles * (1 + 2);

        for (var _i2 = 0; _i2 < numTri3; _i2++) {
          indices[_i2] = geoOut._indices[_i2];
        }

        this.setIndex(new THREE.BufferAttribute(indices, 1));
        this.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        this.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        this.computeBoundingBox();
        this.computeBoundingSphere();
        geoOut.destroy();
      }
    }, {
      key: "convertToAtomsColored",
      value: function convertToAtomsColored(packedArrays, atomsColored) {
        var atoms = packedArrays.atoms,
            colors = packedArrays.colors;

        for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
          var vCenter = atoms[i].position;
          var radius = atoms[i].element.radius;
          atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius);
          var nm = atoms[i].element.number;
          atomsColored[i].atomType = this.getType(nm);
          var cIdx = COLOR_SIZE$3 * i;
          atomsColored[i].colorX = colors[cIdx++];
          atomsColored[i].colorY = colors[cIdx++];
          atomsColored[i].colorZ = colors[cIdx];
          atomsColored[i].srcAtom = atoms[i];
        }
      }
    }, {
      key: "getGeo",
      value: function getGeo() {
        return this.geoOut;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.atoms = null;
        this.hashLines = null;
        this.hashEntries = null;
      }
      /**
       * Calculates bounding box for array with spheres (atoms)
       *
       * @param {Object}  atoms      Atoms array
       * @param {Vector3} vBoxMin    Bounding box min point
       * @param {Vector3} vBoxMax    Bounding box max point
       */

    }, {
      key: "getBoundingBox",
      value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
        var bigNum = 10000000.0;
        vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
        vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
        var probeRadius2 = this.probeRadius * this.atomRadiusScale;
        var radMax = 0.0;

        for (var i = 0, num = atoms.length; i < num; i++) {
          var vCenter = atoms[i].coord;
          var rad = atoms[i].radius + probeRadius2;
          radMax = rad > radMax ? rad : radMax;

          if (vCenter.x - rad < vBoxMin.x) {
            vBoxMin.x = vCenter.x - rad;
          }

          if (vCenter.y - rad < vBoxMin.y) {
            vBoxMin.y = vCenter.y - rad;
          }

          if (vCenter.z - rad < vBoxMin.z) {
            vBoxMin.z = vCenter.z - rad;
          }

          if (vCenter.x + rad > vBoxMax.x) {
            vBoxMax.x = vCenter.x + rad;
          }

          if (vCenter.y + rad > vBoxMax.y) {
            vBoxMax.y = vCenter.y + rad;
          }

          if (vCenter.z + rad > vBoxMax.z) {
            vBoxMax.z = vCenter.z + rad;
          }
        }

        vBoxMin.x -= radMax;
        vBoxMin.y -= radMax;
        vBoxMin.z -= radMax;
        vBoxMax.x += radMax;
        vBoxMax.y += radMax;
        vBoxMax.z += radMax;
      }
      /**
       * Calculate (x,y,z) cordinate of the cell corner point
       *
       * @param {Vector3} vBoxMin Bounding box min point
       * @param {Vector3} vBoxMax Bounding box max point
       * @param {number} x Cell integer x coordinate
       * @param {number} y Cell integer y coordinate
       * @param {number} z Cell integer z coordinate
       * @param {number} numPoints NUm points in cell on side
       * @param {Vector3} vOut Output vector
       */

    }, {
      key: "getCornerCoord",
      value: function getCornerCoord(vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
        var invNP = 1.0 / (numPoints - 1.0);
        var tx = x * invNP;
        var ty = y * invNP;
        var tz = z * invNP;
        vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx;
        vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty;
        vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz;
      }
      /**
       * Calculate point of intersection of sphere surface
       * and cell edge, given by [indexA, indexB] line
       *
       * @param {number} indexA Cell vertex index in [0..11]
       * @param {number} indexB Cell vertex index in [0..11]
       * @param {array}  sign   Sign array for all 8 vertices
       * @param {object} cube   Cube
       * @param {number} indexPointValue for value placement
       * @param {Vector3} vOut  Point of intersection
       */

    }, {
      key: "buildEdgePoint",
      value: function buildEdgePoint(indexA, indexB, sign, cube, indexPointValue, vOut) {
        if (sign[indexA] ^ sign[indexB]) {
          var cTwentyFour = 24;
          var t = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
          var xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
          var ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
          var za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
          var xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
          var yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
          var zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
          vOut.x = xa * (1.0 - t) + xb * t;
          vOut.y = ya * (1.0 - t) + yb * t;
          vOut.z = za * (1.0 - t) + zb * t;
        }
      }
      /**
       * Check if triangle is visible (vertices are close to atoms included in visibility set)
       *
       * @param {Vector3} v0 Vertex #0
       * @param {Vector3} v1 Vertex #1
       * @param {Vector3} v2 Vertex #2
       * @returns {boolean} true if triangle is visible
       */

    }, {
      key: "isTriangleVisible",
      value: function isTriangleVisible(v0, v1, v2) {
        var a0 = this.voxelWorld.getClosestAtom(v0);
        var a1 = this.voxelWorld.getClosestAtom(v1);
        var a2 = this.voxelWorld.getClosestAtom(v2);

        if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
          return false;
        }

        return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
      }
      /**
       * Add triangle to result geometry
       *
       * @param {Vector3} v0 Vertex #0
       * @param {Vector3} v1 Vertex #1
       * @param {Vector3} v2 Vertex #2
       * @returns {boolean} false if no more triangles can be added
       */

    }, {
      key: "addTriangle",
      value: function addTriangle(v0, v1, v2) {
        if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
          return true;
        }

        var geo = this.geoOut;

        if (geo._numTriangles >= this.maxNumTriangles) {
          return false;
        } // Add vertex with optimize


        var indInGeo0 = this.addVertexToGeo(geo, v0);
        var indInGeo1 = this.addVertexToGeo(geo, v1);
        var indInGeo2 = this.addVertexToGeo(geo, v2);

        if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
          return false;
        }

        var itr = 3 * geo._numTriangles;
        geo._indices[itr + 0] = indInGeo0;
        geo._indices[itr + 1] = indInGeo1;
        geo._indices[itr + 2] = indInGeo2;
        geo._numTriangles++;
        return true;
      }
      /**
       * Build result geometry (triangle mesh) from marching cube cells
       *
       * @param {number} meshRes Marchnig cube vertex count on each side
       * @param {Vector3} vBoxMin Bounding box point min
       * @param {Vector3} vBoxMax Bounding box point max
       * @param {number} corners float values array for each cube point
       * @param {Vector3} vCellStep vector to next cube cell diagonal point
       * @param {object} cube IsoSurfaceMarchCube object
       * @returns {number} 0, if success (<0) is error
       */

    }, {
      key: "buildGeoFromCorners",
      value: function buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
        var arrSize = 12;
        var cNumVerts = 8;
        var numCells = meshRes - 1;
        var side = meshRes;
        var side2 = meshRes * meshRes;
        var vaEdges = new Array(arrSize);

        for (var i = 0; i < arrSize; i++) {
          vaEdges[i] = new THREE.Vector3();
        }

        var sign = [];

        for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
          sign[_i3] = 1.0;
        }

        var vCorner = new THREE.Vector3();
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              if (!cube.hasIntersection[indCell]) {
                // next cell
                indCell++;
                continue;
              }

              var bitsInside = cube.bitsInside[indCell];
              this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);
              var indPointValues = indCell * (2 << 2 + 2);

              for (var _i4 = 0, j = 0; _i4 < cNumVerts; _i4++) {
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.x;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.y;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.z;
              }

              cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y; // now current cell has intersections (from -x to +x) on some cube edges

              var indValues = indPointValues + 24;

              for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
                sign[_i5] = cube.pointsValuesLinear[indValues + _i5] < 0.0 ? 1 : 0;
              }

              this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
              this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
              this.buildEdgePoint(2, 3, sign, cube, indPointValues, vaEdges[2]);
              this.buildEdgePoint(3, 0, sign, cube, indPointValues, vaEdges[3]);
              this.buildEdgePoint(4, 5, sign, cube, indPointValues, vaEdges[4]);
              this.buildEdgePoint(5, 6, sign, cube, indPointValues, vaEdges[5]);
              this.buildEdgePoint(6, 7, sign, cube, indPointValues, vaEdges[6]);
              this.buildEdgePoint(7, 4, sign, cube, indPointValues, vaEdges[7]);
              this.buildEdgePoint(0, 4, sign, cube, indPointValues, vaEdges[8]);
              this.buildEdgePoint(1, 5, sign, cube, indPointValues, vaEdges[9]);
              this.buildEdgePoint(2, 6, sign, cube, indPointValues, vaEdges[10]);
              this.buildEdgePoint(3, 7, sign, cube, indPointValues, vaEdges[11]);
              var offs = bitsInside * (2 << 1 + 2);

              for (var numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
                // s_triIndicesMarchCube is external array, defined in mold_ind.js
                var i0 = cube.striIndicesMarchCube[offs + indTri];

                if (i0 < 0) {
                  break;
                }

                var i1 = cube.striIndicesMarchCube[offs + indTri + 1];
                var i2 = cube.striIndicesMarchCube[offs + indTri + 2];

                if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
                  return 0 - 2;
                }
              } // for numTri
              // next cell (cube)


              indCell++;
            } // for (x)

          } // for (z)

        } // for (y)


        return 0;
      }
      /**
       * Returns number of cell with intersection with at least one sphere.
       * Using this number, we can estimate required number of vertices
       * and triangles to build result mesh.
       *
       * @param {number} side Number of points in cube voxels
       * @param {number} numCells Number of cells in cube voxels (per direction)
       * @param {array} corners Array of float values for cube corner points
       * @param {object} cube IsoSurfaceMarchCube object
       * @returns {number} numIntersectedCells
       */

    }, {
      key: "getNumIntersectedCells",
      value: function getNumIntersectedCells(side, numCells, corners, cube) {
        var side2 = side * side;
        var cNumVerts = 8;
        var numIntersectedCells = 0;
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              var cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
              var indCorner = x + indZ + indY;
              cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
              cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side]; // check read exception
              // assert(side2 + indCorner + side + 1 < side3);
              // get bit flags inside

              var bitsInside = 0;

              for (var i = 0; i < cNumVerts; ++i) {
                if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
                  bitsInside |= 1 << i;
                }
              }

              if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
                cube.hasIntersection[indCell] = false;
              } else {
                cube.hasIntersection[indCell] = true;
                numIntersectedCells++;
              }

              cube.bitsInside[indCell] = bitsInside; // next cell

              indCell++;
            } // for (x)

          } // for (z)

        } // for (y)


        return numIntersectedCells;
      }
    }, {
      key: "getType",
      value: function getType(letter) {
        /* eslint-disable no-magic-numbers */
        var atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
        /* eslint-enable no-magic-numbers */

        if (letter < 1 || letter > atomT.length / 2 || Object.keys(Element$1.ByAtomicNumber).length * 2 !== atomT.length) {
          throw new Error('atomT.length  should be equal Element.ByAtomicNumber.length * 2');
        }

        return atomT[letter * 2];
      }
      /**
       * Calculate values for marching cube grid points
       * positive values are outside sphere, negative - is inside
       *
       * @param {array} corners array of float values
       * @param {number} side Number of point in cube in 1 dimennsion
       * @param {Vector3} vBoxMin Bounding box min point
       * @param {Vector3} vBoxMax Bounding box max point
       * @param {array} atoms Array of input atoms
       * @param {number} probeRad radius for atom probing
       */

    }, {
      key: "calculateGridCorners",
      value: function calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
        var side2 = side * side;
        var side3 = side2 * side;
        var vCorner = new THREE.Vector3();
        var vDif = new THREE.Vector3();
        /* eslint-disable no-magic-numbers */

        var aLot = +1.0e12;
        /* eslint-enable no-magic-numbers */

        for (var i = 0; i < side3; i++) {
          corners[i] = aLot; // to large value
        }

        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);

        for (var s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
          var atom = atoms[s];
          var radius = atom.radius + probeRad;
          var fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
          var fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
          var fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
          var indXMin = Math.floor(fx);
          var indYMin = Math.floor(fy);
          var indZMin = Math.floor(fz);
          var indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
          var indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
          var indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
          indXMax++;
          indYMax++;
          indZMax++;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var y = indYMin; y <= indYMax; y++) {
            var indY = y * side2;

            for (var z = indZMin; z <= indZMax; z++) {
              var indZ = z * side;

              for (var x = indXMin; x <= indXMax; x++) {
                var ind = indY + indZ + x;
                this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
                vDif.x = vCorner.x - atom.coord.x;
                vDif.y = vCorner.y - atom.coord.y;
                vDif.z = vCorner.z - atom.coord.z;
                var distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z); // val: < 0, if inside sphere
                // val: > 0, if outside sphere

                var val = distToSphere - radius;

                if (val < corners[ind]) {
                  corners[ind] = val;
                }
              } // for (x)

            } // for (z)

          } // for (y)

        } // for (s)

      }
      /**
       * Create memory pool for vertex hash management
       *
       * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
       * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
       * @returns {number} 0, if success. (<0) is non memory
       */

    }, {
      key: "createVertexHash",
      value: function createVertexHash(maxNumVertices, maxNumTriangles) {
        this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);

        if (this.hashLines === null) {
          return 0 - 1;
        }

        for (var i = 0, j = 0; i < HASH_SIZE; i++) {
          this.hashLines[j++] = 0; // num vertices in this hash line

          this.hashLines[j++] = 0 - 1; // index of the first entry
        }

        this.maxNumVertices = maxNumVertices;
        this.maxNumTriangles = maxNumTriangles;
        this.numHashEtriesAllocated = maxNumVertices;
        this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);

        if (this.hashEntries === null) {
          return 0 - 1;
        }

        for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
          this.hashEntries[_j2++] = 0 - 1; // index of vertex

          this.hashEntries[_j2++] = 0 - 1; // next hash entry index
        }

        this.numHashEntryIndex = 0;
        return 0;
      }
      /**
       * Allocate and return new hash entry. Just check possible amount.
       *
       * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
       */

    }, {
      key: "getNewHashEntry",
      value: function getNewHashEntry() {
        if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
          var i = this.numHashEntryIndex;
          this.numHashEntryIndex++;
          return i;
        }

        return 0 - 1;
      }
      /**
       * Add vertex to geometry structure
       * using vertex hash table to quickly check, is this vertex already exist in geometry
       *
       * @param {object} geoOut Geometry to build
       * @param {Vector3} vAdd Vertex to add
       * @returns {number} index of added (or existing) vertex in geometry.
       */

    }, {
      key: "addVertexToGeo",
      value: function addVertexToGeo(geoOut, vAdd) {
        var entry;
        var oneHynberes = 0.01;
        var n815851 = 815851;
        var n37633 = 37633;
        var n2453543 = 2453543;
        var r106 = 1.0e-6;
        var hashResolution = this.marCubeResoultion << 2;
        var v = new THREE.Vector3();
        var ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
        var iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
        var iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
        var iHash = ix * n815851 + iz * n37633 + iy * n2453543;
        iHash &= HASH_SIZE - 1;
        var hLineIndex = iHash + iHash; // search vertex via hash
        // search in hash list

        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
            var ind = this.hashEntries[entry * 2 + 0]; // vertex index

            v.copy(geoOut._vertices[ind]);
            v.x -= vAdd.x;
            v.y -= vAdd.y;
            v.z -= vAdd.z;
            var dot2 = v.x * v.x + v.y * v.y + v.z * v.z;

            if (dot2 < r106) {
              return ind;
            } // if (found)

          } // for (entry)

        } // search
        // add new vertex to geometry


        if (geoOut._numVertices >= this.maxNumVertices) {
          return 0 - 1;
        }

        var iVertAdd = geoOut._numVertices;

        geoOut._vertices[iVertAdd].copy(vAdd); // add to hash


        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          entry = this.getNewHashEntry();

          if (entry < 0) {
            return 0 - 1;
          }

          var entryFirst = this.hashLines[hLineIndex + 1];
          this.hashLines[hLineIndex + 1] = entry;
          this.hashEntries[entry * 2 + 0] = iVertAdd;
          this.hashEntries[entry * 2 + 1] = entryFirst;
          this.hashLines[hLineIndex + 0]++; // num vertices in line ++
        }

        geoOut._numVertices++;
        return iVertAdd;
      }
      /**
       *
       * @param {number} side some placeholder description
       * @param {number} probeSphereRadius some placeholder description
       * @param {object} vBoxMin some placeholder description
       * @param {object} vBoxMax some placeholder description
       * @param {object} geoOut some placeholder description
       * @param {object} corners some placeholder description
       * @returns {number} always 0
       */

    }, {
      key: "modifyExcludedFromGeo",
      value: function modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
        var ind;
        var distToSphere;
        var distToBorder;
        var r11 = 1.1;

        function innerBlockWorkAround() {
          if (distToBorder > 0.0) {
            // point is inside probe sphere
            if (corners[ind] < 0.0) {
              corners[ind] = distToBorder; // was inside surface, now is oustide ( > 0)
            }

            if (distToBorder > corners[ind]) {
              corners[ind] = distToBorder; // find positive maximum
            }
          } else if (distToBorder > corners[ind]) {
            // point is outside sphere
            corners[ind] = distToBorder; // find negative maximum
          }
        }

        var side2 = side * side;
        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
        var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
        var sideInv = 1.0 / (side - 1);

        for (var i = 0; i < geoOut._numVertices; i++) {
          var vCenter = geoOut._vertices[i];
          var radEst = probeSphereRadius * r11;
          var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
          var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
          var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
          var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
          var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
          var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
          indXMin = indXMin >= 0 ? indXMin : 0;
          indYMin = indYMin >= 0 ? indYMin : 0;
          indZMin = indZMin >= 0 ? indZMin : 0;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var iy = indYMin; iy <= indYMax; iy++) {
            var indY = iy * side2;

            for (var iz = indZMin; iz <= indZMax; iz++) {
              var indZ = iz * side;

              for (var ix = indXMin; ix <= indXMax; ix++) {
                ind = indY + indZ + ix; // getCornerCoord(vBoxMin, vBoxMax, ix, iy, iz, side, &vCorner);

                var t = ix * sideInv;
                var xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t;
                t = iy * sideInv;
                var yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t;
                t = iz * sideInv;
                var zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t;
                var dx = xCorner - vCenter.x;
                var dy = yCorner - vCenter.y;
                var dz = zCorner - vCenter.z;
                var dist2 = dx * dx + dy * dy + dz * dz;

                if (dist2 < probeSpRad2) {
                  distToSphere = Math.sqrt(dist2);
                  distToBorder = -(distToSphere - probeSphereRadius);
                  innerBlockWorkAround();
                } // if (dist from corner point to sphere center more 2 radiuses)

              } // for (ix)

            } // for (iz)

          } // for (iy)

        } // for (i) all geo vertices


        return 0;
      }
    }, {
      key: "_innerBuild",
      value: function _innerBuild() {
        var ok;
        var expandFactor = 1.2; // performance test
        // this.performanceTest();
        // Create temporary atoms (but colored)

        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };
        this.complex = this._opts.parent;
        this.atoms = packedArrays.atoms;
        this.meshResolution = this._opts.gridSpacing;
        this.atomRadiusScale = this._opts.radScale;
        this.colorMode = this._opts.colorMode;
        this.probeRadius = this._opts.probeRadius;
        this.useVertexColors = true;
        this.excludeProbe = this._opts.excludeProbe;
        this.visibilitySelector = this._opts.visibilitySelector;
        this.geoOut = null;
        this.hashLines = null;
        this.hashEntries = null;
        this.numHashEtriesAllocated = 0;
        this.numHashEntryIndex = 0;
        this.maxNumVertices = 0;
        this.maxNumTriangles = 0;
        var atomsColored = new Array(this.atoms.length);
        this.convertToAtomsColored(packedArrays, atomsColored); // find bbox for spheres scene

        var vBoxMin = this.vBoxMin = new THREE.Vector3();
        var vBoxMax = this.vBoxMax = new THREE.Vector3();
        this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
        var marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2); // build grid corners for Marching cube algorithm

        var side = marCubeResoultion;
        var side2 = side * side;
        var side3 = side2 * side;
        var corners = utils.allocateTyped(Float32Array, side3);
        var rProbeRadius = this.probeRadius * this.atomRadiusScale;
        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
        var numCells = marCubeResoultion - 1;
        var cube = new IsoSurfaceMarchCube();
        ok = cube.create(numCells);

        if (ok < 0) {
          return ok;
        } // copy corners to cells


        var vCellStep = new THREE.Vector3();
        vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
        vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
        vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
        var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
        var maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
        var maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

        if (ok < 0) {
          return ok;
        } // build voxel world (used to check triangle-to-atom tie and to calculate normals and colors)


        var probeRadForNormalsColors = rProbeRadius;

        if (this.excludeProbe) {
          probeRadForNormalsColors = 0.01;
        }

        this.voxelWorld = new IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
        this.voxelWorld.createVoxels();
        ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);

        if (this.excludeProbe) {
          // using 3d mesh (geoOut) as a surface points
          // move probe sphere and try to minimuze corners values
          this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners); // delete old builded geo

          this.geoOut._vertices = null;
          this.geoOut._colors = null;
          this.geoOut._indices = null;
          this.geoOut._normals = null;
          this.geoOut._numVertices = 0;
          this.geoOut._numTriangles = 0;
          this.geoOut = null; // estimage geo vertices budget again

          numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
          maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
          maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2); // creates empty new geometry

          this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
          ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

          if (ok < 0) {
            return ok;
          } // build vertices and triangles from corners values


          ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
        } // build vertex normals


        this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals); // More value : more smooth color mixing
        // value about 0.7: very rough colors borders

        var radiusColorSmoothness = 6.5;

        if (this.excludeProbe) {
          radiusColorSmoothness -= 1.5;
        }

        if (this.useVertexColors) {
          this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
        }

        this.voxelWorld.destroyVoxels();
        this.voxelWorld = null; // remove objects

        cube.destroy();
        return ok;
      }
    }]);

    return SSIsosurfaceGeometry;
  }(IsoSurfaceGeometry); // All code below must be erased from every device and each developer's memory

  function _createSuper$x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function createLabel(fieldTxt, className) {
    var text = document.createElement('div');
    text.className = className;

    if (typeof fieldTxt === 'string') {
      var spanText = document.createElement('span');
      spanText.style.fontSize = '150%';
      var strings = fieldTxt.split('\n');

      for (var i = 0, n = strings.length; i < n; ++i) {
        var spanNodeP = document.createElement('span');
        var spanNodeText = document.createTextNode(strings[i]);
        spanNodeP.appendChild(spanNodeText);
        spanText.appendChild(spanNodeP);

        if (i < n - 1) {
          spanText.appendChild(document.createElement('br'));
        }
      }

      text.appendChild(spanText);
    } else {
      text.appendChild(fieldTxt);
    }

    text.worldPos = new THREE.Vector3();
    return text;
  }

  var LabelsGeometry = /*#__PURE__*/function (_EventDispatcher) {
    inherits(LabelsGeometry, _EventDispatcher);

    var _super = _createSuper$x(LabelsGeometry);

    function LabelsGeometry(instanceCount, opts) {
      var _this;

      classCallCheck(this, LabelsGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.items = [];
      _this.needsUpdate = false;
      var xTranslation = -50;
      var yTranslation = -50;

      switch (opts.horizontalAlign) {
        case 'left':
          xTranslation = 0;
          break;

        case 'right':
          xTranslation = -100;
          break;
      }

      switch (opts.verticalAlign) {
        case 'top':
          yTranslation = -100;
          break;

        case 'bottom':
          yTranslation = 0;
          break;
      }

      var deltaPos = new THREE.Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
      _this.userData = {
        translation: "translate(".concat(xTranslation, "%, ").concat(yTranslation, "%)"),
        offset: deltaPos
      };
      return _this;
    }

    createClass(LabelsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, fieldTxt) {
        var opts = this._opts;
        var text = this.items[itemIdx] || createLabel(fieldTxt, 'label');
        text.worldPos.copy(itemPos);
        text.style.textAlign = opts.horizontalAlign;
        text.style.verticalAlign = opts.verticalAlign;
        this.items[itemIdx] = text;
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, fColor, bColor) {
        var text = this.items[itemIdx];
        text.opts = {
          color: fColor,
          background: bColor
        };
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.needsUpdate = true;
        this.dispatchEvent({
          type: 'update'
        });
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
      } // unimplemented functions

    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "setOpacity",
      value: function setOpacity() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return LabelsGeometry;
  }(EventDispatcher);

  var geometries = {
    InstancedSpheresGeometry: InstancedSpheresGeometry,
    SimpleSpheresGeometry: SimpleSpheresGeometry,
    Simple2CCylindersGeometry: Simple2CCylindersGeometry,
    Instanced2CCylindersGeometry: Instanced2CCylindersGeometry,
    ExtrudedObjectsGeometry: ExtrudedObjectsGeometry,
    ChunkedLinesGeometry: ChunkedLinesGeometry,
    TwoColorLinesGeometry: TwoColorLinesGeometry,
    CrossGeometry: CrossGeometry,
    QuickSurfGeometry: QuickSurfGeometry,
    ContactSurfaceGeometry: ContactSurfaceGeometry,
    SSIsosurfaceGeometry: SSIsosurfaceGeometry,
    LabelsGeometry: LabelsGeometry
  };

  var vertexShader = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\n\nattribute vec3 normal;\n\n#ifdef NORMALS_TO_G_BUFFER\n  varying vec3 viewNormal;\n#endif\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  varying vec3 vNormal;\n#endif\n\n#ifdef THICK_LINE\n  attribute vec4 position; // W contains vert pos or neg offset\n#else\n  attribute vec3 position;\n#endif\n\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;\n\n#ifdef ATTR_ALPHA_COLOR\n  attribute float alphaColor;\n  varying float alphaCol;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  attribute vec3 color;\n  varying vec3 vColor;\n#endif\n\n#ifdef ATTR_COLOR2\n  attribute vec3 color2;\n  varying vec3 vColor2;\n  attribute vec2 uv;\n  #ifndef CYLINDER_SPRITE\n    varying vec2 vUv;\n  #endif\n#endif\n\n#ifdef INSTANCED_POS\n  attribute vec4 offset;\n  #ifdef SPHERE_SPRITE\n    varying vec4 instOffset;\n  varying vec4 spritePosEye;\n  #endif\n#endif\n\n#ifdef INSTANCED_MATRIX\n  attribute vec4 matVector1;\n  attribute vec4 matVector2;\n  attribute vec4 matVector3;\n  attribute vec4 invmatVector1;\n  attribute vec4 invmatVector2;\n  attribute vec4 invmatVector3;\n\n  #ifdef CYLINDER_SPRITE\n    varying vec4 matVec1;\n    varying vec4 matVec2;\n    varying vec4 matVec3;\n    varying vec4 invmatVec1;\n    varying vec4 invmatVec2;\n    varying vec4 invmatVec3;\n    varying vec4 spritePosEye;\n  #endif\n#endif\n\nuniform mat4 modelViewMatrix; // optional\nuniform mat4 projectionMatrix; // optional\nuniform mat3 normalMatrix; // optional\nuniform mat4 modelMatrix; // optional\n\n#ifdef DASHED_LINE\n  attribute float lineDistance;\n  varying float vLineDistance;\n#endif\n\n#ifdef THICK_LINE\n  attribute vec3 direction;\n  uniform mat4 projMatrixInv;\n  uniform vec2 viewport;\n  uniform float lineWidth;\n\n  vec4 transform(vec4 coord){\n    return projectionMatrix * modelViewMatrix * coord;\n  }\n\n  vec2 project(vec4 device){\n    vec3 device_normal = device.xyz/device.w;\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\n    return clip_pos * viewport;\n  }\n\n  vec4 unproject(vec2 screen, float z, float w){\n    vec2 clip_pos = screen/viewport;\n    vec2 device_normal = clip_pos*2.0-1.0;\n    return vec4(device_normal*w, z, w);\n  }\n#endif\n\n\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\nvoid main() {\n\n#ifdef ATTR_ALPHA_COLOR\n  alphaCol = alphaColor;\n#endif\n\n#ifdef INSTANCED_MATRIX\n  vec3 objectNormal = vec3(\n    dot(normal, matVector1.xyz),\n    dot(normal, matVector2.xyz),\n    dot(normal, matVector3.xyz));\n#else\n  vec3 objectNormal = vec3( normal );\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  vNormal = normalize(transformedNormal);\n#endif\n\n#ifdef NORMALS_TO_G_BUFFER\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\n#endif\n\n  vec4 localPos = vec4(position.xyz, 1.0);\n  vec4 worldPos = modelMatrix * localPos;\n  vec4 mvPosition = modelViewMatrix * localPos;\n\n// make thick line offset\n#ifdef THICK_LINE\n   // get screen pos\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\n   vec2 sPos = project(dPos);\n   // move pos forward\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\n   // get screen offset pos\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\n   vec2 sPos2 = project(dPos2);\n   // screen line direction\n   vec2 sDir = normalize(sPos2 - sPos);\n   // vertex offset (orthogonal to line direction)\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\n   // move screen vertex\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\n   // get moved pos in view space\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\n#endif // THICK_LINE\n\n#ifdef INSTANCED_POS\n  #ifdef SPHERE_SPRITE\n    instOffset = offset;\n\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\n    float scale = length(modelViewMatrix[0]);\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\n    posEye.w = offset.w * scale;\n\n    spritePosEye = posEye;\n #else\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\n    worldPos = modelMatrix * localPos;\n    mvPosition = modelViewMatrix * localPos;\n  #endif\n#endif\n\n#ifdef INSTANCED_MATRIX\n  #ifdef CYLINDER_SPRITE\n    matVec1 = matVector1;\n    matVec2 = matVector2;\n    matVec3 = matVector3;\n    invmatVec1 = invmatVector1;\n    invmatVec2 = invmatVector2;\n    invmatVec3 = invmatVector3;\n\n    // calculate eye coords of cylinder endpoints\n    vec4 v = vec4(0, -0.5, 0, 1);\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\n    v.y = 0.5;\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\n\n    // sprite is placed at the center of cylinder\n    vec4 posEye;\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\n    posEye.w = 1.0;\n    spritePosEye = posEye;\n\n    // cylinder radius in eye space\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\n    vec2 spriteSize;\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // In ortho projection we skip z coordinate\n      // basic sprite size at screen plane (covers only cylinder axis)\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\n\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\n    #else\n      // basic sprite size at screen plane (covers only cylinder axis)\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\n\n      // full sprite size in eye coords\n      float minZ = min(abs(p1.z), abs(p2.z));\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\n    #endif\n\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\n  #else\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\n    worldPos = modelMatrix * localPos;\n    mvPosition = modelViewMatrix * localPos;\n  #endif\n#endif\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  vWorldPosition = worldPos.xyz;\n  vViewPosition = - mvPosition.xyz;\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t  vec4 worldPosition;\n\t  // see THREE.WebGLProgram.unrollLoops\n\t  #pragma unroll_loop_start\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\n\t  }\n\t  #pragma unroll_loop_end\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  vColor = color.xyz;\n#endif\n\n#ifdef ATTR_COLOR2\n  vColor2 = color2;\n  #ifndef CYLINDER_SPRITE\n    vUv = uv;\n  #endif\n#endif\n\n#ifdef DASHED_LINE\n  vLineDistance = lineDistance;\n#endif\n}\n";

  var fragmentShader = "#if defined (NORMALS_TO_G_BUFFER)\n  #define fragColor gl_FragData[0]\n#else\n  #define fragColor gl_FragColor\n#endif\n\n#ifdef ATTR_ALPHA_COLOR\n  varying float alphaCol;\n#endif\n\n#ifdef COLOR_FROM_POS\n  uniform mat4 world2colorMatrix;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\n\n    #ifdef SHADOWMAP_PCF_RAND\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\n      // unroll_loop and unroll_loop has pattern:\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\n      uniform sampler2D noiseTex;\n      uniform vec2 noiseTexelSize;\n      uniform vec2 srcTexelSize;\n      uniform mat4 projectionMatrix;\n    #endif\n\t#endif\n#endif\n\n#ifdef ATTR_COLOR\n  varying vec3 vColor;\n#endif\n\n#ifdef ATTR_COLOR2\n  varying vec3 vColor2;\n  #ifndef CYLINDER_SPRITE\n    varying vec2 vUv;\n  #endif\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform vec3 fixedColor;\nuniform float opacity;\nuniform float zClipValue;\nuniform float clipPlaneValue;\n\n#ifdef NORMALS_TO_G_BUFFER\n  varying vec3 viewNormal;\n#endif\n\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\n#ifdef USE_FOG\n  uniform vec3 fogColor;\n  uniform float fogAlpha;\n  uniform float fogNear;\n  uniform float fogFar;\n#endif\n\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\nvarying vec3 vViewPosition;\n\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n  varying vec3 vNormal;\n#endif\n\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\n  uniform float nearPlaneValue;\n#endif\n\n#ifdef SPHERE_SPRITE\n  varying vec4 spritePosEye;\n#endif\n\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n  uniform float zOffset;\n\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\n    uniform mat4 projectionMatrix;\n  #endif\n\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\n  }\n#endif\n\n#ifdef SPHERE_SPRITE\n  varying vec4 instOffset;\n  uniform mat4 modelMatrix;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 invModelViewMatrix;\n  uniform mat3 normalMatrix;\n\n\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\n\n    // intersect XZ-projected ray with circle\n    float a = dot(ray, ray);\n    float b = dot(ray, origin);\n    float c = dot(origin, origin) - 1.0;\n    float det = b * b - a * c;\n    if (det < 0.0) return false;\n    float t1 = (-b - sqrt(det)) / a;\n    float t2 = (-b + sqrt(det)) / a;\n\n    // calculate both intersection points\n    vec3 p1 = origin + ray * t1;\n    vec3 p2 = origin + ray * t2;\n\n    // choose nearest point inside frustum\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\n      // t1 is always smaller than t2 (from calculations)\n      point = p1;\n      frontFaced = 1.0;\n      return true;\n    #else\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\n      if (t1 >= 0.0) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (t2 >= 0.0) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #endif\n\n    return false;\n  }\n\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\n    vec3 origin, ray;\n\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // transform vector from sprite center to curPixel into sphere local coords\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\n\n      // transform camera orientation vector into sphere local coords\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n    #else\n      // find point of intersection near plane by the ray from camera to curPixel\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\n\n      // transform intersection point into sphere local coords\n      v = invModelViewMatrix * v;\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\n\n      // transform vector from camera pos to curPixel into sphere local coords\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\n    #endif\n    ray = normalize(ray);\n\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\n  }\n#endif\n\n#ifdef CYLINDER_SPRITE\n  varying vec4 matVec1;\n  varying vec4 matVec2;\n  varying vec4 matVec3;\n  varying vec4 invmatVec1;\n  varying vec4 invmatVec2;\n  varying vec4 invmatVec3;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 invModelViewMatrix;\n  uniform mat3 normalMatrix;\n\n  varying vec4 spritePosEye;\n\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\n\n    // intersect XZ-projected ray with circle\n    float a = dot(ray.xz, ray.xz);\n    float b = dot(ray.xz, origin.xz);\n    float c = dot(origin.xz, origin.xz) - 1.0;\n    float det = b * b - a * c;\n    if (det < 0.0) return false;\n    float t1 = (-b - sqrt(det)) / a;\n    float t2 = (-b + sqrt(det)) / a;\n\n    // calculate both intersection points\n    vec3 p1 = origin + ray * t1;\n    vec3 p2 = origin + ray * t2;\n\n    float halfHeight = 0.5;\n\n    // choose nearest point\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #else\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\n        point = p1;\n        frontFaced = 1.0;\n        return true;\n      }\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\n        point = p2;\n        frontFaced = -1.0;\n        return true;\n      }\n    #endif\n\n    return false;\n  }\n\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\n    vec3 origin, ray;\n    vec4 v;\n\n    #ifdef ORTHOGRAPHIC_CAMERA\n      // transform vector from sprite center to curPixel into cylinder local coords\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n\n      // transform camera orientation vector into cylinder local coords\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n    #else\n      // find point of intersection near plane by the ray from camera to curPixel\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\n\n      // transform intersection point into cylinder local coords\n      v = invModelViewMatrix * v;\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n\n      // transform vector from camera pos to curPixel into cylinder local coords\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\n    #endif\n    ray = normalize(ray);\n\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\n  }\n#endif\n\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n  vec4 r = vec4( fract( v * PackFactors ), v );\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n  return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n  return dot( v, UnpackFactors );\n}\n\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\n#ifdef TOON_SHADING\n  #define LOW_TOON_BORDER 0.0\n  #define MEDIUM_TOON_BORDER 0.7\n  #define HIGH_TOON_BORDER 1.0\n\n  #define MEDIUM_TOON_RANGE 0.5\n  #define HIGH_TOON_RANGE 0.95\n#endif\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\n  struct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n  };\n\n  struct BlinnPhongMaterial {\n    vec3  diffuseColor;\n    vec3  specularColor;\n    float specularShininess;\n  };\n\n  struct GeometricContext {\n    vec3 normal;\n    vec3 viewDir;\n  };\n\n  struct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n  };\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n  struct DirectionalLightShadow {\n     vec2 shadowMapSize;\n     float shadowBias;\n     float shadowRadius;\n   };\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\n\n  uniform vec3 ambientLightColor;\n\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\n\n  #if defined(SHADOWMAP)\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n  \t}\n\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\n   \t  float shadow = 0.0;\n\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\n      shadowCoord.xyz /= shadowCoord.w;\n\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n      bool inFrustum = all( inFrustumVec );\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n      bool frustumTest = all( frustumTestVec );\n\n      if ( frustumTest ) {\n        #ifdef SHADOWMAP_BASIC\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n      \t#endif\n\n      \t#ifdef SHADOWMAP_PCF_SHARP\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\n\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\n\n            shadow = (\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n            ) * ( 1.0 / 9.0 );\n        #endif\n\n        #ifdef SHADOWMAP_PCF_RAND\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\n\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\n\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\n\n          vec2 offset;\n          #pragma unroll_loop_start\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\n          }\n          #pragma unroll_loop_end\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\n        #endif\n      }\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\n   }\n  #endif\n\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\n\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  } // validated\n\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n    // Original approximation by Christophe Schlick '94\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\n  } // validated\n\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n    return 0.25;\n  }\n\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n  }\n\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\n\n    vec3 F = F_Schlick( specularColor, dotLH );\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n    float D = D_BlinnPhong( shininess, dotNH );\n\n    return F * ( G * D );\n  } // validated\n\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\n    #ifdef TOON_SHADING\n      if(dotNL < MEDIUM_TOON_RANGE){\n        dotNL = LOW_TOON_BORDER;\n      }\n      else if(dotNL < HIGH_TOON_RANGE){\n        dotNL = MEDIUM_TOON_BORDER;\n      }\n      else{\n        dotNL = HIGH_TOON_BORDER;\n      }\n    #endif\n\n    vec3 irradiance = dotNL * directLight.color * PI;\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\n  }\n\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n  }\n\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\n    vec3 irradiance = ambientLightColor * PI;\n\n    float shadowMask = 1.0;\n    // see THREE.WebGLProgram.unrollLoops\n  \t#pragma unroll_loop_start\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n  \t    #ifdef SHADOWMAP\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\n        #endif\n\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\n  \t\t}\n  \t\t#pragma unroll_loop_end\n\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\n\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\n  }\n#endif\n\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\n#ifdef DASHED_LINE\n  uniform float dashedLineSize;\n  uniform float dashedLinePeriod;\n  varying float vLineDistance;\n#endif\n\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\nvoid main() {\n\n#ifdef CLIP_PLANE\n  if (vViewPosition.z < clipPlaneValue) discard;\n#endif\n\n#ifdef ZCLIP\n  if (vViewPosition.z < zClipValue) discard;\n#endif\n\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\n  #if NUM_DIR_LIGHTS > 0\n    // see THREE.WebGLProgram.unrollLoops\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\n    }\n    #pragma unroll_loop_end\n  #endif\n#endif\n\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\n  vec4 pixelPosEye;\n\n#ifdef SPHERE_SPRITE\n\n  vec3 viewNormalSprites;\n  float frontFaced = 1.0;\n  vec3 normal;\n\n/* quick-and-dirty method\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\n  float r2 = dot(normal.xy, normal.xy);\n  if (r2 > 1.0) discard;\n  float normalZ = sqrt(1.0 - r2);\n  normal.z = normalZ;\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\n  pixelPosEye.z += spritePosEye.w * normalZ;\n*/\n\n  // ray-trace sphere surface\n  {\n    vec3 p;\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\n    pixelPosWorld = modelMatrix * v;\n    pixelPosEye = modelViewMatrix * v;\n    normal = normalize(normalMatrix * p);\n    #ifdef NORMALS_TO_G_BUFFER\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\n    #endif\n\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\n      #if NUM_DIR_LIGHTS > 0\n        // see THREE.WebGLProgram.unrollLoops\n        #pragma unroll_loop_start\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\n          }\n        #pragma unroll_loop_end\n      #endif\n    #endif\n  }\n#endif\n\n#ifdef CYLINDER_SPRITE\n  vec3 normal;\n  vec3 viewNormalSprites;\n  float frontFaced = 1.0;\n  float cylinderY = 0.0;\n\n  // ray-trace cylinder surface\n  {\n    vec3 p;\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\n\n    cylinderY = 0.5 * (p.y + 1.0);\n\n    vec4 v = vec4(p, 1.0);\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\n    pixelPosWorld = modelMatrix * v;\n    pixelPosEye = modelViewMatrix * v;\n\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\n    normal = vec3(\n      dot(localNormal, matVec1.xyz),\n      dot(localNormal, matVec2.xyz),\n      dot(localNormal, matVec3.xyz));\n    #ifdef NORMALS_TO_G_BUFFER\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\n    #endif\n\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\n      #if NUM_DIR_LIGHTS > 0\n        // see THREE.WebGLProgram.unrollLoops\n        #pragma unroll_loop_start\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\n          }\n        #pragma unroll_loop_end\n      #endif\n    #endif\n\n    normal = normalize(normalMatrix * normal);\n  }\n#endif\n\n  #ifdef ATTR_COLOR\n    vec3 vertexColor = vColor;\n  #else\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\n  #endif\n\n  #ifdef ATTR_COLOR2\n    #ifdef CYLINDER_SPRITE\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\n    #else\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\n    #endif\n      // choose either color or color2\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\n  #endif\n\n  // negative red component is a special condition\n  if (vertexColor.x < 0.0) discard;\n\n  #ifdef DASHED_LINE\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\n  #endif\n\n  // transparency prepass writes only z, so we don't need to calc the color\n  #ifdef PREPASS_TRANSP\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n    #endif\n    return;\n  #endif\n\n    float totalOpacity = opacity;\n\n  #ifdef ATTR_ALPHA_COLOR\n    totalOpacity *= alphaCol;\n  #endif\n\n  // discard fully transparent pixels\n  if (totalOpacity == 0.0) discard;\n\n  #ifdef FAKE_OPACITY\n    // discard pixels in checker pattern\n    vec2 dm_coord = floor(gl_FragCoord.xy);\n    dm_coord = fract(dm_coord * 0.5);\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\n    vec4 diffuseColor = vec4(diffuse, 1.0);\n  #else\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\n  #endif\n\n  float flipNormal;\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\n    flipNormal = 1.0;\n    #ifdef DOUBLE_SIDED\n      flipNormal = float( gl_FrontFacing );\n    #endif\n    vec3 normal = normalize( vNormal ) * flipNormal;\n  #endif\n\n    diffuseColor.rgb *= vertexColor;\n\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n  #endif\n\n  #ifdef NORMALS_TO_G_BUFFER\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\n      vec3 viewNormaInColor = viewNormalSprites;\n    #else\n      vec3 viewNormaInColor = viewNormal;\n      float frontFaced = float( gl_FrontFacing );\n    #endif\n    // [-1, 1] -> [0, 1]\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\n  #endif\n\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\n    vec3 viewDir;\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      viewDir = -pixelPosEye.xyz;\n    #else\n      viewDir = vViewPosition;\n    #endif\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\n  #else\n    vec3 outgoingLight = diffuseColor.rgb;\n  #endif\n\n  #ifdef COLOR_FROM_DEPTH\n    float depth = 0.0;\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\n      depth = gl_FragDepthEXT;\n    #else\n      depth = gl_FragCoord.z;\n    #endif\n    fragColor = packDepthToRGBA(depth);\n    return;\n  #endif\n\n  #ifdef COLOR_FROM_POS\n    fragColor = world2colorMatrix * pixelPosWorld;\n  #else\n    #ifdef OVERRIDE_COLOR\n      fragColor = vec4(fixedColor, diffuseColor.a);\n    #else\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\n    #endif\n\n    #ifdef USE_FOG\n      float viewDistance;\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\n        viewDistance = abs(pixelPosEye.z);\n      #else\n        viewDistance = vViewPosition.z;\n      #endif\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\n      #ifdef FOG_TRANSPARENT\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\n      #else\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\n      #endif\n    #endif\n\n  #endif\n}\n";

  var capabilities = {
    precision: 'mediump',

    /**
     *
     * @param {THREE.WebGLRenderer} renderer
     */
    init: function init(renderer) {
      this.precision = renderer.capabilities.getMaxPrecision('highp');
    }
  };

  var noiseWidth = 4;
  var noiseHeight = 4;

  var _noiseData = new Uint8Array([24, 52, 0, 254, 145, 0, 122, 0, 0, 7, 170, 0, 34, 214, 0, 173, 8, 0, 86, 249, 0, 160, 4, 0, 226, 46, 0, 224, 211, 0, 3, 157, 0, 174, 247, 0, 12, 182, 0, 220, 216, 0, 1, 109, 0, 253, 154, 0]);

  var _noiseWrapS = THREE.RepeatWrapping;
  var _noiseWrapT = THREE.RepeatWrapping;
  var _noiseMinFilter = THREE.NearestFilter;
  var _noiseMagFilter = THREE.NearestFilter;
  var _noiseMapping = THREE.UVMapping;
  var noiseTexture = new THREE.DataTexture(_noiseData, noiseWidth, noiseHeight, THREE.RGBFormat, THREE.UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
  noiseTexture.needsUpdate = true;
  var noise = {
    noiseWidth: noiseWidth,
    noiseHeight: noiseHeight,
    noiseTexture: noiseTexture
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  // If you want to change length of _samplesKernel, please, remember change it in Uber.frag too.
  // You can easy find places for replace using word:_samplesKernel

  var _samplesKernel = [new THREE.Vector2(-0.541978, 0.840393), new THREE.Vector2(0.125533, -0.992089), new THREE.Vector2(0.374329, 0.927296), new THREE.Vector2(-0.105475, 0.994422)];
  var defaultUniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
    // are updated automatically by three.js (see THREE.ShaderLib.common)
    diffuse: {
      value: new THREE.Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    specular: {
      type: 'c',
      value: new THREE.Color(0x111111)
    },
    shininess: {
      type: 'f',
      value: 30
    },
    fixedColor: {
      type: 'c',
      value: new THREE.Color(0xffffff)
    },
    zOffset: {
      type: 'f',
      value: 0.0
    },
    zClipValue: {
      type: 'f',
      value: 0.0
    },
    clipPlaneValue: {
      type: 'f',
      value: 0.0
    },
    nearPlaneValue: {
      type: 'f',
      value: -0.5
    },
    invModelViewMatrix: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    world2colorMatrix: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    dashedLineSize: {
      type: 'f',
      value: 0.1
    },
    dashedLinePeriod: {
      type: 'f',
      value: 0.2
    },
    projMatrixInv: {
      type: '4fv',
      value: new THREE.Matrix4()
    },
    viewport: {
      type: 'v2',
      value: new THREE.Vector2()
    },
    lineWidth: {
      type: 'f',
      value: 2.0
    },
    // default value must be the same as settings
    fogAlpha: {
      type: 'f',
      value: 1.0
    },
    samplesKernel: {
      type: 'v2v',
      value: null
    },
    noiseTex: {
      type: 't',
      value: null
    },
    noiseTexelSize: {
      type: 'v2',
      value: null
    },
    srcTexelSize: {
      type: 'v2',
      value: null
    }
  }]);
  var uberOptionNames = ['shininess', 'opacity', 'zOffset', 'diffuse', 'specular', 'fixedColor', 'zClipCoef', 'zClipValue', 'clipPlaneValue', 'world2colorMatrix', 'dashedLineSize', 'dashedLinePeriod', 'projMatrixInv', 'viewport', 'lineWidth', 'fogAlpha', 'samplesKernel', 'noiseTex', 'noiseTexelSize', 'srcTexelSize'];

  function UberMaterial(params) {
    THREE.RawShaderMaterial.call(this); // add fog

    this.fog = true; // used for instanced geometry

    this.instancedPos = false;
    this.instancedMatrix = false; // atoms and links color

    this.attrColor = false; // second link color for cylinders

    this.attrColor2 = false; //

    this.attrAlphaColor = false; // overrides color for all vertices (used in selection)

    this.overrideColor = false; // zsrpites

    this.sphereSprite = false;
    this.cylinderSprite = false; // clip Surfs individually

    this.zClip = false; // clip scene with global clip plane

    this.clipPlane = false; // enable fake (chess-like) opacity

    this.fakeOpacity = false; // render only depth, don't take care about the pixel color (used for transparency depth prepass)

    this.prepassTransparancy = false; // used to render pixel positions

    this.colorFromPos = false; // used to render shadowmap

    this.shadowmap = false; // used to describe shadowmap type

    this.shadowmapType = 'random'; // used to render pixel view deph

    this.colorFromDepth = false; // mark that rendering is for orthographic camera

    this.orthoCam = false; // used to render dashed line

    this.dashedLine = false; // mark as transparent

    this.transparent = true; // mark as thick lines

    this.thickLine = false; // makes fog begin transparency (required for transparent background)

    this.fogTransparent = false; // used to render surface normals to G buffer for ssao effect

    this.normalsToGBuffer = false; // used for toon material

    this.toonShading = false; // uber options of "root" materials are inherited from single uber-options object that resides in prototype

    this.uberOptions = Object.create(UberMaterial.prototype.uberOptions); // set default values

    THREE.RawShaderMaterial.prototype.setValues.call(this, {
      uniforms: THREE.UniformsUtils.clone(defaultUniforms),
      vertexShader: this.precisionString() + vertexShader,
      fragmentShader: this.precisionString() + fragmentShader,
      lights: true,
      fog: true,
      side: THREE.DoubleSide
    });
    this.setValues(params);
  }

  UberMaterial.prototype = Object.create(THREE.RawShaderMaterial.prototype);
  UberMaterial.prototype.constructor = UberMaterial;

  UberMaterial.prototype.precisionString = function () {
    var precision = capabilities.precision;
    var str = "precision ".concat(precision, " float;\n") + "precision ".concat(precision, " int;\n\n");
    return str;
  }; // properties that convert to uniforms


  UberMaterial.prototype.uberOptions = {
    diffuse: new THREE.Color(0xffffff),
    // used in phong lighting
    specular: new THREE.Color(0x111111),
    // used in phong lighting
    shininess: 30,
    // used in phong lighting
    opacity: 1,
    // set mesh opacity
    fixedColor: new THREE.Color(0xffffff),
    // color to override (see OVERRIDE_COLOR)
    zOffset: 0.0,
    // used fo zsprites (see SPHERE_SPRITE CYLINDER_SPRITE)
    zClipCoef: 2.0,
    // use for Surfs clipping (mesh param, isn't used in shader)  FIXME move to representation param
    zClipValue: 0.0,
    //  value to clip Surfs in shader  (see ZCLIP)
    clipPlaneValue: 0.0,
    // value to clip scene globally (see CLIPPLANE)
    world2colorMatrix: new THREE.Matrix4(),
    dashedLineSize: 0.1,
    dashedLinePeriod: 0.3,
    projMatrixInv: new THREE.Matrix4(),
    viewport: new THREE.Vector2(800, 600),
    lineWidth: 2.0,
    fogAlpha: 1.0,
    samplesKernel: _samplesKernel,
    noiseTex: noise.noiseTexture,
    noiseTexelSize: new THREE.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight),
    srcTexelSize: new THREE.Vector2(1.0 / 800.0, 1.0 / 600.0),
    copy: function copy(source) {
      this.diffuse.copy(source.diffuse);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.opacity = source.opacity;
      this.fixedColor.copy(source.fixedColor);
      this.zOffset = source.zOffset;
      this.zClipCoef = source.zClipCoef;
      this.zClipValue = source.zClipValue;
      this.clipPlaneValue = source.clipPlaneValue;
      this.world2colorMatrix.copy(source.world2colorMatrix);
      this.dashedLineSize = source.dashedLineSize;
      this.dashedLinePeriod = source.dashedLinePeriod;
      this.projMatrixInv = source.projMatrixInv;
      this.viewport = source.viewport;
      this.lineWidth = source.lineWidth; // used for thick lines only

      this.toonShading = source.toonShading;
      this.fogAlpha = source.fogAlpha;
      this.samplesKernel = source.samplesKernel;
      this.noiseTex = source.noiseTex;
      this.noiseTexelSize = source.noiseTexelSize;
      this.srcTexelSize = source.srcTexelSize;
    }
  };

  UberMaterial.prototype.copy = function (source) {
    THREE.RawShaderMaterial.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
    this.defines = _objectSpread({}, source.defines);
    this.extensions = source.extensions;
    this.fog = source.fog;
    this.instancedPos = source.instancedPos;
    this.instancedMatrix = source.instancedMatrix;
    this.attrColor = source.attrColor;
    this.attrColor2 = source.attrColor2;
    this.attrAlphaColor = source.attrAlphaColor;
    this.overrideColor = source.overrideColor;
    this.sphereSprite = source.sphereSprite;
    this.cylinderSprite = source.cylinderSprite;
    this.zClip = source.zClip;
    this.clipPlane = source.clipPlane;
    this.fakeOpacity = source.fakeOpacity;
    this.colorFromPos = source.colorFromPos;
    this.shadowmap = source.shadowmap;
    this.shadowmapType = source.shadowmapType;
    this.colorFromDepth = source.colorFromDepth;
    this.orthoCam = source.orthoCam;
    this.prepassTransparancy = source.prepassTransparancy;
    this.dashedLine = source.dashedLine;
    this.thickLine = source.thickLine;
    this.fogTransparent = source.fogTransparent;
    this.normalsToGBuffer = source.normalsToGBuffer;
    this.toonShading = source.toonShading;
    this.uberOptions.copy(source.uberOptions);
    return this;
  }; // create copy of this material
  // its options are prototyped after this material's options


  UberMaterial.prototype.createInstance = function () {
    var inst = new UberMaterial();
    inst.copy(this);
    inst.uberOptions = Object.create(this.uberOptions);
    return inst;
  };

  UberMaterial.prototype.setValues = function (values) {
    if (typeof values === 'undefined') {
      return;
    } // set direct values


    THREE.RawShaderMaterial.prototype.setValues.call(this, values);
    var defines = {};
    var extensions = {};

    if (this.fog) {
      defines.USE_FOG = 1;
    }

    if (this.instancedPos) {
      defines.INSTANCED_POS = 1;
    }

    if (this.instancedMatrix) {
      defines.INSTANCED_MATRIX = 1;
    }

    if (this.attrColor) {
      defines.ATTR_COLOR = 1;
    }

    if (this.attrColor2) {
      defines.ATTR_COLOR2 = 1;
    }

    if (this.attrAlphaColor) {
      defines.ATTR_ALPHA_COLOR = 1;
    }

    if (this.overrideColor) {
      defines.OVERRIDE_COLOR = 1;
    }

    if (this.sphereSprite) {
      defines.SPHERE_SPRITE = 1;
      extensions.fragDepth = 1;
    }

    if (this.cylinderSprite) {
      defines.CYLINDER_SPRITE = 1;
      extensions.fragDepth = 1;
    }

    if (this.zClip) {
      defines.ZCLIP = 1;
    }

    if (this.clipPlane) {
      defines.CLIP_PLANE = 1;
    }

    if (this.fakeOpacity) {
      defines.FAKE_OPACITY = 1;
    }

    if (this.lights) {
      defines.USE_LIGHTS = 1;
    }

    if (this.colorFromPos) {
      defines.COLOR_FROM_POS = 1;
    }

    if (this.shadowmap) {
      defines.SHADOWMAP = 1;

      if (this.shadowmapType === 'pcf') {
        defines.SHADOWMAP_PCF_SHARP = 1;
      } else if (this.shadowmapType === 'random') {
        defines.SHADOWMAP_PCF_RAND = 1;
      } else {
        defines.SHADOWMAP_BASIC = 1;
      }
    }

    if (this.colorFromDepth) {
      defines.COLOR_FROM_DEPTH = 1;
    }

    if (this.orthoCam) {
      defines.ORTHOGRAPHIC_CAMERA = 1;
    }

    if (this.prepassTransparancy) {
      defines.PREPASS_TRANSP = 1;
    }

    if (this.dashedLine) {
      defines.DASHED_LINE = 1;
    }

    if (this.thickLine) {
      defines.THICK_LINE = 1;
    }

    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }

    if (this.normalsToGBuffer) {
      extensions.drawBuffers = 1;
      defines.NORMALS_TO_G_BUFFER = 1;
    }

    if (this.toonShading) {
      defines.TOON_SHADING = 1;
    } // set dependent values


    this.defines = defines;
    this.extensions = extensions;
  };

  UberMaterial.prototype.setUberOptions = function (values) {
    if (typeof values === 'undefined') {
      return;
    }

    for (var key in values) {
      if (!values.hasOwnProperty(key)) {
        continue;
      }

      if (this.uberOptions[key] instanceof THREE.Color) {
        this.uberOptions[key] = values[key].clone();
      } else {
        this.uberOptions[key] = values[key];
      }
    }
  };

  UberMaterial.prototype.clone = function (shallow) {
    if (!shallow) {
      return THREE.Material.prototype.clone.call(this);
    }

    return this.createInstance();
  };

  UberMaterial.prototype.updateUniforms = function () {
    var self = this;
    uberOptionNames.forEach(function (p) {
      if (self.uniforms.hasOwnProperty(p)) {
        if (self.uberOptions[p] instanceof THREE.Color || self.uberOptions[p] instanceof THREE.Matrix4) {
          self.uniforms[p].value = self.uberOptions[p].clone();
        } else {
          self.uniforms[p].value = self.uberOptions[p];
        }
      }
    });
  };

  function _createSuper$y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  function UberObject (SuperClass) {
    var NewObjectType = /*#__PURE__*/function (_SuperClass) {
      inherits(NewObjectType, _SuperClass);

      var _super = _createSuper$y(NewObjectType);

      function NewObjectType() {
        var _this;

        classCallCheck(this, NewObjectType);

        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(rest));
        _this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
        return _this;
      }

      createClass(NewObjectType, [{
        key: "onBeforeRender",
        value: function onBeforeRender(renderer, scene, camera, geometry, material, group) {
          this._onBeforeRender(renderer, scene, camera, geometry, material, group);

          this._update();
        }
      }, {
        key: "_onBeforeRender",
        value: function _onBeforeRender() {}
      }, {
        key: "_update",
        value: function _update() {
          var material = this.material;

          if (!material) {
            return;
          }

          if (material instanceof UberMaterial) {
            material.updateUniforms();
          }
        }
      }]);

      return NewObjectType;
    }(SuperClass);

    return NewObjectType;
  }

  function _createSuper$z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$A(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh = UberObject(THREE.Mesh);

  var ZSpriteMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ZSpriteMesh, _Mesh);

    var _super = _createSuper$z(ZSpriteMesh);

    function ZSpriteMesh() {
      var _this;

      classCallCheck(this, ZSpriteMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    createClass(ZSpriteMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        Mesh.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var material = this.material;

        if (!material) {
          return;
        }

        if (material.uniforms.invModelViewMatrix) {
          // NOTE: update of modelViewMatrix inside threejs is done after onBeforeRender call,
          // so we have to do it manually in that place
          this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld); // get inverse matrix

          material.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
          material.uniforms.nearPlaneValue.value = camera.near;
          material.uniformsNeedUpdate = true;
        }
      }
    }]);

    return ZSpriteMesh;
  }(Mesh);

  function _createSuper$A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$B(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$1 = UberObject(THREE.Mesh);

  var ZClippedMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ZClippedMesh, _Mesh);

    var _super = _createSuper$A(ZClippedMesh);

    function ZClippedMesh(geometry, material) {
      var _this;

      classCallCheck(this, ZClippedMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    createClass(ZClippedMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera) {
        Mesh$1.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var geo = this.geometry;
        var material = this.material;

        if (!geo.zClip || !material.uberOptions) {
          return;
        }

        var zClipCoef = 0.5;
        var modelView = ZClippedMesh._modelView;
        var mvLength = ZClippedMesh._mvLength;
        var center = ZClippedMesh._center;
        modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
        var s = mvLength.setFromMatrixColumn(modelView, 0).length();
        center.copy(geo.boundingSphere.center);
        this.localToWorld(center);
        material.uberOptions.zClipValue = camera.position.z - center.z - s * (zClipCoef * geo.boundingSphere.radius);
      }
    }]);

    return ZClippedMesh;
  }(Mesh$1);

  defineProperty(ZClippedMesh, "_mvLength", new THREE.Vector3());

  defineProperty(ZClippedMesh, "_center", new THREE.Vector3());

  defineProperty(ZClippedMesh, "_modelView", new THREE.Matrix4());

  function _createSuper$B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$C(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TextMesh = /*#__PURE__*/function (_THREE$Group) {
    inherits(TextMesh, _THREE$Group);

    var _super = _createSuper$B(TextMesh);

    function TextMesh(geometry, _material) {
      var _this;

      classCallCheck(this, TextMesh);

      _this = _super.call(this);
      _this.geometry = geometry;

      var self = assertThisInitialized(_this);

      self.initialized = false;

      _this.geometry.addEventListener('update', function () {
        self.update();
      });

      return _this;
    }

    createClass(TextMesh, [{
      key: "init",
      value: function init() {
        var children = this.children;

        for (var i = children.length - 1; i >= 0; --i) {
          this.remove(children[i]);
        }

        var _this$geometry = this.geometry,
            items = _this$geometry.items,
            userData = _this$geometry.userData;

        for (var _i = 0, n = items.length; _i < n; ++_i) {
          var srcItem = items[_i];

          if (!srcItem) {
            continue;
          }

          var item = utils.shallowCloneNode(srcItem);
          var label = new CSS2DObject(item);
          label.userData = ___default['default'].clone(userData);
          var el = label.getElement();
          el.style.visibility = 'visible';
          label.source = srcItem;
          this.add(label);
        }

        this.initialized = true;
      }
    }, {
      key: "update",
      value: function update() {
        var geo = this.geometry;

        if (!geo.needsUpdate) {
          return;
        }

        var children = this.children;

        if (!this.initialized) {
          this.init();
        }

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];
          var item = child.source;
          child.position.copy(item.worldPos);
          child.userData.color = item.opts.color;
          child.userData.background = item.opts.background;
        }
      }
    }]);

    return TextMesh;
  }(THREE.Group);

  function _createSuper$C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$D(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$2 = UberObject(THREE.Mesh);

  var SimpleMesh = /*#__PURE__*/function (_Mesh) {
    inherits(SimpleMesh, _Mesh);

    var _super = _createSuper$C(SimpleMesh);

    function SimpleMesh(geometry, material) {
      var _this;

      classCallCheck(this, SimpleMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return SimpleMesh;
  }(Mesh$2);

  function _createSuper$D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$E(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$3 = UberObject(THREE.Mesh);

  var _viewport = new THREE.Vector2();

  var ThickLineMesh = /*#__PURE__*/function (_Mesh) {
    inherits(ThickLineMesh, _Mesh);

    var _super = _createSuper$D(ThickLineMesh);

    function ThickLineMesh() {
      classCallCheck(this, ThickLineMesh);

      return _super.apply(this, arguments);
    }

    createClass(ThickLineMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!material.uberOptions) {
          return;
        }

        material.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
        renderer.getSize(_viewport);
        material.uberOptions.viewport.set(_viewport.width, _viewport.height);
      }
    }]);

    return ThickLineMesh;
  }(Mesh$3);

  function _createSuper$E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$F(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$4 = UberObject(THREE.Mesh);

  var InstancedMesh = /*#__PURE__*/function (_Mesh) {
    inherits(InstancedMesh, _Mesh);

    var _super = _createSuper$E(InstancedMesh);

    function InstancedMesh() {
      var _this;

      classCallCheck(this, InstancedMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return InstancedMesh;
  }(Mesh$4);

  var meshes = {
    ZClipped: ZClippedMesh,
    ZSprite: ZSpriteMesh,
    Text: TextMesh,
    Line: UberObject(THREE.Line),
    LineSegments: UberObject(THREE.LineSegments),
    Mesh: SimpleMesh,
    ThickLineMesh: ThickLineMesh,
    Instanced: InstancedMesh
  };

  function setMatParams(params, uniforms) {
    return function (material) {
      material.setValues(params);
      material.setUberOptions(uniforms);
    };
  }

  function _createInstancedCylinders(useZSprites, openEnded) {
    return {
      Geometry: function Geometry(a, b) {
        return new geometries.Instanced2CCylindersGeometry(a, b, useZSprites, openEnded);
      },
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedMatrix: true,
        attrColor: true,
        attrColor2: true,
        attrAlphaColor: true,
        cylinderSprite: useZSprites
      })
    };
  }

  function _createLineSegmentsGeoTriplet(geo, renderParams) {
    var thickLines = geo.prototype instanceof ThickLinesGeometry;
    var lineWidth = renderParams.lineWidth || 0;
    return {
      Geometry: geo,
      Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
      initMaterial: setMatParams({
        lights: false,
        attrColor: true,
        attrAlphaColor: true,
        thickLine: thickLines
      }, {
        lineWidth: lineWidth
      })
    };
  }

  function _createSimpleGeoTriplet(geoClass) {
    return {
      Geometry: geoClass,
      Object: meshes.Mesh,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: true
      })
    };
  }

  function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
    var surfaceOpts = {
      wireframe: !!renderParams.wireframe,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity,
      zClip: renderParams.zClip
    };
    return {
      Geometry: geoClass,
      Object: meshes.ZClipped,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: false,
        wireframe: surfaceOpts.wireframe,
        fakeOpacity: surfaceOpts.fakeOpacity,
        zClip: surfaceOpts.zClip
      })
    };
  }

  var MeshCreator = /*#__PURE__*/function () {
    function MeshCreator() {
      classCallCheck(this, MeshCreator);
    }

    createClass(MeshCreator, null, [{
      key: "createSpheres",
      value: function createSpheres(caps, settings) {
        var useZSprites = settings.now.zSprites;
        return {
          Geometry: function Geometry(a, b) {
            return new geometries.InstancedSpheresGeometry(a, b, useZSprites);
          },
          Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
          initMaterial: setMatParams({
            instancedPos: true,
            attrColor: true,
            attrAlphaColor: true,
            sphereSprite: useZSprites
          })
        };
      }
    }, {
      key: "create2CClosedCylinders",
      value: function create2CClosedCylinders(_caps, _settings) {
        return _createInstancedCylinders(false, false);
      }
    }, {
      key: "create2CCylinders",
      value: function create2CCylinders(caps, settings) {
        return _createInstancedCylinders(settings.now.zSprites, true);
      }
    }, {
      key: "create2CLines",
      value: function create2CLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
      }
    }, {
      key: "createCrosses",
      value: function createCrosses(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
      }
    }, {
      key: "createExtrudedChains",
      value: function createExtrudedChains(_caps, _settings) {
        return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
      }
    }, {
      key: "createChunkedLines",
      value: function createChunkedLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
      }
    }, {
      key: "createQuickSurface",
      value: function createQuickSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createContactSurface",
      value: function createContactSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createSASSES",
      value: function createSASSES(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createLabels",
      value: function createLabels(_caps, _settings) {
        return {
          Geometry: geometries.LabelsGeometry,
          Object: meshes.Text,
          initMaterial: function initMaterial() {}
        };
      }
    }]);

    return MeshCreator;
  }();

  function _createSuper$F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$G(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TransformGroup = /*#__PURE__*/function (_THREE$Object3D) {
    inherits(TransformGroup, _THREE$Object3D);

    var _super = _createSuper$F(TransformGroup);

    function TransformGroup(geometry, geoParams, material, transforms) {
      var _this;

      classCallCheck(this, TransformGroup);

      _this = _super.call(this);
      _this._geometry = geometry;
      _this._geoParams = geoParams;
      var mat = material.createInstance();
      geoParams.initMaterial(mat);
      _this._material = mat;
      _this._transforms = transforms.length > 0 ? transforms : [new THREE.Matrix4()];

      var meshes = _this._createMeshes(geometry);

      for (var i = 0, n = meshes.length; i < n; ++i) {
        _this.add(meshes[i]);
      }

      return _this;
    }

    createClass(TransformGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var ray = TransformGroup._ray;
        var inverseMatrix = TransformGroup._inverseMatrix;
        var children = this.children;
        ray.copy(raycaster.ray);

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];

          if (!gfxutils.belongToSelectLayers(child)) {
            continue;
          }

          child.updateMatrixWorld();
          var mtx = child.matrixWorld;
          inverseMatrix.copy(mtx).invert();
          raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
          var childIntersects = [];

          this._geometry.raycast(raycaster, childIntersects);

          for (var j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
            var inters = childIntersects[j];

            if (inters.point) {
              inters.point.applyMatrix4(mtx);
              inters.distance = ray.origin.distanceTo(inters.point);
            }

            inters.object = child;
            intersects[intersects.length] = inters;
          }
        }

        raycaster.ray.copy(ray);
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var geos = this._geometry.getSubset(chunkIndices);

        var subset = [];
        var subIdx = 0;

        for (var i = 0, n = geos.length; i < n; ++i) {
          var _meshes = this._createMeshes(geos[i]);

          for (var j = 0, meshCnt = _meshes.length; j < meshCnt; ++j) {
            subset[subIdx++] = _meshes[j];
          }
        }

        return subset;
      }
    }, {
      key: "_createMeshes",
      value: function _createMeshes(geometry) {
        var transforms = this._transforms;
        var Mesh = this._geoParams.Object;
        var material = this._material;
        var meshes = [];

        for (var i = 0, n = transforms.length; i < n; ++i) {
          var mesh = new Mesh(geometry, material);
          mesh.applyMatrix4(transforms[i]);
          meshes[i] = mesh;
        }

        return meshes;
      }
    }]);

    return TransformGroup;
  }(THREE.Object3D);

  defineProperty(TransformGroup, "_inverseMatrix", new THREE.Matrix4());

  defineProperty(TransformGroup, "_ray", new THREE.Ray());

  function _createSuper$G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$H(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function wrapper(Name, args) {
    var params = [Name].concat(args);
    return Name.bind.apply(Name, toConsumableArray(params));
  }

  var ChemGroup = /*#__PURE__*/function (_RCGroup) {
    inherits(ChemGroup, _RCGroup);

    var _super = _createSuper$G(ChemGroup);

    function ChemGroup(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
      var _this;

      classCallCheck(this, ChemGroup);

      _this = _super.call(this);

      if (_this.constructor === ChemGroup) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._selection = selection;
      _this._mode = mode;
      _this._colorer = colorer;
      _this._chunksIdc = selection.chunks;
      _this._polyComplexity = polyComplexity;
      _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))();
      _this._mesh = new TransformGroup(_this._geo, geoParams, material, transforms);

      _this.add(_this._mesh);

      _this._build();

      return _this;
    }

    createClass(ChemGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        throw new Error('ChemGroup subclass must override _makeGeoArgs() method');
      }
      /**
       * Builds subset geometry by ATOMS index list
       *
       * @param {Number} mask - Representation mask
       * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
       * @returns {Array} Subset geometry
       */

    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : false;

        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return [];
        }

        return this._mesh.getSubset(chunksList);
      }
    }, {
      key: "_changeSubsetOpacity",
      value: function _changeSubsetOpacity(mask, value, innerOnly) {
        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return;
        }

        this._geo.setOpacity(chunksList, value);
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 1.0, innerOnly);
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 0.0, innerOnly);
      }
    }]);

    return ChemGroup;
  }(RCGroup);

  function _createSuper$H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$I(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(AtomsGroup, _ChemGroup);

    var _super = _createSuper$H(AtomsGroup);

    function AtomsGroup() {
      classCallCheck(this, AtomsGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var atoms = this._selection.atoms;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var atomsIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var atomIdx = atomsIdc[inters[i].chunkIdx];

          if (atomIdx < atoms.length) {
            inters[i].atom = atoms[atomIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var atoms = this._selection.atoms;
        var atomsIdc = this._chunksIdc;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];

          if ((atom.mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return AtomsGroup;
  }(ChemGroup);

  function _createSuper$I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$J(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSphereGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AtomsSphereGroup, _AtomsGroup);

    var _super = _createSuper$I(AtomsSphereGroup);

    function AtomsSphereGroup() {
      classCallCheck(this, AtomsSphereGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSphereGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, atom.position, mode.calcAtomRadius(atom));
          geo.setColor(i, colorer.getAtomColor(atom, parent));
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var mode = this._mode;
        var colorer = this._colorer;
        var updateColor = frameData.needsColorUpdate(colorer);
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), mode.calcAtomRadius(atom));

          if (updateColor) {
            geo.setColor(i, frameData.getAtomColor(colorer, atom));
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsSphereGroup;
  }(AtomsGroup);

  function _createSuper$J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$K(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSurfaceGroup = /*#__PURE__*/function (_AtomsSphereGroup) {
    inherits(AtomsSurfaceGroup, _AtomsSphereGroup);

    var _super = _createSuper$J(AtomsSurfaceGroup);

    function AtomsSurfaceGroup() {
      classCallCheck(this, AtomsSurfaceGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSurfaceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        return [n, opts];
      }
    }]);

    return AtomsSurfaceGroup;
  }(AtomsSphereGroup);

  function _createSuper$K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$L(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSASSESGroupStub = /*#__PURE__*/function (_AtomsSphereGroup) {
    inherits(AtomsSASSESGroupStub, _AtomsSphereGroup);

    var _super = _createSuper$K(AtomsSASSESGroupStub);

    function AtomsSASSESGroupStub() {
      classCallCheck(this, AtomsSASSESGroupStub);

      return _super.apply(this, arguments);
    }

    createClass(AtomsSASSESGroupStub, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        opts.selection = this._selection;
        opts.colorMode = this._colorer;
        return [n, opts];
      }
    }]);

    return AtomsSASSESGroupStub;
  }(AtomsSphereGroup);

  function _createSuper$L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$M(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function adjustColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;

    if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
      r = r * 3 / 10;
      g = g * 3 / 10;
      b = b * 3 / 10;
    } else {
      r = 255 - (255 - r) * 3 / 10;
      g = 255 - (255 - g) * 3 / 10;
      b = 255 - (255 - b) * 3 / 10;
    }

    return r << 16 | g << 8 | b;
  }

  function inverseColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;
    return 255 - r << 16 | 255 - g << 8 | 255 - b;
  }

  function getAtomText(atom) {
    if (atom.name.getNode() !== null) {
      return atom.name.getNode();
    }

    return atom.getVisualName();
  }

  var colorMappings = {
    none: function none(c) {
      return c;
    },
    adjust: adjustColor,
    inverse: inverseColor
  };

  function propagateColor(color, rule) {
    var result;

    if (colorMappings.hasOwnProperty(rule)) {
      result = utils.hexColor(colorMappings[rule](color));
    } else {
      var val = parseInt(rule, 16);

      if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
        result = utils.hexColor(val);
      } else {
        result = '#000000';
      }
    }

    return result;
  }

  var templateMappings = {
    serial: function serial(a) {
      return a.serial;
    },
    name: function name(a) {
      return a.getVisualName();
    },
    elem: function elem(a) {
      return a.element.name;
    },
    residue: function residue(a) {
      return a.residue.getType().getName();
    },
    sequence: function sequence(a) {
      return a.residue.getSequence();
    },
    chain: function chain(a) {
      return a.residue.getChain().getName();
    },
    hetatm: function hetatm(a) {
      return a.isHet();
    },
    water: function water(a) {
      return a.residue.getType().getName() === 'HOH' || a.residue.getType().getName() === 'WAT';
    }
  };

  var parseTemplate = function parseTemplate(atom, str) {
    return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function (m) {
      var key = m.replace(/\s+/g, '');
      key = key.substring(2, key.length - 2).toLowerCase();

      if (templateMappings.hasOwnProperty(key)) {
        return templateMappings[key](atom);
      }

      return 'null';
    });
  };

  var AtomsTextGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AtomsTextGroup, _AtomsGroup);

    var _super = _createSuper$L(AtomsTextGroup);

    function AtomsTextGroup() {
      classCallCheck(this, AtomsTextGroup);

      return _super.apply(this, arguments);
    }

    createClass(AtomsTextGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var opts = this._mode.getLabelOpts();

        return [this._selection.chunks.length, opts];
      }
    }, {
      key: "_build",
      value: function _build() {
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = colorer.getAtomColor(atom, parent);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, atom.position, text);
          geo.setColor(i, fgColor, bgColor);
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var colorer = this._colorer;
        var geo = this._geo;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = frameData.getAtomColor(colorer, atom);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text);

          if (updateColor) {
            geo.setColor(i, fgColor, bgColor);
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsTextGroup;
  }(AtomsGroup);

  function _createSuper$M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$N(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega);
    return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
  }

  var AromaticGroup = /*#__PURE__*/function (_AtomsGroup) {
    inherits(AromaticGroup, _AtomsGroup);

    var _super = _createSuper$M(AromaticGroup);

    function AromaticGroup() {
      classCallCheck(this, AromaticGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticGroup, [{
      key: "_buildInner",
      value: function _buildInner(radOffset, addChunk) {
        var chunksToIdx = this._selection.chunks;
        var prevVector = new THREE.Vector3();
        var currVector = new THREE.Vector3();
        var segmentsHeight = this._segmentsHeight;
        var leprStep = 1.0 / segmentsHeight;
        var colorer = this._colorer;
        var _this$_selection = this._selection,
            cycles = _this$_selection.cycles,
            parent = _this$_selection.parent;
        var chunkIdx = 0;
        var currAtomIdx = chunksToIdx[chunkIdx];

        for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
          var cycle = cycles[cIdx];
          var cycAtoms = cycle.atoms;
          var chunkPoints = [];
          var tmpDir = [];
          var center = cycle.center;
          var cycleRad = cycle.radius - radOffset;
          var n = cycAtoms.length;
          var i = 0;
          var prevPos = cycAtoms[n - 1].position;
          var currPos = cycAtoms[i].position;
          prevVector.subVectors(prevPos, center);
          currVector.subVectors(currPos, center);
          var upDir = currVector.clone().cross(prevVector).normalize();

          for (; i < n; ++i) {
            var omega = prevVector.angleTo(currVector);
            tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize();
            currPos = cycAtoms[(i + 1) % n].position;
            prevVector.copy(currVector);
            currVector.subVectors(currPos, center);
          }

          for (i = 0; i < n; ++i) {
            if (cycAtoms[i].index !== currAtomIdx) {
              continue;
            }

            var start = tmpDir[i];
            var end = tmpDir[(i + 1) % n];
            var color = colorer.getAtomColor(cycAtoms[i], parent);
            var currAngle = start.angleTo(end);

            for (var j = 0; j <= segmentsHeight; ++j) {
              chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
            }

            addChunk(chunkIdx++, color, chunkPoints, center, upDir);
            currAtomIdx = chunksToIdx[chunkIdx];
          }
        }
      }
    }]);

    return AromaticGroup;
  }(AtomsGroup);

  function _createSuper$N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$O(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      var a = -2 * i / parts * Math.PI;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  var calcChunkMatrix = gfxutils.calcChunkMatrix;

  var AromaticTorusGroup = /*#__PURE__*/function (_AromaticGroup) {
    inherits(AromaticTorusGroup, _AromaticGroup);

    var _super = _createSuper$N(AromaticTorusGroup);

    function AromaticTorusGroup() {
      classCallCheck(this, AromaticTorusGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticTorusGroup, [{
      key: "_build",
      value: function _build() {
        var segmentsHeight = this._segmentsHeight;

        var torusRad = this._mode.getAromRadius();

        var radiusV = new THREE.Vector2(torusRad, torusRad);
        var radOffset = this._mode.calcStickRadius() + 2 * torusRad;
        var lookAtVector = new THREE.Vector3();
        var mtc = [];
        var geo = this._geo;

        this._buildInner(radOffset, function (chunkIdx, color, points, center, upDir) {
          for (var j = 0; j <= segmentsHeight; ++j) {
            var currPoint = points[j];
            var currDir = currPoint.clone().sub(center).cross(upDir);
            lookAtVector.addVectors(currPoint, currDir);
            mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
          }

          geo.setItem(chunkIdx, mtc);
          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._polyComplexity;
        return [_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
      }
    }]);

    return AromaticTorusGroup;
  }(AromaticGroup);

  function _createSuper$O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$P(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticLinesGroup = /*#__PURE__*/function (_AromaticGroup) {
    inherits(AromaticLinesGroup, _AromaticGroup);

    var _super = _createSuper$O(AromaticLinesGroup);

    function AromaticLinesGroup() {
      classCallCheck(this, AromaticLinesGroup);

      return _super.apply(this, arguments);
    }

    createClass(AromaticLinesGroup, [{
      key: "_build",
      value: function _build() {
        var _this = this;

        var geo = this._geo;

        var radOffset = this._mode.getAromaticOffset();

        this._buildInner(radOffset, function (chunkIdx, color, points) {
          var prevPt = points[0]; // do not replace with start

          for (var j = 1; j <= _this._segmentsHeight; ++j) {
            var currPoint = points[j];
            geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
            prevPt = currPoint;
          }

          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._mode.getAromaticArcChunks();
        return [this._selection.chunks.length, this._segmentsHeight, true];
      }
    }]);

    return AromaticLinesGroup;
  }(AromaticGroup);

  function _createSuper$P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(ResiduesGroup, _ChemGroup);

    var _super = _createSuper$P(ResiduesGroup);

    function ResiduesGroup() {
      classCallCheck(this, ResiduesGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[inters[i].chunkIdx];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesGroup;
  }(ChemGroup);

  function _createSuper$Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$R(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicItemGroup = /*#__PURE__*/function (_ResiduesGroup) {
    inherits(NucleicItemGroup, _ResiduesGroup);

    var _super = _createSuper$Q(NucleicItemGroup);

    function NucleicItemGroup() {
      classCallCheck(this, NucleicItemGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicItemGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finalize();
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunkIdx = 0;
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList[chunkIdx++] = 2 * i;
            chunksList[chunkIdx++] = 2 * i + 1;
          }
        }

        return chunksList;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finishUpdate();
      }
    }]);

    return NucleicItemGroup;
  }(ResiduesGroup);

  function _createSuper$R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$S(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicCylindersGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    inherits(NucleicCylindersGroup, _NucleicItemGroup);

    var _super = _createSuper$R(NucleicCylindersGroup);

    function NucleicCylindersGroup() {
      classCallCheck(this, NucleicCylindersGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicCylindersGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
        geo.setColor(chunkIdx, color, color);
      }
    }]);

    return NucleicCylindersGroup;
  }(NucleicItemGroup);

  function _createSuper$S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$T(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicSpheresGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    inherits(NucleicSpheresGroup, _NucleicItemGroup);

    var _super = _createSuper$S(NucleicSpheresGroup);

    function NucleicSpheresGroup() {
      classCallCheck(this, NucleicSpheresGroup);

      return _super.apply(this, arguments);
    }

    createClass(NucleicSpheresGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length * 2, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        var idx = chunkIdx * 2;
        geo.setItem(idx, cyl1, stickRad);
        geo.setColor(idx, color);
        idx++;
        geo.setItem(idx, cyl2, stickRad);
        geo.setColor(idx, color);
      }
    }]);

    return NucleicSpheresGroup;
  }(NucleicItemGroup);

  var Smooth = createCommonjsModule(function (module, exports) {
  /*
  Smooth.js version 0.1.7

  Turn arrays into smooth functions.

  Copyright 2012 Spencer Cohen
  Licensed under MIT license (see "Smooth.js MIT license.txt")
  */

  /*Constants (these are accessible by Smooth.WHATEVER in user space)
  */

  (function() {
    var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v, validateNumber, validateVector,
      __hasProp = Object.prototype.hasOwnProperty,
      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

    Enum = {
      /*Interpolation methods
      */
      METHOD_NEAREST: 'nearest',
      METHOD_LINEAR: 'linear',
      METHOD_CUBIC: 'cubic',
      METHOD_LANCZOS: 'lanczos',
      METHOD_SINC: 'sinc',
      /*Input clipping modes
      */
      CLIP_CLAMP: 'clamp',
      CLIP_ZERO: 'zero',
      CLIP_PERIODIC: 'periodic',
      CLIP_MIRROR: 'mirror',
      /* Constants for control over the cubic interpolation tension
      */
      CUBIC_TENSION_DEFAULT: 0,
      CUBIC_TENSION_CATMULL_ROM: 0
    };

    defaultConfig = {
      method: Enum.METHOD_CUBIC,
      cubicTension: Enum.CUBIC_TENSION_DEFAULT,
      clip: Enum.CLIP_CLAMP,
      scaleTo: 0,
      sincFilterSize: 2,
      sincWindow: void 0
    };

    /*Index clipping functions
    */

    clipClamp = function(i, n) {
      return Math.max(0, Math.min(i, n - 1));
    };

    clipPeriodic = function(i, n) {
      i = i % n;
      if (i < 0) i += n;
      return i;
    };

    clipMirror = function(i, n) {
      var period;
      period = 2 * (n - 1);
      i = clipPeriodic(i, period);
      if (i > n - 1) i = period - i;
      return i;
    };

    /*
    Abstract scalar interpolation class which provides common functionality for all interpolators
    
    Subclasses must override interpolate().
    */

    AbstractInterpolator = (function() {

      function AbstractInterpolator(array, config) {
        this.array = array.slice(0);
        this.length = this.array.length;
        if (!(this.clipHelper = {
          clamp: this.clipHelperClamp,
          zero: this.clipHelperZero,
          periodic: this.clipHelperPeriodic,
          mirror: this.clipHelperMirror
        }[config.clip])) {
          throw "Invalid clip: " + config.clip;
        }
      }

      AbstractInterpolator.prototype.getClippedInput = function(i) {
        if ((0 <= i && i < this.length)) {
          return this.array[i];
        } else {
          return this.clipHelper(i);
        }
      };

      AbstractInterpolator.prototype.clipHelperClamp = function(i) {
        return this.array[clipClamp(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperZero = function(i) {
        return 0;
      };

      AbstractInterpolator.prototype.clipHelperPeriodic = function(i) {
        return this.array[clipPeriodic(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperMirror = function(i) {
        return this.array[clipMirror(i, this.length)];
      };

      AbstractInterpolator.prototype.interpolate = function(t) {
        throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
      };

      return AbstractInterpolator;

    })();

    NearestInterpolator = (function(_super) {

      __extends(NearestInterpolator, _super);

      function NearestInterpolator() {
        NearestInterpolator.__super__.constructor.apply(this, arguments);
      }

      NearestInterpolator.prototype.interpolate = function(t) {
        return this.getClippedInput(Math.round(t));
      };

      return NearestInterpolator;

    })(AbstractInterpolator);

    LinearInterpolator = (function(_super) {

      __extends(LinearInterpolator, _super);

      function LinearInterpolator() {
        LinearInterpolator.__super__.constructor.apply(this, arguments);
      }

      LinearInterpolator.prototype.interpolate = function(t) {
        var k;
        k = Math.floor(t);
        t -= k;
        return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
      };

      return LinearInterpolator;

    })(AbstractInterpolator);

    CubicInterpolator = (function(_super) {

      __extends(CubicInterpolator, _super);

      function CubicInterpolator(array, config) {
        this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
        CubicInterpolator.__super__.constructor.apply(this, arguments);
      }

      CubicInterpolator.prototype.getTangent = function(k) {
        return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
      };

      CubicInterpolator.prototype.interpolate = function(t) {
        var k, m, p, t2, t3;
        k = Math.floor(t);
        m = [this.getTangent(k), this.getTangent(k + 1)];
        p = [this.getClippedInput(k), this.getClippedInput(k + 1)];
        t -= k;
        t2 = t * t;
        t3 = t * t2;
        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
      };

      return CubicInterpolator;

    })(AbstractInterpolator);

    sin = Math.sin, PI = Math.PI;

    sinc = function(x) {
      if (x === 0) {
        return 1;
      } else {
        return sin(PI * x) / (PI * x);
      }
    };

    makeLanczosWindow = function(a) {
      return function(x) {
        return sinc(x / a);
      };
    };

    makeSincKernel = function(window) {
      return function(x) {
        return sinc(x) * window(x);
      };
    };

    SincFilterInterpolator = (function(_super) {

      __extends(SincFilterInterpolator, _super);

      function SincFilterInterpolator(array, config) {
        SincFilterInterpolator.__super__.constructor.apply(this, arguments);
        this.a = config.sincFilterSize;
        if (!config.sincWindow) throw 'No sincWindow provided';
        this.kernel = makeSincKernel(config.sincWindow);
      }

      SincFilterInterpolator.prototype.interpolate = function(t) {
        var k, n, sum, _ref, _ref2;
        k = Math.floor(t);
        sum = 0;
        for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
          sum += this.kernel(t - n) * this.getClippedInput(n);
        }
        return sum;
      };

      return SincFilterInterpolator;

    })(AbstractInterpolator);

    getColumn = function(arr, i) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        row = arr[_i];
        _results.push(row[i]);
      }
      return _results;
    };

    makeScaledFunction = function(f, baseScale, scaleRange) {
      var scaleFactor, translation;
      if (scaleRange.join === '0,1') {
        return f;
      } else {
        scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
        translation = scaleRange[0];
        return function(t) {
          return f(scaleFactor * (t - translation));
        };
      }
    };

    getType = function(x) {
      return Object.prototype.toString.call(x).slice('[object '.length, -1);
    };

    validateNumber = function(n) {
      if (isNaN(n)) throw 'NaN in Smooth() input';
      if (getType(n) !== 'Number') throw 'Non-number in Smooth() input';
      if (!isFinite(n)) throw 'Infinity in Smooth() input';
    };

    validateVector = function(v, dimension) {
      var n, _i, _len;
      if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input';
      if (v.length !== dimension) throw 'Inconsistent dimension in Smooth() input';
      for (_i = 0, _len = v.length; _i < _len; _i++) {
        n = v[_i];
        validateNumber(n);
      }
    };

    isValidNumber = function(n) {
      return (getType(n) === 'Number') && isFinite(n) && !isNaN(n);
    };

    normalizeScaleTo = function(s) {
      var invalidErr;
      invalidErr = "scaleTo param must be number or array of two numbers";
      switch (getType(s)) {
        case 'Number':
          if (!isValidNumber(s)) throw invalidErr;
          s = [0, s];
          break;
        case 'Array':
          if (s.length !== 2) throw invalidErr;
          if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr;
          break;
        default:
          throw invalidErr;
      }
      return s;
    };

    shallowCopy = function(obj) {
      var copy, k, v;
      copy = {};
      for (k in obj) {
        if (!__hasProp.call(obj, k)) continue;
        v = obj[k];
        copy[k] = v;
      }
      return copy;
    };

    Smooth = function(arr, config) {
      var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
      if (config == null) config = {};
      properties = {};
      config = shallowCopy(config);
      properties.config = shallowCopy(config);
      if (config.scaleTo == null) config.scaleTo = config.period;
      if (config.sincFilterSize == null) {
        config.sincFilterSize = config.lanczosFilterSize;
      }
      for (k in defaultConfig) {
        if (!__hasProp.call(defaultConfig, k)) continue;
        v = defaultConfig[k];
        if (config[k] == null) config[k] = v;
      }
      if (!(interpolatorClass = {
        nearest: NearestInterpolator,
        linear: LinearInterpolator,
        cubic: CubicInterpolator,
        lanczos: SincFilterInterpolator,
        sinc: SincFilterInterpolator
      }[config.method])) {
        throw "Invalid method: " + config.method;
      }
      if (config.method === 'lanczos') {
        config.sincWindow = makeLanczosWindow(config.sincFilterSize);
      }
      if (arr.length < 2) throw 'Array must have at least two elements';
      properties.count = arr.length;
      smoothFunc = (function() {
        var _i, _j, _len, _len2;
        switch (getType(arr[0])) {
          case 'Number':
            properties.dimension = 'scalar';
            if (Smooth.deepValidation) {
              for (_i = 0, _len = arr.length; _i < _len; _i++) {
                n = arr[_i];
                validateNumber(n);
              }
            }
            interpolator = new interpolatorClass(arr, config);
            return function(t) {
              return interpolator.interpolate(t);
            };
          case 'Array':
            properties.dimension = dimension = arr[0].length;
            if (!dimension) throw 'Vectors must be non-empty';
            if (Smooth.deepValidation) {
              for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                v = arr[_j];
                validateVector(v, dimension);
              }
            }
            interpolators = (function() {
              var _results;
              _results = [];
              for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
                _results.push(new interpolatorClass(getColumn(arr, i), config));
              }
              return _results;
            })();
            return function(t) {
              var interpolator, _k, _len3, _results;
              _results = [];
              for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                interpolator = interpolators[_k];
                _results.push(interpolator.interpolate(t));
              }
              return _results;
            };
          default:
            throw "Invalid element type: " + (getType(arr[0]));
        }
      })();
      if (config.clip === 'periodic') {
        baseDomainEnd = arr.length;
      } else {
        baseDomainEnd = arr.length - 1;
      }
      config.scaleTo || (config.scaleTo = baseDomainEnd);
      properties.domain = normalizeScaleTo(config.scaleTo);
      smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
      properties.domain.sort();
      /*copy properties
      */
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        smoothFunc[k] = v;
      }
      return smoothFunc;
    };

    for (k in Enum) {
      if (!__hasProp.call(Enum, k)) continue;
      v = Enum[k];
      Smooth[k] = v;
    }

    Smooth.deepValidation = true;

    ( exports !== null ? exports : window).Smooth = Smooth;

  }).call(commonjsGlobal);
  });
  var Smooth_1 = Smooth.Smooth;

  var ResidueType$1 = chem.ResidueType;
  var calcMatrix = gfxutils.calcChunkMatrix;

  function _buildStructureInterpolator(points, tension) {
    var path = Smooth_1(points, {
      method: Smooth_1.METHOD_CUBIC,
      clip: Smooth_1.CLIP_CLAMP,
      cubicTension: tension,
      scaleTo: 1
    });
    return function (t, argTrans) {
      var transformT = argTrans;

      if (transformT === null) {
        // map our range to the [second .. last but one]
        transformT = function transformT(tt) {
          return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
        };
      }

      var newt = transformT(t);
      var ans = path(newt);
      return new THREE.Vector3(ans[0], ans[1], ans[2]);
    };
  }

  function _addPoints(centerPoints, topPoints, idx, residue) {
    if (!residue._isValid) {
      centerPoints[idx] = centerPoints[idx - 1];
      topPoints[idx] = topPoints[idx - 1];
      return;
    }

    var cp = residue._controlPoint;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    var tp = cp.clone().add(residue._wingVector);
    topPoints[idx] = [tp.x, tp.y, tp.z];
  }

  function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
    var nucleic = (residue._type.flags & ResidueType$1.Flags.NUCLEIC) !== 0;
    var nameFrom = nucleic ? 'C5\'' : 'N';
    var nameTo = nucleic ? 'C3\'' : 'C';
    var posFrom;
    var posTo;
    residue.forEachAtom(function (atom) {
      var name = atom.getVisualName();

      if (!posFrom && name === nameFrom) {
        posFrom = atom.position;
      } else if (!posTo && name === nameTo) {
        posTo = atom.position;
      }
    }); // provide a fallback for unknown residues

    if (!(posFrom && posTo)) {
      posFrom = residue._firstAtom.position;
      posTo = residue._lastAtom.position;
    }

    if (posFrom && posTo) {
      var shift = posTo.clone().sub(posFrom);
      var wing = residue._wingVector;
      var cp = residue._controlPoint;
      var tp = cp.clone().add(wing);
      var cpPrev = cp.clone().sub(shift);
      var tpPrev = cpPrev.clone().add(wing);
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cp.x, cp.y, cp.z];
      topPoints[idx] = [tp.x, tp.y, tp.z];
      ++idx;
      var cpNext = cp.clone().add(shift);
      var tpNext = cpNext.clone().add(wing);
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
      ++idx;
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    }
  }

  function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
    var left = boundaries.start;
    var right = boundaries.end;

    function _prevIdx(idx) {
      return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
    }

    function _nextIdx(idx) {
      return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
    }

    var topPoints = [];
    var centerPoints = [];
    var arrIdx = 0;

    function _extrapolate2(currIdx, otherIdx) {
      var cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);

      var tp = cp.clone().add(residues[currIdx]._wingVector);
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    } // a single disconnected residue


    var prevIdx = _prevIdx(firstIdx);

    var nextIdx = _nextIdx(lastIdx);

    if (prevIdx === nextIdx) {
      _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);

      return {
        centerPoints: centerPoints,
        topPoints: topPoints
      };
    } // Two points (prev-prev and next-next) are added to support edge conditions for cubic splines, they are ignored
    // Another two (prev and next) were added to support the outside of the sub chain
    // prev and prev-prev


    if (firstIdx === prevIdx) {
      // do the extrapolation
      _extrapolate2(firstIdx, _nextIdx(firstIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);

      _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
    } // main loop


    for (var idx = firstIdx; idx <= lastIdx; ++idx) {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
    } // next and next-next


    if (nextIdx === _nextIdx(nextIdx)) {
      // do the extrapolation
      _extrapolate2(lastIdx, _prevIdx(lastIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);

      _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
    }

    return {
      centerPoints: centerPoints,
      topPoints: topPoints
    };
  }

  var CartoonHelper = /*#__PURE__*/function () {
    function CartoonHelper(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
      classCallCheck(this, CartoonHelper);

      var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);

      this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
      this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
      this._shift = 0.5 / (endIdx - startIdx + 2);
      this._valueStep = (1.0 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
      this._segmentsCount = segmentsCount;
    }

    createClass(CartoonHelper, [{
      key: "prepareMatrices",
      value: function prepareMatrices(idx, firstRad, secondRad) {
        var mtcCount = this._segmentsCount;
        var outMtc = new Array(mtcCount);
        var currRad = new THREE.Vector2(0, 0);
        var topInterp = this._topInterp;
        var cenInterp = this._centerInterp;
        var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;

        for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
          var lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1));
          currRad.lerpVectors(firstRad, secondRad, lerpVal);
          var currTop = topInterp(currentValue, null);
          var currCenter = cenInterp(currentValue, null);
          currentValue += this._valueStep;
          var nextCenter = cenInterp(currentValue, null);
          outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
        }

        return outMtc;
      }
    }]);

    return CartoonHelper;
  }();

  function _createSuper$T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$U(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape$1(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      // starts from pi/2 because it's important that points are lied on the angles of arrows (visual issues if not)
      var a = Math.PI / 2.0 - 2 * Math.PI * i / parts;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
    for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      var subs = subDiv[subDivI].arr;
      var boundaries = subDiv[subDivI].boundaries;

      for (var i = 0, n = subs.length; i < n; ++i) {
        var idc = [subs[i].start, subs[i].end];
        var matrixHelper = new CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
        var prevLast = null;
        var startIdx = subs[i].start * 2;
        var endIdx = subs[i].end * 2 + 1;
        var prevSecondRad = mode.getResidueRadius(residues[0], 0);

        for (var idx = startIdx; idx <= endIdx; ++idx) {
          var resIdx = idx / 2 | 0;
          var currRes = residues[resIdx];
          var firstRad = mode.getResidueRadius(currRes, idx % 2);
          var secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
          var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
          mtc.unshift(prevLast === null ? mtc[0] : prevLast); // Slope - radius is changed along this residue part

          var hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y; // Cut - end radius of previous part not equal to start radius of this part. First section of this part lies in the orthogonal plane

          var hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
          callback(currRes, mtc, hasSlope, hasCut);
          prevLast = mtc[segmentsHeight];
          prevSecondRad = secondRad;
        }
      }
    }
  }

  var ResiduesSubseqGroup = /*#__PURE__*/function (_ResiduesGroup) {
    inherits(ResiduesSubseqGroup, _ResiduesGroup);

    var _super = _createSuper$T(ResiduesSubseqGroup);

    function ResiduesSubseqGroup() {
      classCallCheck(this, ResiduesSubseqGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesSubseqGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var cmpMultiplier = this._mode.getHeightSegmentsRatio();

        this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
        return [_createShape$1(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];

        _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var color = colorer.getResidueColor(currRes, parent);
          chunkIdc[chunkIdx] = currRes._index;
          geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
          geo.setColor(chunkIdx++, color);
        });

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var frameRes = frameData.getResidues();
        var chunkIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          geo.setItem(chunkIdx, mtc);

          if (updateColor) {
            geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
          }

          chunkIdx++;
        });

        geo.finalize();
      }
    }]);

    return ResiduesSubseqGroup;
  }(ResiduesGroup);

  function _createSuper$U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$V(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesTraceGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(ResiduesTraceGroup, _ChemGroup);

    var _super = _createSuper$U(ResiduesTraceGroup);

    function ResiduesTraceGroup() {
      classCallCheck(this, ResiduesTraceGroup);

      return _super.apply(this, arguments);
    }

    createClass(ResiduesTraceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var subDiv = this._selection.subdivs;
        var chunksCount = 0;

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            chunksCount += subs[i].end - subs[i].start;
          }
        }

        return [chunksCount, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              chunkIdc[chunkIdx] = {
                first: prevRes._index,
                second: currRes._index
              };
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
              geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);

              if (updateColor) {
                geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              }

              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        geo.finalize();
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];
        var residues = this._selection.residues;

        this._mesh.raycast(raycaster, inters);

        var chunksToIdx = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
          var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunksToIdx = this._chunksIdc;
        var residues = this._selection.residues;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var chunk = chunksToIdx[i];

          if (residues[chunk.first]._mask & mask) {
            chunksList.push(i * 2);
          }

          if (residues[chunk.second]._mask & mask) {
            chunksList.push(i * 2 + 1);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesTraceGroup;
  }(ChemGroup);

  function _createSuper$V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$W(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }

  var BondsGroup = /*#__PURE__*/function (_ChemGroup) {
    inherits(BondsGroup, _ChemGroup);

    var _super = _createSuper$V(BondsGroup);

    function BondsGroup() {
      classCallCheck(this, BondsGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var drawMultiple = this._mode.drawMultiorderBonds();

        var showAromatic = this._mode.showAromaticLoops();

        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var bondsCount = 0;

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          bondsCount += this.getBondOrder(bonds[bondsIdc[i]], drawMultiple, showAromatic);
        }

        return [bondsCount, this._polyComplexity];
      }
    }, {
      key: "getBondOrder",
      value: function getBondOrder(bond, drawMultiple, showAromatic) {
        var bondOrder = 1;

        if (drawMultiple && (!showAromatic || bond._type !== Bond.BondType.AROMATIC)) {
          bondOrder = getCylinderCount(bond._order);
        }

        return bondOrder;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var bonds = this._selection.bonds;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var bondsIdc = this._chunksIdc; // process inters array - arr object references

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];

          if (bondIdx < bonds.length) {
            var bond = bonds[bondIdx];
            inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask, innerOnly) {
        var chunksList = [];
        var bonds = this._selection.bonds;
        var chunksToIdx = this._chunksIdc;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var bond = bonds[chunksToIdx[i]];

          if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
            chunksList.push(2 * i);
          }

          if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
            chunksList.push(2 * i + 1);
          }
        }

        return chunksList;
      }
    }]);

    return BondsGroup;
  }(ChemGroup);

  function _createSuper$W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$X(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BondsCylinderGroup = /*#__PURE__*/function (_BondsGroup) {
    inherits(BondsCylinderGroup, _BondsGroup);

    var _super = _createSuper$W(BondsCylinderGroup);

    function BondsCylinderGroup() {
      classCallCheck(this, BondsCylinderGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsCylinderGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            chunksToIdx[currBondIdx] = bond._index;
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsCylinderGroup;
  }(BondsGroup);

  function _createSuper$X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var STEP_SIZE = 0.15;

  var BondsLinesGroup = /*#__PURE__*/function (_BondsGroup) {
    inherits(BondsLinesGroup, _BondsGroup);

    var _super = _createSuper$X(BondsLinesGroup);

    function BondsLinesGroup() {
      classCallCheck(this, BondsLinesGroup);

      return _super.apply(this, arguments);
    }

    createClass(BondsLinesGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE.Vector3();
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
            chunksToIdx[currBondIdx] = bond._index;

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        // This method looks like a copy paste. However, it
        // was decided to postpone animation refactoring until GFX is fixed.
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE.Vector3();
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsLinesGroup;
  }(BondsGroup);

  var groups = {
    AtomsSphereGroup: AtomsSphereGroup,
    AtomsSurfaceGroup: AtomsSurfaceGroup,
    AtomsSASSESGroupStub: AtomsSASSESGroupStub,
    AtomsTextGroup: AtomsTextGroup,
    AromaticTorusGroup: AromaticTorusGroup,
    AromaticLinesGroup: AromaticLinesGroup,
    NucleicCylindersGroup: NucleicCylindersGroup,
    NucleicSpheresGroup: NucleicSpheresGroup,
    ResiduesSubseqGroup: ResiduesSubseqGroup,
    ResiduesTraceGroup: ResiduesTraceGroup,
    BondsCylinderGroup: BondsCylinderGroup,
    BondsLinesGroup: BondsLinesGroup
  };

  function _createSuper$Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(AtomsProcessor, _RCGroup);

    var _super = _createSuper$Y(AtomsProcessor);

    function AtomsProcessor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, AtomsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      _this._mode = mode;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var atomCount = 0;
        component.forEachAtom(function (atom) {
          if (!self._checkAtom(atom, mask)) {
            return;
          }

          atomsIdc[atomCount++] = atom.index;
        });

        if (atomCount === 0) {
          return;
        }

        var atomsGroup = new AtomsGroup(geoParams, {
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    createClass(AtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        return atom.mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AtomsProcessor;
  }(RCGroup);

  function _createSuper$Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$_(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var OrphanAtomsProcessor = /*#__PURE__*/function (_AtomsProcessor) {
    inherits(OrphanAtomsProcessor, _AtomsProcessor);

    var _super = _createSuper$Z(OrphanAtomsProcessor);

    function OrphanAtomsProcessor() {
      classCallCheck(this, OrphanAtomsProcessor);

      return _super.apply(this, arguments);
    }

    createClass(OrphanAtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        if (!(atom.mask & mask)) {
          return false;
        }

        var bonds = atom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          if (bonds[i]._left.mask & mask && bonds[i]._right.mask & mask) {
            return false;
          }
        }

        return true;
      }
    }]);

    return OrphanAtomsProcessor;
  }(AtomsProcessor);

  function _createSuper$_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$$(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(ResiduesProcessor, _RCGroup);

    var _super = _createSuper$_(ResiduesProcessor);

    function ResiduesProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, ResiduesProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var chunksCount = 0;
        var resIdc = [];
        component.forEachResidue(function (residue) {
          if (self._checkResidue(residue, mask)) {
            resIdc[chunksCount++] = residue._index;
          }
        });

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    createClass(ResiduesProcessor, [{
      key: "checkResidue",
      value: function checkResidue(residue, mask) {
        return residue._mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return ResiduesProcessor;
  }(RCGroup);

  function _createSuper$$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$10(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$10() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicProcessor = /*#__PURE__*/function (_ResidueProcessor) {
    inherits(NucleicProcessor, _ResidueProcessor);

    var _super = _createSuper$$(NucleicProcessor);

    function NucleicProcessor() {
      classCallCheck(this, NucleicProcessor);

      return _super.apply(this, arguments);
    }

    createClass(NucleicProcessor, [{
      key: "_checkResidue",
      value: function _checkResidue(residue, mask) {
        return mask & residue._mask && residue._cylinders !== null;
      }
    }]);

    return NucleicProcessor;
  }(ResiduesProcessor);

  function _createSuper$10(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$11(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$11() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SubseqsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(SubseqsProcessor, _RCGroup);

    var _super = _createSuper$10(SubseqsProcessor);

    function SubseqsProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, SubseqsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var subDivs = component.getMaskedSubdivSequences(mask);
        var chunksCount = 0;
        var resIdc = [];

        for (var subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
          var subs = subDivs[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            for (var j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
              resIdc[chunksCount++] = residues[j]._index;
            }
          }
        }

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          subdivs: subDivs,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    createClass(SubseqsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return SubseqsProcessor;
  }(RCGroup);

  function _createSuper$11(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$12(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$12() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BondsProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(BondsProcessor, _RCGroup);

    var _super = _createSuper$11(BondsProcessor);

    function BondsProcessor(BondsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, BondsProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var bonds = complex.getBonds();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var bondsIdc = [];
        var bondsCount = 0;
        component.forEachBond(function (bond) {
          var atom1 = bond._left;
          var atom2 = bond._right;

          if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
            return;
          }

          bondsIdc[bondsCount++] = bond._index;
        });

        if (bondsCount === 0) {
          return;
        }

        var bondsGroup = new BondsGroup(geoParams, {
          bonds: bonds,
          chunks: bondsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        bondsGroup._component = component;
        self.add(bondsGroup);
      });
      return _this;
    }

    createClass(BondsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return BondsProcessor;
  }(RCGroup);

  function _createSuper$12(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$13(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$13() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticProcessor = /*#__PURE__*/function (_RCGroup) {
    inherits(AromaticProcessor, _RCGroup);

    var _super = _createSuper$12(AromaticProcessor);

    function AromaticProcessor(AromaticGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      classCallCheck(this, AromaticProcessor);

      _this = _super.call(this);

      var self = assertThisInitialized(_this);

      _this._complex = complex;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();

      if (!mode.showAromaticLoops()) {
        return possibleConstructorReturn(_this);
      }

      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var chunksCount = 0;
        var cycles = [];
        var cycleIdx = 0;
        component.forEachCycle(function (cycle) {
          var cycAtoms = cycle.atoms;
          var perCycle = 0;

          for (var i = 0, n = cycAtoms.length; i < n; ++i) {
            if ((cycAtoms[i].mask & mask) !== 0) {
              ++perCycle;
              atomsIdc[chunksCount++] = cycAtoms[i].index;
            }
          }

          if (perCycle > 0) {
            cycles[cycleIdx++] = cycle;
          }
        });
        var atomsGroup = new AromaticGroup(geoParams, {
          cycles: cycles,
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    createClass(AromaticProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AromaticProcessor;
  }(RCGroup);

  var processors = {
    Atoms: AtomsProcessor,
    OrphanAtoms: OrphanAtomsProcessor,
    Residues: ResiduesProcessor,
    Nucleic: NucleicProcessor,
    Subseqs: SubseqsProcessor,
    Bonds: BondsProcessor,
    Aromatic: AromaticProcessor
  };

  function _bakeGroup(triplet, Processor, Group) {
    return function (complex, colorer, mode, polyComplexity, mask, material) {
      return new Processor(Group, triplet, complex, colorer, mode, polyComplexity, mask, material);
    };
  }

  var GroupsFactory = /*#__PURE__*/function () {
    function GroupsFactory() {
      classCallCheck(this, GroupsFactory);
    }

    createClass(GroupsFactory, null, [{
      key: "AtomsSpheres",
      value: function AtomsSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "OrphanedAtomsCrosses",
      value: function OrphanedAtomsCrosses(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createCrosses(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "BondsCylinders",
      value: function BondsCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
      }
    }, {
      key: "BondsLines",
      value: function BondsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.create2CLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
      }
    }, {
      key: "CartoonChains",
      value: function CartoonChains(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
      }
    }, {
      key: "TraceChains",
      value: function TraceChains(caps, settings) {
        var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
      }
    }, {
      key: "NucleicSpheres",
      value: function NucleicSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
      }
    }, {
      key: "NucleicCylinders",
      value: function NucleicCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
      }
    }, {
      key: "ALoopsTorus",
      value: function ALoopsTorus(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
      }
    }, {
      key: "ALoopsLines",
      value: function ALoopsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createChunkedLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
      }
    }, {
      key: "QuickSurfGeo",
      value: function QuickSurfGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createQuickSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "ContactSurfaceGeo",
      value: function ContactSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createContactSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "SASSESSurfaceGeo",
      value: function SASSESSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createSASSES(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
      }
    }, {
      key: "TextLabelsGeo",
      value: function TextLabelsGeo(caps, settings) {
        var gfxTriplet = MeshCreator.createLabels(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
      }
    }]);

    return GroupsFactory;
  }();

  /**
   * Create new mode.
   *
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the mode after its creation.
   *
   * @exports Mode
   * @this Mode
   * @abstract
   * @constructor
   * @classdesc Basic class for all available modes used for building and displaying molecule geometry.
   */

  var Mode = /*#__PURE__*/function () {
    function Mode(opts) {
      classCallCheck(this, Mode);

      if (this.constructor === Mode) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Mode options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.opts = ___default['default'].merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
    }
    /**
     * Get mode identification, probably with options.
     * @returns {string|Array} Mode identifier string ({@link Mode#id}) or two-element array containing both mode
     *   identifier and options ({@link Mode#opts}).
     * Options are returned if they were changed during or after the mode creation.
     */


    createClass(Mode, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
        var groupList = this.depGroups;
        var groupCount = groupList.length;
        var group = new gfxutils.RCGroup();
        var self = this;

        for (var i = 0; i < groupCount; ++i) {
          var currGroup = groupList[i];
          var renderParams = {};

          if (___default['default'].isArray(currGroup)) {
            renderParams = currGroup[1].call(this);
            var _currGroup = currGroup;

            var _currGroup2 = slicedToArray(_currGroup, 1);

            currGroup = _currGroup2[0];
          }

          var Group = GroupsFactory[currGroup](null, this.settings, renderParams);
          var newGroup = new Group(complex, colorer, self, polyComplexity, mask, material);

          if (newGroup.children.length > 0) {
            group.add(newGroup);
          }
        }

        return group;
      }
    }]);

    return Mode;
  }();

  makeContextDependent(Mode.prototype);
  /**
  * Mode identifier.
  * @type {string}
  */

  Mode.prototype.id = '__';
  /**
   * Mode geo groups.
   * @type {Array}
   */

  Mode.prototype.depGroups = [];

  function _createSuper$13(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$14(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$14() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function getRenderParams() {
    return {
      lineWidth: this.opts.lineWidth
    };
  }

  var LinesMode = /*#__PURE__*/function (_Mode) {
    inherits(LinesMode, _Mode);

    var _super = _createSuper$13(LinesMode);

    function LinesMode(opts) {
      var _this;

      classCallCheck(this, LinesMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits

      var groups = _this.depGroups;

      for (var i = 0, n = groups.length; i < n; ++i) {
        groups[i] = [groups[i], getRenderParams];
      }

      return _this;
    }

    createClass(LinesMode, [{
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }, {
      key: "calcAtomRadius",
      value: function calcAtomRadius() {
        return this.opts.atom;
      }
    }, {
      key: "getAromaticOffset",
      value: function getAromaticOffset() {
        return this.opts.offsarom;
      }
    }, {
      key: "getAromaticArcChunks",
      value: function getAromaticArcChunks() {
        return this.opts.chunkarom;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }]);

    return LinesMode;
  }(Mode);

  defineProperty(LinesMode, "id", 'LN');

  LinesMode.prototype.id = 'LN';
  LinesMode.prototype.name = 'Lines';
  LinesMode.prototype.shortName = 'Lines';
  LinesMode.prototype.depGroups = ['ALoopsLines', 'BondsLines', 'OrphanedAtomsCrosses'];

  function _createSuper$14(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$15(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$15() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var LicoriceMode = /*#__PURE__*/function (_Mode) {
    inherits(LicoriceMode, _Mode);

    var _super = _createSuper$14(LicoriceMode);

    function LicoriceMode() {
      classCallCheck(this, LicoriceMode);

      return _super.apply(this, arguments);
    }

    createClass(LicoriceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(_atom) {
        return this.opts.bond;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return LicoriceMode;
  }(Mode);

  defineProperty(LicoriceMode, "id", 'LC');

  LicoriceMode.prototype.id = 'LC';
  LicoriceMode.prototype.name = 'Licorice';
  LicoriceMode.prototype.shortName = 'Licorice';
  LicoriceMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$15(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$16(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$16() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var BallsAndSticksMode = /*#__PURE__*/function (_Mode) {
    inherits(BallsAndSticksMode, _Mode);

    var _super = _createSuper$15(BallsAndSticksMode);

    function BallsAndSticksMode() {
      classCallCheck(this, BallsAndSticksMode);

      return _super.apply(this, arguments);
    }

    createClass(BallsAndSticksMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius * this.opts.atom;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return BallsAndSticksMode;
  }(Mode);

  defineProperty(BallsAndSticksMode, "id", 'BS');

  BallsAndSticksMode.prototype.id = 'BS';
  BallsAndSticksMode.prototype.name = 'Balls and Sticks';
  BallsAndSticksMode.prototype.shortName = 'Balls';
  BallsAndSticksMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$16(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$17(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$17() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VanDerWaalsMode = /*#__PURE__*/function (_Mode) {
    inherits(VanDerWaalsMode, _Mode);

    var _super = _createSuper$16(VanDerWaalsMode);

    function VanDerWaalsMode() {
      classCallCheck(this, VanDerWaalsMode);

      return _super.apply(this, arguments);
    }

    createClass(VanDerWaalsMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }]);

    return VanDerWaalsMode;
  }(Mode);

  defineProperty(VanDerWaalsMode, "id", 'VW');

  VanDerWaalsMode.prototype.id = 'VW';
  VanDerWaalsMode.prototype.name = 'Van der Waals';
  VanDerWaalsMode.prototype.shortName = 'VDW';
  VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres'];

  function _createSuper$17(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$18(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$18() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TraceMode = /*#__PURE__*/function (_Mode) {
    inherits(TraceMode, _Mode);

    var _super = _createSuper$17(TraceMode);

    function TraceMode() {
      classCallCheck(this, TraceMode);

      return _super.apply(this, arguments);
    }

    createClass(TraceMode, [{
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.radius;
      }
    }]);

    return TraceMode;
  }(Mode);

  defineProperty(TraceMode, "id", 'TR');

  TraceMode.prototype.id = 'TR';
  TraceMode.prototype.name = 'Trace';
  TraceMode.prototype.shortName = 'Trace';
  TraceMode.prototype.depGroups = ['TraceChains'];

  function _createSuper$18(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$19(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$19() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TubeMode = /*#__PURE__*/function (_Mode) {
    inherits(TubeMode, _Mode);

    var _super = _createSuper$18(TubeMode);

    function TubeMode() {
      classCallCheck(this, TubeMode);

      return _super.apply(this, arguments);
    }

    createClass(TubeMode, [{
      key: "getResidueRadius",
      value: function getResidueRadius(_residue) {
        return this.TUBE_RADIUS;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var rad = this.opts.radius;
        this.TUBE_RADIUS = new THREE.Vector2(rad, rad);
        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return TubeMode;
  }(Mode);

  defineProperty(TubeMode, "id", 'TU');

  TubeMode.prototype.id = 'TU';
  TubeMode.prototype.name = 'Tube';
  TubeMode.prototype.shortName = 'Tube';
  TubeMode.prototype.depGroups = ['CartoonChains'];

  function _createSuper$19(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1a(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CartoonMode = /*#__PURE__*/function (_Mode) {
    inherits(CartoonMode, _Mode);

    var _super = _createSuper$19(CartoonMode);

    function CartoonMode(opts) {
      var _this;

      classCallCheck(this, CartoonMode);

      _this = _super.call(this, opts); // cache for secondary structure options

      _this.secCache = {};
      return _this;
    }

    createClass(CartoonMode, [{
      key: "getResidueStartRadius",
      value: function getResidueStartRadius(residue) {
        var second = residue.getSecondary();

        if (!second || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return secOpts.start;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueEndRadius",
      value: function getResidueEndRadius(residue) {
        var second = residue.getSecondary();

        if (second === null || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return this.ARROW_END;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueRadius",
      value: function getResidueRadius(residue, val) {
        var startRad = this.getResidueStartRadius(residue);

        if (val === 0) {
          return startRad;
        }

        var endRad = this.getResidueEndRadius(residue);

        if (val === 2) {
          return endRad;
        }

        return startRad.clone().lerp(endRad, val / 2.0);
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius(_res) {
        return this.opts.radius;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var tubeRad = this.opts.radius;
        var secHeight = this.opts.depth;
        this.TUBE_RADIUS = new THREE.Vector2(tubeRad, tubeRad);
        this.ARROW_END = new THREE.Vector2(secHeight, tubeRad);
        var secCache = {};
        var secData = this.opts.ss;
        /* eslint-disable guard-for-in */

        for (var prop in secData) {
          secCache[prop] = {
            center: new THREE.Vector2(secHeight, secData[prop].width),
            start: new THREE.Vector2(secHeight, secData[prop].arrow)
          };
        }

        this.secCache = secCache;
        /* eslint-enable guard-for-in */

        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return CartoonMode;
  }(Mode);

  defineProperty(CartoonMode, "id", 'CA');

  CartoonMode.prototype.id = 'CA';
  CartoonMode.prototype.name = 'Cartoon';
  CartoonMode.prototype.shortName = 'Cartoon';
  CartoonMode.prototype.depGroups = ['CartoonChains', 'NucleicSpheres', 'NucleicCylinders'];

  function _createSuper$1a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1b(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$1 = chem.selectors;

  function getRenderParams$1() {
    return {
      wireframe: this.opts.wireframe,
      zClip: this.opts.zClip
    };
  }

  var SurfaceMode = /*#__PURE__*/function (_Mode) {
    inherits(SurfaceMode, _Mode);

    var _super = _createSuper$1a(SurfaceMode);

    function SurfaceMode(opts) {
      var _this;

      classCallCheck(this, SurfaceMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits

      var surfaces = _this.surfaceNames;
      var groups = _this.depGroups;

      for (var i = 0, n = surfaces.length; i < n; ++i) {
        groups[groups.length] = [surfaces[i], getRenderParams$1];
      }

      return _this;
    }

    createClass(SurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getVisibilitySelector",
      value: function getVisibilitySelector() {
        var visibilitySelector = null;

        if (this.opts.subset !== '') {
          var res = selectors$1.parse(this.opts.subset);

          if (!res.error) {
            visibilitySelector = res.selector;
          }
        }

        return visibilitySelector;
      }
    }]);

    return SurfaceMode;
  }(Mode);

  SurfaceMode.prototype.isSurface = true;
  SurfaceMode.prototype.surfaceNames = [];

  function _createSuper$1b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1c(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var QuickSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(QuickSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1b(QuickSurfaceMode);

    function QuickSurfaceMode() {
      classCallCheck(this, QuickSurfaceMode);

      return _super.apply(this, arguments);
    }

    createClass(QuickSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          useBeads: false,
          isoValue: this.opts.isoValue,
          gaussLim: this.opts.gaussLim[this.settings.now.resolution],
          radScale: this.opts.scale,
          gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return QuickSurfaceMode;
  }(SurfaceMode);

  defineProperty(QuickSurfaceMode, "id", 'QS');

  QuickSurfaceMode.prototype.id = 'QS';
  QuickSurfaceMode.prototype.name = 'Quick Surface';
  QuickSurfaceMode.prototype.shortName = 'Quick Surf';
  QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo'];

  function _createSuper$1c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1d(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(IsoSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1c(IsoSurfaceMode);

    function IsoSurfaceMode(excludeProbe, opts) {
      var _this;

      classCallCheck(this, IsoSurfaceMode);

      _this = _super.call(this, opts);
      _this._excludeProbe = excludeProbe;
      return _this;
    }

    createClass(IsoSurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
          radScale: this._radScale,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector(),
          probeRadius: this.opts.probeRadius,
          excludeProbe: this._excludeProbe
        };
      }
    }]);

    return IsoSurfaceMode;
  }(SurfaceMode);

  IsoSurfaceMode.prototype.id = 'SU';
  IsoSurfaceMode.prototype.name = 'Surface';
  IsoSurfaceMode.prototype.shortName = 'Surface';
  IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo'];
  IsoSurfaceMode.prototype._radScale = 1;
  IsoSurfaceMode.prototype._excludeProbe = false;

  function _createSuper$1d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1e(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSASMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    inherits(IsoSurfaceSASMode, _IsoSurfaceMode);

    var _super = _createSuper$1d(IsoSurfaceSASMode);

    function IsoSurfaceSASMode(opts) {
      classCallCheck(this, IsoSurfaceSASMode);

      return _super.call(this, false, opts);
    }

    return IsoSurfaceSASMode;
  }(IsoSurfaceMode);

  defineProperty(IsoSurfaceSASMode, "id", 'SA');

  IsoSurfaceSASMode.prototype.id = 'SA';
  IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
  IsoSurfaceSASMode.prototype.shortName = 'SAS';

  function _createSuper$1e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1f(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSESMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    inherits(IsoSurfaceSESMode, _IsoSurfaceMode);

    var _super = _createSuper$1e(IsoSurfaceSESMode);

    function IsoSurfaceSESMode(opts) {
      classCallCheck(this, IsoSurfaceSESMode);

      return _super.call(this, true, opts);
    }

    return IsoSurfaceSESMode;
  }(IsoSurfaceMode);

  defineProperty(IsoSurfaceSESMode, "id", 'SE');

  IsoSurfaceSESMode.prototype.id = 'SE';
  IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
  IsoSurfaceSESMode.prototype.shortName = 'SES';

  function _createSuper$1f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1g(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ContactSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    inherits(ContactSurfaceMode, _SurfaceMode);

    var _super = _createSuper$1f(ContactSurfaceMode);

    function ContactSurfaceMode() {
      classCallCheck(this, ContactSurfaceMode);

      return _super.apply(this, arguments);
    }

    createClass(ContactSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          probeRadius: this.opts.probeRadius,
          radScale: this.opts.polyComplexity[this.settings.now.resolution],
          scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
          gridSpacing: 1.0 / this.opts.polyComplexity[this.settings.now.resolution],
          isoValue: this.opts.isoValue,
          probePositions: this.opts.probePositions,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return ContactSurfaceMode;
  }(SurfaceMode);

  defineProperty(ContactSurfaceMode, "id", 'CS');

  ContactSurfaceMode.prototype.id = 'CS';
  ContactSurfaceMode.prototype.name = 'Contact Surface';
  ContactSurfaceMode.prototype.shortName = 'Contact Surf';
  ContactSurfaceMode.prototype.isSurface = true;
  ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo'];

  function _createSuper$1g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1h(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var TextMode = /*#__PURE__*/function (_Mode) {
    inherits(TextMode, _Mode);

    var _super = _createSuper$1g(TextMode);

    function TextMode() {
      classCallCheck(this, TextMode);

      return _super.apply(this, arguments);
    }

    createClass(TextMode, [{
      key: "getTemplateOptions",
      value: function getTemplateOptions() {
        return this.opts.template;
      }
    }, {
      key: "getLabelOpts",
      value: function getLabelOpts() {
        return ___default['default'].merge(this.opts, {
          colors: true,
          adjustColor: true,
          transparent: true
        });
      }
    }]);

    return TextMode;
  }(Mode);

  defineProperty(TextMode, "id", 'TX');

  TextMode.prototype.id = 'TX';
  TextMode.prototype.name = 'Text mode';
  TextMode.prototype.shortName = 'Text';
  TextMode.prototype.depGroups = ['TextLabelsGeo'];

  var modes = new EntityList([LinesMode, LicoriceMode, BallsAndSticksMode, VanDerWaalsMode, TraceMode, TubeMode, CartoonMode, QuickSurfaceMode, IsoSurfaceSASMode, IsoSurfaceSESMode, ContactSurfaceMode, TextMode]);

  function clamp(x, a, b) {
    return x <= b ? x < 0 ? 0 : x : b;
  }

  function lerpColor(c1, c2, alpha) {
    var beta = 1 - alpha;
    var r1 = c1 >> 16 & 0xff;
    var g1 = c1 >> 8 & 0xff;
    var b1 = c1 & 0xff;
    var r2 = c2 >> 16 & 0xff;
    var g2 = c2 >> 8 & 0xff;
    var b2 = c2 & 0xff;
    var r = beta * r1 + alpha * r2;
    var g = beta * g1 + alpha * g2;
    var b = beta * b1 + alpha * b2;
    return r << 16 | g << 8 | b;
  }

  var Palette = /*#__PURE__*/function () {
    function Palette(name, id) {
      classCallCheck(this, Palette);

      this.name = name || 'Custom';
      this.id = id || 'CP';
    }

    createClass(Palette, [{
      key: "getElementColor",
      value: function getElementColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.elementColors[name];
        return color === undefined && !asIs ? this.defaultElementColor : color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.residueColors[name];
        return color === undefined && !asIs ? this.defaultResidueColor : color;
      }
    }, {
      key: "getChainColor",
      value: function getChainColor(name) {
        var chain = name.charCodeAt(0);
        chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1F) % this.chainColors.length;
        return this.chainColors[chain];
      }
    }, {
      key: "getSecondaryColor",
      value: function getSecondaryColor(type) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.secondaryColors[type];
        return color === undefined && !asIs ? this.defaultSecondaryColor : color;
      }
    }, {
      key: "getSequentialColor",
      value: function getSequentialColor(index) {
        var colors = this.colors;
        var len = colors.length;
        return index < 0 ? colors[index % len + len] : colors[index % len];
      }
    }, {
      key: "getGradientColor",
      value: function getGradientColor(value, gradientName) {
        var gradient = this.gradients[gradientName];

        if (!gradient) {
          return this.defaultNamedColor;
        }

        var count = gradient.length;
        var index = value * (count - 1);
        var left = Math.floor(index);
        var right = clamp(left + 1, 0, count - 1);
        left = clamp(left, 0, count - 1);
        return lerpColor(gradient[left], gradient[right], index - left);
      }
    }, {
      key: "getNamedColor",
      value: function getNamedColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.namedColors[name];
        return color === undefined && !asIs ? this.defaultNamedColor : color;
      }
    }]);

    return Palette;
  }();

  ___default['default'].assign(Palette.prototype, {
    colors: [0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0x808080],
    minRangeColor: 0x000000,
    midRangeColor: 0x7F7F7F,
    maxRangeColor: 0xFFFFFF,
    defaultElementColor: 0xFFFFFF,
    elementColors: {},
    defaultResidueColor: 0xFFFFFF,
    residueColors: {},
    chainColors: [0xFFFFFF],
    defaultSecondaryColor: 0xFFFFFF,
    secondaryColors: {},
    defaultGradientColor: 0x000000,
    defaultNamedColor: 0xFFFFFF,
    namedColorsArray: [
    /* eslint-disable no-multi-spaces */
    ['indianred', 0xcd5c5c], ['lightcoral', 0xf08080], ['salmon', 0xfa8072], ['darksalmon', 0xe9967a], ['lightsalmon', 0xffa07a], ['crimson', 0xdc143c], ['red', 0xff0000], ['firebrick', 0xb22222], ['darkred', 0x8b0000], ['pink', 0xffc0cb], ['lightpink', 0xffb6c1], ['hotpink', 0xff69b4], ['deeppink', 0xff1493], ['mediumvioletred', 0xc71585], ['palevioletred', 0xdb7093], ['coral', 0xff7f50], ['tomato', 0xff6347], ['orangered', 0xff4500], ['darkorange', 0xff8c00], ['orange', 0xffa500], ['gold', 0xffd700], ['yellow', 0xffff00], ['lightyellow', 0xffffe0], ['lemonchiffon', 0xfffacd], ['lightgoldenrodyellow', 0xfafad2], ['papayawhip', 0xffefd5], ['moccasin', 0xffe4b5], ['peachpuff', 0xffdab9], ['palegoldenrod', 0xeee8aa], ['khaki', 0xf0e68c], ['darkkhaki', 0xbdb76b], ['lavender', 0xe6e6fa], ['thistle', 0xd8bfd8], ['plum', 0xdda0dd], ['violet', 0xee82ee], ['orchid', 0xda70d6], ['fuchsia', 0xff00ff], ['magenta', 0xff00ff], ['mediumorchid', 0xba55d3], ['mediumpurple', 0x9370db], ['rebeccapurple', 0x663399], ['blueviolet', 0x8a2be2], ['darkviolet', 0x9400d3], ['darkorchid', 0x9932cc], ['darkmagenta', 0x8b008b], ['purple', 0x800080], ['indigo', 0x4b0082], ['slateblue', 0x6a5acd], ['mediumslateblue', 0x7b68ee], ['darkslateblue', 0x483d8b], ['greenyellow', 0xadff2f], ['chartreuse', 0x7fff00], ['lawngreen', 0x7cfc00], ['lime', 0x00ff00], ['limegreen', 0x32cd32], ['palegreen', 0x98fb98], ['lightgreen', 0x90ee90], ['mediumspringgreen', 0x00fa9a], ['springgreen', 0x00ff7f], ['mediumseagreen', 0x3cb371], ['seagreen', 0x2e8b57], ['forestgreen', 0x228b22], ['green', 0x008000], ['darkgreen', 0x006400], ['yellowgreen', 0x9acd32], ['olivedrab', 0x6b8e23], ['olive', 0x808000], ['darkolivegreen', 0x556b2f], ['mediumaquamarine', 0x66cdaa], ['darkseagreen', 0x8fbc8f], ['lightseagreen', 0x20b2aa], ['darkcyan', 0x008b8b], ['teal', 0x008080], ['aqua', 0x00ffff], ['cyan', 0x00ffff], ['lightcyan', 0xe0ffff], ['paleturquoise', 0xafeeee], ['aquamarine', 0x7fffd4], ['turquoise', 0x40e0d0], ['mediumturquoise', 0x48d1cc], ['darkturquoise', 0x00ced1], ['cadetblue', 0x5f9ea0], ['steelblue', 0x4682b4], ['lightsteelblue', 0xb0c4de], ['powderblue', 0xb0e0e6], ['lightblue', 0xadd8e6], ['skyblue', 0x87ceeb], ['lightskyblue', 0x87cefa], ['deepskyblue', 0x00bfff], ['dodgerblue', 0x1e90ff], ['cornflowerblue', 0x6495ed], ['royalblue', 0x4169e1], ['blue', 0x0000ff], ['mediumblue', 0x0000cd], ['darkblue', 0x00008b], ['navy', 0x000080], ['midnightblue', 0x191970], ['cornsilk', 0xfff8dc], ['blanchedalmond', 0xffebcd], ['bisque', 0xffe4c4], ['navajowhite', 0xffdead], ['wheat', 0xf5deb3], ['burlywood', 0xdeb887], ['tan', 0xd2b48c], ['rosybrown', 0xbc8f8f], ['sandybrown', 0xf4a460], ['goldenrod', 0xdaa520], ['darkgoldenrod', 0xb8860b], ['peru', 0xcd853f], ['chocolate', 0xd2691e], ['saddlebrown', 0x8b4513], ['sienna', 0xa0522d], ['brown', 0xa52a2a], ['maroon', 0x800000], ['white', 0xffffff], ['snow', 0xfffafa], ['honeydew', 0xf0fff0], ['mintcream', 0xf5fffa], ['azure', 0xf0ffff], ['aliceblue', 0xf0f8ff], ['ghostwhite', 0xf8f8ff], ['whitesmoke', 0xf5f5f5], ['seashell', 0xfff5ee], ['beige', 0xf5f5dc], ['oldlace', 0xfdf5e6], ['floralwhite', 0xfffaf0], ['ivory', 0xfffff0], ['antiquewhite', 0xfaebd7], ['linen', 0xfaf0e6], ['lavenderblush', 0xfff0f5], ['mistyrose', 0xffe4e1], ['gainsboro', 0xdcdcdc], ['lightgray', 0xd3d3d3], ['silver', 0xc0c0c0], ['darkgray', 0xa9a9a9], ['gray', 0x808080], ['dimgray', 0x696969], ['lightslategray', 0x778899], ['slategray', 0x708090], ['darkslategray', 0x2f4f4f], ['black', 0x000000]
    /* eslint-enable no-multi-spaces */
    ],
    namedColors: {},

    /* eslint-enable no-magic-numbers */
    gradients: {
      rainbow: [0x0000ff, // blue
      0x00ffff, // cyan
      0x00ff00, // green
      0xffff00, // yellow
      0xff0000 // red
      ],
      temp: [0x0000ff, // blue
      0x007fff, // light-blue
      0xffffff, // white
      0xff7f00, // orange
      0xff0000 // red
      ],
      hot: [0xffffff, // white
      0xff7f00, // orange
      0xff0000 // red
      ],
      cold: [0xffffff, // white
      0x007fff, // light-blue
      0x0000ff // blue
      ],
      'blue-red': [0x0000ff, // blue
      0xffffff, // white
      0xff0000 // red
      ],
      reds: [0xffffff, // white
      0xff0000 // red
      ],
      blues: [0xffffff, // white
      0x0000ff // blue
      ]
    }
  });

  var _Palette$prototype = Palette.prototype,
      namedColorsArray = _Palette$prototype.namedColorsArray,
      namedColors = _Palette$prototype.namedColors;

  for (var i = 0, length = namedColorsArray.length; i < length; ++i) {
    var _namedColorsArray$i = slicedToArray(namedColorsArray[i], 2),
        name = _namedColorsArray$i[0],
        value = _namedColorsArray$i[1];

    namedColors[name] = value;
  }

  var palette = new Palette('CPK', 'CP'); // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    C: 0x202020,
    N: 0x2060FF,
    O: 0xEE2010,
    F: 0x00FF00,
    P: 0x8020FF,
    S: 0xFFFF00,
    CL: 0x00BB00,
    FE: 0xD0D0D0,
    CO: 0xD0D0D0,
    NI: 0xD0D0D0,
    CU: 0xD0D0D0,
    BR: 0x008800,
    I: 0x005500
    /* eslint-enable no-magic-numbers */

  };

  var _palette$secondaryCol;
  var palette$1 = new Palette('Jmol', 'JM');
  palette$1.colors = [
  /* eslint-disable no-magic-numbers */
  0x0000FF, // blue
  0x0055FF, //
  0x00ABFF, //
  0x00FFFF, // cyan
  0x00FFAB, //
  0x00FF55, //
  0x00FF00, // green
  0x55FF00, //
  0xABFF00, //
  0xFFFF00, // yellow
  0xFFAB00, //
  0xFF5500, //
  0xFF0000, // red
  0xFF0055, //
  0xFF00AB, //
  0xFF00FF, // magenta
  0xAB00FF, //
  0x5500FF //

  /* eslint-enable no-magic-numbers */
  ]; // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette$1.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    D: 0xFFFFC0,
    T: 0xFFFFA0,
    HE: 0xD9FFFF,
    LI: 0xCC80FF,
    BE: 0xC2FF00,
    B: 0xFFB5B5,
    C: 0x909090,
    N: 0x3050F8,
    O: 0xFF0D0D,
    F: 0x90E050,
    NE: 0xB3E3F5,
    NA: 0xAB5CF2,
    MG: 0x8AFF00,
    AL: 0xBFA6A6,
    SI: 0xF0C8A0,
    P: 0xFF8000,
    S: 0xFFFF30,
    CL: 0x1FF01F,
    AR: 0x80D1E3,
    K: 0x8F40D4,
    CA: 0x3DFF00,
    SC: 0xE6E6E6,
    TI: 0xBFC2C7,
    V: 0xA6A6AB,
    CR: 0x8A99C7,
    MN: 0x9C7AC7,
    FE: 0xE06633,
    CO: 0xF090A0,
    NI: 0x50D050,
    CU: 0xC88033,
    ZN: 0x7D80B0,
    GA: 0xC28F8F,
    GE: 0x668F8F,
    AS: 0xBD80E3,
    SE: 0xFFA100,
    BR: 0xA62929,
    KR: 0x5CB8D1,
    RB: 0x702EB0,
    SR: 0x00FF00,
    Y: 0x94FFFF,
    ZR: 0x94E0E0,
    NB: 0x73C2C9,
    MO: 0x54B5B5,
    TC: 0x3B9E9E,
    RU: 0x248F8F,
    RH: 0x0A7D8C,
    PD: 0x006985,
    AG: 0xC0C0C0,
    CD: 0xFFD98F,
    IN: 0xA67573,
    SN: 0x668080,
    SB: 0x9E63B5,
    TE: 0xD47A00,
    I: 0x940094,
    XE: 0x429EB0,
    CS: 0x57178F,
    BA: 0x00C900,
    LA: 0x70D4FF,
    CE: 0xFFFFC7,
    PR: 0xD9FFC7,
    ND: 0xC7FFC7,
    PM: 0xA3FFC7,
    SM: 0x8FFFC7,
    EU: 0x61FFC7,
    GD: 0x45FFC7,
    TB: 0x30FFC7,
    DY: 0x1FFFC7,
    HO: 0x00FF9C,
    ER: 0x00E675,
    TM: 0x00D452,
    YB: 0x00BF38,
    LU: 0x00AB24,
    HF: 0x4DC2FF,
    TA: 0x4DA6FF,
    W: 0x2194D6,
    RE: 0x267DAB,
    OS: 0x266696,
    IR: 0x175487,
    PT: 0xD0D0E0,
    AU: 0xFFD123,
    HG: 0xB8B8D0,
    TL: 0xA6544D,
    PB: 0x575961,
    BI: 0x9E4FB5,
    PO: 0xAB5C00,
    AT: 0x754F45,
    RN: 0x428296,
    FR: 0x420066,
    RA: 0x007D00,
    AC: 0x70ABFA,
    TH: 0x00BAFF,
    PA: 0x00A1FF,
    U: 0x008FFF,
    NP: 0x0080FF,
    PU: 0x006BFF,
    AM: 0x545CF2,
    CM: 0x785CE3,
    BK: 0x8A4FE3,
    CF: 0xA136D4,
    ES: 0xB31FD4,
    FM: 0xB31FBA,
    MD: 0xB30DA6,
    NO: 0xBD0D87,
    LR: 0xC70066,
    RF: 0xCC0059,
    DB: 0xD1004F,
    SG: 0xD90045,
    BH: 0xE00038,
    HS: 0xE6002E,
    MT: 0xEB0026
    /* eslint-enable no-magic-numbers */

  };
  palette$1.defaultResidueColor = 0xBEA06E; // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

  palette$1.residueColors = {
    /* eslint-disable no-magic-numbers */
    ALA: 0xC8C8C8,
    ARG: 0x145AFF,
    ASN: 0x00DCDC,
    ASP: 0xE60A0A,
    CYS: 0xE6E600,
    GLN: 0x00DCDC,
    GLU: 0xE60A0A,
    GLY: 0xEBEBEB,
    HIS: 0x8282D2,
    ILE: 0x0F820F,
    LEU: 0x0F820F,
    LYS: 0x145AFF,
    MET: 0xE6E600,
    PHE: 0x3232AA,
    PRO: 0xDC9682,
    SER: 0xFA9600,
    THR: 0xFA9600,
    TRP: 0xB45AB4,
    TYR: 0x3232AA,
    VAL: 0x0F820F,
    A: 0xA0A0FF,
    C: 0xFF8C4B,
    G: 0xFF7070,
    I: 0x80FFFF,
    T: 0xA0FFA0,
    U: 0xFF8080,
    DA: 0xA0A0FF,
    DC: 0xFF8C4B,
    DG: 0xFF7070,
    DI: 0x80FFFF,
    DT: 0xA0FFA0,
    DU: 0xFF8080,
    '+A': 0xA0A0FF,
    '+C': 0xFF8C4B,
    '+G': 0xFF7070,
    '+I': 0x80FFFF,
    '+T': 0xA0FFA0,
    '+U': 0xFF8080
    /* eslint-enable no-magic-numbers */

  };
  palette$1.chainColors = [// ' '->0 'A'->1, 'B'->2
  0xFFffffff, // ' ' & '0' white
  //
  0xFFC0D0FF, // skyblue
  0xFFB0FFB0, // pastel green
  0xFFFFC0C8, // pink
  0xFFFFFF80, // pastel yellow
  0xFFFFC0FF, // pastel magenta
  0xFFB0F0F0, // pastel cyan
  0xFFFFD070, // pastel gold
  0xFFF08080, // lightcoral
  0xFFF5DEB3, // wheat
  0xFF00BFFF, // deepskyblue
  0xFFCD5C5C, // indianred
  0xFF66CDAA, // mediumaquamarine
  0xFF9ACD32, // yellowgreen
  0xFFEE82EE, // violet
  0xFF00CED1, // darkturquoise
  0xFF00FF7F, // springgreen
  0xFF3CB371, // mediumseagreen
  0xFF00008B, // darkblue
  0xFFBDB76B, // darkkhaki
  0xFF006400, // darkgreen
  0xFF800000, // maroon
  0xFF808000, // olive
  0xFF800080, // purple
  0xFF008080, // teal
  0xFFB8860B, // darkgoldenrod
  0xFFB22222 // firebrick
  ];
  var StructuralElementType$3 = StructuralElement.Type;
  palette$1.secondaryColors = (_palette$secondaryCol = {}, defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_ALPHA, 0xFF0080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_PI, 0x600080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_310, 0xA00080), defineProperty(_palette$secondaryCol, StructuralElementType$3.STRAND, 0xFFC800), defineProperty(_palette$secondaryCol, StructuralElementType$3.TURN, 0x6080FF), defineProperty(_palette$secondaryCol, "dna", 0xAE00FE), defineProperty(_palette$secondaryCol, "rna", 0xFD0162), _palette$secondaryCol);

  var _palette$secondaryCol$1;
  var palette$2 = new Palette('VMD', 'VM');
  palette$2.colors = [
  /* eslint-disable no-magic-numbers */
  0x0000FF, // blue
  0xFF0000, // red
  0x606060, // gray
  0xFF8000, // orange
  0xFFFF00, // yellow
  0x808033, // tan
  0x999999, // silver
  0x00FF00, // green
  0xFFFFFF, // white
  0xFF9999, // pink
  0x40C0C0, // cyan
  0xA600A6, // purple
  0x80E666, // lime
  0xE666B3, // mauve
  0x804D00, // ochre
  0x8080C0 // ice blue

  /* eslint-enable no-magic-numbers */
  ];
  palette$2.defaultElementColor = 0x804D00; // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.

  palette$2.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 0xFFFFFF,
    C: 0x40BFBF,
    N: 0x0000FF,
    O: 0xFF0000,
    P: 0x808033,
    S: 0xFFFF00
    /* eslint-enable no-magic-numbers */

  };
  palette$2.defaultResidueColor = 0x40C0C0; // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.

  palette$2.residueColors = {
    /* eslint-disable no-magic-numbers */
    ALA: 0x0000FF,
    ARG: 0xFFFFFF,
    ASN: 0x808033,
    ASP: 0xFF0000,
    CYS: 0xFFFF00,
    GLN: 0xFF8000,
    GLU: 0xFF9999,
    GLY: 0xFFFFFF,
    HIS: 0x40C0C0,
    ILE: 0x00FF00,
    LEU: 0xFF9999,
    LYS: 0x40C0C0,
    MET: 0xFFFF00,
    PHE: 0xA600A6,
    PRO: 0x804C00,
    SER: 0xFFFF00,
    THR: 0xE666B3,
    TRP: 0x999999,
    TYR: 0x00FF00,
    VAL: 0x808033,
    A: 0x0000FF,
    C: 0xFF8000,
    G: 0xFFFF00,
    T: 0xA600A6,
    U: 0x00FF00,
    DA: 0x0000FF,
    DC: 0xFF8000,
    DG: 0xFFFF00,
    DT: 0xA600A6,
    DU: 0x00FF00,
    '+A': 0x0000FF,
    '+C': 0xFF8000,
    '+G': 0xFFFF00,
    '+T': 0xA600A6,
    '+U': 0x00FF00,
    WAT: 0x40C0C0,
    H2O: 0x40C0C0,
    HOH: 0x40C0C0
    /* eslint-enable no-magic-numbers */

  };
  palette$2.chainColors = [0xFFFFFF].concat(palette$2.colors);
  var StructuralElementType$4 = StructuralElement.Type;
  palette$2.secondaryColors = (_palette$secondaryCol$1 = {}, defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_ALPHA, 0xA600A6), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_310, 0x0000FF), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_PI, 0xFF0000), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.STRAND, 0xFFFF00), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.BRIDGE, 0x808033), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.TURN, 0x40C0C0), _palette$secondaryCol$1);

  var palettes = new EntityList([palette, palette$1, palette$2]);

  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
   *
   * @exports Colorer
   * @this Colorer
   * @abstract
   * @constructor
   * @classdesc Basic class for all available coloring algorithms used for building and displaying molecule geometry.
   */

  var Colorer = /*#__PURE__*/function () {
    function Colorer(opts) {
      classCallCheck(this, Colorer);

      if (this.constructor === Colorer) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Colorer options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.opts = ___default['default'].merge(utils.deriveDeep(settings.now.colorers[this.id], true), opts);
      /**
       * Palette in use.
       * @type {Palette}
       */

      this.palette = palettes.first;
    }
    /**
     * Get Colorer identification, probably with options.
     * @returns {string|Array} Colorer identifier string ({@link Colorer#id}) or two-element array containing both colorer
     *   identifier and options ({@link Colorer#opts}).
     * Options are returned if they were changed during or after colorer creation.
     */


    createClass(Colorer, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, settings.now.colorers[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }]);

    return Colorer;
  }();
  /**
   * Colorer identifier.
   * @type {string}
   */


  Colorer.prototype.id = '__';

  function _createSuper$1h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1i(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Element
   *
   * @exports ElementColorer
   * @augments Colorer
   * @constructor
   * @classdesc Coloring algorithm based on chemical element.
   */

  var ElementColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ElementColorer, _Colorer);

    var _super = _createSuper$1h(ElementColorer);

    function ElementColorer() {
      classCallCheck(this, ElementColorer);

      return _super.apply(this, arguments);
    }

    createClass(ElementColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var type = atom.element.name;

        if (type === 'C' && this.opts.carbon >= 0) {
          return this.opts.carbon;
        }

        return this.palette.getElementColor(type);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ElementColorer;
  }(Colorer);

  defineProperty(ElementColorer, "id", 'EL');

  ElementColorer.prototype.id = 'EL';
  ElementColorer.prototype.name = 'Element';
  ElementColorer.prototype.shortName = 'Element';

  function _createSuper$1i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1j(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Coloring algorithm based on residue type.
   *
   * @see ResidueType
   *
   * @exports ResidueTypeColorer
   * @constructor
   */

  var ResidueTypeColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ResidueTypeColorer, _Colorer);

    var _super = _createSuper$1i(ResidueTypeColorer);

    function ResidueTypeColorer() {
      classCallCheck(this, ResidueTypeColorer);

      return _super.apply(this, arguments);
    }

    createClass(ResidueTypeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getResidueColor(residue._type._name);
      }
    }]);

    return ResidueTypeColorer;
  }(Colorer);

  defineProperty(ResidueTypeColorer, "id", 'RT');

  ResidueTypeColorer.prototype.id = 'RT';
  ResidueTypeColorer.prototype.name = 'Residue Type';
  ResidueTypeColorer.prototype.shortName = 'Residue';

  function _createSuper$1j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1k(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SequenceColorer = /*#__PURE__*/function (_Colorer) {
    inherits(SequenceColorer, _Colorer);

    var _super = _createSuper$1j(SequenceColorer);

    function SequenceColorer() {
      classCallCheck(this, SequenceColorer);

      return _super.apply(this, arguments);
    }

    createClass(SequenceColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var chain = residue._chain;

        if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
          return this.palette.defaultNamedColor;
        }

        var min = chain.minSequence;
        var max = chain.maxSequence > min ? chain.maxSequence : min + 1;
        return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
      }
    }]);

    return SequenceColorer;
  }(Colorer);

  defineProperty(SequenceColorer, "id", 'SQ');

  SequenceColorer.prototype.id = 'SQ';
  SequenceColorer.prototype.name = 'Sequence';
  SequenceColorer.prototype.shortName = 'Sequence';

  function _createSuper$1k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1l(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ChainColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ChainColorer, _Colorer);

    var _super = _createSuper$1k(ChainColorer);

    function ChainColorer() {
      classCallCheck(this, ChainColorer);

      return _super.apply(this, arguments);
    }

    createClass(ChainColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getChainColor(residue.getChain()._name);
      }
    }]);

    return ChainColorer;
  }(Colorer);

  defineProperty(ChainColorer, "id", 'CH');

  ChainColorer.prototype.id = 'CH';
  ChainColorer.prototype.name = 'Chain';
  ChainColorer.prototype.shortName = 'Chain';

  function _createSuper$1l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1m(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var SecondaryStructureColorer = /*#__PURE__*/function (_Colorer) {
    inherits(SecondaryStructureColorer, _Colorer);

    var _super = _createSuper$1l(SecondaryStructureColorer);

    function SecondaryStructureColorer() {
      classCallCheck(this, SecondaryStructureColorer);

      return _super.apply(this, arguments);
    }

    createClass(SecondaryStructureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        if (residue._type.flags & ResidueType.Flags.DNA) {
          return this.palette.getSecondaryColor('dna');
        }

        if (residue._type.flags & ResidueType.Flags.RNA) {
          return this.palette.getSecondaryColor('rna');
        }

        var secondary = residue.getSecondary();

        if (secondary) {
          var color = this.palette.getSecondaryColor(secondary.type, true);

          if (color === undefined) {
            color = this.palette.getSecondaryColor(secondary.generic);
          }

          return color;
        }

        return this.palette.defaultSecondaryColor;
      }
    }]);

    return SecondaryStructureColorer;
  }(Colorer);

  defineProperty(SecondaryStructureColorer, "id", 'SS');

  SecondaryStructureColorer.prototype.id = 'SS';
  SecondaryStructureColorer.prototype.name = 'Secondary Structure';
  SecondaryStructureColorer.prototype.shortName = 'Structure';

  function _createSuper$1m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1n(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var UniformColorer = /*#__PURE__*/function (_Colorer) {
    inherits(UniformColorer, _Colorer);

    var _super = _createSuper$1m(UniformColorer);

    function UniformColorer() {
      classCallCheck(this, UniformColorer);

      return _super.apply(this, arguments);
    }

    createClass(UniformColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(_atom, _complex) {
        return this.opts.color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return UniformColorer;
  }(Colorer);

  defineProperty(UniformColorer, "id", 'UN');

  UniformColorer.prototype.id = 'UN';
  UniformColorer.prototype.name = 'Uniform';
  UniformColorer.prototype.shortName = 'Uniform';

  function _createSuper$1n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1o(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @exports ConditionalColorer
   * @augments Colorer
   * @constructor
   * @classdesc Bicolor coloring algorithm based on a selector string used as a condition.
   */

  var ConditionalColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ConditionalColorer, _Colorer);

    var _super = _createSuper$1n(ConditionalColorer);

    function ConditionalColorer(opts) {
      var _this;

      classCallCheck(this, ConditionalColorer);

      _this = _super.call(this, opts);
      var parsed = selectors.parse(_this.opts.subset);
      _this._subsetCached = parsed.error ? selectors.none() : parsed.selector;
      return _this;
    }

    createClass(ConditionalColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var subset = this._subsetCached;
        var atoms = residue._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (!subset.includesAtom(atoms[i])) {
            return this.opts.baseColor;
          }
        }

        return this.opts.color;
      }
    }]);

    return ConditionalColorer;
  }(Colorer);

  defineProperty(ConditionalColorer, "id", 'CO');

  ConditionalColorer.prototype.id = 'CO';
  ConditionalColorer.prototype.name = 'Conditional';
  ConditionalColorer.prototype.shortName = 'Conditional';

  function _createSuper$1o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1p(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ConformationColorer = /*#__PURE__*/function (_Colorer) {
    inherits(ConformationColorer, _Colorer);

    var _super = _createSuper$1o(ConformationColorer);

    function ConformationColorer() {
      classCallCheck(this, ConformationColorer);

      return _super.apply(this, arguments);
    }

    createClass(ConformationColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this.palette.getChainColor(String.fromCharCode(atom.location));
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ConformationColorer;
  }(Colorer);

  defineProperty(ConformationColorer, "id", 'CF');

  ConformationColorer.prototype.id = 'CF';
  ConformationColorer.prototype.name = 'Conformation';
  ConformationColorer.prototype.shortName = 'Conformation';

  function _createSuper$1p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Temperature
   *
   * @exports TemperatureColorer
   * @augments Colorer
   * @constructor
   * @classdesc Coloring algorithm based on temperature of chemical element.
   */

  var TemperatureColorer = /*#__PURE__*/function (_Colorer) {
    inherits(TemperatureColorer, _Colorer);

    var _super = _createSuper$1p(TemperatureColorer);

    function TemperatureColorer() {
      classCallCheck(this, TemperatureColorer);

      return _super.apply(this, arguments);
    }

    createClass(TemperatureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        var factor = 1;

        if (atom.temperature && opts) {
          if (opts.min === opts.max) {
            factor = atom.temperature > opts.max ? 1 : 0;
          } else {
            factor = (atom.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;

        if (!opts) {
          return this.palette.defaultGradientColor;
        }

        if (residue.temperature) {
          var factor = 0;

          if (opts.min === opts.max) {
            factor = residue.temperature > opts.max ? 1 : 0;
          } else {
            factor = (residue.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }]);

    return TemperatureColorer;
  }(Colorer);

  defineProperty(TemperatureColorer, "id", 'TM');

  TemperatureColorer.prototype.id = 'TM'; // [T]e[M]perature

  TemperatureColorer.prototype.name = 'Temperature';
  TemperatureColorer.prototype.shortName = 'Temperature';

  function _createSuper$1q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1r(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @see Occupancy
   *
   * @exports OccupancyColorer
   * @augments Occupancy
   * @constructor
   * @classdesc Coloring algorithm based on occupancy of chemical element.
   */

  var OccupancyColorer = /*#__PURE__*/function (_Colorer) {
    inherits(OccupancyColorer, _Colorer);

    var _super = _createSuper$1q(OccupancyColorer);

    function OccupancyColorer() {
      classCallCheck(this, OccupancyColorer);

      return _super.apply(this, arguments);
    }

    createClass(OccupancyColorer, [{
      key: "_getColorByOccupancy",
      value: function _getColorByOccupancy(occupancy, opts) {
        if (occupancy !== undefined) {
          var factor = 1 - occupancy;
          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(atom.occupancy, opts);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(residue.occupancy, opts);
      }
    }]);

    return OccupancyColorer;
  }(Colorer);

  defineProperty(OccupancyColorer, "id", 'OC');

  OccupancyColorer.prototype.id = 'OC'; // [OC]cupancy

  OccupancyColorer.prototype.name = 'Occupancy';
  OccupancyColorer.prototype.shortName = 'Occupancy';

  function _createSuper$1r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1s(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var HydrophobicityColorer = /*#__PURE__*/function (_Colorer) {
    inherits(HydrophobicityColorer, _Colorer);

    var _super = _createSuper$1r(HydrophobicityColorer);

    function HydrophobicityColorer() {
      classCallCheck(this, HydrophobicityColorer);

      return _super.apply(this, arguments);
    }

    createClass(HydrophobicityColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var color = this.palette.defaultResidueColor;

        if (residue._type.hydrophobicity !== undefined) {
          // Kyte Doolitle hydro [-4.5,4.5]->[0.1]
          var min = -4.5;
          var max = 4.5;
          color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
        }

        return color;
      }
    }]);

    return HydrophobicityColorer;
  }(Colorer);

  defineProperty(HydrophobicityColorer, "id", 'HY');

  HydrophobicityColorer.prototype.id = 'HY';
  HydrophobicityColorer.prototype.name = 'Hydrophobicity';
  HydrophobicityColorer.prototype.shortName = 'Hydrophobicity';

  function _createSuper$1s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1t(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var MoleculeColorer = /*#__PURE__*/function (_Colorer) {
    inherits(MoleculeColorer, _Colorer);

    var _super = _createSuper$1s(MoleculeColorer);

    function MoleculeColorer() {
      classCallCheck(this, MoleculeColorer);

      return _super.apply(this, arguments);
    }

    createClass(MoleculeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var molecule = residue._molecule;

        var count = _complex.getMoleculeCount();

        if (count > 1) {
          return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
        }

        return this.palette.getGradientColor(0, this.opts.gradient);
      }
    }]);

    return MoleculeColorer;
  }(Colorer);

  defineProperty(MoleculeColorer, "id", 'MO');

  MoleculeColorer.prototype.id = 'MO';
  MoleculeColorer.prototype.name = 'Molecule';
  MoleculeColorer.prototype.shortName = 'Molecule';

  function _createSuper$1t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1u(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function scaleColor(c, factor) {
    var r1 = c >> 16 & 0xff;
    var g1 = c >> 8 & 0xff;
    var b1 = c & 0xff;
    var r = factor * r1;
    var g = factor * g1;
    var b = factor * b1;
    return r << 16 | g << 8 | b;
  }
  /**
   * Create new colorer.
   *
   * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
   *
   * @exports CarbonColorer
   * @augments Colorer
   * @constructor
   * @classdesc Bicolor coloring algorithm based on selection carbon atoms.
   */


  var CarbonColorer = /*#__PURE__*/function (_Colorer) {
    inherits(CarbonColorer, _Colorer);

    var _super = _createSuper$1t(CarbonColorer);

    function CarbonColorer() {
      classCallCheck(this, CarbonColorer);

      return _super.apply(this, arguments);
    }

    createClass(CarbonColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var colorCarbon = this.opts.color;
        var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
        return atom.flags & Atom.Flags.CARBON ? colorCarbon : colorNotCarbon;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return CarbonColorer;
  }(Colorer);

  defineProperty(CarbonColorer, "id", 'CB');

  CarbonColorer.prototype.id = 'CB';
  CarbonColorer.prototype.name = 'Carbon';
  CarbonColorer.prototype.shortName = 'Carbon';

  var colorers = new EntityList([ElementColorer, ResidueTypeColorer, SequenceColorer, ChainColorer, SecondaryStructureColorer, UniformColorer, ConditionalColorer, ConformationColorer, TemperatureColorer, OccupancyColorer, HydrophobicityColorer, MoleculeColorer, CarbonColorer]);

  function neutralColor(intensity) {
    return new THREE.Color(intensity, intensity, intensity);
  }

  var materialList = [{
    id: 'DF',
    name: 'Diffuse',
    shortName: 'Diffuse',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'SF',
    name: 'Soft Plastic',
    shortName: 'Soft',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.1),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'PL',
    name: 'Glossy Plastic',
    shortName: 'Glossy',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.28),
      shininess: 100,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'ME',
    name: 'Metal',
    shortName: 'Metal',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.55),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TR',
    name: 'Transparent',
    shortName: 'Transparent',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'GL',
    name: 'Glass',
    shortName: 'Glass',
    uberOptions: {
      diffuse: neutralColor(0.50),
      specular: neutralColor(0.65),
      shininess: 100,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'BA',
    name: 'Backdrop',
    shortName: 'Backdrop',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: false,
      depthWrite: false,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TN',
    name: 'Toon',
    shortName: 'Toon',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: true
    }
  }, {
    id: 'FL',
    name: 'Flat',
    shortName: 'Flat',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 0,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: true,
      depthWrite: true,
      transparent: false
    }
  }];
  var materials = new EntityList(materialList);

  /**
   * Utils functions which is worked with meshes
   *
   * functions for doing something with all/specified meshes
   * functions for traversihg tree and create auxiliary meshes for transparency/shadowmaps...
   * functions for calculating data connected with meshes
   */

  function _gatherObjects(root, meshTypes) {
    var meshes = [];
    root.traverse(function (object) {
      for (var i = 0; i < meshTypes.length; i++) {
        if (object instanceof meshTypes[i]) {
          meshes[meshes.length] = object;
          break;
        }
      }
    });
    return meshes;
  } // new mesh with the same geometry and specified material values and layer


  function createDerivativeMesh(mesh, values, layer) {
    var material = mesh.material.createInstance();
    material.setValues(values);
    var newMesh = new mesh.constructor(mesh.geometry, material);
    newMesh.material.needsUpdate = true;
    newMesh.applyMatrix4(mesh.matrix);
    newMesh.layers.set(layer);
    return newMesh;
  }

  function traverseMeshes(root, meshTypes, func) {
    var meshes = _gatherObjects(root, meshTypes);

    for (var i = 0, n = meshes.length; i < n; ++i) {
      var mesh = meshes[i];

      if (!mesh.parent) {
        continue;
      }

      func(mesh);
    }
  }

  function applyTransformsToMeshes(root, mtc) {
    var mtcCount = mtc.length;

    if (mtcCount < 1) {
      return;
    }

    var meshTypes = [THREE.Mesh, THREE.LineSegments, THREE.Line];
    traverseMeshes(root, meshTypes, function (mesh) {
      mesh.applyMatrix4(mtc[0]);

      for (var j = 1; j < mtcCount; ++j) {
        var newMesh = new mesh.constructor(mesh.geometry, mesh.material);
        mesh.parent.add(newMesh);
        newMesh.applyMatrix4(mtc[j]);
      }
    });
  }

  var processTransparentMaterial = function () {
    var matValues = {
      prepassTransparancy: true,
      fakeOpacity: false,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        mesh.material.setValues({
          prepassTransparancy: false,
          fakeOpacity: false
        });
        mesh.material.needsUpdate = true;
        mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
        var prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
        mesh.parent.add(prepassTranspMesh);
      });
    };
  }();

  var processColFromPosMaterial = function () {
    var matValues = {
      colorFromPos: true,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false,
      overrideColor: false,
      fogTransparent: false,
      attrColor: false,
      attrColor2: false,
      attrAlphaColor: false,
      fakeOpacity: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        var colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
        mesh.parent.add(colFromPosMesh);
      });
    };
  }();

  var createShadowmapMaterial = function () {
    var matValues = {
      colorFromDepth: true,
      orthoCam: true,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
        if (!mesh.receiveShadow && mesh.material.shadowmap) {
          // remove shadow from non-receivers
          mesh.material.setValues({
            shadowmap: false
          });
        }

        if (!mesh.material.lights) {
          // skip creating shadowmap meshes for materials without lighting
          return;
        }

        if (!mesh.castShadow) {
          // skip creating shadowmap meshes for non-casters
          return;
        }

        if (!gfxutils.belongToSelectLayers(mesh)) {
          // skip creating shadowmap meshes for selection layer
          return;
        }

        var shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
        shadowmapMesh.isShadowmapMesh = true;
        mesh.parent.add(shadowmapMesh);
      });
    };
  }();

  function removeShadowmapMaterial(root, material) {
    if (!(material instanceof UberMaterial)) {
      return;
    }

    traverseMeshes(root, [THREE.Mesh, THREE.LineSegments], function (mesh) {
      if (mesh.isShadowmapMesh) {
        mesh.parent.remove(mesh);
      }
    });
  }

  function forEachMeshInGroup(group, process) {
    function processObj(object) {
      if (object instanceof THREE.Mesh) {
        process(object);
      }

      for (var i = 0, l = object.children.length; i < l; i++) {
        processObj(object.children[i]);
      }
    }

    processObj(group);
  }

  function _countMeshTriangles(mesh) {
    var geom = mesh.geometry;

    if (geom instanceof THREE.InstancedBufferGeometry) {
      var attribs = geom.attributes;

      for (var property in attribs) {
        if (attribs.hasOwnProperty(property) && attribs[property] instanceof THREE.InstancedBufferAttribute) {
          var currAttr = attribs[property];
          var indexSize = geom.index ? geom.index.array.length / 3 : 0;
          return indexSize * currAttr.array.length / currAttr.itemSize;
        }
      }

      return 0;
    }

    if (geom instanceof THREE.BufferGeometry) {
      return geom.index ? geom.index.array.length / 3 : 0;
    }

    return geom.faces ? geom.faces.length : 0;
  }

  function countTriangles(group) {
    var totalCount = 0;
    forEachMeshInGroup(group, function (mesh) {
      totalCount += _countMeshTriangles(mesh);
    });
    return totalCount;
  }

  var meshutils = {
    applyTransformsToMeshes: applyTransformsToMeshes,
    processTransparentMaterial: processTransparentMaterial,
    processColFromPosMaterial: processColFromPosMaterial,
    createShadowmapMaterial: createShadowmapMaterial,
    removeShadowmapMaterial: removeShadowmapMaterial,
    forEachMeshInGroup: forEachMeshInGroup,
    countTriangles: countTriangles
  };

  var selectors$2 = chem.selectors;

  var Representation = /*#__PURE__*/function () {
    function Representation(index, mode, colorer, selector) {
      classCallCheck(this, Representation);

      var startMaterialValues = {
        clipPlane: settings.now.draft.clipPlane,
        fogTransparent: settings.now.bg.transparent,
        shadowmap: settings.now.shadow.on,
        shadowmapType: settings.now.shadow.type
      };
      this.index = index;
      this.mode = mode;
      this.colorer = colorer;
      this.selector = selector;
      this.selectorString = '';
      this.count = 0;
      this.material = new UberMaterial();
      this.material.setValues(startMaterialValues);
      this.material.setUberOptions({
        fogAlpha: settings.now.fogAlpha
      });
      this.materialPreset = materials.first;
      this.needsRebuild = true;
      this.visible = true; // apply mode params & preset

      this.setMode(mode);
    }

    createClass(Representation, [{
      key: "markAtoms",
      value: function markAtoms(complex) {
        this.count = complex.markAtoms(this.selector, 1 << this.index);
        this.needsRebuild = true;
        return this.count;
      }
    }, {
      key: "unmarkAtoms",
      value: function unmarkAtoms(complex) {
        complex.clearAtomBits(1 << this.index);
        this.count = 0;
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        this.mode = mode;
      }
    }, {
      key: "setMaterialPreset",
      value: function setMaterialPreset(preset) {
        this.materialPreset = preset;
        this.material.setUberOptions(preset.uberOptions);
        this.material.setValues(preset.values);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.geo = null;
        this.selectionGeo = null;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex) {
        this.reset();
        this.needsRebuild = false;

        if (settings.now.ao) {
          this.material.setValues({
            normalsToGBuffer: settings.now.ao
          });
        }

        this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);

        if (this.material.uberOptions.opacity < 0.99 && settings.now.transparency === 'prepass') {
          meshutils.processTransparentMaterial(this.geo, this.material);
        }

        this.geo.visible = this.visible;
        gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
        meshutils.processColFromPosMaterial(this.geo, this.material);

        if (settings.now.shadow.on) {
          meshutils.createShadowmapMaterial(this.geo, this.material);
        }

        return this.geo;
      }
    }, {
      key: "buildSelectionGeometry",
      value: function buildSelectionGeometry(mask) {
        var sg = null;

        if (this.geo && 'getSubset' in this.geo) {
          var meshes = this.geo.getSubset(mask);

          if (meshes && meshes.length > 0) {
            sg = new THREE.Group();
            sg.matrixAutoUpdate = false;
            sg.matrix = this.geo.matrix;

            for (var j = 0; j < meshes.length; j++) {
              var m = meshes[j];
              sg.add(m);
            }
          }
        }

        if (sg) {
          sg.visible = this.visible;
        }

        this.selectionGeo = sg;
        return this.selectionGeo;
      }
      /**
       * Create object that represents difference between current and another rep
       * anotherRep could be undefined. In this case everything is reported.
       */

    }, {
      key: "compare",
      value: function compare(repSettings) {
        var diff = {};
        var selStr = String(this.selector);

        if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
          diff.selector = selStr;
        }

        var modeDiff = this.mode.identify();

        if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
          diff.mode = modeDiff;
        }

        var colorerDiff = this.colorer.identify();

        if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
          diff.colorer = colorerDiff;
        }

        if (!repSettings || this.materialPreset.id !== repSettings.material) {
          diff.material = this.materialPreset.id;
        }

        return diff;
      }
      /**
       * Change representation. Write fields what was changed into new object, return it.
       */

    }, {
      key: "change",
      value: function change(repSettings, complex, mode, color) {
        var diff = {}; // modify selector

        if (repSettings.selector) {
          var newSelectorObject = selectors$2.parse(repSettings.selector).selector;
          var newSelector = String(newSelectorObject);

          if (this.selectorString !== newSelector) {
            diff.selector = newSelector;
            this.selectorString = newSelector;
            this.selector = newSelectorObject;
            this.markAtoms(complex);
          }
        } // modify mode


        if (repSettings.mode) {
          var newMode = repSettings.mode;

          if (!___default['default'].isEqual(this.mode.identify(), newMode)) {
            diff.mode = newMode;
            this.setMode(mode);
          }
        } // modify colorer


        if (repSettings.colorer) {
          var newColorer = repSettings.colorer;

          if (!___default['default'].isEqual(this.colorer.identify(), newColorer)) {
            diff.colorer = newColorer;
            this.colorer = color;
          }
        } // modify material


        if (repSettings.material) {
          var newMaterial = repSettings.material;

          if (!___default['default'].isEqual(this.materialPreset.id, newMaterial)) {
            diff.material = newMaterial;
            this.setMaterialPreset(materials.get(repSettings.material));
          }
        }

        return diff;
      }
    }, {
      key: "show",
      value: function show(visible) {
        this.visible = visible;

        if (this.geo) {
          this.geo.visible = visible;
        }

        if (this.selectionGeo) {
          this.selectionGeo.visible = visible;
        }
      }
    }]);

    return Representation;
  }();

  function _createSuper$1u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1v(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _traverseComponentGroups(root, component, callback) {
    var children = root.children;

    if (!children) {
      return;
    }

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];

      if (child._component === component) {
        callback(child);
      }

      if (child instanceof gfxutils.RCGroup) {
        _traverseComponentGroups(child, component, callback);
      }
    }
  }

  function ComplexEditor() {}

  var ComplexComponentEditor = /*#__PURE__*/function (_ComplexEditor) {
    inherits(ComplexComponentEditor, _ComplexEditor);

    var _super = _createSuper$1u(ComplexComponentEditor);

    function ComplexComponentEditor(complexVisual) {
      var _this;

      classCallCheck(this, ComplexComponentEditor);

      _this = _super.call(this);
      _this._complexVisual = complexVisual;
      _this._inProgress = false;
      return _this;
    }

    createClass(ComplexComponentEditor, [{
      key: "begin",
      value: function begin() {
        var complex = this._complexVisual.getComplex(); // init component matrices


        this._componentTransforms = [];

        for (var i = 0; i < complex._components.length; ++i) {
          var component = complex._components[i];
          this._componentTransforms[component._index] = new THREE.Object3D();
        }

        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var complex = this._complexVisual.getComplex();

        for (var i = 0; i < complex._components.length; ++i) {
          this._bakeComponentTransform(complex._components[i]);
        }

        complex.onAtomPositionChanged();

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE.Vector3(0, 0, 0)
        };
        var visual = this._complexVisual;
        var component = visual.getSelectedComponent();

        if (component === null) {
          return res;
        }

        var selection = this._complexVisual.getSelectionGeo();

        var selectionMask = 1 << visual.getSelectionBit();
        var i;
        var j;
        var reprNode;
        var geo; // find all geo nodes for this component

        _traverseComponentGroups(visual, component, function (child) {
          res.objects.push(child);
        }); // find all selection nodes for this component


        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component') && geo._component === component) {
              res.objects.push(geo);
            }
          }
        } // add dummy object that stores component transformation


        res.objects.push(this._componentTransforms[component._index]);
        var bbmin = new THREE.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var bbmax = new THREE.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        component.forEachResidue(function (residue) {
          var atoms = residue._atoms;

          for (j = 0; j < atoms.length; ++j) {
            if (atoms[j].mask & selectionMask) {
              bbmin.min(atoms[j].position);
              bbmax.max(atoms[j].position);
            }
          }
        });
        res.pivot.lerpVectors(bbmin, bbmax, 0.5);
        return res;
      }
    }, {
      key: "_bakeComponentTransform",
      value: function _bakeComponentTransform(component) {
        var t = this._componentTransforms[component._index];

        if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {
          t.updateMatrix();
          component.forEachResidue(function (residue) {
            var atoms = residue._atoms;

            for (var j = 0; j < atoms.length; ++j) {
              atoms[j].position.applyMatrix4(t.matrix);
            }
          });
        }
      }
    }, {
      key: "_resetComponentTransform",
      value: function _resetComponentTransform() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var i;
        var j;
        var reprNode;
        var geo;

        for (i = 0; i < this._componentTransforms.length; ++i) {
          geo = this._componentTransforms[i];
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        } // reset all geo nodes


        for (i = 0; i < visual.children.length; ++i) {
          reprNode = visual.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        } // reset all selection nodes


        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        }
      }
    }]);

    return ComplexComponentEditor;
  }(ComplexEditor);

  var ComplexFragmentEditor = /*#__PURE__*/function (_ComplexEditor2) {
    inherits(ComplexFragmentEditor, _ComplexEditor2);

    var _super2 = _createSuper$1u(ComplexFragmentEditor);

    function ComplexFragmentEditor(complexVisual) {
      var _this2;

      classCallCheck(this, ComplexFragmentEditor);

      _this2 = _super2.call(this);
      _this2._complexVisual = complexVisual;
      _this2._inProgress = false;
      return _this2;
    }

    createClass(ComplexFragmentEditor, [{
      key: "begin",
      value: function begin() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var atoms = this._getSelectionBorderAtoms();

        if (atoms.length < 1 || atoms.length > 2) {
          logger.error('Can only edit fragments with one or two bound atoms.');
          return false;
        }

        this._fragmentBoundAtoms = atoms;
        var selectionMask = 1 << visual.getSelectionBit(); // hide selected fragment in main model

        visual.disableSubset(selectionMask, true); // hide selection geo in main model

        for (var k = 0; k < selection.children.length; ++k) {
          selection.children[k].visible = false;
        } // create visible fragment representation to rotate


        var pivotPos = atoms[0].position.clone();

        if (atoms.length === 2) {
          pivotPos.lerp(atoms[1].position, 0.5);
        }

        this._fragmentGeo = new THREE.Group();
        visual.add(this._fragmentGeo);

        this._fragmentGeo.position.copy(pivotPos);

        this._fragmentSelectionGeo = new THREE.Group();
        selection.add(this._fragmentSelectionGeo);

        this._fragmentSelectionGeo.position.copy(pivotPos);

        var offset = pivotPos.clone();
        offset.negate();

        for (var i = 0; i < visual.children.length; ++i) {
          var g = visual.children[i];

          if (!('getSubset' in g)) {
            continue;
          }

          var vg = new THREE.Group();

          this._fragmentGeo.add(vg);

          var sg = new THREE.Group();

          this._fragmentSelectionGeo.add(sg);

          var meshes = g.getSubset(selectionMask, true);

          for (var j = 0; j < meshes.length; j++) {
            var m = meshes[j];
            vg.add(m);
            m.position.copy(offset);
          }

          var smeshes = g.getSubset(selectionMask, true);

          for (var h = 0; h < smeshes.length; h++) {
            var sm = smeshes[h];
            sg.add(sm);
            sm.position.copy(offset);
          }
        }

        gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;
        var selectionBit = visual.getSelectionBit();
        var p = this._fragmentGeo.position;

        var m = this._fragmentGeo.matrix.clone();

        m.multiply(new THREE.Matrix4().makeTranslation(-p.x, -p.y, -p.z));

        this._bakeAtomTransform(m, 1 << selectionBit); // show selected fragment in main model


        visual.enableSubset(1 << selectionBit, true);
        visual.getComplex().onAtomPositionChanged();
        visual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        this._fragmentGeo.parent.remove(this._fragmentGeo); // show selected fragment in main model


        visual.enableSubset(1 << visual.getSelectionBit(), true); // show selection geo in main model (+ remove fragment selection geo)

        for (var i = 0; i < selection.children.length; ++i) {
          var node = selection.children[i];

          if (node.visible) {
            selection.remove(node);
          } else {
            node.visible = true;
          }
        }

        visual.finalizeEdit();
      }
    }, {
      key: "isFreeRotationAllowed",
      value: function isFreeRotationAllowed() {
        return this._fragmentBoundAtoms.length < 2;
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE.Vector3(0, 0, 0)
        };
        res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
        var boundAtoms = this._fragmentBoundAtoms;

        if (boundAtoms.length === 1) {
          if (boundAtoms[0].bonds.length === 1) {
            // single external bond allows rotation about bond axis
            var bond = boundAtoms[0].bonds[0];
            res.axis = new THREE.Vector3().subVectors(bond._right.position, bond._left.position);
            res.axis.normalize();
            res.axis.transformDirection(this._complexVisual.matrixWorld);
          }
        } else if (boundAtoms.length === 2) {
          // two bound atoms allow rotation only about axis running through their centers
          res.axis = new THREE.Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
          res.axis.normalize();
          res.axis.transformDirection(this._complexVisual.matrixWorld);
        }

        return res;
      }
    }, {
      key: "_getSelectionBorderAtoms",
      value: function _getSelectionBorderAtoms() {
        var complex = this._complexVisual.getComplex();

        var selectionMask = 1 << this._complexVisual.getSelectionBit();

        var atomHash = {};
        complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              atomHash[bond._left.index] = 1;
            }
          } else if (bond._right.mask & selectionMask) {
            atomHash[bond._right.index] = 1;
          }
        });
        var atoms = [];
        var keys = Object.keys(atomHash);

        for (var i = 0, n = keys.length; i < n; ++i) {
          var idx = keys[i];
          atoms.push(complex._atoms[idx]);
        }

        return atoms;
      }
    }, {
      key: "_bakeAtomTransform",
      value: function _bakeAtomTransform(matrix, mask) {
        this._complexVisual.getComplex().forEachAtom(function (atom) {
          if (atom.mask & mask) {
            atom.position.applyMatrix4(matrix);
          }
        });
      }
    }]);

    return ComplexFragmentEditor;
  }(ComplexEditor);

  var ComplexVisualEdit = {
    ComponentEditor: ComplexComponentEditor,
    FragmentEditor: ComplexFragmentEditor
  };

  function _createSuper$1v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1w(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$3 = chem.selectors;

  function lookupAndCreate(entityList, specs) {
    if (!Array.isArray(specs)) {
      specs = [specs];
    }

    var _specs = specs,
        _specs2 = slicedToArray(_specs, 2),
        id = _specs2[0],
        opts = _specs2[1];

    var Entity = entityList.get(id) || entityList.first;
    return new Entity(opts);
  }

  var ComplexVisual = /*#__PURE__*/function (_Visual) {
    inherits(ComplexVisual, _Visual);

    var _super = _createSuper$1v(ComplexVisual);

    function ComplexVisual(name, dataSource) {
      var _this;

      classCallCheck(this, ComplexVisual);

      _this = _super.call(this, name, dataSource);
      _this._complex = dataSource;
      /** @type {Representation[]} */

      _this._reprList = [];
      /** @type {?Representation} */

      _this._repr = null;
      _this._reprListChanged = true;
      _this._selectionBit = 0;
      _this._reprUsedBits = 0;
      _this._selectionCount = 0;
      _this._selectionGeometry = new THREE.Group();
      return _this;
    }

    createClass(ComplexVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._complex.getBoundaries();
      }
    }, {
      key: "release",
      value: function release() {
        if (this._selectionGeometry.parent) {
          this._selectionGeometry.remove(this._selectionGeometry);
        }

        Visual.prototype.release.call(this);
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getSelectionCount",
      value: function getSelectionCount() {
        return this._selectionCount;
      }
    }, {
      key: "getSelectionGeo",
      value: function getSelectionGeo() {
        return this._selectionGeometry;
      }
    }, {
      key: "getSelectionBit",
      value: function getSelectionBit() {
        return this._selectionBit;
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        return this._editor;
      }
    }, {
      key: "resetReps",
      value: function resetReps(reps) {
        // Create all necessary representations
        if (this._complex) {
          this._complex.clearAtomBits(~0);
        }

        this._reprListChanged = true;
        this._reprUsedBits = 0;
        this._reprList.length = reps.length;

        for (var i = 0, n = reps.length; i < n; ++i) {
          var rep = reps[i];
          var selector = void 0;
          var selectorString = void 0;

          if (typeof rep.selector === 'string') {
            selectorString = rep.selector;

            var _selectors$parse = selectors$3.parse(selectorString);

            selector = _selectors$parse.selector;
          } else if (typeof rep.selector === 'undefined') {
            selectorString = settings.now.presets["default"][0].selector;

            var _selectors$parse2 = selectors$3.parse(selectorString);

            selector = _selectors$parse2.selector;
          } else {
            selector = rep.selector;
            selectorString = selector.toString();
          }

          var mode = lookupAndCreate(modes, rep.mode);
          var colorer = lookupAndCreate(colorers, rep.colorer);
          var material = materials.get(rep.material) || materials.first;
          this._reprList[i] = new Representation(i, mode, colorer, selector);

          this._reprList[i].setMaterialPreset(material);

          this._reprList[i].selectorString = selectorString;

          if (this._complex) {
            this._complex.markAtoms(selector, 1 << i);
          }

          this._reprUsedBits |= 1 << i;
        }

        this._repr = reps.length > 0 ? this._reprList[0] : null;
        this._selectionBit = reps.length;
        this._reprUsedBits |= 1 << this._selectionBit; // selection uses one bit

        this._selectionCount = 0;

        if (this._complex) {
          this._complex.update();
        }
      }
      /**
       * Get number of representations created so far.
       * @returns {number} Number of reps.
       */

    }, {
      key: "repCount",
      value: function repCount() {
        return this._reprList.length;
      }
      /**
       * Get or set the current representation index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @returns {number} The current index.
       */

    }, {
      key: "repCurrent",
      value: function repCurrent(index) {
        if (index >= 0 && index < this._reprList.length) {
          this._repr = this._reprList[index];
        } else {
          index = this._reprList.indexOf(this._repr);
        }

        return index;
      }
      /**
       * Get or set representation by index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @param {object=} rep - Optional representation description.
       * @param {string=} rep.selector - Selector string.
       * @param {string=} rep.mode - Mode id.
       * @param {string=} rep.colorer - Colorer id.
       * @param {string=} rep.material - Material id.
       * @returns {Object} {desc, index, status} field desc contains rep description, index - index of correspondent rep,
       * status - one of three strings: 'created', 'changed', ''. 'created' means new rep was created during this function,
       * 'changed' - rep was changed during this function. '' - something else.
       */

    }, {
      key: "rep",
      value: function rep(index, _rep) {
        // if index is missing then it is the current
        if (!_rep && (index === undefined || index instanceof Object)) {
          _rep = index;
          index = this.repCurrent();
        } // fail if out of bounds


        if (index < 0 || index > this._reprList.length) {
          logger.error("Rep ".concat(index, " does not exist!"));
          return null;
        } // a special case of adding just after the end


        if (index === this._reprList.length) {
          var res = this.repAdd(_rep);
          logger.warn("Rep ".concat(index, " does not exist! New representation was created."));
          return {
            desc: res.desc,
            index: index,
            status: 'created'
          };
        } // gather description


        var target = this._reprList[index];
        var desc = {
          selector: target.selectorString,
          mode: target.mode.identify(),
          colorer: target.colorer.identify(),
          material: target.materialPreset.id
        }; // modification is requested

        if (_rep) {
          // modify
          var diff = target.change(_rep, this._complex, lookupAndCreate(modes, _rep.mode), lookupAndCreate(colorers, _rep.colorer)); // something was changed

          if (!___default['default'].isEmpty(diff)) {
            target.needsRebuild = true;

            for (var key in diff) {
              if (diff.hasOwnProperty(key)) {
                desc[key] = diff[key];
                logger.debug("rep[".concat(index, "].").concat(key, " changed to ").concat(diff[key]));
              }
            } // safety trick: lower resolution for surface modes


            if (diff.mode && target.mode.isSurface && (settings.now.resolution === 'ultra' || settings.now.resolution === 'high')) {
              logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
              settings.set('resolution', 'medium');
            }

            return {
              desc: desc,
              index: index,
              status: 'changed'
            };
          }
        }

        return {
          desc: desc,
          index: index,
          status: ''
        };
      }
      /**
       * Get representation (not just description) by index.
       * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
       * @returns {?object} Representation.
       */

    }, {
      key: "repGet",
      value: function repGet(index) {
        // if index is missing then it is the current
        if (index === undefined || index instanceof Object) {
          index = this.repCurrent();
        } // fail if out of bounds


        if (index < 0 || index >= this._reprList.length) {
          return null;
        }

        return this._reprList[index];
      }
    }, {
      key: "_getFreeReprIdx",
      value: function _getFreeReprIdx() {
        var bits = this._reprUsedBits;

        for (var i = 0; i <= ComplexVisual.NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
          if ((bits & 1) === 0) {
            return i;
          }
        }

        return -1;
      }
      /**
       * Add new representation.
       * @param {object=} rep - Representation description.
       * @returns {Object} {desc, index} field desc contains added rep description, index - index of this rep.
       */

    }, {
      key: "repAdd",
      value: function repAdd(rep) {
        if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
          return null;
        }

        var newSelectionBit = this._getFreeReprIdx();

        if (newSelectionBit < 0) {
          return null; // no more slots for representations
        }

        var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit); // Fill in default values

        var def = settings.now.presets["default"][0];

        var desc = ___default['default'].merge({
          selector: def.selector,
          mode: def.mode,
          colorer: def.colorer,
          material: def.material
        }, rep);

        var selector = typeof desc.selector === 'string' ? selectors$3.parse(desc.selector).selector : desc.selector;
        var target = new Representation(this._selectionBit, lookupAndCreate(modes, desc.mode), lookupAndCreate(colorers, desc.colorer), selector);
        target.selectorString = selector.toString();
        target.setMaterialPreset(materials.get(desc.material));
        target.markAtoms(this._complex);

        this._reprList.push(target); // change selection bit


        this._selectionBit = newSelectionBit;
        this._reprUsedBits |= 1 << this._selectionBit; // restore selection using new selection bit

        this._complex.markAtoms(originalSelection, 1 << this._selectionBit);

        return {
          desc: desc,
          index: this._reprList.length - 1
        };
      }
      /**
       * Remove representation.
       * @param {number=} index - Zero-based representation index.
       */

    }, {
      key: "repRemove",
      value: function repRemove(index) {
        if (index === undefined) {
          index = this.repCurrent();
        } // catch out of bounds case


        var count = this._reprList.length;

        if (index < 0 || index >= count || count <= 1) {
          // do not allow to remove the single rep
          return;
        }

        var target = this._reprList[index];
        target.unmarkAtoms(this._complex);
        this._reprUsedBits &= ~(1 << target.index);

        this._reprList.splice(index, 1); // update current rep


        if (target === this._repr) {
          --count;
          index = index < count ? index : count - 1;
          this._repr = this._reprList[index];
        }

        this._reprListChanged = true;
      }
      /**
       * Hide representation.
       * @param {number} index - Zero-based representation index.
       * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
       */

    }, {
      key: "repHide",
      value: function repHide(index, hide) {
        if (hide === undefined) {
          hide = true;
        } // fail if out of bounds


        if (index < 0 || index >= this._reprList.length) {
          return;
        }

        var target = this._reprList[index];
        target.show(!hide);
      }
      /**
       * Select atoms with selector
       * @param {Selector} selector - selector
       * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
       */

    }, {
      key: "select",
      value: function select(selector, append) {
        if (append) {
          this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
        } else {
          this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
        }

        this._complex.updateStructuresMask();

        this.rebuildSelectionGeometry();
      }
    }, {
      key: "resetSelectionMask",
      value: function resetSelectionMask() {
        if (this._selectionCount !== 0) {
          this._selectionCount = 0;

          if (this._complex) {
            this._complex.clearAtomBits(1 << this._selectionBit);
          }
        }
      }
    }, {
      key: "updateSelectionMask",
      value: function updateSelectionMask(pickedObj) {
        var self = this;
        var atom = pickedObj.atom;
        var residue = pickedObj.residue,
            chain = pickedObj.chain,
            molecule = pickedObj.molecule;
        var setMask = 1 << this._selectionBit;
        var clearMask = ~setMask;

        if (atom) {
          residue = atom.residue;
          chain = residue._chain;
          molecule = residue._molecule;

          if (atom.mask & setMask) {
            atom.mask &= clearMask;
            residue._mask &= clearMask;
            chain._mask &= clearMask;

            if (molecule) {
              molecule.mask &= clearMask;
            }

            this._selectionCount--;
          } else {
            atom.mask |= setMask;
            this._selectionCount++; // select residue if all atoms in it are selected

            residue.collectMask(); // select chain and molecule if all residues in it are selected

            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (residue) {
          chain = residue._chain;
          molecule = residue._molecule;

          if (residue._mask & setMask) {
            residue._mask &= clearMask;
            chain._mask &= clearMask;
            residue.forEachAtom(function (a) {
              if (a.mask & setMask) {
                a.mask &= clearMask;
                self._selectionCount--;
              }
            });
          } else {
            residue._mask |= setMask;
            residue.forEachAtom(function (a) {
              if (!(a.mask & setMask)) {
                a.mask |= setMask;
                self._selectionCount++;
              }
            }); // select chain and molecule if all residues in it are selected

            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (chain || molecule) {
          var obj = chain || molecule;

          if (obj._mask & setMask) {
            obj._mask &= clearMask;
            obj.forEachResidue(function (r) {
              if (r._mask & setMask) {
                r._mask &= clearMask;
                r.forEachAtom(function (a) {
                  if (a.mask & setMask) {
                    a.mask &= clearMask;
                    self._selectionCount--;
                  }
                });
                r._mask &= clearMask;
              }
            });
          } else {
            obj._mask |= setMask;
            obj.forEachResidue(function (r) {
              if (!(r._mask & setMask)) {
                r._mask |= setMask;
                r.forEachAtom(function (a) {
                  if (!(a.mask & setMask)) {
                    a.mask |= setMask;
                    self._selectionCount++;
                  }
                });
                var otherObj = chain ? r.getMolecule() : r.getChain();

                if (otherObj) {
                  otherObj.collectMask();
                }
              }
            });
          }
        } else {
          this.resetSelectionMask();
        }
      }
    }, {
      key: "expandSelection",
      value: function expandSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31; // mark atoms to add

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._right.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._left.mask |= tmpMask;
          }
        }); // select marked atoms


        var deselectionMask = ~tmpMask;

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask = atom.mask & deselectionMask | selectionMask;
            ++self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "shrinkSelection",
      value: function shrinkSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31; // mark atoms neighbouring to unselected ones

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._left.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._right.mask |= tmpMask;
          }
        }); // mark hanging atoms


        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask && atom.bonds.length === 1) {
            atom.mask |= tmpMask;
          }
        }); // deselect marked atoms


        var deselectionMask = ~(selectionMask | tmpMask);

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask &= deselectionMask;
            --self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "getSelectedComponent",
      value: function getSelectedComponent() {
        var selectionMask = 1 << this._selectionBit;
        var component = null;
        var multiple = false; // find which component is selected (exclusively)

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask) {
            if (component === null) {
              component = atom.residue._component;
            } else if (component !== atom.residue._component) {
              multiple = true;
            }
          }
        });

        return multiple ? null : component;
      }
    }, {
      key: "getSelectionCenter",
      value: function getSelectionCenter(center, includesAtom, selRule) {
        center.set(0.0, 0.0, 0.0);
        var count = 0;

        this._complex.forEachAtom(function (atom) {
          if (includesAtom(atom, selRule)) {
            center.add(atom.position);
            count++;
          }
        });

        if (count === 0) {
          return false;
        }

        center.divideScalar(count);
        center.applyMatrix4(this.matrix);
        return true;
      }
    }, {
      key: "needsRebuild",
      value: function needsRebuild() {
        if (this._reprListChanged) {
          return true;
        }

        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          var repr = reprList[i];

          if (repr.needsRebuild) {
            return true;
          }
        }

        return false;
      }
      /**
       * Rebuild molecule geometry asynchronously.
       */

    }, {
      key: "rebuild",
      value: function rebuild() {
        var self = this; // Destroy current geometry

        gfxutils.clearTree(this);
        return new Promise(function (resolve) {
          // Nothing to do?
          var complex = self._complex;

          if (!complex) {
            resolve();
            return;
          }

          var errorOccured = false;
          setTimeout(function () {
            console.time('build');
            var reprList = self._reprList;
            var palette = palettes.get(settings.now.palette) || palettes.first;
            var hasGeometry = false;

            for (var i = 0, n = reprList.length; i < n; ++i) {
              var repr = reprList[i];
              repr.colorer.palette = palette;

              if (repr.needsRebuild) {
                repr.reset();

                try {
                  repr.buildGeometry(complex);
                } catch (e) {
                  if (e instanceof utils.OutOfMemoryError) {
                    repr.needsRebuild = false;
                    repr.reset();
                    logger.error("Not enough memory to build geometry for representation ".concat(repr.index + 1));
                    errorOccured = true;
                  } else {
                    throw e;
                  }
                }
              }

              hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);

              if (repr.geo) {
                self.add(repr.geo);
              }
            }

            self._reprListChanged = false;
            console.timeEnd('build');
            resolve();
          }, 10);
        });
      }
    }, {
      key: "setNeedsRebuild",
      value: function setNeedsRebuild() {
        // invalidate all representations
        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          reprList[i].needsRebuild = true;
        }
      }
    }, {
      key: "rebuildSelectionGeometry",
      value: function rebuildSelectionGeometry() {
        var mask = 1 << this._selectionBit;
        gfxutils.clearTree(this._selectionGeometry);

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var repr = this._reprList[i];
          var sg = repr.buildSelectionGeometry(mask);

          if (!sg) {
            continue;
          }

          this._selectionGeometry.add(sg);

          for (var j = 0; j < sg.children.length; j++) {
            var m = sg.children[j]; // copy component transform (that's not applied yet)
            // TODO make this code obsolete, accessing editor is bad

            if (this._editor && this._editor._componentTransforms) {
              var t = this._editor._componentTransforms[m._component._index];

              if (t) {
                m.position.copy(t.position);
                m.quaternion.copy(t.quaternion);
              }
            }
          }

          gfxutils.applySelectionMaterial(sg);
        }
      }
    }, {
      key: "_buildSelectorFromSortedLists",
      value: function _buildSelectorFromSortedLists(atoms, residues, chains) {
        var complex = this._complex;

        function optimizeList(list) {
          var result = [];
          var k = 0;
          var first = NaN;
          var last = NaN;

          for (var i = 0, n = list.length; i < n; ++i) {
            var value = list[i];

            if (value === last + 1) {
              last = value;
            } else {
              if (!Number.isNaN(first)) {
                result[k++] = new selectors$3.Range(first, last);
              }

              first = last = value;
            }
          }

          if (!Number.isNaN(first)) {
            result[k] = new selectors$3.Range(first, last);
          }

          return result;
        }

        var expression = null;

        if (chains.length === complex._chains.length) {
          expression = selectors$3.all();
        } else {
          var selector;

          if (chains.length > 0) {
            selector = selectors$3.chain(chains);
            expression = expression ? selectors$3.or(expression, selector) : selector; // NOSONAR
          }

          if (Object.keys(residues).length > 0) {
            for (var ch in residues) {
              if (residues.hasOwnProperty(ch)) {
                selector = selectors$3.and(selectors$3.chain(ch), selectors$3.residx(optimizeList(residues[ch])));
                expression = expression ? selectors$3.or(expression, selector) : selector;
              }
            }
          }

          if (atoms.length > 0) {
            selector = selectors$3.serial(optimizeList(atoms));
            expression = expression ? selectors$3.or(expression, selector) : selector;
          }

          if (!expression) {
            expression = selectors$3.none();
          }
        }

        return expression;
      }
    }, {
      key: "buildSelectorFromMask",
      value: function buildSelectorFromMask(mask) {
        var complex = this._complex;
        var chains = [];
        var residues = {};
        var atoms = [];
        complex.forEachChain(function (chain) {
          if (chain._mask & mask) {
            chains.push(chain._name);
          }
        });
        complex.forEachResidue(function (residue) {
          if (residue._mask & mask && !(residue._chain._mask & mask)) {
            var c = residue._chain._name;

            if (!(c in residues)) {
              residues[c] = [residue._index];
            } else {
              residues[c].push(residue._index);
            }
          }
        });
        complex.forEachAtom(function (atom) {
          if (atom.mask & mask && !(atom.residue._mask & mask)) {
            atoms.push(atom.serial);
          }
        });
        return this._buildSelectorFromSortedLists(atoms, residues, chains);
      }
    }, {
      key: "forSelectedResidues",
      value: function forSelectedResidues(process) {
        var selectionMask = 1 << this._selectionBit;

        this._complex.forEachResidue(function (residue) {
          if (residue._mask & selectionMask) {
            process(residue);
          }
        });
      }
    }, {
      key: "beginComponentEdit",
      value: function beginComponentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.ComponentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      }
    }, {
      key: "beginFragmentEdit",
      value: function beginFragmentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.FragmentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      } // should only be called by editors

    }, {
      key: "finalizeEdit",
      value: function finalizeEdit() {
        this._editor = null;
      }
    }, {
      key: "setMaterialValues",
      value: function setMaterialValues(values) {
        var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setValues(values);

          if (needTraverse) {
            rep.geo.traverse(function (object) {
              if (object instanceof THREE.Mesh) {
                object.material.setValues(values);

                if (process !== undefined) {
                  process(object);
                }

                object.material.needsUpdate = true;
              }
            });
          }
        }
      }
    }, {
      key: "setUberOptions",
      value: function setUberOptions(values) {
        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setUberOptions(values);
        }
      }
      /**
       * Build selector that contains all atoms within given distance from group of atoms
       * @param {Selector} selector - selector describing source group of atoms
       * @param {number} radius - distance
       * @returns {Selector} selector describing result group of atoms
       */

    }, {
      key: "within",
      value: function within(selector, radius) {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return false;
        } // mark atoms of the group as selected


        var selectionMask = 1 << this._selectionBit;

        this._complex.markAtoms(selector, selectionMask); // mark all atoms within distance as selected


        if (vw) {
          vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), function (atom) {
            atom.mask |= selectionMask;
          });
        } // update selection count


        this._selectionCount = this._complex.countAtomsByMask(selectionMask); // update secondary structure mask

        this._complex.updateStructuresMask();

        return this.buildSelectorFromMask(selectionMask);
      }
    }]);

    return ComplexVisual;
  }(Visual); // 32 bits = 30 bits for reps + 1 for selection + 1 for selection expansion


  ComplexVisual.NUM_REPRESENTATION_BITS = 30;

  var vertexVolumeFaces = "varying vec3 pos;\n\nvoid main() {\n  // we're assuming local position is in [-0.5, 0.5]\n  // we need to offset it to be represented in RGB\n  pos = position.xyz + 0.5;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";

  var fragmentVolumeFaces = "varying vec3 pos;\n\nvoid main() {\n  gl_FragColor = vec4(pos, 0.5);\n}";

  var vertexVolume = "varying vec4 screenSpacePos;\n\nvoid main() {\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = screenSpacePos;\n}";

  var fragmentVolume = "uniform mat4 projectionMatrix;\n\n// 3D volume texture\nuniform vec3 volumeDim;    // volume dimensions, pixels\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\n\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\n\nuniform vec3 _isoLevel0;\nuniform float _flipV;\nuniform sampler2D _BFLeft;\nuniform sampler2D _BFRight;\nuniform sampler2D _FFLeft;\nuniform sampler2D _FFRight;\nuniform sampler2D _WFFLeft;\nuniform sampler2D _WFFRight;\n\nvarying vec4 screenSpacePos;\n\n#define NO_COLOR vec4(0., 0., 0., 0.)\n\nvec4 sample3DTexture(vec3 texCoord) {\n  // a pair of Z slices is determined by nearest slice border\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\n\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\n\n  // calculate coords in tile texture for both slices\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\n\n  // bilinear filtering\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\n  return mix(colorSlice1, colorSlice2, weightSlice2);\n}\n\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\n  vec3 textCoord = boxCoord;\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\n\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\n    return NO_COLOR;\n\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\n\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\n    return NO_COLOR;\n\n  return sample3DTexture(textCoord);\n}\n\nfloat CalcColor(vec3 iter, vec3 dir) {\n  float d = 1. / 128.;\n  vec3 dx = vec3(d, 0.0, 0.0);\n  vec3 dy = vec3(0.0, d, 0.0);\n  vec3 dz = vec3(0.0, 0.0, d);\n\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\n  vec3 coordInc = mix(\n    vec3(\n      sample3DTextureInclined(iter + dx).x,\n      sample3DTextureInclined(iter + dy).x,\n      sample3DTextureInclined(iter + dz).x\n    ),\n    vec3(0. ,0. , 0.),\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\n  );\n\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\n  vec3 coordDec = mix(\n    vec3(0. ,0. , 0.),\n    vec3(\n      sample3DTextureInclined(iter - dx).x,\n      sample3DTextureInclined(iter - dy).x,\n      sample3DTextureInclined(iter - dz).x\n    ),\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\n  );\n\n  vec3 N = normalize(coordInc - coordDec);\n  float dif = max(0.0, dot(N, dir));\n  return dif;\n}\n\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\n  for (int i = 0; i < 5; i++) {\n    vec3 iterator = 0.5 * (left + right);\n    float vol = sample3DTextureInclined(iterator).r;\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\n      right = iterator;\n    else\n      left = iterator;\n  }\n  return 0.5 * (left + right);\n}\n\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\n  for (int j = 0; j < 5; j++) {\n    vec3 iterator = 0.5 * (left + right);\n    float vol = sample3DTextureInclined(iterator).r;\n    if (vol < tr)\n      right = iterator;\n    else\n      left = iterator;\n  }\n  return 0.5 * (left + right);\n}\n\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\n  vec3 step = stepSize * dir, iterator = start, left, right;\n  vec4 acc = NO_COLOR;\n\n  for (int i = 0; i < STEPS_COUNT; i++) {\n    iterator = iterator + step;\n    vol = sample3DTextureInclined(iterator).r;\n    if (length(iterator - back) <= stepSize || (vol > tr))\n      break;\n  }\n\n  if (vol > tr)\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\n\n  return acc;\n}\n\nfloat easeOut(float x0, float x1, float x) {\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\n  return 1.0 - (1.0 - t) * (1.0 - t);\n}\n\nfloat easeIn(float x0, float x1, float x) {\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\n  return t * t;\n}\n\nvec3 GetColSimple(float vol) {\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\n}\n\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\n  vec4 acc = NO_COLOR, iso;\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\n  vec3 step, col, colOld, right;\n  float tr0 = _isoLevel0.x;\n  float dif, r, kd, finish;\n  int count = 0, stopMol = 0;\n\n  for (int k = 0; k < 3; k++) {\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\n    kd = 140. * tr0 * stepSize;\n    r = 1. - kd;\n    step = stepSize * dir;\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\n      break;\n    iterator = iso.xyz;\n    dif = 1.;// CalcColor(iterator, dir);\n    colOld = GetColSimple(tr0);\n    curStepSize = stepSize;\n    for (int i = 0; i < STEPS_COUNT; i++) {\n      iterator = iterator + step;\n      molD = length(iterator - start);\n      vol = sample3DTextureInclined(iterator).r;\n      finish = distance(iterator, back) - stepSize;\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\n        break;\n      alpha = (1. - r);\n      col = GetColSimple(vol);\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\n      vec3 colMid = GetColSimple(vol);\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\n      colOld = col;\n    } // for i\n\n    if (finish < 0.0 || sumAlpha > 0.97)\n      break;\n\n    if (molD > molDist) {\n      curStepSize = stepSize - (molD - molDist);\n      right = iterator - (molD - molDist) * dir;\n      vol = sample3DTextureInclined(right).r;\n    } else {\n      vec3 left = iterator - step;\n      right = CorrectIso(left, iterator, tr0);\n      curStepSize = distance(left, right);\n      vol = tr0;\n    }\n\n    alpha = (1. - r) * curStepSize / stepSize;\n    dif = 1.;// CalcColor(right, dir);\n    col = GetColSimple(vol);\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\n    vec3 colMid = GetColSimple(vol);\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\n\n    if (molD > molDist)\n      break;\n  } // for k\n  acc.rgb = 1. * sumColor / sumAlpha;\n  acc.a = sumAlpha;\n  return acc;\n}\n\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\n  float stepSize = 1.0 / float(STEPS_COUNT);\n  float len = length(back - start);\n  vec3 step = stepSize * dir;\n  vec3 iterator = start;\n  float acc = 0.0;\n\n  for (int i = 0; i < STEPS_COUNT; i++) {\n    if (float(i) * stepSize > len)\n      break;\n    iterator = iterator + step;\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\n  }\n\n  return vec4(1.,1.,1., acc);\n}\n\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\n  vec4 col = NO_COLOR;\n\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\n    float dif =  CalcColor(tst.xyz, dir);\n    dif = 0.9 * dif * dif;\n    col = vec4(dif, dif, dif, 1);\n  }\n  return col;\n}\n\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\n  return sample3DTexture(start);\n}\n\nvoid main() {\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\n\n  if (_flipV > 0.0) {\n    tc.y = 1.0 - tc.y;\n  }\n\n  vec3 start;\n  vec3 back;\n  vec3 molBack;\n  if (projectionMatrix[0][2] < 0.0) {\n    start = texture2D(_FFLeft, tc.xy).xyz;\n    back = texture2D(_BFLeft, tc.xy).xyz;\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\n  } else {\n    start = texture2D(_FFRight, tc.xy).xyz;\n    back = texture2D(_BFRight, tc.xy).xyz;\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\n  }\n\n  vec3 dir = normalize(back - start);\n\n  float molDist = 2.0;\n  if (length(molBack) > 0.001) {\n    molDist = distance(start, molBack);\n  }\n\n  #ifdef ISO_MODE\n    gl_FragColor = IsoRender(start, back, molDist, dir);\n  #else\n    gl_FragColor = VolRender(start, back, molDist, dir);\n  #endif\n}\n";

  var vertexFarPlane = "varying vec4 volPos;\nuniform float aspectRatio;\nuniform float farZ;\nuniform float tanHalfFOV;\nuniform mat4  matWorld2Volume;\n\nvoid main() {\n  // rescale plane to fill in the whole far plane area seen from camera\n  vec3 pos = position.xyz;\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\n  pos.y = pos.y * tanHalfFOV * farZ;\n  // common transformation\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  // calc pos in volume CS\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\n  // we're assuming local position is in [-0.5, 0.5]\n  // we need to offset it to be represented in RGB\n  volPos = volPos + 0.5;\n  volPos.w = 0.5;\n}\n";

  var fragmentFarPlane = "varying vec4 volPos;\n\nvoid main() {\n  gl_FragColor = volPos;\n}";

  function _createSuper$1w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1x(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var volumeUniforms = THREE.UniformsUtils.merge([{
    volumeDim: {
      type: 'v3',
      value: new THREE.Vector3(512, 512, 512)
    },
    tileTex: {
      type: 't',
      value: null
    },
    tileTexSize: {
      type: 'v2',
      value: new THREE.Vector2(512, 512)
    },
    tileStride: {
      type: 'v2',
      value: new THREE.Vector2(512, 512)
    },
    boxAngles: {
      type: 'v3',
      value: new THREE.Vector3(1, 1, 1)
    },
    delta: {
      type: 'v3',
      value: new THREE.Vector3(0, 0, 0)
    },
    _isoLevel0: {
      type: 'v2',
      value: new THREE.Vector3(0.5, 0.75, 1.0)
    },
    _flipV: {
      type: 'f',
      value: 0.0
    },
    _BFLeft: {
      type: 't',
      value: null
    },
    _BFRight: {
      type: 't',
      value: null
    },
    _FFLeft: {
      type: 't',
      value: null
    },
    _FFRight: {
      type: 't',
      value: null
    },
    _WFFLeft: {
      type: 't',
      value: null
    },
    _WFFRight: {
      type: 't',
      value: null
    }
  }]);

  function overrideUniforms(params, defUniforms) {
    var uniforms = THREE.UniformsUtils.clone(defUniforms);

    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p];
      }
    }

    return uniforms;
  }

  function facesPosMaterialParams(params, sideType) {
    return {
      uniforms: overrideUniforms(params, {}),
      vertexShader: vertexVolumeFaces,
      fragmentShader: fragmentVolumeFaces,
      transparent: false,
      depthTest: false,
      depthWrite: false,
      side: sideType
    };
  }

  var BackFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {
    inherits(BackFacePosMaterial, _THREE$ShaderMaterial);

    var _super = _createSuper$1w(BackFacePosMaterial);

    function BackFacePosMaterial(params) {
      classCallCheck(this, BackFacePosMaterial);

      var backFaceParams = facesPosMaterialParams(params, THREE.BackSide);
      return _super.call(this, backFaceParams);
    }

    return BackFacePosMaterial;
  }(THREE.ShaderMaterial);

  var ShaderParams = function ShaderParams(params, uniforms, vertexShader, fragmentShader) {
    classCallCheck(this, ShaderParams);

    this.uniforms = overrideUniforms(params, uniforms);
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.transparent = false;
    this.depthTest = false;
    this.depthWrite = false;
    this.side = THREE.FrontSide;
  };

  var BackFacePosMaterialFarPlane = /*#__PURE__*/function (_THREE$ShaderMaterial2) {
    inherits(BackFacePosMaterialFarPlane, _THREE$ShaderMaterial2);

    var _super2 = _createSuper$1w(BackFacePosMaterialFarPlane);

    function BackFacePosMaterialFarPlane(params) {
      classCallCheck(this, BackFacePosMaterialFarPlane);

      var matUniforms = THREE.UniformsUtils.merge([{
        aspectRatio: {
          type: 'f',
          value: 0.0
        },
        farZ: {
          type: 'f',
          value: 0.0
        },
        tanHalfFOV: {
          type: 'f',
          value: 0.0
        },
        matWorld2Volume: {
          type: '4fv',
          value: new THREE.Matrix4()
        }
      }]);
      var shaderParams = new ShaderParams(params, matUniforms, vertexFarPlane, fragmentFarPlane);
      return _super2.call(this, shaderParams);
    }

    return BackFacePosMaterialFarPlane;
  }(THREE.ShaderMaterial);

  var FrontFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial3) {
    inherits(FrontFacePosMaterial, _THREE$ShaderMaterial3);

    var _super3 = _createSuper$1w(FrontFacePosMaterial);

    function FrontFacePosMaterial(params) {
      classCallCheck(this, FrontFacePosMaterial);

      var frontFaceParams = facesPosMaterialParams(params, THREE.FrontSide);
      return _super3.call(this, frontFaceParams);
    }

    return FrontFacePosMaterial;
  }(THREE.ShaderMaterial);

  var VolumeMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial4) {
    inherits(VolumeMaterial, _THREE$ShaderMaterial4);

    var _super4 = _createSuper$1w(VolumeMaterial);

    function VolumeMaterial(params) {
      var _this;

      classCallCheck(this, VolumeMaterial);

      var shaderParams = new ShaderParams(params, volumeUniforms, vertexVolume, fragmentVolume);
      shaderParams.transparent = true;
      shaderParams.depthTest = true;
      _this = _super4.call(this, shaderParams);

      _this.updateDefines();

      return _this;
    }

    createClass(VolumeMaterial, [{
      key: "updateDefines",
      value: function updateDefines() {
        this.defines = {
          ISO_MODE: settings.now.modes.VD.isoMode,
          STEPS_COUNT: settings.now.modes.VD.polyComplexity[settings.now.resolution] * 100
        };
        this.needsUpdate = true;
      }
    }]);

    return VolumeMaterial;
  }(THREE.ShaderMaterial);

  var VolumeMaterial$1 = {
    BackFacePosMaterial: BackFacePosMaterial,
    BackFacePosMaterialFarPlane: BackFacePosMaterialFarPlane,
    FrontFacePosMaterial: FrontFacePosMaterial,
    VolumeMaterial: VolumeMaterial
  };

  function _createSuper$1x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeMesh = /*#__PURE__*/function (_THREE$Mesh) {
    inherits(VolumeMesh, _THREE$Mesh);

    var _super = _createSuper$1x(VolumeMesh);

    // data for noise filter
    function VolumeMesh() {
      var _this;

      classCallCheck(this, VolumeMesh);

      var geo = new THREE.BufferGeometry();
      _this = _super.call(this, geo);

      defineProperty(assertThisInitialized(_this), "volumeInfo", {});

      _this.clipPlane = new THREE.Plane();
      var size = new THREE.Vector3(0.5, 0.5, 0.5);
      _this.size = size;
      _this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
      _this.faces = [{
        indices: [],
        norm: new THREE.Vector3(0, 0, -1)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 0, 1)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, -1, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 1, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(-1, 0, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(1, 0, 0)
      }, {
        indices: [],
        norm: new THREE.Vector3(0, 0, 0)
      }];
      _this.vertices = [new THREE.Vector3(-size.x, -size.y, -size.z), new THREE.Vector3(-size.x, size.y, -size.z), new THREE.Vector3(size.x, -size.y, -size.z), new THREE.Vector3(size.x, size.y, -size.z), new THREE.Vector3(-size.x, -size.y, size.z), new THREE.Vector3(-size.x, size.y, size.z), new THREE.Vector3(size.x, -size.y, size.z), new THREE.Vector3(size.x, size.y, size.z), new THREE.Vector3(0.0, 0.0, 0.0), // Placeholder for section
      new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.0, 0.0, 0.0)];
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(_this.vertices.length * 3), 3));
      _this.name = 'VolumeMesh';
      return _this;
    }

    createClass(VolumeMesh, [{
      key: "_updateVertices",
      value: function _updateVertices() {
        // Algorithm:
        // 1. Get plane parameters
        // 2. Compute culling flags for all vertices
        // 3. If intersection occurs => compute from 3 to 6 intersection points
        var corners = VolumeMesh._corners;
        var edges = VolumeMesh._edges;
        var edgeIntersections = VolumeMesh._edgeIntersections;
        var i;
        var norm = this.clipPlane.normal;
        var D = this.clipPlane.constant;
        var vert = this.vertices;
        var size = this.size;
        var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
        var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        var curEdge = new THREE.Vector3();
        var curEdgeInter = null;

        function CheckX() {
          if (norm.x === 0) return 0;
          var x = -(norm.dot(curEdge) + D) / norm.x;

          if (-size.x <= x && x <= size.x) {
            curEdgeInter.set(x, curEdge.y, curEdge.z);
            if (x === size.x) return 2;
            if (x === -size.x) return -2;
            return 1;
          }

          return 0;
        }

        function CheckY() {
          if (norm.y === 0) return 0;
          var y = -(norm.dot(curEdge) + D) / norm.y;

          if (-size.y <= y && y <= size.y) {
            curEdgeInter.set(curEdge.x, y, curEdge.z);
            if (y === size.y) return 2;
            if (y === -size.y) return -2;
            return 1;
          }

          return 0;
        }

        function CheckZ() {
          if (norm.z === 0) return 0;
          var z = -(norm.dot(curEdge) + D) / norm.z;

          if (-size.z <= z && z <= size.z) {
            curEdgeInter.set(curEdge.x, curEdge.y, z);
            if (z === size.z) return 2;
            if (z === -size.z) return -2;
            return 1;
          }

          return 0;
        } // for each edge


        for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
          var curEdgeSource = edges[curEdgeIdx];
          curEdgeInter = edgeIntersections[curEdgeIdx];
          curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
          curEdge.multiply(size); // calculate intersection point

          var flag = 0;
          if (curEdgeSource[2] === 0) flag = CheckX();
          if (curEdgeSource[3] === 0) flag = CheckY();
          if (curEdgeSource[4] === 0) flag = CheckZ(); // mark corresponding corner (if plane cuts through one)

          if (flag === -2) {
            cornerMark[curEdgeSource[0]] = 1;
          } else if (flag === 2) {
            cornerMark[curEdgeSource[1]] = 1;
          } else if (flag === 0) {
            // edge is not intersected by the plane (doesn't produce a vertex)
            edgeMark[curEdgeIdx] = 0;
          }
        }

        var face = {
          indices: [],
          norm: norm.clone().negate()
        };
        var nextVertex = 8; // for each marked corner

        for (i = 0; i < 8; ++i) {
          if (cornerMark[i] === 1) {
            // add corner as vertex to the face
            vert[nextVertex].set(corners[i][0], corners[i][1], corners[i][2]).multiply(size);
            face.indices.push(nextVertex++); // skip adjacent edges

            edgeMark[corners[i][3]] = 0;
            edgeMark[corners[i][4]] = 0;
            edgeMark[corners[i][5]] = 0;
          }
        } // for each edge that has internal intersection


        for (i = 0; i < 12; ++i) {
          if (edgeMark[i] === 1) {
            // add intersection point as vertex to the face
            vert[nextVertex].copy(edgeIntersections[i]);
            face.indices.push(nextVertex++);
          }
        }

        this.faces[6] = face;
        var diff = new THREE.Vector3();
        var coplanarPoint = new THREE.Vector3();
        this.clipPlane.coplanarPoint(coplanarPoint);

        for (i = 0; i < vert.length; ++i) {
          this.cullFlag[i] = false;

          if (i < 8) {
            // corners should be culled by clipping plane
            diff.subVectors(vert[i], coplanarPoint);
            this.cullFlag[i] = norm.dot(diff) >= 0.0;
          } else if (i < 8 + face.indices.length) {
            // cross section vertices don't get culled
            this.cullFlag[i] = true;
          }
        } // write data to vertex buffer


        var positions = this.geometry.getAttribute('position');
        var idx = 0;

        for (i = 0; i < vert.length; ++i) {
          positions.array[idx++] = vert[i].x;
          positions.array[idx++] = vert[i].y;
          positions.array[idx++] = vert[i].z;
        }

        positions.needsUpdate = true;
      }
    }, {
      key: "_collectVertices",
      value: function _collectVertices(face, filter) {
        var i;
        var vert = this.vertices;
        face.indices = [];

        for (i = 0; i < vert.length; ++i) {
          if (this.cullFlag[i] && filter(vert[i])) {
            face.indices.push(i);
          }
        }
      }
    }, {
      key: "_sortIndices",
      value: function _sortIndices(face, right) {
        var i;
        var j;
        var vert = this.vertices;
        var angle = [];
        var dir = new THREE.Vector3();

        for (i = 1; i < face.indices.length; ++i) {
          dir.subVectors(vert[face.indices[i]], vert[face.indices[0]]);
          dir.normalize();
          dir.cross(right);
          dir.negate();
          angle[i] = face.norm.dot(dir);
        } // Exchange sort


        for (i = 1; i < face.indices.length - 1; ++i) {
          for (j = i + 1; j < face.indices.length; ++j) {
            if (angle[j] < angle[i]) {
              // swap
              var t = angle[i];
              angle[i] = angle[j];
              angle[j] = t;
              t = face.indices[i];
              face.indices[i] = face.indices[j];
              face.indices[j] = t;
            }
          }
        }
      }
    }, {
      key: "_updateIndices",
      value: function _updateIndices() {
        // Algorithm:
        // 1. Get plane vertices (from 3 to 6 vertices)
        // 2. Get "right" vector in plane
        // 3. Sort vertices using Graham-like method
        // 4. Create indices
        var i;
        var faceIdx;
        var face;
        var vert = this.vertices;
        var size = this.size;

        this._collectVertices(this.faces[0], function (vertex) {
          return vertex.z === -size.z;
        });

        this._collectVertices(this.faces[1], function (vertex) {
          return vertex.z === size.z;
        });

        this._collectVertices(this.faces[2], function (vertex) {
          return vertex.y === -size.y;
        });

        this._collectVertices(this.faces[3], function (vertex) {
          return vertex.y === size.y;
        });

        this._collectVertices(this.faces[4], function (vertex) {
          return vertex.x === -size.x;
        });

        this._collectVertices(this.faces[5], function (vertex) {
          return vertex.x === size.x;
        });

        var vCenter = new THREE.Vector3();
        var vRight = new THREE.Vector3();
        var vDir = new THREE.Vector3();

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];
          if (face.indices.length === 0) continue;
          vCenter.set(0, 0, 0);

          for (i = 0; i < face.indices.length; ++i) {
            vCenter.add(vert[face.indices[i]]);
          }

          vCenter.multiplyScalar(1.0 / face.indices.length);
          vRight.subVectors(vert[face.indices[0]], vCenter);
          vRight.normalize();
          var rightProj = [];

          for (i = 0; i < face.indices.length; ++i) {
            vDir.subVectors(vert[face.indices[i]], vCenter);
            rightProj[i] = vDir.dot(vRight);
          }

          for (i = 1; i < face.indices.length; ++i) {
            if (rightProj[i] < rightProj[0]) {
              // swap
              var t = rightProj[0];
              rightProj[0] = rightProj[i];
              rightProj[i] = t;

              var _face$indices = slicedToArray(face.indices, 1);

              t = _face$indices[0];
              face.indices[0] = face.indices[i];
              face.indices[i] = t;
            }
          }

          this._sortIndices(face, vRight);
        }

        var numIndices = 0;

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          if (face.indices.length >= 3) {
            numIndices += 3 * (face.indices.length - 2);
          }
        }

        var offset = 0;
        var indices = new Uint16Array(numIndices);

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          for (i = 0; i < face.indices.length - 2; ++i) {
            indices[offset] = face.indices[0]; // eslint-disable-line prefer-destructuring

            indices[offset + 1] = face.indices[i + 1];
            indices[offset + 2] = face.indices[i + 2];
            offset += 3;
          }
        }

        this.geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      }
    }, {
      key: "setDataSource",
      value: function setDataSource(dataSource) {
        var vm = new VolumeMaterial$1.VolumeMaterial();
        var dim = dataSource.getDimensions();
        var stride = dataSource.getTiledTextureStride();
        var texture = dataSource.buildTiledTexture();
        var bbox = dataSource.getBox();
        vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
        vm.uniforms.tileTex.value = texture;
        vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
        vm.uniforms.tileStride.value.set(stride[0], stride[1]);
        Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
        var volInfo = this.volumeInfo;
        vm.uniforms.delta.value.copy(volInfo.delta);
        vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
        this.material = vm;
        bbox.getSize(this.scale);
        bbox.getCenter(this.position);
      }
    }, {
      key: "_updateIsoLevel",
      value: function _updateIsoLevel() {
        var _settings$now$modes$V = settings.now.modes.VD,
            kSigma = _settings$now$modes$V.kSigma,
            kSigmaMed = _settings$now$modes$V.kSigmaMed,
            kSigmaMax = _settings$now$modes$V.kSigmaMax;
        var volInfo = this.volumeInfo;
        var mean = volInfo.dmean - volInfo.dmin;
        var span = volInfo.dmax - volInfo.dmin;

        var level = function level(k) {
          return (mean + k * volInfo.sd) / span;
        };

        this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
      }
    }, {
      key: "rebuild",
      value: function rebuild(camera) {
        var nearClipPlaneOffset = VolumeMesh._nearClipPlaneOffset;
        var pos = VolumeMesh._pos;
        var norm = VolumeMesh._norm;
        var norm4D = VolumeMesh._norm4D;
        var matrixWorldToLocal = VolumeMesh._matrixWorldToLocal;
        var clipPlane = VolumeMesh._clipPlane;

        this._updateIsoLevel(); // get clip plane in local space


        camera.getWorldDirection(norm);
        camera.getWorldPosition(pos);
        pos.addScaledVector(norm, camera.near + nearClipPlaneOffset); // transform pos to local CS

        matrixWorldToLocal.copy(this.matrixWorld).invert();
        pos.applyMatrix4(matrixWorldToLocal); // transform norm to local CS

        norm4D.set(norm.x, norm.y, norm.z, 0.0); // NOTE: use homogeneous norm for proper transformation

        norm4D.applyMatrix4(matrixWorldToLocal);
        norm.copy(norm4D);
        norm.normalize();
        clipPlane.setFromNormalAndCoplanarPoint(norm, pos);

        if (!this.clipPlane.equals(clipPlane)) {
          this.clipPlane = clipPlane.clone();

          this._updateVertices();

          this._updateIndices();
        }
      }
    }]);

    return VolumeMesh;
  }(THREE.Mesh);

  defineProperty(VolumeMesh, "_corners", [// x, y, z, edge1, edge2, edge3
  [-1, -1, -1, 0, 4, 8], [1, -1, -1, 0, 5, 9], [1, 1, -1, 1, 5, 10], [-1, 1, -1, 1, 4, 11], [-1, -1, 1, 2, 6, 8], [1, -1, 1, 2, 7, 9], [1, 1, 1, 3, 7, 10], [-1, 1, 1, 3, 6, 11]]);

  defineProperty(VolumeMesh, "_edges", [// corner1, corner2, center_x, center_y, center_z
  [0, 1, 0, -1, -1], [2, 3, 0, 1, -1], [4, 5, 0, -1, 1], [6, 7, 0, 1, 1], [0, 3, -1, 0, -1], [1, 2, 1, 0, -1], [4, 7, -1, 0, 1], [5, 6, 1, 0, 1], [0, 4, -1, -1, 0], [1, 5, 1, -1, 0], [2, 6, -1, 1, 0], [3, 7, 1, 1, 0]]);

  defineProperty(VolumeMesh, "_edgeIntersections", function () {
    var edgeIntersections = [];

    for (var j = 0; j < 12; ++j) {
      edgeIntersections.push(new THREE.Vector3());
    }

    return edgeIntersections;
  }());

  defineProperty(VolumeMesh, "_nearClipPlaneOffset", 0.2);

  defineProperty(VolumeMesh, "_pos", new THREE.Vector3());

  defineProperty(VolumeMesh, "_norm", new THREE.Vector3());

  defineProperty(VolumeMesh, "_norm4D", new THREE.Vector4());

  defineProperty(VolumeMesh, "_matrixWorldToLocal", new THREE.Matrix4());

  defineProperty(VolumeMesh, "_clipPlane", new THREE.Plane());

  function _flattenArray(input) {
    var n = input.length;
    var output = new Float32Array(n * 3);

    for (var i = 0; i < n; ++i) {
      var j = 3 * i;
      var v = input[i];
      output[j] = v.x;
      output[j + 1] = v.y;
      output[j + 2] = v.z;
    }

    return output;
  }

  var VolumeBounds = /*#__PURE__*/function () {
    function VolumeBounds(bBox, volInfo) {
      classCallCheck(this, VolumeBounds);

      var delta = volInfo.delta; // {x: XY, y : XZ, z: YZ}

      var obtuseAngle = volInfo.obtuseAngle; // 1 - obtuse, 0 - acute

      var bSize = new THREE.Vector3();
      bBox.getSize(bSize);
      bSize.multiplyScalar(0.5);

      var offsetVert = this._getBaseVertices(delta, obtuseAngle);

      var geometry = new THREE.BufferGeometry();
      var vertices = [];

      for (var i = 0; i < 4; i++) {
        vertices.push(offsetVert[i].clone().multiply(bSize));
        vertices.push(offsetVert[(i + 1) % 4].clone().multiply(bSize));
      }

      var translation = new THREE.Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);

      for (var _i = 0; _i < 8; _i++) {
        vertices.push(vertices[_i].clone().add(translation));
      }

      for (var _i2 = 0; _i2 < 4; _i2++) {
        vertices.push(vertices[_i2 * 2].clone());
        vertices.push(vertices[_i2 * 2 + 8].clone());
      }

      var center = new THREE.Vector3();
      bBox.getCenter(center);
      vertices.forEach(function (vertex) {
        return vertex.add(center);
      }); // pivot shift

      var flatVertices = _flattenArray(vertices);

      geometry.setAttribute('position', new THREE.BufferAttribute(flatVertices, 3));
      this._lines = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({
        color: 0xFFFFFF
      }));

      this._lines.layers.set(gfxutils.LAYERS.VOLUME);
    } // Set one edge (4 points) of frame, from which with parallel transfer  the rest of the frame points can be obtained


    createClass(VolumeBounds, [{
      key: "_getBaseVertices",
      value: function _getBaseVertices(delta, obtuseAngle) {
        var projTable = VolumeBounds._projectionTable;

        var proj = function proj(index, inv) {
          // tricky function to take account of projections: their position(related to box) and sign
          var currDelta = delta[projTable[index][0]];
          var angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]]; // inv = 1: alpha; inv = -1: 1 - alpha

          return angleValue * currDelta;
        };

        var offsetVert = [new THREE.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', 1)), -1 + 2 * proj('YZ', 1), -1), new THREE.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', 1)), -1 + 2 * proj('YZ', -1), 1), new THREE.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', -1)), 1 - 2 * proj('YZ', 1), 1), new THREE.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', -1)), 1 - 2 * proj('YZ', -1), -1)];
        return offsetVert;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._lines;
      }
    }]);

    return VolumeBounds;
  }();

  defineProperty(VolumeBounds, "_projectionTable", {
    // corresponds between (origin axes and angles between them) and between saving vector coordinates
    XY: ['x', 2],
    XZ: ['y', 1],
    YZ: ['z', 0]
  });

  // cube. In cut place of cube there is no correct data in BFTexture and volume rendering integral is calculated
  // with errors.
  // Far plane cuts the cube in case of large volume scale (zoom), because farplane doesn't change

  var VolumeFarPlane = /*#__PURE__*/function () {
    // create plane with unit corners coords (for future rescale in vshader according to camera properties)
    function VolumeFarPlane(volume, width, height) {
      classCallCheck(this, VolumeFarPlane);

      var planeGeo = this._initPlaneGeo(width, height);

      var mat = new VolumeMaterial$1.BackFacePosMaterialFarPlane();
      this._plane = new meshes.Mesh(planeGeo, mat);
      this._plane.frustumCulled = false;
      this._plane.doubleSided = true;
      var matWorldToVolume = new THREE.Matrix4();

      this._plane._onBeforeRender = function (_renderer, _scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!volume || !material) {
          return;
        } // count point in world at farplane place


        var planeCamPos = new THREE.Vector4(0, 0, -(camera.far - 0.1), 1);
        planeCamPos.applyMatrix4(camera.matrixWorld); // recalc matrices to make plane be placed as farplane in the World relative to camera

        this.matrix.identity();
        this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
        this.matrixWorld.copy(this.matrix);
        this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix); // build worldToVolume matrix to transform plane into volumeCS (volumeCS coords are written to BackFaceTexture)

        var volumeMatrix = volume.matrixWorld;
        matWorldToVolume.copy(volumeMatrix).invert(); // update material props

        material.uniforms.aspectRatio.value = camera.aspect;
        material.uniforms.farZ.value = camera.far;
        material.uniforms.tanHalfFOV.value = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov);
        material.uniforms.matWorld2Volume.value = matWorldToVolume;
      }; // set it to special layer to draw only into BFTexture


      this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
    }

    createClass(VolumeFarPlane, [{
      key: "_initPlaneGeo",
      value: function _initPlaneGeo(width, height) {
        var planeGeo = new THREE.BufferGeometry();
        width = width || 1;
        height = height || 1;
        var vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
        planeGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
        return planeGeo;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._plane;
      }
    }]);

    return VolumeFarPlane;
  }();

  function _createSuper$1y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeVisual = /*#__PURE__*/function (_Visual) {
    inherits(VolumeVisual, _Visual);

    var _super = _createSuper$1y(VolumeVisual);

    function VolumeVisual(name, dataSource) {
      var _this;

      classCallCheck(this, VolumeVisual);

      _this = _super.call(this, name, dataSource);
      _this._mesh = new VolumeMesh();

      _this._mesh.setDataSource(dataSource);

      _this.add(_this._mesh);

      _this._frame = new VolumeBounds(_this.getBoundaries().boundingBox, _this._mesh.volumeInfo);

      _this.add(_this._frame.getMesh());

      _this.showFrame(settings.now.modes.VD.frame);

      _this._farPlane = new VolumeFarPlane(_this._mesh, 2, 2);

      _this.add(_this._farPlane.getMesh());

      return _this;
    }

    createClass(VolumeVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        var box = this._dataSource.getBox();

        var sphere = new THREE.Sphere();
        box.getBoundingSphere(sphere);
        return {
          boundingBox: box,
          boundingSphere: sphere
        };
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._mesh;
      }
    }, {
      key: "showFrame",
      value: function showFrame(needShow) {
        this._frame.getMesh().material.visible = needShow;
      }
    }]);

    return VolumeVisual;
  }(Visual);

  function _createSuper$1z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1A(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available loaders.
   * @extends EntityList
   */

  var LoaderList = /*#__PURE__*/function (_EntityList) {
    inherits(LoaderList, _EntityList);

    var _super = _createSuper$1z(LoaderList);

    /**
     * Create a list of loaders.
     * The loaders are indexed by supported source types (`.types` property of a Loader
     * subclass).
     * The loaders can be retrieved later by matching against specs (see {@link LoaderList#find}).
     *
     * @param {!Array<function(new:Loader)>=} someLoaders A list of {@link Loader} subclasses to
     *   automatically register at creation time.
     * @see LoaderList#register
     */
    function LoaderList() {
      var someLoaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, LoaderList);

      return _super.call(this, someLoaders, ['types']);
    }
    /**
     * Find a suitable loader for a source type.
     *
     * @param {Object} specs Loader specifications.
     * @param {string=} specs.type Supported source type.
     * @param {*=} specs.source Source to load from.
     */


    createClass(LoaderList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.type) {
          list = this._dict.types[specs.type.toLowerCase()] || [];
        } else if (specs.source) {
          return this._list.filter(function (SomeLoader) {
            return SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source);
          });
        }

        return toConsumableArray(list);
      }
    }]);

    return LoaderList;
  }(EntityList);

  function _createSuper$1A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1B(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var Loader = /*#__PURE__*/function (_EventDispatcher) {
    inherits(Loader, _EventDispatcher);

    var _super = _createSuper$1A(Loader);

    function Loader(source, options) {
      var _this;

      classCallCheck(this, Loader);

      _this = _super.call(this);
      _this._source = source;
      _this._options = options || {};
      _this._abort = false;
      _this._agent = null;
      return _this;
    }

    createClass(Loader, [{
      key: "load",
      value: function load() {
        return Promise.reject(new Error('Loading from this source is not implemented'));
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;

        if (this._agent) {
          this._agent.abort();
        }
      }
    }], [{
      key: "extractName",
      value: function extractName(_source) {
        return undefined;
      }
    }]);

    return Loader;
  }(EventDispatcher);
  makeContextDependent(Loader.prototype);

  function _createSuper$1B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1C(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FileLoader = /*#__PURE__*/function (_Loader) {
    inherits(FileLoader, _Loader);

    var _super = _createSuper$1B(FileLoader);

    function FileLoader(source, options) {
      var _this;

      classCallCheck(this, FileLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    createClass(FileLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var blob = _this2._source;
          var reader = _this2._agent = new FileReader();
          reader.addEventListener('load', function () {
            resolve(reader.result);
          });
          reader.addEventListener('error', function () {
            reject(reader.error);
          });
          reader.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          reader.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });

          if (_this2._binary) {
            reader.readAsArrayBuffer(blob);
          } else {
            reader.readAsText(blob);
          }
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return File && source instanceof File || Blob && source instanceof Blob;
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        return source && source.name;
      }
    }]);

    return FileLoader;
  }(Loader);
  FileLoader.types = ['file', 'blob'];

  function _createSuper$1C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1D(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var urlStartRegexp = /^(https?|ftp):\/\//i;

  var XHRLoader = /*#__PURE__*/function (_Loader) {
    inherits(XHRLoader, _Loader);

    var _super = _createSuper$1C(XHRLoader);

    function XHRLoader(source, options) {
      var _this;

      classCallCheck(this, XHRLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    createClass(XHRLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var url = _this2._source;
          var request = _this2._agent = new XMLHttpRequest();
          request.addEventListener('load', function () {
            if (request.status === 200) {
              resolve(request.response);
            } else {
              reject(new Error("HTTP ".concat(request.status, " while fetching ").concat(url)));
            }
          });
          request.addEventListener('error', function () {
            reject(new Error('HTTP request failed'));
          });
          request.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          request.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });
          request.open('GET', url);

          if (_this2._binary) {
            request.responseType = 'arraybuffer';
          } else {
            request.responseType = 'text';
          }

          request.send();
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return ___default['default'].isString(source) && urlStartRegexp.test(source);
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        if (source) {
          var last = (source.indexOf('?') + 1 || source.lastIndexOf('#') + 1 || source.length + 1) - 1;
          return source.slice(source.lastIndexOf('/', last) + 1, last);
        }

        return undefined;
      }
    }]);

    return XHRLoader;
  }(Loader);
  XHRLoader.types = ['url'];

  function _createSuper$1D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1E(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ImmediateLoader = /*#__PURE__*/function (_Loader) {
    inherits(ImmediateLoader, _Loader);

    var _super = _createSuper$1D(ImmediateLoader);

    function ImmediateLoader() {
      classCallCheck(this, ImmediateLoader);

      return _super.apply(this, arguments);
    }

    createClass(ImmediateLoader, [{
      key: "load",
      value: function load() {
        var _this = this;

        return new Promise(function (resolve) {
          if (_this._abort) {
            throw new Error('Loading aborted');
          }

          resolve(_this._source);
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(_source) {
        return false;
      }
    }]);

    return ImmediateLoader;
  }(Loader);
  ImmediateLoader.types = ['immediate'];

  var loaders = new LoaderList([// note: order might be important
  FileLoader, XHRLoader, ImmediateLoader]);

  function _createSuper$1E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1F(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available parsers.
   * @extends EntityList
   */

  var ParserList = /*#__PURE__*/function (_EntityList) {
    inherits(ParserList, _EntityList);

    var _super = _createSuper$1E(ParserList);

    /**
     * Create a list of parsers.
     * The parsers are indexed by supported data formats and file extensions (`.formats` and
     * `.extensions` properties of a Parser subclass).
     * The parsers can be retrieved later by matching against specs (see {@link ParsrerList#find}).
     *
     * @param {!Array<function(new:Parser)>=} someParsers A list of {@link Parser} subclasses to
     *   automatically register at creation time.
     * @see ParserList#register
     */
    function ParserList() {
      var someParsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, ParserList);

      return _super.call(this, someParsers, ['formats', 'extensions']);
    }
    /**
     * Find a suitable parser for data.
     *
     * @param {Object} specs Parser specifications.
     * @param {string=} specs.format Supported data format.
     * @param {string=} specs.ext Supported filename extension.
     * @param {*=} specs.data Data to parse.
     */


    createClass(ParserList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        } else if (specs.ext) {
          list = this._dict.extensions[specs.ext.toLowerCase()] || [];
        } // autodetect only if no format is forced


        if (list.length === 0 && !specs.format && specs.data) {
          return this._list.filter(function (SomeParser) {
            return SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data);
          });
        }

        return toConsumableArray(list);
      }
    }]);

    return ParserList;
  }(EntityList);

  var Parser = /*#__PURE__*/function () {
    function Parser(data, options) {
      classCallCheck(this, Parser);

      this._data = data;
      this._options = options || {};
      this._abort = false;
    }

    createClass(Parser, [{
      key: "parseSync",
      value: function parseSync() {
        throw new Error('Parsing this type of data is not implemented');
      }
    }, {
      key: "parse",
      value: function parse() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Parsing aborted'));
              }

              return resolve(_this.parseSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      } // only for volume Parsers

    }, {
      key: "getModel",
      value: function getModel() {
        this.model._parseHeader(this._data);

        return this.model;
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Parser;
  }();
  makeContextDependent(Parser.prototype);

  /**
   * Parser helper for PDB tag "REMARK 290".
   *
   * @exports Remark290
   * @constructor
   */

  var Remark290 = /*#__PURE__*/function () {
    function Remark290() {
      classCallCheck(this, Remark290);

      /** @type {THREE.Matrix4[]} */
      this.matrices = [];
      /** @type {?THREE.Matrix4} */

      this._matrix = null;
      /** @type {number} */

      this._matrixIndex = -1;
    }
    /**
     * Parse a single line of a stream.
     * @param {PDBStream} stream - stream to parse
     */


    createClass(Remark290, [{
      key: "parse",
      value: function parse(stream) {
        /** @type {?THREE.Matrix4} */
        var matrix = this._matrix;

        if (stream.readString(12, 18) === '  SMTRY') {
          var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2

          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            // TODO: assert(matrixIndex === this.matrices.length + 1);
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE.Matrix4();
            this.matrices[this.matrices.length] = matrix;
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        }
      }
    }]);

    return Remark290;
  }();

  Remark290.prototype.id = 290;

  var Assembly$1 = chem.Assembly;
  /**
   * Parser helper for PDB tag "REMARK 350".
   *
   * @exports Remark350
   * @constructor
   */

  var Remark350 = /*#__PURE__*/function () {
    function Remark350(complex) {
      classCallCheck(this, Remark350);

      /** @type {Complex} */
      this._complex = complex;
      /** @type {Assembly[]} */

      this.assemblies = [];
      /** @type {?Assembly} */

      this._assembly = null;
      /** @type {?THREE.Matrix4} */

      this._matrix = null;
      /** @type {number} */

      this._matrixIndex = -1;
    }
    /**
     * Parse a single line of a stream.
     * @param {PDBStream} stream - stream to parse
     */


    createClass(Remark350, [{
      key: "parse",
      value: function parse(stream) {
        /** @type {?Assembly} */
        var assembly = this._assembly;
        /** @type {?THREE.Matrix4} */

        var matrix = this._matrix;

        if (assembly && stream.readString(12, 18) === '  BIOMT') {
          var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2

          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            // TODO: assert(matrixIndex === assembly.matrices.length + 1);
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE.Matrix4();
            assembly.addMatrix(matrix);
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
          var entries = stream.readString(42, 80).split(',');

          for (var i = 0, n = entries.length; i < n; ++i) {
            var chain = entries[i].trim();

            if (chain.length > 0) {
              assembly.addChain(chain);
            }
          }
        } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
          // assert molIndex === this.assemblies.length + 1
          this._matrix = null;
          this._matrixIndex = -1;
          this._assembly = assembly = new Assembly$1(this._complex);
          this.assemblies.push(assembly);
        }
      }
    }]);

    return Remark350;
  }();

  Remark350.prototype.id = 350;

  /** Helper class for stream-like reading input files. */
  var PDBStream = /*#__PURE__*/function () {
    /**
     * Create a stream
     * @param {String} data Input data
     */
    function PDBStream(data) {
      classCallCheck(this, PDBStream);

      /** @type String */
      this._data = data; // Input file

      /** @type Number */

      this._start = 0; // Starting position of line

      /** @type Number */

      this._nextCR = -1; // Position of next CR (0x0D)

      /** @type Number */

      this._nextLF = -1; // Position of next LF (0x0A)

      /** @type Number */

      this._next = -1; // End position of line

      /** @type Number */

      this._end = data.length; // End of data

      this.next();
    }
    /**
     * Reading next line.
     * @returns {String} Next line in data (ending with LF or CR)
     */


    createClass(PDBStream, [{
      key: "readLine",
      value: function readLine() {
        return this._data.slice(this._start, this._next);
      }
      /**
       * Reading character from position.
       * @param {Number} pos - Position in current line.
       * @returns {String} Character from position
       */

    }, {
      key: "readChar",
      value: function readChar(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data[pos] : ' ';
      }
      /**
       * Reading character code from position.
       * @param {Number} pos - Position in current line.
       * @returns {Number} Character code from position
       */

    }, {
      key: "readCharCode",
      value: function readCharCode(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data.charCodeAt(pos) : 32;
      }
      /**
       * Reading string from begin to end points.
       * For a reason unknown, numbering assumed not to start from 0, but from 1.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {String} String from begin to end
       */

    }, {
      key: "readString",
      value: function readString(begin, end) {
        var from = this._start + begin - 1;
        var to = this._start + end;
        return this._data.slice(from, to < this._next ? to : this._next);
      }
      /**
       * Reading integer from begin to end points.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {Number} Integer from begin to end
       */

    }, {
      key: "readInt",
      value: function readInt(begin, end) {
        return parseInt(this.readString(begin, end), 10);
      }
      /**
       * Reading float from begin to end points.
       * @param {Number} begin - Begin point in current line.
       * @param {Number} end - End point in current line.
       * @returns {Number} Float from begin to end
       */

    }, {
      key: "readFloat",
      value: function readFloat(begin, end) {
        return parseFloat(this.readString(begin, end));
      }
      /**
       * Checking for end of data.
       * @returns {boolean} True if data is ended, false otherwise
       */

    }, {
      key: "end",
      value: function end() {
        return this._start >= this._end;
      }
      /**
       * Procedure to re-arrange current pointers in data.
       */

    }, {
      key: "next",
      value: function next() {
        var start = this._next + 1;
        this._start = start < this._end ? start : this._end; // support CR, LF, CR+LF line endings
        // do not support LF+CR, CR+CR+LF, and other strange combinations

        if (this._start > this._nextCR) {
          this._nextCR = (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1;
        }

        if (this._start > this._nextLF) {
          this._nextLF = (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1;
        }

        this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
      }
    }]);

    return PDBStream;
  }();

  function _createSuper$1F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1G(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$1 = chem.Complex,
      Element$2 = chem.Element,
      Helix$1 = chem.Helix,
      Sheet$1 = chem.Sheet,
      Strand$1 = chem.Strand,
      Bond$1 = chem.Bond,
      Molecule$1 = chem.Molecule;
  var TAG_LENGTH = 6;

  function nameToElement(name) {
    // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    //
    // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
    //
    // Atom names start with element symbols right-justified in columns 13-14
    // as permitted by the length of the name. For example, the symbol FE for
    // iron appears in columns 13-14, whereas the symbol C for carbon appears
    // in column 14 (see Misaligned Atom Names). If an atom name has four
    // characters, however, it must start in column 13 even if the element
    // symbol is a single character (for example, see Hydrogen Atoms).
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  } // the most frequently used beginnings; although HEADER is mandatory, it is often missing in handmade files


  var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
  var remarkParsers = {
    // NOTE: please forget the idea to build the method name in runtime, it can be obfuscated.
    290: Remark290,
    350: Remark350
  };

  var PDBParser = /*#__PURE__*/function (_Parser) {
    inherits(PDBParser, _Parser);

    var _super = _createSuper$1F(PDBParser);

    function PDBParser(data, options) {
      var _this;

      classCallCheck(this, PDBParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._sheet = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._compaundFound = false;
      _this._biomoleculeFound = false;
      _this._allowedChainsIDs = null;
      _this._lastMolId = -1;
      _this._remarks = {};
      _this._remark = null;
      _this._molecules = [];
      _this._molecule = null;
      _this._compndCurrToken = '';
      _this._options.fileType = 'pdb';
      return _this;
    }

    createClass(PDBParser, [{
      key: "_finalize",
      value: function _finalize() {
        this._fixBondsArray();

        this._fixChains(); // keep crystallographic symmetry transformations


        var remark290 = this._remarks[290];
        this._complex.symmetry = ___default['default'].isUndefined(remark290) ? [] : remark290.matrices; // add loaded biological assemblies

        var remark350 = this._remarks[350];
        this._complex.units = this._complex.units.concat(___default['default'].isUndefined(remark350) ? [] : remark350.assemblies); // add loaded macromolecules

        this._finalizeMolecules(); // create secondary structure etc.


        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // get chains from complex
        var chainDict = {};
        var i;
        var chains = this._complex._chains;

        for (i = 0; i < chains.length; ++i) {
          var chainObj = chains[i];
          var chainName = chainObj._name;
          chainDict[chainName] = chainObj;
        } // aggregate residues from chains


        for (i = 0; i < this._molecules.length; i++) {
          var m = this._molecules[i];
          var residues = [];

          for (var j = 0; j < m._chains.length; j++) {
            var name = m._chains[j];
            var chain = chainDict[name];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$1(this._complex, m._name, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_fixChains",
      value: function _fixChains() {
        var idChainMap = {};
        var complex = this._complex; // prepare

        for (var i = 0; i < complex._chains.length; i++) {
          var chain = complex._chains[i];
          idChainMap[chain._name.charCodeAt(0)] = chain;
        }
      } // FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.

    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseATOM",
      value: function _parseATOM(stream) {
        if (this._modelId !== 1) {
          return;
        }
        /* eslint-disable no-magic-numbers */


        var het = stream.readCharCode(1) === 0x48; // field names according to wwPDB Format
        // NOTE: Chimera allows (nonstandard) use of columns 6-11 for the integer atom serial number in ATOM records.

        var serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
        var name = stream.readString(13, 16);
        var altLoc = stream.readChar(17);
        var resName = stream.readString(18, 20).trim();
        var chainID = stream.readChar(22);
        var resSeq = stream.readInt(23, 26);
        var iCode = stream.readChar(27);
        var x = stream.readFloat(31, 38);
        var y = stream.readFloat(39, 46);
        var z = stream.readFloat(47, 54);
        var occupancy = stream.readFloat(55, 60);
        var tempFactor = stream.readFloat(61, 66);
        var element = stream.readString(77, 78).trim() || nameToElement(name);
        var charge = stream.readInt(79, 80) || 0;
        /* eslint-enable no-magic-numbers */
        // skip waters (there may be lots of them)

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return;
          }
        } // PDB uses positional system for atom names. It helps derive element type from the name
        // but names may include extra spaces. From this point on we don't need those spaces anymore.


        name = name.trim();
        var type = Element$2.getByName(element);
        var role = Element$2.Role[name]; // FIXME: Maybe should use type as additional index (" CA " vs. "CA  ")
        // NOTE: Residues of a particular chain are not required to be listed next to each other.
        // https://github.com/biasmv/pv/commit/7319b898b7473ba380c26699e3b028b2b1a7e1a1

        var chain = this._chain;

        if (!chain || chain.getName() !== chainID) {
          this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
          this._residue = null;
        }

        var residue = this._residue;

        if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
          this._residue = residue = chain.addResidue(resName, resSeq, iCode);
        }

        var xyz = new THREE.Vector3(x, y, z);
        residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
      }
    }, {
      key: "_parseENDMDL",
      value: function _parseENDMDL() {
        this._modelId += 1;
      }
    }, {
      key: "_parseCONECT",
      value: function _parseCONECT(stream) {
        /* eslint-disable no-magic-numbers */
        var serial0 = stream.readInt(7, 11);
        var serial1 = stream.readInt(12, 16);
        var serial2 = stream.readInt(17, 21);
        var serial3 = stream.readInt(22, 26);
        var serial4 = stream.readInt(27, 31);
        /* eslint-enable no-magic-numbers */

        var complex = this._complex; // Keep bonds ordered by atom serial

        if (serial1 && serial1 > serial0) {
          complex.addBond(serial0, serial1, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial2 && serial2 > serial0) {
          complex.addBond(serial0, serial2, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial3 && serial3 > serial0) {
          complex.addBond(serial0, serial3, 0, Bond$1.BondType.UNKNOWN, true);
        }

        if (serial4 && serial4 > serial0) {
          complex.addBond(serial0, serial4, 0, Bond$1.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseCOMPND",
      value: function _parseCOMPND(stream) {
        /* eslint-disable no-magic-numbers */
        var str = stream.readString(11, 80);
        var tokenIdx = str.indexOf(':');
        this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
        /* eslint-enable no-magic-numbers */
        // start reading new molecule

        if (this._compndCurrToken === 'MOL_ID') {
          this._molecule = {
            _index: '',
            _chains: []
          };
          this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(';')), 10);

          this._molecules.push(this._molecule); // parse molecule name

        } else if (this._compndCurrToken === 'MOLECULE' && this._molecule != null) {
          this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(';')).trim(); // parse molecule chains
        } else if (this._compndCurrToken === 'CHAIN' && this._molecule != null) {
          var chainStr = str.substring(tokenIdx + 1, 80).trim();
          var lastChar = chainStr[chainStr.length - 1];

          if (lastChar === ';' || lastChar === ',') {
            chainStr = chainStr.slice(0, -1);
          }

          chainStr = chainStr.replace(/\s+/g, '');
          var chains = chainStr.split(',');
          this._molecule._chains = this._molecule._chains.concat(chains);
        }
      }
    }, {
      key: "_parseREMARK",
      value: function _parseREMARK(stream) {
        /* eslint-disable no-magic-numbers */
        var remarkNum = stream.readInt(8, 10);
        /* eslint-enable no-magic-numbers */
        // create remark parser if needed

        var remark = this._remarks[remarkNum];

        if (___default['default'].isUndefined(remark)) {
          var RemarkParser = remarkParsers[remarkNum];

          if (___default['default'].isFunction(RemarkParser)) {
            this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
          }
        } // delegate parsing


        if (!___default['default'].isUndefined(remark)) {
          remark.parse(stream);
        }
      }
    }, {
      key: "_parseHELIX",
      value: function _parseHELIX(stream) {
        var _this2 = this;

        /* eslint-disable no-magic-numbers */
        var fields = [20, 22, 32, 34];
        /* eslint-enable no-magic-numbers */

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this2._complex.addHelix(obj);

          _this2._complex.structures.push(obj);
        });
      }
    }, {
      key: "_parseSHEET",
      value: function _parseSHEET(stream) {
        var _this3 = this;

        /* eslint-disable no-magic-numbers */
        var fields = [22, 23, 33, 34];
        /* eslint-enable no-magic-numbers */

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this3._complex.addSheet(obj);
        });
      }
    }, {
      key: "_parseSTRUCTURE",
      value: function _parseSTRUCTURE(stream, pars, adder) {
        var startId = 0;
        var startIndex = 1;
        var endId = 2;
        var endIndex = 3; // identify fields: debugging and stuff

        /* eslint-disable no-magic-numbers */

        var codeOfS = 0x53;
        var serialNumber = stream.readInt(8, 10);
        var structureName = stream.readString(12, 14).trim(); // FIXME: LString(3) forbids trim()

        var comment = stream.readString(41, 70).trim();
        var helLength = stream.readInt(72, 76);
        var helixClass = stream.readInt(39, 40);
        var shWidth = stream.readInt(15, 16);
        var shCur = stream.readInt(42, 45);
        var shPrev = stream.readInt(57, 60);
        /* eslint-enable no-magic-numbers */
        // file fields

        var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
        var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
        var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
        var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
        var startICode = 0;

        if (iCodeStr.length > 0) {
          startICode = iCodeStr.charCodeAt(0);
        }

        var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
        iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
        var endICode = 0;

        if (iCodeStr.length > 0) {
          endICode = iCodeStr.charCodeAt(0);
        }

        var obj;
        var cs = this._sheet;

        if (stream.readCharCode(1) === codeOfS) {
          if (cs !== null && cs.getName() !== structureName) {
            cs = null;
            this._sheet = null;
          }

          if (cs === null) {
            this._sheet = obj = new Sheet$1(structureName, shWidth);
            adder(obj);
          } else {
            obj = cs;
          }

          var strand = new Strand$1(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
          obj.addStrand(strand);

          this._complex.structures.push(strand);
        } else {
          obj = new Helix$1(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
          adder(obj);
        }
      }
    }, {
      key: "_parseHEADER",
      value: function _parseHEADER(stream) {
        var metadata = this._complex.metadata;
        metadata.classification = stream.readString(11, 50).trim();
        metadata.date = stream.readString(51, 59).trim();
        var id = stream.readString(63, 66).trim();
        metadata.id = id;

        if (id) {
          this._complex.name = id;
        }

        metadata.format = 'pdb';
      }
    }, {
      key: "_parseTITLE",
      value: function _parseTITLE(stream) {
        var metadata = this._complex.metadata;
        metadata.title = metadata.title || [];
        var line = stream.readInt(9, 10) || 1;
        metadata.title[line - 1] = stream.readString(11, 80).trim();
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var stream = new PDBStream(this._data);
        var result = this._complex = new Complex$1(); // parse PDB line by line

        while (!stream.end()) {
          var tag = stream.readString(1, TAG_LENGTH);
          var func = PDBParser.tagParsers[tag];

          if (___default['default'].isFunction(func)) {
            func.call(this, stream);
          }

          stream.next();
        } // Resolve indices and serials to objects


        this._finalize(); // cleanup


        this._serialAtomMap = null;
        this._sheet = null;
        this._residue = null;
        this._chain = null;
        this._complex = null;

        if (result.getAtomCount() === 0) {
          throw new Error('The data does not contain valid atoms');
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && pdbStartRegexp.test(data);
      }
    }]);

    return PDBParser;
  }(Parser);

  defineProperty(PDBParser, "tagParsers", {
    HEADER: PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    HETATM: PDBParser.prototype._parseATOM,
    ENDMDL: PDBParser.prototype._parseENDMDL,
    CONECT: PDBParser.prototype._parseCONECT,
    COMPND: PDBParser.prototype._parseCOMPND,
    REMARK: PDBParser.prototype._parseREMARK,
    // 'SOURCE': PDBParser.prototype._parseSOURCE,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET,
    // nonstandard extension to allow range 100,000 - 999,999
    'ATOM 1': PDBParser.prototype._parseATOM,
    'ATOM 2': PDBParser.prototype._parseATOM,
    'ATOM 3': PDBParser.prototype._parseATOM,
    'ATOM 4': PDBParser.prototype._parseATOM,
    'ATOM 5': PDBParser.prototype._parseATOM,
    'ATOM 6': PDBParser.prototype._parseATOM,
    'ATOM 7': PDBParser.prototype._parseATOM,
    'ATOM 8': PDBParser.prototype._parseATOM,
    'ATOM 9': PDBParser.prototype._parseATOM
  });

  PDBParser.formats = ['pdb'];
  PDBParser.extensions = ['.pdb', '.ent'];

  function _createSuper$1G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1H(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$2 = chem.Complex,
      Element$3 = chem.Element,
      SGroup$1 = chem.SGroup,
      Bond$2 = chem.Bond;
  var cOrderCharCodes = {
    A: 0,
    S: 1,
    D: 2,
    T: 3
  };
  var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;

  var CMLParser = /*#__PURE__*/function (_Parser) {
    inherits(CMLParser, _Parser);

    var _super = _createSuper$1G(CMLParser);

    function CMLParser(data, options) {
      var _this;

      classCallCheck(this, CMLParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._residue = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._lastMolId = -1;
      _this._readOnlyOneMolecule = false;
      _this._options.fileType = 'cml';
      return _this;
    }

    createClass(CMLParser, [{
      key: "_rebuidBondIndexes",
      value: function _rebuidBondIndexes(atoms, bonds) {
        var count = atoms.length;

        for (var i = 0; i < count; i++) {
          var atomId = atoms[i].id;
          var countBonds = bonds.length;

          for (var j = 0; j < countBonds; j++) {
            var idxs = bonds[j].atomRefs2.split(' ');

            if (idxs[0] === atomId) {
              bonds[j].start = i;
            }

            if (idxs[1] === atomId) {
              bonds[j].end = i;
            }
          }
        }
      }
    }, {
      key: "_createSGroup",
      value: function _createSGroup(molecule, moleculeArr) {
        var newGroup = new SGroup$1(molecule.id, molecule.fieldData, new THREE.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);

        if (molecule.placement === 'Relative') {
          newGroup._center = new THREE.Vector3(0, 0, 0);
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
          newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
          newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
        }

        moleculeArr.push(newGroup);
      }
    }, {
      key: "_extractSGroup",
      value: function _extractSGroup(molecule, moleculeArr) {
        if (!Array.isArray(moleculeArr)) {
          moleculeArr = [];
        }

        if (molecule) {
          if (Array.isArray(molecule)) {
            var count = molecule.length;

            for (var i = 0; i < count; i++) {
              if (molecule[i].molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
              }

              this._createSGroup(molecule[i], moleculeArr);
            }
          } else {
            if (molecule.molecule) {
              if (molecule.molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
              }
            }

            this._createSGroup(molecule, moleculeArr);
          }
        }

        return moleculeArr;
      }
    }, {
      key: "_extractSGroups",
      value: function _extractSGroups(molecule, atoms) {
        var moleculeArr = this._extractSGroup(molecule);

        var count = atoms.length;
        var i;
        var j;

        for (i = 0; i < count; i++) {
          var atomId = atoms[i].id;

          for (j = 0; j < moleculeArr.length; j++) {
            var firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];

            if (firstAtomRef === atomId) {
              if (!atoms[i].sgroupRef) {
                atoms[i].sgroupRef = [];
              }

              atoms[i].sgroupRef.push(moleculeArr[j]);
            }
          }
        } // build sGroups centers


        var atomMap = {}; // sgrpmap cache

        var mapEntry = null;
        var nLimon = 100000000;
        var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);

        function cycleFuncInner(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            moleculeArr[j]._atoms.push(mapEntry.a);
          }
        }

        function cycleFunc(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
            bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
            cycleFuncInner(e);
          }
        }

        for (i = 0; i < atoms.length; i++) {
          atomMap[atoms[i].id] = {};
          atomMap[atoms[i].id].x = atoms[i].x2;

          if (atoms[i].x3) {
            atomMap[atoms[i].id].x = atoms[i].x3;
          }

          atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
          atomMap[atoms[i].id].y = atoms[i].y2;

          if (atoms[i].y3) {
            atomMap[atoms[i].id].y = atoms[i].y3;
          }

          atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
          atomMap[atoms[i].id].z = '0.0';

          if (atoms[i].z3) {
            atomMap[atoms[i].id].z = atoms[i].z3;
          }

          atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
          atomMap[atoms[i].id].a = atoms[i];
        }

        var atomsRef;

        for (j = 0; j < moleculeArr.length; j++) {
          if (moleculeArr[j]._center !== null) {
            bLow.set(nLimon, nLimon, nLimon);
            bHight.set(-nLimon, -nLimon, -nLimon);
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFunc);

            moleculeArr[j]._center.addVectors(bLow, bHight);

            moleculeArr[j]._center.multiplyScalar(0.5);
          } else {
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFuncInner);
          }
        }

        atomMap = null;
      }
    }, {
      key: "_traverseData",
      value: function _traverseData(dom) {
        function isArray(o) {
          return Object.prototype.toString.apply(o) === '[object Array]';
        }

        function parseNode(xmlNode, result) {
          if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
            return;
          }

          var jsonNode = {};
          jsonNode.xmlNode = xmlNode;
          var existing = result[xmlNode.nodeName];

          if (existing) {
            if (!isArray(existing)) {
              result[xmlNode.nodeName] = [existing, jsonNode];
            } else {
              result[xmlNode.nodeName].push(jsonNode);
            }
          } else {
            result[xmlNode.nodeName] = jsonNode;
          }

          var length;
          var i;

          if (xmlNode.attributes) {
            length = xmlNode.attributes.length;

            for (i = 0; i < length; i++) {
              var attribute = xmlNode.attributes[i];
              jsonNode[attribute.nodeName] = attribute.nodeValue;
            }
          }

          length = xmlNode.childNodes.length;

          for (i = 0; i < length; i++) {
            parseNode(xmlNode.childNodes[i], jsonNode);
          }
        }

        var result = {};

        if (dom.childNodes.length) {
          parseNode(dom.childNodes[0], result);
        }

        return result;
      }
    }, {
      key: "_findSuitableMolecule",
      value: function _findSuitableMolecule(data, molSet) {
        for (var key in data) {
          if (key === 'xmlNode') {
            continue;
          } else if (key === 'molecule') {
            if (data.molecule) {
              if (data.molecule.atomArray && data.molecule.atomArray.atom) {
                molSet.push(data);
              }

              if (Array.isArray(data.molecule)) {
                for (var i = 0; i < data.molecule.length; i++) {
                  if (data.molecule[i].atomArray && data.molecule[i].atomArray.atom) {
                    molSet.push({
                      molecule: data.molecule[i]
                    });
                  }
                }
              }
            }
          } else if (data[key] && data[key] !== null && _typeof_1(data[key]) === 'object') {
            this._findSuitableMolecule(data[key], molSet);
          }
        }
      }
    }, {
      key: "_selectComponents",
      value: function _selectComponents(text) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(text, 'application/xml');

        var traversedData = this._traverseData(doc);

        var rawData;
        var self = this;

        function prepareComponentCompound(data) {
          var atoms = [];

          if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
            if (!Array.isArray(data.molecule.atomArray.atom)) {
              atoms.push(data.molecule.atomArray.atom);
            } else {
              atoms = data.molecule.atomArray.atom;
            }
          } else if (!data.molecule) {
            var ret = {};
            ret.atomLabels = null;
            ret.labelsCount = 1;
            return ret;
          }

          if (data.molecule.molecule) {
            self._extractSGroups(data.molecule.molecule, atoms);
          }

          var atom;
          var count = atoms.length;

          for (var i = 0; i < count; i++) {
            atom = atoms[i];
            atom.edges = [];
          }

          var localBond = [];

          if (data.molecule.bondArray && data.molecule.bondArray.bond) {
            if (!Array.isArray(data.molecule.bondArray.bond)) {
              localBond.push(data.molecule.bondArray.bond);
            } else {
              localBond = data.molecule.bondArray.bond;
            }
          }

          var bond;
          count = localBond.length;

          self._rebuidBondIndexes(atoms, localBond);

          function addCurrBond(index) {
            bond = localBond[index];
            atom = atoms[bond.start];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.end);
            atom = atoms[bond.end];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.start);
            return true;
          }

          for (var _i = 0; _i < count; _i++) {
            if (!addCurrBond(_i)) {
              // ignore invalid bond
              continue;
            }

            var orderAttr = bond.xmlNode.getAttribute('order');
            var tc = parseInt(orderAttr, 10); // the default bond order is unknown

            localBond[_i].order = 0;
            localBond[_i].type = Bond$2.BondType.UNKNOWN;

            if (tc > 1) {
              localBond[_i].order = tc;
            } else {
              // another option - bond order is a string
              var order = cOrderCharCodes[orderAttr];

              if (order !== undefined) {
                localBond[_i].order = order;

                if (orderAttr === 'A') {
                  localBond[_i].type = Bond$2.BondType.AROMATIC;
                }
              }
            }
          }

          count = atoms.length;

          for (var _i2 = 0; _i2 < count; _i2++) {
            atom = atoms[_i2];
            atom.edges.sort();
          }

          var labels = self._breadWidthSearch(atoms, 0); // for now


          var retStruct = {};
          retStruct.atoms = atoms;
          retStruct.bonds = localBond;
          retStruct.labels = labels.atomLabels;
          retStruct.count = Math.min(1, labels.labelsCount); // for now

          retStruct.curr = -1;
          retStruct.originalCML = doc;
          return retStruct;
        }

        if (traversedData.cml) {
          rawData = traversedData.cml;
        } else {
          rawData = traversedData;
        }

        var retData = [];
        var filteredData = [];

        this._findSuitableMolecule(rawData, filteredData);

        if (this._readOnlyOneMolecule && filteredData.length > 1) {
          filteredData.splice(1, filteredData.length - 1);
        }

        filteredData.forEach(function (d) {
          var rd = prepareComponentCompound(d);

          if (rd.atoms.length > 0) {
            retData.push(rd);
          }
        });
        return retData;
      }
    }, {
      key: "_packLabel",
      value: function _packLabel(compId, molId) {
        var shift = 16;
        return (molId << shift) + compId;
      }
    }, {
      key: "_unpackLabel",
      value: function _unpackLabel(l) {
        var shift = 16;
        var mask = (1 << shift) - 1;
        return {
          molId: l >>> shift,
          compId: l & mask
        };
      }
    }, {
      key: "_breadWidthSearch",
      value: function _breadWidthSearch(atoms, molID) {
        var atomLabels = new Array(atoms.length);
        var id;

        for (id = 0; id < atomLabels.length; id++) {
          atomLabels[id] = this._packLabel(0, molID);
        }

        var breadthQueue = [];
        var componentID = 0;
        var labeledAtoms = atoms.length;

        while (labeledAtoms > 0) {
          componentID++;
          var startID = -1;

          for (id = 0; id < atomLabels.length; id++) {
            if (this._unpackLabel(atomLabels[id]).compId === 0) {
              startID = id;
              break;
            }
          }

          if (startID < 0) {
            break;
          } // Bread first search


          breadthQueue.push(atoms[startID]);
          atomLabels[startID] = this._packLabel(componentID, molID);
          labeledAtoms--;

          while (breadthQueue.length > 0) {
            var curr = breadthQueue.shift();

            if (!curr) {
              continue;
            }

            for (var i = 0; i < curr.edges.length; i++) {
              if (atomLabels[curr.edges[i]] !== componentID) {
                breadthQueue.push(atoms[curr.edges[i]]);
                atomLabels[curr.edges[i]] = componentID;
                labeledAtoms--;
              }
            }
          }
        }

        var ret = {};
        ret.atomLabels = atomLabels;
        ret.labelsCount = componentID;
        return ret;
      }
    }, {
      key: "_parseBond",
      value: function _parseBond(eAtom, mainAtom, order, type) {
        if (eAtom >= 0) {
          var h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];

          this._complex.addBond(h[0], h[1], order, type, true);
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseSet",
      value: function _parseSet(varData) {
        var complex = this._complex = new Complex$2();
        var data = varData;
        var currentLabel = data.curr;
        var atoms = data.atoms,
            labels = data.labels;
        var atom = null;
        var i;
        var j;
        var count = atoms.length;

        function addFunc(a) {
          a.xmlNodeRef = atom;

          if (atom.x2) {
            atom.x3 = atom.x2;
            delete atom.x2;
          }

          if (atom.y2) {
            atom.y3 = atom.y2;
            delete atom.y2;
          }

          if (!atom.z3) {
            atom.z3 = '0.0';
          }

          atom.complexAtom = a;
        }

        var chains = {}; // parse atoms in label order

        var reorder = [];

        for (i = 0; i < count; i++) {
          reorder.push(i);
        }

        reorder.sort(function (a, b) {
          return labels[a] - labels[b];
        });

        for (i = 0; i < count; i++) {
          var atomCharge = 0;
          var lLabel = labels[reorder[i]];

          if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[reorder[i]];
            var atomFullNameStruct = atom.elementType;

            if (atom.sgroupRef) {
              var countRef = atom.sgroupRef.length;

              for (var k = 0; k < countRef; ++k) {
                complex._sgroups.push(atom.sgroupRef[k]);
              }
            }

            if (atom.x3 || atom.x2) {
              var currAtomComp = this._unpackLabel(lLabel).compId; // use ' ' by default instead of synthetic creation of chain names


              var chainID = ' '; //= String.fromCharCode('A'.charCodeAt(0) + currAtomComp);

              var resSeq = currAtomComp;
              var iCode = ' ';
              var strLabel = currAtomComp.toString();

              if (strLabel.length === 1) {
                strLabel = "0".concat(strLabel);
              }

              var resName = "N".concat(strLabel);
              var chain = chains[chainID];

              if (!chain || chain.getName() !== chainID) {
                chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
                this._residue = null;
              }

              var residue = this._residue;

              if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
                this._residue = residue = chain.addResidue(resName, resSeq, iCode);
              } // _x, _y, _z, mname, mindex, atomNameFull, atomName, chainID, serial, isHet, atlLocInd, atomNameToTypeF


              var xyz = null;

              if (atom.x3) {
                xyz = new THREE.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
              } else if (atom.x2) {
                xyz = new THREE.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
              }

              var element = Element$3.ByName[atom.elementType.toUpperCase()];

              if (!element) {
                element = JSON.parse(JSON.stringify(Element$3.ByName[Object.keys(Element$3.ByName)[Object.keys(Element$3.ByName).length - 1]]));
                element.number += 1;
                element.name = atom.elementType.toUpperCase();
                element.fullName = 'Unknown';
                Element$3.ByName[atom.elementType.toUpperCase()] = element;
              }

              var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
              var added = residue.addAtom(atomFullNameStruct, element, xyz, Element$3.Role.SG, true, atomSerial, ' ', 1.0, 0.0, atomCharge);

              if (atom.hydrogenCount) {
                added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
              }

              if (atom.mrvValence) {
                added.valence = parseInt(atom.mrvValence, 10);
              }

              addFunc(added);
            }
          }
        }

        chains = null; // NOSONAR

        for (i = 0; i < data.bonds.length; i++) {
          var cb = data.bonds[i];

          if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[cb.start];

            if (!atom || !atoms[cb.end]) {
              continue; // skip invalid
            }

            this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
          }
        }

        for (i = 0; i < this._complex.getSGroupCount(); i++) {
          var sGrp = this._complex.getSGroups()[i];

          for (j = 0; j < sGrp._atoms.length; j++) {
            sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
          }
        }

        for (i = 0; i < count; i++) {
          if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[i];
            atom.complexAtom = null;
            delete atom.complexAtom;
          }
        }

        this._complex.originalCML = data.originalCML;

        this._fixBondsArray();

        complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
        this._serialAtomMap = null;
        this._complex = null;
        return complex;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var complexes = [];
        var self = this;

        var moleculaSet = this._selectComponents(this._data);

        moleculaSet.forEach(function (molSet) {
          molSet.curr = 2;

          if (molSet.count === 0) {
            molSet.count = 1;
          }

          for (var i = 0; i < molSet.count; i++) {
            molSet.curr = i + 1;
            complexes.push(self._parseSet(molSet, false));
          }
        });
        var totalAtomsParsed = 0;
        complexes.forEach(function (c) {
          totalAtomsParsed += c.getAtomCount();
        });

        if (totalAtomsParsed <= 0) {
          throw new Error('The data does not contain valid atoms');
        }

        if (complexes.length > 1) {
          var joinedComplex = new Complex$2();
          joinedComplex.joinComplexes(complexes);
          joinedComplex.originalCML = complexes[0].originalCML;
          return joinedComplex;
        }

        if (complexes.length === 1) {
          return complexes[0];
        }

        return new Complex$2();
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && cmlStartRegexp.test(data);
      }
    }]);

    return CMLParser;
  }(Parser);

  CMLParser.formats = ['cml'];
  CMLParser.extensions = ['.cml'];

  var mmtf = createCommonjsModule(function (module, exports) {
  !function(r,t){t(exports);}(commonjsGlobal,function(r){function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else {if(!(1114112>o))throw new Error("bad codepoint "+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else {if(!(1114112>i))throw new Error("bad codepoint "+i);t+=4;}}return t}function e(r,i,o){var a=typeof r;if("string"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if("number"===a){if(!isFinite(r))throw new Error("Number not finite: "+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error("Number too small -0x"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if("boolean"===a)return i.setUint8(o,r?195:194),1;if("object"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else {var d=Object.keys(r);u=d.length;}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var v=d[l];f+=e(v,i,o+f),f+=e(r[v],i,o+f);}return f}throw new Error("Unknown type "+a)}function i(r){var t=typeof r;if("string"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if("number"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error("Number too small -0x"+r.toString(16).substr(1))}if("boolean"===t||null===r)return 1;if("object"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a]);}else {var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s]);}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error("Array or object too long 0x"+e.toString(16))}throw new Error("Unknown type "+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function v(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function g(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i);}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u);}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e;}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:a+=u===e||u===i?2:u>0?Math.ceil(u/e):Math.ceil(u/i);}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f;}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return [n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=v(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n]);}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o();}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join("")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error("Unknown type 0x"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return g(t);case 5:return s(t);case 6:return p(g(t),new Uint8Array(n));case 7:return p(g(t));case 8:return A(g(t));case 9:return M(g(t),g(e)[0]);case 10:return O(l(t),g(e)[0]);case 11:return y(l(t),g(e)[0]);case 12:return N(l(t),g(e)[0]);case 13:return N(f(t),g(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o);}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,v=t.onAtom,g=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k});}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z});}for(u=0;q>u;++u){if(v){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),v({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R});}m+=1;}if(g){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)g({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]});}y+=1;}h+=1;}if(p=U+1,U=m-1,g&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&g({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null});}L+=1;}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r);}catch(t){e(t);}}var o=new XMLHttpRequest;o.addEventListener("load",i,!0),o.addEventListener("error",e,!0),o.responseType="arraybuffer",o.open("GET",t+r.toUpperCase()),o.send();}function $(r,t,n){Z(r,or,t,n);}function _(r,t,n){Z(r,ar,t,n);}var rr=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],tr=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],nr=rr.concat(tr),er="v1.1.0dev",ir="//mmtf.rcsb.org/v1.0/",or=ir+"full/",ar=ir+"reduced/";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X;});
  });

  function _createSuper$1H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1I(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$3 = chem.Complex,
      Chain$1 = chem.Chain,
      Atom$1 = chem.Atom,
      Element$4 = chem.Element,
      Helix$2 = chem.Helix,
      Sheet$2 = chem.Sheet,
      Strand$2 = chem.Strand,
      Bond$3 = chem.Bond,
      Assembly$2 = chem.Assembly,
      Molecule$2 = chem.Molecule;

  var ArrayComparator = /*#__PURE__*/function () {
    function ArrayComparator(original) {
      classCallCheck(this, ArrayComparator);

      this._original = Array.from(original);

      this._original.sort();

      this._sum = 0;

      for (var i = 0; i < this._original.length; ++i) {
        this._sum += this._original[i];
      }
    }

    createClass(ArrayComparator, [{
      key: "compare",
      value: function compare(candidate) {
        var len = candidate.length;

        if (len !== this._original.length) {
          return false;
        }

        var sum = 0;
        var i;

        for (i = 0; i < len; ++i) {
          sum += candidate[i];
        }

        if (sum !== this._sum) {
          return false;
        }

        var sorted = Array.from(candidate);
        sorted.sort();

        for (i = 0; i < len; ++i) {
          if (sorted[i] !== this._original[i]) {
            return false;
          }
        }

        return true;
      }
    }]);

    return ArrayComparator;
  }();

  ArrayComparator.prototype.constructor = ArrayComparator;
  var StructuralElementType$5 = StructuralElement.Type; // see https://github.com/rcsb/mmtf-javascript/blob/master/src/mmtf-traverse.js

  var secStructToType = [StructuralElementType$5.HELIX_PI, // 0
  StructuralElementType$5.BEND, // 1
  StructuralElementType$5.HELIX_ALPHA, // 2
  StructuralElementType$5.STRAND, // 3
  StructuralElementType$5.HELIX_310, // 4
  StructuralElementType$5.BRIDGE, // 5
  StructuralElementType$5.TURN, // 6
  StructuralElementType$5.COIL // 7
  ];

  function getFirstByte(buf) {
    var bytes = new Uint8Array(buf, 0, 1);
    return bytes[0];
  }

  var MMTFParser = /*#__PURE__*/function (_Parser) {
    inherits(MMTFParser, _Parser);

    var _super = _createSuper$1H(MMTFParser);

    function MMTFParser(data, options) {
      var _this;

      classCallCheck(this, MMTFParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'mmtf';
      return _this;
    }

    createClass(MMTFParser, [{
      key: "_onModel",
      value: function _onModel(_modelData) {}
    }, {
      key: "_onChain",
      value: function _onChain(chainData) {
        if (chainData.modelIndex !== 0) {
          return;
        }

        var chain = new Chain$1(this._complex, chainData.chainName);
        this._complex._chains[chainData.chainIndex] = chain;
        chain._index = chainData.chainIndex;
      }
    }, {
      key: "_onGroup",
      value: function _onGroup(groupData) {
        if (groupData.modelIndex !== 0) {
          return;
        }

        if (this.settings.now.nowater) {
          // skip water
          if (groupData.groupName === 'HOH' || groupData.groupName === 'WAT') {
            return;
          }
        }

        var chain = this._complex._chains[groupData.chainIndex];
        var icode = !groupData.insCode.charCodeAt(0) ? '' : groupData.insCode;
        var residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
        residue._index = groupData.groupIndex;

        this._updateSecStructure(this._complex, residue, groupData);
      }
    }, {
      key: "_onAtom",
      value: function _onAtom(atomData) {
        if (atomData.modelIndex !== 0) {
          return;
        }

        var altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc;
        var atom = new Atom$1(atomData.groupIndex, // we store residue index here to replace it later with actual reference
        atomData.atomName, Element$4.getByName(atomData.element.toUpperCase()), new THREE.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord), Element$4.Role[atomData.atomName], false, // hetero atoms will be marked later
        atomData.atomId, altLoc, atomData.occupancy, atomData.bFactor, atomData.formalCharge);
        this._complex._atoms[atomData.atomIndex] = atom;
        atom.index = atomData.atomIndex;
        this._serialAtomMap[atomData.atomId] = atom;
      }
    }, {
      key: "_onBond",
      value: function _onBond(bondData) {
        var right = Math.max(bondData.atomIndex1, bondData.atomIndex2);

        if (right >= this._complex._atoms.length) {
          return;
        }

        var left = Math.min(bondData.atomIndex1, bondData.atomIndex2);

        this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, Bond$3.BondType.UNKNOWN, true);
      }
    }, {
      key: "_updateSecStructure",
      value: function _updateSecStructure(complex, residue, groupData) {
        var helixClasses = [3, -1, 1, -1, 5];

        if (!___default['default'].isUndefined(groupData) && groupData.secStruct === this._ssType) {
          residue._secondary = this._ssStruct;

          if (this._ssStruct) {
            this._ssStruct.term = residue;
          }

          return;
        }

        if (!___default['default'].isUndefined(groupData)) {
          // start new secondary structure
          var type = secStructToType[groupData.secStruct];
          this._ssType = groupData.secStruct;
          this._ssStart = residue;
          var struct = null;

          switch (this._ssType) {
            case -1: // undefined

            case 7:
              // coil
              break;

            case 0: // pi helix

            case 2: // alpha helix

            case 4:
              // 3-10 helix
              struct = new Helix$2(helixClasses[this._ssType], residue, residue, 0, '', '', 0);

              complex._helices.push(struct);

              break;

            case 3:
              {
                // extended
                var sheet = new Sheet$2('', 0);

                complex._sheets.push(sheet);

                struct = new Strand$2(sheet, residue, residue, 0, null, null);
                break;
              }

            default:
              if (type !== undefined) {
                struct = new StructuralElement(type, residue, residue);
              }

              break;
          }

          this._ssStruct = struct;
          residue._secondary = struct;

          if (struct) {
            complex.structures.push(struct);
          }
        }
      }
    }, {
      key: "_updateMolecules",
      value: function _updateMolecules(mmtfData) {
        var entities = mmtfData.entityList;

        if (!entities) {
          return;
        }

        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < entities.length; i++) {
          var entity = entities[i];
          var chains = entity.chainIndexList;
          var residues = [];

          for (var j = 0; j < chains.length; j++) {
            var chainIndex = chains[j]; // skip chains in models other than the first one

            if (chainIndex >= chainsInModel0) {
              continue;
            }

            var chain = this._complex._chains[chainIndex];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$2(this._complex, entity.description, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      } // populate complex with chains, residues and atoms

    }, {
      key: "_traverse",
      value: function _traverse(mmtfData) {
        var self = this; // get metadata

        var metadata = this._complex.metadata;
        metadata.id = mmtfData.structureId;
        metadata.title = [];
        metadata.title[0] = mmtfData.title;
        metadata.date = mmtfData.releaseDate;
        metadata.format = 'mmtf'; // create event callback functions

        var eventCallbacks = {
          onModel: function onModel(modelData) {
            self._onModel(modelData);
          },
          onChain: function onChain(chainData) {
            self._onChain(chainData);
          },
          onGroup: function onGroup(groupData) {
            self._onGroup(groupData);
          },
          onAtom: function onAtom(atomData) {
            self._onAtom(atomData);
          },
          onBond: function onBond(bondData) {
            self._onBond(bondData);
          }
        }; // temporary variables used during traversal to track secondary structures

        this._ssType = -1;
        this._ssStruct = null;
        this._ssStart = null; // traverse the structure and listen to the events

        mmtf.traverse(mmtfData, eventCallbacks);

        this._updateSecStructure(this._complex);

        this._updateMolecules(mmtfData);
      } // During traversal atoms and residues don't come sequentially
      // so a residue for certain atom can be unavailable. Thus we
      // store residue index in atom.
      // This function being called after traversal replaces the index
      // with actual reference, and also populates atom lists in residues.

    }, {
      key: "_linkAtomsToResidues",
      value: function _linkAtomsToResidues() {
        for (var i = 0; i < this._complex._atoms.length; ++i) {
          var atom = this._complex._atoms[i];
          var residue = this._complex._residues[atom.residue];
          atom.residue = residue;

          residue._atoms.push(atom);
        }
      }
    }, {
      key: "_findSynonymousChains",
      value: function _findSynonymousChains() {
        var named = {};

        for (var i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!named.hasOwnProperty(name)) {
            named[name] = [];
          }

          named[name].push(chain._index);
        }

        return named;
      } // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.

    }, {
      key: "_parseAssemblyInfo",
      value: function _parseAssemblyInfo(mmtfData) {
        var i;
        var j;
        var k;
        var assemblies = [];
        var logger = this.logger;

        for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
          var baInfo = mmtfData.bioAssemblyList[i];

          if (baInfo.transformList.length === 0) {
            continue;
          }

          var chains = baInfo.transformList[0].chainIndexList;
          var chainListCheck = new ArrayComparator(chains); // build list of chain names

          var chainNames = {};

          for (j = 0; j < chains.length; ++j) {
            chainNames[this._complex._chains[chains[j]].getName()] = 1;
          } // all chains with the same name should belong to assembly if one of them belongs


          var allChains = [];
          var name = void 0;

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              // just concat arrays -- there should be no duplicates
              Array.prototype.push.apply(allChains, this._chainsByName[name]);
            }
          }

          if (!chainListCheck.compare(allChains)) {
            // assembly is missing some of the chains
            logger.debug('MMTF: Assembly is missing some of the synonymous chains. Skipping...');
          }

          var a = new Assembly$2(this._complex); // add chains to assembly

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              a.addChain(name);
            }
          } // add unique matrices to assembly


          a.addMatrix(new THREE.Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());

          for (j = 1; j < baInfo.transformList.length; ++j) {
            var transform = baInfo.transformList[j];

            if (!chainListCheck.compare(transform.chainIndexList)) {
              // list of chains for this transform doesn't match that for other transforms
              // this is illegal in our structure
              logger.debug('MMTF: Chain lists differ for different transforms in one assembly. Skipping...');
              continue;
            }

            var m = new THREE.Matrix4().fromArray(transform.matrix).transpose(); // check if matrix is already in the list

            for (k = 0; k < a.matrices.length; ++k) {
              if (a.matrices[k].equals(m)) {
                break;
              }
            }

            if (k === a.matrices.length) {
              a.addMatrix(m);
            }
          }

          a.finalize();
          assemblies.push(a);
        }

        return assemblies;
      } // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.

    }, {
      key: "_markHeteroAtoms",
      value: function _markHeteroAtoms(mmtfData) {
        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < mmtfData.entityList.length; ++i) {
          var entity = mmtfData.entityList[i];

          if (entity.type !== 'polymer') {
            for (var j = 0; j < entity.chainIndexList.length; ++j) {
              var chainIndex = entity.chainIndexList[j]; // skip chains in models other than the first one

              if (chainIndex >= chainsInModel0) {
                continue;
              }

              var chain = this._complex._chains[chainIndex];

              for (var k = 0; k < chain._residues.length; ++k) {
                var res = chain._residues[k];

                for (var m = 0; m < res._atoms.length; ++m) {
                  res._atoms[m].het = true;
                }
              }
            }
          }
        }
      } // joins chains with the same name into single chain

    }, {
      key: "_joinSynonymousChains",
      value: function _joinSynonymousChains() {
        var i;
        var j;
        var primaryChainsArray = [];
        var primaryChainsHash = {}; // join chains

        for (i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!primaryChainsHash.hasOwnProperty(name)) {
            // new name -- this is a primary chain
            primaryChainsHash[name] = chain;
            chain._index = primaryChainsArray.length; // update index as this array will later replace original chain list

            primaryChainsArray.push(chain);
            continue;
          } // this chain should be joined with the primary chain of the same name


          var primary = primaryChainsHash[name];

          for (j = 0; j < chain._residues.length; ++j) {
            var residue = chain._residues[j];

            primary._residues.push(residue);

            residue._chain = primary;
          }
        } // replace chains list with one containing only primary chains
        // dropping references to all chains but primary


        this._complex._chains = primaryChainsArray;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var mmtfData = mmtf.decode(this._data);
        this._complex = new Complex$3();
        this._serialAtomMap = {}; // filled during traversal

        this._traverse(mmtfData);

        this._linkAtomsToResidues();

        this._markHeteroAtoms(mmtfData);

        this._chainsByName = this._findSynonymousChains();
        Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));

        this._joinSynonymousChains();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        return this._complex;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        // check if it's binary MessagePack format containing a map (dictionary)
        // see https://github.com/msgpack/msgpack/blob/master/spec.md
        return ___default['default'].isArrayBuffer(data) && (getFirstByte(data) | 1) === 0xDF;
      }
    }]);

    return MMTFParser;
  }(Parser);

  MMTFParser.formats = ['mmtf'];
  MMTFParser.extensions = ['.mmtf'];
  MMTFParser.binary = true;

  function _createSuper$1I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1J(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var ParsingError = /*#__PURE__*/function (_Error) {
    inherits(ParsingError, _Error);

    var _super = _createSuper$1I(ParsingError);

    function ParsingError(message, line, column) {
      var _this;

      classCallCheck(this, ParsingError);

      _this = _super.call(this, "data:".concat(line, ":").concat(column, ": ").concat(message));

      if (Error.captureStackTrace) {
        Error.captureStackTrace(assertThisInitialized(_this), ParsingError);
      }

      _this.name = 'ParsingError';
      _this.parseLine = line;
      _this.parseColumn = column;
      return _this;
    }

    return ParsingError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function _isWhitespace(ch) {
    return ch === 32 || ch === 10 || ch === 13 || ch === 9;
  }

  function _inlineIndexOf(ch0, str, idx) {
    var len = str.length;
    var ch = -1;

    while (idx < len) {
      ch = str.charCodeAt(idx);

      if (ch === ch0 || ch === 10) {
        break;
      }

      ++idx;
    }

    return ch === ch0 ? idx : -1;
  }

  function readCIF(source) {
    var i = 0;
    var j = 0;
    var n = source.length;
    var code = NaN;
    var newline = true;
    var line = 1;
    var column = 1;
    var begin;
    var state = 0; // 0 - start, 1 - block, 2 - item, 3 - loop, 4 - values, 5 - value

    var result = {};
    var block = {};
    var keys = [];
    var keysCount = 0;
    var key = '';
    var values = [];
    var valuesCount = 0;
    var value;

    function _parseValue() {
      var val;

      if ((code === 46 || code === 63) && (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))) {
        // '.' or '?' .....
        // it's a missing value
        ++column;
        ++i;
        return undefined;
      }

      if (newline && code === 59) {
        // ';' ......................................................................
        // parse multi-line string
        j = i;
        var lines = 0;

        do {
          j = _inlineIndexOf(10, source, j + 1); // '\n'

          if (j === -1) {
            throw new ParsingError('Unterminated text block found', line, column);
          }

          ++lines;
        } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);

        val = source.substring(i + 1, j).replace(/\r/g, '');
        i = j + 2;
        line += lines;
        column = 1;
        newline = false;
        return val;
      }

      if (code === 39 || code === 34) {
        // ''' or '"' ...........................................................
        // parse quoted string
        j = i;

        do {
          j = _inlineIndexOf(code, source, j + 1);

          if (j === -1) {
            throw new ParsingError('Unterminated quoted string found', line, column);
          }
        } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));

        val = source.substring(i + 1, j);
        column += j - i + 1;
        i = j + 1;
        return val;
      } // ......................................................................................................
      // parse until the first whitespace


      j = i;

      while (j < n && !_isWhitespace(source.charCodeAt(j))) {
        ++j;
      }

      val = source.substring(i, j);
      column += j - i;
      i = j; // try to convert to a number

      var num = Number(val);

      if (!Number.isNaN(num)) {
        return num;
      } // or leave as an unquoted string


      return val;
    }

    function _storeKey(tag) {
      keys[keysCount++] = tag;
    }

    function _storeValue(val) {
      var keyIndex = valuesCount % keysCount;
      values[keyIndex].push(val);
      ++valuesCount;
      return val;
    }

    while (i <= n) {
      code = source.charCodeAt(i); // 'NaN' in place of '<eof>'

      if (code === 13) ; else if (code === 10) {
        // '\n' ................................................................................
        // take note of new lines
        newline = true;
        ++line;
        column = 1;
      } else {
        // process inline characters
        if (code === 32 || code === 9) ; else if (code === 35) {
          // '#' ...............................................................................
          // skip the comment until before the end of the line
          i = _inlineIndexOf(10, source, i + 1); // '\n'

          if (i === -1) {
            break;
          } else {
            continue; // don't forget to process the new line
          }
        } else if (state === 0) {
          // start =============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            j = i + 5;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // add new data block
              result[source.substring(begin, i)] = block = {};
              state = 1; // block

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Data block name missing', line, column);
            }
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            break;
          } else {
            // ..................................................................................................
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 1) {
          // block =============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            state = 0; // start

            continue; // parse again in a different state
          } else if (code === 95) {
            // '_' .............................................................................
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // start new item
              key = source.substring(begin, i);
              state = 2; // item

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            // 'loop_' ...
            i += 5;
            column += 5;

            if (i < n && !_isWhitespace(source.charCodeAt(i))) {
              throw new ParsingError("Unexpected character in state ".concat(state), line, column);
            } else {
              // start new loop
              keys = [];
              keysCount = 0;
              values = [];
              valuesCount = 0;
              state = 3; // loop

              continue; // don't forget to process the whitespace
            }
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            break;
          } else {
            // ..................................................................................................
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 2) {
          // item ==============================================================================
          if (Number.isNaN(code)) {
            break;
          }

          value = _parseValue();

          ___default['default'].set(block, key, value);

          state = 1; // block

          continue;
        } else if (state === 3) {
          // loop ==============================================================================
          if (code === 95) {
            // '_' ....................................................................................
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              // add new key
              _storeKey(source.substring(begin, i));

              continue; // don't forget to process the whitespace
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else {
            // ..................................................................................................
            if (keysCount > 0) {
              for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
                value = [];
                values[keyIndex] = value;

                ___default['default'].set(block, keys[keyIndex], value);
              }

              state = 4;
              continue; // parse again in a different state
            }

            throw new ParsingError('Data tags are missing inside a loop', line, column);
          }
        } else if (state === 4) {
          // values ============================================================================
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            // 'data_' ..........
            state = 0; // start
          } else if (code === 95) {
            // '_' .............................................................................
            state = 1; // block
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            // 'loop_' ...
            state = 1; // block
          } else if (Number.isNaN(code)) {
            // <eof> ....................................................................
            state = 0;
          } else {
            // ..................................................................................................
            _storeValue(_parseValue());
          }

          continue; // parse again in a different state
        } else {
          // ====================================================================================================
          throw new ParsingError("Unexpected internal state ".concat(state), line, column);
        }

        newline = false;
        ++column;
      }

      ++i;
    }

    if (state === 2) {
      // item
      throw new ParsingError("Unexpected end of file in state ".concat(state), line, column);
    }

    return result;
  }

  function _createSuper$1J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1K(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$4 = chem.Complex,
      Element$5 = chem.Element,
      Helix$3 = chem.Helix,
      Sheet$3 = chem.Sheet,
      Strand$3 = chem.Strand,
      Assembly$3 = chem.Assembly,
      Molecule$3 = chem.Molecule;
  var cRequiredAtomFields = ['auth_seq_id', 'Cartn_x', 'Cartn_y', 'Cartn_z', 'label_atom_id'];
  var cSecondaryCoding = {
    helx: 'helix',
    turn: 'turn',
    strn: 'strand'
  };

  function getTypeFromId(string) {
    var typeId = /[A-Za-z]+/.exec(string);

    if (!typeId) {
      return null;
    }

    return cSecondaryCoding[typeId[0].toLowerCase()];
  }
  /**
   * Make valid object an array
   * @param arrayLikeObject
   * @return {array, object} array or object
   */


  function arrize(arrayLikeObject) {
    if (arrayLikeObject === null || arrayLikeObject === undefined || ___default['default'].isArray(arrayLikeObject)) {
      return arrayLikeObject;
    }

    return [arrayLikeObject];
  }

  function nameToElement$1(name) {
    // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    //
    // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
    //
    // Atom names start with element symbols right-justified in columns 13-14
    // as permitted by the length of the name. For example, the symbol FE for
    // iron appears in columns 13-14, whereas the symbol C for carbon appears
    // in column 14 (see Misaligned Atom Names). If an atom name has four
    // characters, however, it must start in column 13 even if the element
    // symbol is a single character (for example, see Hydrogen Atoms).
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  }

  var AtomDataError = /*#__PURE__*/function (_Error) {
    inherits(AtomDataError, _Error);

    var _super = _createSuper$1J(AtomDataError);

    function AtomDataError(message) {
      var _this;

      classCallCheck(this, AtomDataError);

      _this = _super.call(this);
      _this.name = 'AtomDataError';
      _this.message = message;
      return _this;
    }

    return AtomDataError;
  }( /*#__PURE__*/wrapNativeSuper(Error));

  function _getOperations(operList) {
    if (!operList) {
      return null;
    }

    var idc = arrize(operList.id);
    var matrix = operList.matrix,
        vector = operList.vector;

    if (!idc || !matrix || !vector) {
      return null;
    }

    var ops = [];

    for (var i = 0, n = idc.length; i < n; ++i) {
      var mtx = new THREE.Matrix4();
      var elements = mtx.elements;

      for (var row = 0; row < 3; ++row) {
        var matrixData = matrix[row + 1];
        elements[row] = arrize(matrixData[1])[i];
        elements[row + 4] = arrize(matrixData[2])[i];
        elements[row + 8] = arrize(matrixData[3])[i];
        elements[row + 12] = arrize(vector[row + 1])[i];
      }

      ops[idc[i]] = mtx;
    }

    return ops;
  }

  function _extractOperations(assemblyGen, opsDict) {
    assemblyGen = ___default['default'].isString(assemblyGen) ? assemblyGen : "".concat(assemblyGen);
    var l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '');
    var groupStr = l.split('!');
    var gps = [];

    for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
      var gr = groupStr[grIdx].split(',');
      var gp = [];
      var idx = 0;

      for (var i = 0, n = gr.length; i < n; ++i) {
        var s = gr[i];

        if (s.includes('-')) {
          var es = s.split('-');
          var j = parseInt(es[0], 10);
          var m = parseInt(es[1], 10);

          for (; j <= m; ++j) {
            gp[idx++] = opsDict[j];
          }
        } else {
          gp[idx++] = opsDict[s];
        }
      }

      gps.push(gp);
    } // traverse all groups from the end of array and make all mults


    var matrices = [];
    var cnt = 0;

    function traverse(level, mtx) {
      for (var ii = 0, nn = gps[level].length; ii < nn; ++ii) {
        var newMtx = mtx ? mtx.clone() : new THREE.Matrix4();
        newMtx.multiplyMatrices(gps[level][ii], newMtx);

        if (level === 0) {
          matrices[cnt++] = newMtx;
        } else {
          traverse(level - 1, newMtx);
        }
      }
    }

    traverse(gps.length - 1);
    return matrices;
  }

  var CIFParser = /*#__PURE__*/function (_Parser) {
    inherits(CIFParser, _Parser);

    var _super2 = _createSuper$1J(CIFParser);

    function CIFParser(data, options) {
      var _this2;

      classCallCheck(this, CIFParser);

      _this2 = _super2.call(this, data, options);
      _this2.asymDict = {};
      _this2.molecules = [];
      _this2._options.fileType = 'cif';
      return _this2;
    }

    createClass(CIFParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing CIF file..');
        var data = readCIF(this._data);
        return this._toComplex(data);
      }
      /**
       * Convert intermediate structure into our valid Complex object
       * @param cifData intermediate CIF object
       * @returns {Complex} complex
       * @private
       */

    }, {
      key: "_toComplex",
      value: function _toComplex(cifData) {
        var complex = new Complex$4();
        var complexData = cifData[Object.keys(cifData)[0]];

        this._extractAtoms(complex, complexData);

        this._extractSecondary(complex, complexData);

        this._extractAssemblies(complex, complexData);

        this._extractMolecules(complex, complexData);

        this._extractMetadata(complex, complexData);

        complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing
        });
        return complex;
      }
      /**
       * Extract metadata
       * @param complex structure to fill
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractMetadata",
      value: function _extractMetadata(complex, complexData) {
        var metadata = complex.metadata;
        metadata.id = complexData.entry.id;
        metadata.classification = complexData.struct_keywords.pdbx_keywords;
        var databaserev = complexData.database_PDB_rev;
        metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : '';
        metadata.format = 'cif';
        metadata.title = [];
        metadata.title[0] = complexData.struct.title;
      }
      /**
       * Extract molecules information from CIF structure (should be called strictly after _extractAtoms)
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractMolecules",
      value: function _extractMolecules(complex, complexData) {
        var molData = complexData.entity;
        var names = arrize(molData.pdbx_description);
        var count = names.length;
        var i; // molecules names from cif

        for (i = 0; i < count; i++) {
          if (this.molecules[i]) {
            // molecule was created during atoms processing
            this.molecules[i].name = names[i];
          } else {
            // molecule wasn't created, because there is no atom which is contained
            this.molecules[i] = {
              name: names[i],
              residues: []
            };
          }
        } // reorganize molecules for complex and check chains


        var molecules = complex.getMolecules();

        for (i = 0; i < count; i++) {
          var molecule = this.molecules[i];
          molecules[i] = new Molecule$3(complex, molecule.name, i + 1);
          molecules[i].residues = molecule.residues;
        }
      }
      /**
       * Extract atom information from CIF structure and fill complex
       * @param {Complex} complex
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var atomData = complexData.atom_site;

        if (!atomData) {
          throw new AtomDataError('CIF parsing error: atom_site is not specified!');
        }

        for (var f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
          if (!atomData[cRequiredAtomFields[f]]) {
            throw new AtomDataError("CIF parsing error: requires field ".concat(cRequiredAtomFields[f], " not found!"));
          }
        }

        var asymDict = this.asymDict; // required fields

        var resIdc = arrize(atomData.auth_seq_id);
        var x = arrize(atomData.Cartn_x);
        var y = arrize(atomData.Cartn_y);
        var z = arrize(atomData.Cartn_z);
        var names = arrize(atomData.label_atom_id);
        var count = names.length; // optional fields

        var group = arrize(atomData.group_PDB) || [];
        var chainIdc = arrize(atomData.auth_asym_id) || [];
        var chainLabelIdc = arrize(atomData.label_asym_id) || [];
        var serials = arrize(atomData.id) || [];
        var iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
        var resNames = arrize(atomData.label_comp_id) || [];
        var elements = arrize(atomData.type_symbol) || [];
        var tempFactors = arrize(atomData.B_iso_or_equiv) || [];
        var occupancies = arrize(atomData.occupancy) || [];
        var charges = arrize(atomData.pdbx_formal_charge) || [];
        var altLocs = arrize(atomData.label_alt_id) || [];
        var models = arrize(atomData.pdbx_PDB_model_num) || [];
        var molecules = arrize(atomData.label_entity_id) || [];
        var chain = null;
        var residue = null;

        for (var i = 0; i < count; ++i) {
          var model = models[i] || 1;

          if (model !== 1) {
            continue;
          }

          var chainID = String(chainIdc[i] || ' ');

          if (!chain || chain.getName() !== chainID) {
            chain = complex.getChain(chainID) || complex.addChain(chainID);
          }

          asymDict[String(chainLabelIdc[i] || ' ')] = chainID;
          var resSeq = resIdc[i];
          var iCode = String(iCodes[i] || ' ');
          var resName = String(resNames[i] || '');

          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            residue = chain.addResidue(resName, resSeq, iCode); // store residue in appropriate molecule

            var moleculeIdx = molecules[i] - 1;
            var entity = this.molecules[moleculeIdx];

            if (!entity) {
              // create new molecule if it hasn't been created
              this.molecules[moleculeIdx] = {
                name: '',
                residues: []
              };
              entity = this.molecules[moleculeIdx];
            }

            entity.residues.push(residue);
          }

          var name = names[i];
          var element = elements[i] || nameToElement$1(name);
          var type = Element$5.getByName(element);
          var role = Element$5.Role[name.trim()];
          var xyz = new THREE.Vector3(x[i], y[i], z[i]);
          var het = group[i] === 'HETATM' || false;
          var serial = serials[i] || i;
          var tempFactor = tempFactors[i] || 0.0;
          var occupancy = occupancies[i] || 0.0;
          var altLoc = String(altLocs[i] || '');
          var charge = charges[i] || 0;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }
      }
      /**
       * Extracts secondary structure information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex - complex to fill
       * @param complexData - CIF complex data
       * @private
       */

    }, {
      key: "_extractSecondary",
      value: function _extractSecondary(complex, complexData) {
        if (complexData.struct_conf) {
          this._extractConfs(complex, complexData.struct_conf);
        }

        if (complexData.struct_sheet_range) {
          this._extractSheets(complex, complexData.struct_sheet_range);
        }
      }
      /**
       * Extracts sheets information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex
       * @param sheetData
       * @private
       */

    }, {
      key: "_extractSheets",
      value: function _extractSheets(complex, sheetData) {
        var asymDict = this.asymDict;

        if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
          return;
        } // Strand(sheet, start, end, sense, cur, prev)


        var sheets = complex._sheets;

        function getSheet(name) {
          var n = sheets.length;

          for (var i = 0; i < n; ++i) {
            if (sheets[i]._name === name) {
              return sheets[i];
            }
          }

          sheets[n] = new Sheet$3(name, 0);
          return sheets[n];
        }

        var sheetNames = arrize(sheetData.sheet_id);
        var strandNames = arrize(sheetData.id);
        var starts = arrize(sheetData.beg_auth_seq_id);
        var ends = arrize(sheetData.end_auth_seq_id);
        var chains = arrize(sheetData.beg_label_asym_id);
        var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
        var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];

        for (var i = 0, n = strandNames.length; i < n; ++i) {
          var chain = complex.getChain(asymDict[chains[i]]);
          var sheet = getSheet(sheetNames[i]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode); // TODO think about last condition

          if (!start || !end) {
            continue;
          }

          var strand = new Strand$3(sheet, start[0], end[0], 0, null, null);
          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = strand;
          }

          sheet.addStrand(strand);
          complex.structures.push(strand);
        }
      }
      /**
       * Extracts helix/turn/strand(?) information from CIF intermediate data
       * and adds it into complex
       * @param {Complex} complex
       * @param helicesData
       * @private
       */

    }, {
      key: "_extractConfs",
      value: function _extractConfs(complex, helicesData) {
        var asymDict = this.asymDict;

        if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
          return;
        }

        var types = arrize(helicesData.conf_type_id);
        var starts = arrize(helicesData.beg_auth_seq_id);
        var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
        var ends = arrize(helicesData.end_auth_seq_id);
        var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
        var comments = arrize(helicesData.details) || [];
        var lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
        var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
        var names = arrize(helicesData.id) || [];
        var chains = arrize(helicesData.beg_label_asym_id);

        for (var i = 0, n = types.length; i < n; ++i) {
          var type = getTypeFromId(types[i]);

          if (!type) {
            continue;
          }

          var name = names[i] || types[i];
          var chain = complex.getChain(asymDict[chains[i]]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode); // TODO think about last condition

          if (!start || !end) {
            continue;
          }

          var comment = comments[i] || '';
          var length = lengths[i] || 0;
          var helixClass = helixClasses[i] || ' ';
          var struct = void 0;

          if (type === 'helix') {
            var idx = complex._helices.length;
            struct = new Helix$3(helixClass, start[0], end[0], idx, name, comment, length);
            complex.addHelix(struct);
            complex.structures.push(struct);
          } else if (type === 'turn') {
            struct = new StructuralElement(StructuralElement.Type.TURN, start[0], end[0]);
            complex.structures.push(struct);
          } else {
            struct = null;
          }

          if (!struct) {
            continue;
          }

          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = struct;
          }
        }
      }
      /**
       * Extract biological assemblies information from CIF structure and fill complex
       * @param {Complex} complex
       * @param complexData complex data from CIF file
       * @private
       */

    }, {
      key: "_extractAssemblies",
      value: function _extractAssemblies(complex, complexData) {
        var asymDict = this.asymDict;
        var asmGen = complexData.pdbx_struct_assembly_gen;

        if (!asmGen) {
          return;
        }

        var asmIdx = arrize(asmGen.assembly_id);
        var asmOper = arrize(asmGen.oper_expression);
        var asmList = arrize(asmGen.asym_id_list);

        if (!asmIdx || !asmOper || !asmList) {
          return;
        }

        var operList = _getOperations(complexData.pdbx_struct_oper_list);

        if (!operList) {
          return;
        }

        for (var i = 0, n = asmIdx.length; i < n; ++i) {
          var asm = new Assembly$3(complex);

          var assemblyOps = _extractOperations(asmOper[i], operList);

          var entries = asmList[i].split(',');

          for (var ii = 0, nn = entries.length; ii < nn; ++ii) {
            var chain = entries[ii].trim();

            if (chain.length > 0) {
              asm.addChain(asymDict[chain]);
            }
          }

          asm.matrices = assemblyOps;
          complex.units.push(asm);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && /^\s*data_/i.test(data);
      }
    }]);

    return CIFParser;
  }(Parser);

  CIFParser.formats = ['cif', 'mmcif'];
  CIFParser.extensions = ['.cif', '.mmcif'];

  var valueType = {
    singular: 0,
    vector: 1,
    array: 2,
    buffer: 3
  };

  var VolumeModel = /*#__PURE__*/function () {
    function VolumeModel() {
      classCallCheck(this, VolumeModel);

      defineProperty(this, "_xyz2crs", []);

      defineProperty(this, "_origin", new THREE.Vector3(0, 0, 0));

      this._header = {};
      this._boxSize = new THREE.Vector3();
      this._boxStart = new THREE.Vector3();
      this._header.delta = {};
      this._header.extent = [];
      this._header.nstart = [];
      this._header.grid = [];
      this._header.crs2xyz = [];
      this._header.cellDims = new THREE.Vector3();
      this._header.angles = [];
      this._header.origin = new THREE.Vector3(0, 0, 0);
      this._header.dmin = 0;
      this._header.dmean = 0;
      this._header.dmax = 0;
    }

    createClass(VolumeModel, [{
      key: "_typedCheck",
      value: function _typedCheck() {
        if (___default['default'].isTypedArray(this._buff)) {
          this._buff = this._buff.buffer;
        } else if (!___default['default'].isArrayBuffer(this._buff)) {
          throw new TypeError('Expected ArrayBuffer or TypedArray');
        }
      }
    }, {
      key: "_fillHeader",
      value: function _fillHeader(headerFormat, arrays) {
        for (var key in headerFormat) {
          if (headerFormat.hasOwnProperty(key)) {
            switch (headerFormat[key][0]) {
              case valueType.singular:
                this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
                break;

              case valueType.array:
                this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.vector:
                this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.buffer:
                this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
                break;
            }
          }
        }
      }
    }, {
      key: "_parseVector",
      value: function _parseVector(vector, arr, pos) {
        var _ref = [arr[pos], arr[pos + 1], arr[pos + 2]];
        vector.x = _ref[0];
        vector.y = _ref[1];
        vector.z = _ref[2];
      }
    }, {
      key: "_parseArray",
      value: function _parseArray(vector, arr, pos) {
        vector[0] = arr[pos];
        vector[1] = arr[pos + 1];
        vector[2] = arr[pos + 2];
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {}
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {}
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {}
    }, {
      key: "_getAxis",
      value: function _getAxis() {
        var header = this._header;
        var xScale = header.cellDims.x / header.grid[0];
        var yScale = header.cellDims.y / header.grid[1];
        var zScale = header.cellDims.z / header.grid[2];

        var _header$angles = slicedToArray(header.angles, 3),
            alpha = _header$angles[0],
            beta = _header$angles[1],
            gamma = _header$angles[2];

        var z1 = Math.cos(beta);
        var z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
        var z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
        var xaxis = new THREE.Vector3(xScale, 0, 0);
        var yaxis = new THREE.Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
        var zaxis = new THREE.Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
        return [xaxis, yaxis, zaxis];
      }
    }, {
      key: "_getXYZdim",
      value: function _getXYZdim() {
        return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
      }
    }, {
      key: "_getVolumeInfo",
      value: function _getVolumeInfo() {
        var volInfo = ___default['default'].pick(this._header, ['dmean', 'dmin', 'dmax', 'sd', 'delta']);

        volInfo.obtuseAngle = this._header.angles.map(function (angle) {
          return Number(angle >= Math.PI / 2);
        });
        return volInfo;
      }
    }, {
      key: "_setBoxParams",
      value: function _setBoxParams(xaxis, yaxis, zaxis) {
        var _this = this;

        // if axes are not orthogonal, the origins might not match with box coordinates - need to make shift
        var shiftX = 0;
        var shiftY = 0;

        var _this$_header$angles = slicedToArray(this._header.angles, 3),
            alpha = _this$_header$angles[0],
            beta = _this$_header$angles[1],
            gamma = _this$_header$angles[2];

        if (gamma >= Math.PI / 2) {
          shiftX += Math.abs(yaxis.x);
        }

        if (beta >= Math.PI / 2) {
          shiftX += Math.abs(zaxis.x);
        }

        if (alpha >= Math.PI / 2) {
          shiftY += Math.abs(zaxis.y);
        }

        this._boxStart = new THREE.Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
        this._boxSize = new THREE.Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));

        var delta = function delta(axe, proj) {
          return Math.abs(axe[proj]) / _this._boxSize[proj];
        };

        this._header.delta.x = delta(yaxis, 'x');
        this._header.delta.y = delta(zaxis, 'x');
        this._header.delta.z = delta(zaxis, 'y');
      }
    }, {
      key: "_getXYZbox",
      value: function _getXYZbox() {
        return new THREE.Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {}
    }, {
      key: "parse",
      value: function parse(data) {
        this._parseHeader(data);

        this._setOrigins();

        return new Volume(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
      }
    }]);

    return VolumeModel;
  }();

  function _createSuper$1K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1L(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var CCP4Header = {
    extent: [valueType.array, 'u32', 0],
    type: [valueType.singular, 'u32', 3],
    nstart: [valueType.array, 'i32', 4],
    grid: [valueType.array, 'u32', 7],
    cellDims: [valueType.vector, 'f32', 10],
    angles: [valueType.array, 'f32', 13],
    crs2xyz: [valueType.array, 'i32', 16],
    dmin: [valueType.singular, 'f32', 19],
    dmax: [valueType.singular, 'f32', 20],
    dmean: [valueType.singular, 'f32', 21],
    ispg: [valueType.singular, 'u32', 22],
    nsymbt: [valueType.singular, 'u32', 23],
    lksflg: [valueType.singular, 'u32', 24],
    customData: [valueType.buffer, 'buffer', 25, 9],
    origin: [valueType.vector, 'f32', 34],
    map: [valueType.buffer, 'buffer', 52, 1],
    machine: [valueType.singular, 'u32', 53],
    sd: [valueType.singular, 'f32', 54],
    nlabel: [valueType.singular, 'f32', 55],
    label: [valueType.buffer, 'buffer', 56, 200]
  };

  var Ccp4Model = /*#__PURE__*/function (_VolumeModel) {
    inherits(Ccp4Model, _VolumeModel);

    var _super = _createSuper$1K(Ccp4Model);

    function Ccp4Model() {
      classCallCheck(this, Ccp4Model);

      return _super.apply(this, arguments);
    }

    createClass(Ccp4Model, [{
      key: "_parseHeader",
      // read header (http://www.ccp4.ac.uk/html/maplib.html)
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.u32 = new Uint32Array(this._buff, 0, 56);
        arrays.i32 = new Int32Array(this._buff, 0, 56);
        arrays.f32 = new Float32Array(this._buff, 0, 56);
        arrays.buffer = this._buff;
        var header = this._header;

        this._fillHeader(CCP4Header, arrays); // calculate non-orthogonal unit cell coordinates


        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0;
        });
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        var header = this._header;

        if (header.cellDims.x === 0.0 && header.cellDims.y === 0.0 && header.cellDims.z === 0.0) {
          header.cellDims.set(1.0, 1.0, 1.0);
        } // Apply header conversion
        // Mapping between CCP4 column, row, section and VMD x, y, z.


        var crs2xyz = this._header.crs2xyz;

        if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
          crs2xyz[0] = 1;
          crs2xyz[1] = 2;
          crs2xyz[2] = 3;
        }

        var xyz2crs = this._xyz2crs;
        xyz2crs[crs2xyz[0] - 1] = 0; // column

        xyz2crs[crs2xyz[1] - 1] = 1; // row

        xyz2crs[crs2xyz[2] - 1] = 2; // section
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        var header = this._header;
        var xyz2crs = this._xyz2crs; // Handle both MRC-2000 and older format maps

        if (header.origin.x === 0.0 && header.origin.y === 0.0 && header.origin.z === 0.0) {
          this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);

          this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);

          this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
        } else {
          this._origin = header.origin; // Use ORIGIN records rather than old n[xyz]start records
          //   http://www2.mrc-lmb.cam.ac.uk/image2000.html
          // XXX the ORIGIN field is only used by the EM community, and
          // has undefined meaning for non-orthogonal maps and/or non-cubic voxels, etc.
        }

        xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
        yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
        zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);

        if (header.type === 2) {
          this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
        } else {
          throw new Error("CCP4: Unsupported format ".concat(header.type));
        }

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var data = this._data;
        var xyz2crs = this._xyz2crs;
        var xyzData = new Float32Array(data.length);

        var dim = this._getXYZdim();

        var xSize = dim[0];
        var ySize = dim[1];
        var crsIdx = 0;
        var coord = [];
        var x;
        var y;
        var z;

        for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
          // Site
          for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
            // Row
            for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
              // Column
              x = coord[xyz2crs[0]];
              y = coord[xyz2crs[1]];
              z = coord[xyz2crs[2]];
              xyzData[x + xSize * (y + ySize * z)] = data[crsIdx];
            }
          }
        }

        return xyzData;
      }
    }]);

    return Ccp4Model;
  }(VolumeModel);

  var CCP4Parser = /*#__PURE__*/function (_Parser) {
    inherits(CCP4Parser, _Parser);

    var _super2 = _createSuper$1K(CCP4Parser);

    function CCP4Parser(data, options) {
      var _this;

      classCallCheck(this, CCP4Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'ccp4';
      _this.model = new Ccp4Model();
      return _this;
    }

    createClass(CCP4Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false; // Autodetection is not implemented yet
      }
    }]);

    return CCP4Parser;
  }(Parser);

  CCP4Parser.formats = ['ccp4'];
  CCP4Parser.extensions = ['.ccp4', '.map', '.mrc'];
  CCP4Parser.binary = true;

  function _createSuper$1L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1M(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$5 = chem.Complex,
      Element$6 = chem.Element,
      Molecule$4 = chem.Molecule;

  var XYZParser = /*#__PURE__*/function (_Parser) {
    inherits(XYZParser, _Parser);

    var _super = _createSuper$1L(XYZParser);

    function XYZParser(data, options) {
      var _this;

      classCallCheck(this, XYZParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._atomsInf = null;
      _this._options.fileType = 'xyz';
      _this._fileName = options.name;
      return _this;
    }

    createClass(XYZParser, [{
      key: "_parseToAtomsInf",
      value: function _parseToAtomsInf(source) {
        var endnAtoms = source.indexOf('\n');
        var nAtoms = parseInt(source.substring(0, endnAtoms), 10);
        var endComment = source.indexOf('\n', endnAtoms + 1);
        var comment = source.slice(endnAtoms + 1, endComment).trim();

        if (comment.length === 0) {
          comment = this._fileName;
        }

        var startAtomsInf = endComment + source.substring(endComment).search(/\S/);
        this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);

        if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
          this._complex.error = {
            message: 'wrong number of atoms'
          };
          return;
        }

        this._complex.metadata.format = 'xyz';
        this._complex.name = comment;
      }
    }, {
      key: "_parseAtomsInf",
      value: function _parseAtomsInf() {
        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;

        var chain = this._complex.addChain('A');

        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0; i < this._atomsInf.length - 1; i++) {
          var words = this._atomsInf[i].split(/[\s,]+/);

          if (words.length !== 4) {
            this._complex.error = {
              message: 'missed parameters'
            };
            break;
          }

          var serial = i + 1;
          var name = words[0];
          var xyz = new THREE.Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
          var type = Element$6.getByName(name);
          var role = undefined;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }

        var molecule = new Molecule$4(this._complex, this._complex.name, 1);
        molecule.residues = residue;
        this._complex._molecules[0] = molecule;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$5();

        this._parseToAtomsInf(this._data);

        this._parseAtomsInf();

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        this._complex = null;
        this._atomsInf = null;

        if (result.error) {
          throw new Error(result.error.message);
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
      }
    }]);

    return XYZParser;
  }(Parser);

  defineProperty(XYZParser, "formats", ['xyz']);

  defineProperty(XYZParser, "extensions", ['.xyz']);

  function _createSuper$1M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1N(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$6 = chem.Complex,
      Element$7 = chem.Element;

  var PubChemParser = /*#__PURE__*/function (_Parser) {
    inherits(PubChemParser, _Parser);

    var _super = _createSuper$1M(PubChemParser);

    function PubChemParser(data, options) {
      var _this;

      classCallCheck(this, PubChemParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'pubchem+json';
      return _this;
    }

    createClass(PubChemParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing PubChem JSON file...');
        return this._toComplex(JSON.parse(this._data));
      }
    }, {
      key: "_toComplex",
      value: function _toComplex(jsonData) {
        var complex = new Complex$6();
        var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];

        if (complexData) {
          this._extractAtoms(complex, complexData);

          complex.finalize({
            needAutoBonding: false,
            detectAromaticLoops: this.settings.now.aromatic,
            enableEditing: this.settings.now.editing
          });
        }

        return complex;
      }
    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var aids = complexData.atoms && complexData.atoms.aid;
        var elements = aids && complexData.atoms.element;

        if (!elements || aids.length !== elements.length) {
          throw new Error('Unable to parse atom elements');
        }

        elements = ___default['default'].fromPairs(___default['default'].zip(aids, elements));
        var atoms = {};
        var coords = complexData.coords && complexData.coords[0];
        var model = coords && coords.conformers && coords.conformers[0];
        var xs = model && model.x;
        var ys = model && model.y;
        var zs = model && model.z || [];
        aids = coords && coords.aid;

        if (!aids || !xs || !ys) {
          throw new Error('Coordinates are not found in the file');
        }

        var chain = complex.addChain(' ');
        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0, n = aids.length; i < n; ++i) {
          var aid = aids[i];
          var element = Element$7.ByAtomicNumber[elements[aid]];
          var xyz = new THREE.Vector3(xs[i], ys[i], zs[i] || 0.0);
          atoms[aid] = residue.addAtom(element.name, element, xyz, undefined, true, aid, ' ', 1.0, 0.0, 0);
        }

        var aids1 = complexData.bonds && complexData.bonds.aid1;
        var aids2 = complexData.bonds && complexData.bonds.aid2;
        var orders = complexData.bonds && complexData.bonds.order || [];

        if (!aids1 || !aids2 || aids1.length !== aids2.length) {
          return;
        }

        for (var j = 0, m = aids1.length; j < m; ++j) {
          complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && data[0] === '{';
      }
    }]);

    return PubChemParser;
  }(Parser);

  PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc'];
  PubChemParser.extensions = ['.json'];

  var SDFStream = /*#__PURE__*/function () {
    function SDFStream(data) {
      classCallCheck(this, SDFStream);

      this._strings = data.split(/\r?\n|\r/);
      this._currentStart = 0;
      this._currentStringIndx = 0;
    }

    createClass(SDFStream, [{
      key: "setStart",
      value: function setStart(start) {
        if (start >= this._strings.length) {
          this._currentStart = this._strings.length - 1;
          this._currentStringIndx = this._strings.length - 1;
        } else {
          this._currentStart = start;
          this._currentStringIndx = start;
        }
      }
    }, {
      key: "getNextString",
      value: function getNextString() {
        return this._strings[++this._currentStringIndx];
      }
    }, {
      key: "getCurrentString",
      value: function getCurrentString() {
        return this._strings[this._currentStringIndx];
      }
    }, {
      key: "getStringFromStart",
      value: function getStringFromStart(numb) {
        this._currentStringIndx = this._currentStart + numb;
        return this._strings[this._currentStart + numb];
      }
    }, {
      key: "findNextDataItem",
      value: function findNextDataItem() {
        var curStr = this.getNextString();
        var res = false;

        while (!___default['default'].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          if (curStr.match(/>\s+<(.*)>/)) {
            res = true;
            break;
          }

          curStr = this.getNextString();
        }

        return res;
      }
    }, {
      key: "findNextCompoundStart",
      value: function findNextCompoundStart() {
        var curStr = this.getCurrentString();

        while (!___default['default'].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          curStr = this.getNextString();
        }

        this.setStart(++this._currentStringIndx);
        return this.probablyHaveDataToParse();
      }
    }, {
      key: "probablyHaveDataToParse",
      value: function probablyHaveDataToParse() {
        return this._currentStringIndx < this._strings.length - 2;
      }
    }]);

    return SDFStream;
  }();

  function _createSuper$1N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1O(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$7 = chem.Complex,
      Element$8 = chem.Element,
      Bond$4 = chem.Bond,
      Molecule$5 = chem.Molecule;
  var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
  var orderMap = [0, 1, 2, 3, 1, 1, 1, 2];
  var typeMap = [Bond$4.BondType.UNKNOWN, // 0 - error
  Bond$4.BondType.COVALENT, // 1 - single
  Bond$4.BondType.COVALENT, // 2 - double
  Bond$4.BondType.COVALENT, // 3 - triple
  Bond$4.BondType.AROMATIC, // 4 - aromatic
  Bond$4.BondType.UNKNOWN, // 5 - single or double
  Bond$4.BondType.AROMATIC, // 6 - single or aromatic
  Bond$4.BondType.AROMATIC // 7 - double or aromatic
  // 8 - any
  // 9 - coordination
  // 10 - hydrogen
  ];
  var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
  var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
  var fileFormat = {
    SDF: 'sdf',
    MOL: 'mol'
  };
  var possibleNameTags = ['PUBCHEM_IUPAC_TRADITIONAL_NAME', /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
  var possibleIDTags = ['PUBCHEM_COMPOUND_CID', 'id', 'ID', /.*CID/, /.*ID/, /.*id/];
  var possibleTitleTags = ['msg', 'MSG', 'message', 'title', 'description', 'desc'];
  var tagsNames = ['name', 'id', 'title'];
  var tags = {
    name: possibleNameTags,
    id: possibleIDTags,
    title: possibleTitleTags
  };

  function buildChainID(index) {
    if (!index) {
      return 'A';
    }

    var codes = [];

    while (index) {
      codes.push(65 + index % 26);
      index = Math.trunc(index / 26);
    }

    if (codes.length > 1) {
      codes.reverse();
      codes[0] -= 1;
    }

    return String.fromCharCode.apply(String, codes);
  }

  var SDFParser = /*#__PURE__*/function (_Parser) {
    inherits(SDFParser, _Parser);

    var _super = _createSuper$1N(SDFParser);

    function SDFParser(data, options) {
      var _this;

      classCallCheck(this, SDFParser);

      _this = _super.call(this, data, options);
      _this._format = 'sdf';
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._molecules = null;
      _this._metadata = {};
      _this._metadata.molecules = [];
      _this._currentMolProps = {};
      _this._compoundIndx = -1;
      _this._assemblies = [];
      _this._atomsParsed = 0;
      _this._atomsIndexes = [];
      return _this;
    }

    createClass(SDFParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(data) && sdfAndMolRegexp.test(data);
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(stream) {
        var molecule = {};
        molecule.name = stream.getStringFromStart(0);
        var date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
        molecule.date = date.toString() || '';
        molecule.title = stream.getStringFromStart(2);

        this._metadata.molecules.push(molecule);
      }
    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(stream, atomsNum) {
        var curStr;
        var serial = this._atomsParsed; // each molecule = chain\residue

        var chainID = buildChainID(this._compoundIndx);
        var resName = 'UNK';
        var resSeq = 1;
        this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
        this._residue = this._chain.addResidue(resName, resSeq, ' ');

        for (var i = 0; i < atomsNum; i++) {
          curStr = stream.getNextString();
          serial++;
          var x = parseFloat(curStr.substr(0, 10));
          var y = parseFloat(curStr.substr(10, 10));
          var z = parseFloat(curStr.substr(20, 10));
          var charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
          var xyz = new THREE.Vector3(x, y, z);
          var name = curStr.substr(31, 3).trim().toUpperCase();
          var type = Element$8.getByName(name);

          if (!this._atomsIndexes[name]) {
            this._atomsIndexes[name] = 0;
          }

          this._atomsIndexes[name] += 1;
          name += this._atomsIndexes[name]; // every atom need to have unique name.

          this._residue.addAtom(name, type, xyz, undefined, true, serial, ' ', 1.0, 0.0, charge);
        }
      }
    }, {
      key: "_parseBonds",
      value: function _parseBonds(stream, bondsNum) {
        var curStr;

        for (var i = 0; i < bondsNum; i++) {
          curStr = stream.getNextString();

          var atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;

          var atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;

          var bondType = parseInt(curStr.substr(6, 3), 10);

          if (atom1 > atom2) {
            var _ref = [atom2, atom1];
            atom1 = _ref[0];
            atom2 = _ref[1];
          }

          this._complex.addBond(atom1, atom2, orderMap[bondType] || 1, typeMap[bondType] || Bond$4.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseMOL",
      value: function _parseMOL(stream) {
        this._compoundIndx++;

        this._parseHeader(stream);

        var countsLine = stream.getStringFromStart(3);
        var atomsNum = parseInt(countsLine.substr(0, 3), 10);
        var bondsNum = parseInt(countsLine.substr(3, 3), 10);

        this._parseAtoms(stream, atomsNum);

        this._parseBonds(stream, bondsNum);

        this._atomsParsed += atomsNum;
        this._metadata.molecules[this._compoundIndx]._residues = [];

        this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
      }
    }, {
      key: "_parseDataItem",
      value: function _parseDataItem(stream) {
        var tag = stream.getCurrentString();
        var data = [];
        var curStr = stream.getNextString(); // read data

        while (curStr.trim() !== '') {
          data.push(curStr);
          curStr = stream.getNextString();
        }

        if (data.length === 1) {
          var _data = data;

          var _data2 = slicedToArray(_data, 1);

          data = _data2[0];
        }

        this._currentMolProps[tag.replace(/[<>]/g, '').trim()] = data;
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(stream) {
        this._parseMOL(stream); // parse data items block


        if (this._format === fileFormat.SDF) {
          this._currentMolProps = {};

          while (stream.findNextDataItem()) {
            this._parseDataItem(stream);
          }

          if (Object.keys(this._currentMolProps).length !== 0) {
            var molecule = this._metadata.molecules[this._compoundIndx];
            molecule.props = this._currentMolProps;

            this._tryToUpdateMoleculeData(molecule);
          }
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;
        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            console.log('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_buildAssemblies",
      value: function _buildAssemblies() {
        var chains = this._complex._chains;

        if (chains.length === 1) {
          return this._assemblies;
        }

        for (var i = 0; i < chains.length; i++) {
          var assembly = new Assembly(this._complex);
          var matrix = new THREE.Matrix4();
          assembly.addMatrix(matrix);
          assembly.addChain(chains[i]._name);

          this._assemblies.push(assembly);
        }

        return this._assemblies;
      }
    }, {
      key: "_buildMolecules",
      value: function _buildMolecules() {
        this._complex._molecules = [];
        var molecules = this._metadata.molecules;

        for (var i = 0; i < molecules.length; i++) {
          var molecule = new Molecule$5(this._complex, molecules[i].name, i + 1);
          molecule.residues = molecules[i]._residues;
          this._complex._molecules[i] = molecule;
        }

        return this._complex._molecules;
      }
    }, {
      key: "_searchTag",
      value: function _searchTag(tag, props) {
        for (var i = 0; i < props.length; i++) {
          if (tag instanceof RegExp && tag.test(props[i].tag) || tag === props[i].tag) {
            return props[i].data;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToFind",
      value: function _tryToFind(tagsList, props) {
        for (var j = 0; j < tagsList.length; j++) {
          var res = this._searchTag(tagsList[j], props);

          if (res) {
            return res;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToUpdateMoleculeData",
      value: function _tryToUpdateMoleculeData(molecule) {
        var res = false;

        for (var i = 0; i < tagsNames.length; i++) {
          var tagPossibleNames = tags[tagsNames[i]];

          var data = this._tryToFind(tagPossibleNames, molecule.props);

          if (data) {
            molecule[tagsNames[i]] = data;
            res = true;
          }
        }

        molecule.name = molecule.name || molecule.id;

        if (molecule.name.match(/^\d+$/)) {
          molecule.name = "CID: ".concat(molecule.name);
        }

        return res;
      }
    }, {
      key: "_finalizeMetadata",
      value: function _finalizeMetadata() {
        var molecules = this._metadata.molecules;
        var metadata = this._complex.metadata;
        var complex = this._complex;

        if (molecules.length === 1) {
          complex.name = molecules[0].name;
          metadata.title = molecules[0].title;
          metadata.date = molecules[0].date;
          metadata.properties = molecules[0].props;
        } else if (molecules.length > 1) {
          metadata.molecules = [];

          for (var i = 0; i < molecules.length; i++) {
            metadata.molecules.push({
              name: molecules[i].name,
              date: molecules[i].date,
              title: molecules[i].title,
              properties: molecules[i].props
            });
          }
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var serialAtomMap = this._serialAtomMap = {};
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        this._complex._finalizeBonds();

        this._fixBondsArray();

        this._finalizeMetadata();

        this._buildAssemblies();

        this._complex.units = this._complex.units.concat(this._assemblies);

        this._buildMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: false,
          enableEditing: false,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "defineFormat",
      value: function defineFormat(data) {
        var format;

        if (sdfRegExp.test(data)) {
          format = fileFormat.SDF;
        } else {
          format = fileFormat.MOL;
        }

        return format;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$7();
        var stream = new SDFStream(this._data);
        this._format = this.defineFormat(this._data);
        result.metadata.format = this._format;

        do {
          this._parseCompound(stream);
        } while (stream.findNextCompoundStart());

        this._finalize();

        return result;
      }
    }]);

    return SDFParser;
  }(Parser);
  SDFParser.formats = ['mol', 'sdf'];
  SDFParser.extensions = ['.mol', '.sdf'];

  function _createSuper$1O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1P(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var DSN6Header = {
    nstart: [valueType.array, 'i16', 0],
    extent: [valueType.array, 'i16', 3],
    grid: [valueType.array, 'i16', 6],
    cellDims: [valueType.vector, 'i16', 9],
    angles: [valueType.array, 'i16', 12],
    div: [valueType.singular, 'i16', 15],
    adder: [valueType.singular, 'i16', 16],
    scaleFactor: [valueType.singular, 'i16', 17]
  };

  var DSN6Model = /*#__PURE__*/function (_VolumeModel) {
    inherits(DSN6Model, _VolumeModel);

    var _super = _createSuper$1O(DSN6Model);

    function DSN6Model() {
      classCallCheck(this, DSN6Model);

      return _super.apply(this, arguments);
    }

    createClass(DSN6Model, [{
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.i16 = new Int16Array(this._buff); // check and reverse if big endian

        if (arrays.i16[18] !== 100) {
          for (var i = 0, n = arrays.i16.length; i < n; ++i) {
            var val = arrays.i16[i];
            arrays.i16[i] = (val & 0xff) << 8 | val >> 8 & 0xff;
          }
        }

        if (arrays.i16[18] !== 100) {
          throw new Error('DSN6: Incorrect format ');
        }

        var header = this._header;

        this._fillHeader(DSN6Header, arrays);

        header.cellDims.multiplyScalar(1.0 / header.scaleFactor);
        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0 / header.scaleFactor;
        });
        header.div /= 100;
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        this._xyz2crs[0] = 0;
        this._xyz2crs[1] = 1;
        this._xyz2crs[2] = 2;
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var header = this._header;

        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        this._origin.addScaledVector(xaxis, header.nstart[0]);

        this._origin.addScaledVector(yaxis, header.nstart[1]);

        this._origin.addScaledVector(zaxis, header.nstart[2]);

        xaxis.multiplyScalar(header.extent[0]);
        yaxis.multiplyScalar(header.extent[1]);
        zaxis.multiplyScalar(header.extent[2]);

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_pointCalculate",
      value: function _pointCalculate(xyzData, byteBuffer, z, y, x, pos, i) {
        var header = this._header;

        if (x < header.extent[0] && y < header.extent[1] && z < header.extent[2]) {
          var idx = x + header.extent[0] * (y + header.extent[1] * z);
          xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
          ++pos.counter;
        } else {
          pos.counter += 8 - i;
          return false;
        }

        return true;
      }
    }, {
      key: "_blockCalculate",
      value: function _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
        for (var k = 0; k < 8; ++k) {
          var z = 8 * zBlock + k;

          for (var j = 0; j < 8; ++j) {
            var y = 8 * yBlock + j;
            var inRange = true;
            var i = 0;

            while (inRange && i < 8) {
              var x = 8 * xBlock + i;
              inRange = this._pointCalculate(xyzData, byteBuffer, z, y, x, pos, i);
              i++;
            }
          }
        }
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var byteBuffer = new Uint8Array(this._buff);
        var xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
        var blocks = new THREE.Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
        var pos = {};
        pos.counter = 512;

        for (var zBlock = 0; zBlock < blocks.z; ++zBlock) {
          for (var yBlock = 0; yBlock < blocks.y; ++yBlock) {
            for (var xBlock = 0; xBlock < blocks.x; ++xBlock) {
              this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
            }
          }
        }

        this._calculateInfoParams(xyzData);

        return xyzData;
      }
    }, {
      key: "_calculateInfoParams",
      value: function _calculateInfoParams(xyzData) {
        this._header.dmean /= xyzData.length;
        var dispersion = 0;
        var minDensity = xyzData[0];
        var maxDensity = xyzData[0];

        for (var j = 0; j < xyzData.length; j++) {
          dispersion += Math.pow(this._header.dmean - xyzData[j], 2);

          if (xyzData[j] < minDensity) {
            minDensity = xyzData[j];
          }

          if (xyzData[j] > maxDensity) {
            maxDensity = xyzData[j];
          }
        }

        this._header.sd = Math.sqrt(dispersion / xyzData.length);
        this._header.dmax = maxDensity;
        this._header.dmin = minDensity;
      }
    }]);

    return DSN6Model;
  }(VolumeModel);

  var DSN6Parser = /*#__PURE__*/function (_Parser) {
    inherits(DSN6Parser, _Parser);

    var _super2 = _createSuper$1O(DSN6Parser);

    function DSN6Parser(data, options) {
      var _this;

      classCallCheck(this, DSN6Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'dsn6';
      _this.model = new DSN6Model();
      return _this;
    }

    createClass(DSN6Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canParse",
      value: function canParse(data, options) {
        if (!data) {
          return false;
        }

        return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'dsn6');
      }
    }, {
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false;
      }
    }]);

    return DSN6Parser;
  }(Parser);

  DSN6Parser.formats = ['dsn6'];
  DSN6Parser.extensions = ['.dsn6', '.omap'];
  DSN6Parser.binary = true;

  function _createSuper$1P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Q(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Little helper class for GRO Parser usage.
   * @extends PDBStream
   */

  var GROReader = /*#__PURE__*/function (_PDBStream) {
    inherits(GROReader, _PDBStream);

    var _super = _createSuper$1P(GROReader);

    function GROReader(data) {
      var _this;

      classCallCheck(this, GROReader);

      _this = _super.call(this, data);
      /** @type Number */

      _this._next = -1; // End position of line

      _this.next();

      return _this;
    }
    /**
     * Getting end of string.
     * @returns {Number} Pointer to end of string
     */


    createClass(GROReader, [{
      key: "getNext",
      value: function getNext() {
        return this._next;
      }
    }]);

    return GROReader;
  }(PDBStream);

  function _createSuper$1Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1R(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$8 = chem.Complex,
      Element$9 = chem.Element,
      Molecule$6 = chem.Molecule;
  /**
   * Gromos87 file format parser.
   * @extends Parser
   */

  var GROParser = /*#__PURE__*/function (_Parser) {
    inherits(GROParser, _Parser);

    var _super = _createSuper$1Q(GROParser);

    /**
     * Create parser for .gro file format
     *
     * @param {String} data Input file
     * @param {String} options Input options (optional field)
     */
    function GROParser(data, options) {
      var _this;

      classCallCheck(this, GROParser);

      _this = _super.call(this, data, options);
      /** @type Date */

      _this._time = null; // Time in ps, optional field for animations

      /** @type Number */

      _this._numAtoms = null; // Number of atoms in complex

      /** @type Number */

      _this._residueNumber = null; // Number of exact residue

      /** @type String */

      _this._residueName = ''; // Scientific name of exact residue

      /** @type String */

      _this._atomName = ''; // Scientific name of exact atom

      /** @type Number */

      _this._atomNumber = null; // Sorted number of exact atom

      /** @type Array */

      _this._atomPosition = []; // Array which contains x, y, z position of exact atom

      /** @type Array */

      _this._atomVelocity = []; // Array which contains x, y, z velocity of exact atom (optional)

      /** @type Complex */

      _this._complex = null; // Complex structure for unified molecule representation

      /** @type Vector3 */

      _this._molecules = []; // Molecules array

      /** @type Molecule */

      _this._molecule = null; // Single molecule

      /** @type String */

      _this._options.filetype = 'gro'; // Extension of data file.

      return _this;
    }
    /**
     * General check for possibility of parsing.
     * @param {String} data - Input file
     * @returns {boolean} true if this file is in ascii, false otherwise
     */


    createClass(GROParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default['default'].isString(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
      }
      /**
       * Parsing title of molecule complex.
       * NOTE: that names are ESTIMATES, there is no strict rules in Gromos87 standard for first line in input file.
       * @param {GROReader} line - Line containing title and time.
       */

    }, {
      key: "_parseTitle",
      value: function _parseTitle(line) {
        var metadata = this._complex.metadata;
        metadata.id = line.readLine().trim();
        metadata.name = metadata.id.slice(metadata.id.lastIndexOf('\\') + 1, metadata.id.lastIndexOf('.'));
        metadata.format = 'gro';
      }
      /**
       * Parsing line containing number of atoms information.
       * @param {GROReader} line - Line containing number of atoms.
       */

    }, {
      key: "_parseNumberOfAtoms",
      value: function _parseNumberOfAtoms(line) {
        this._numAtoms = line.readInt(0, line.getNext());

        if (Number.isNaN(this._numAtoms)) {
          throw new Error('Line 2 is not representing atom number. Consider checking input file');
        }
      }
      /**
       * Parsing line containing information about residues, atoms etc. Also information about box vectors.
       * Format of atoms MUST (by Gromos87 standard) be this: (note that numbering starts not from 0, but from 1!)
       * ResidueNumber[1 - 5]  ResidueName[6 - 10] AtomName[11 - 15] AtomNumber[16 - 20] Position[21 - 45] Velocity[46 - 69]
       * @param {GROReader} line - Line containing information about atom.
       */

    }, {
      key: "_parseAtom",
      value: function _parseAtom(line) {
        this._residueNumber = line.readInt(1, 5);
        this._residueName = line.readString(6, 10).trim();
        this._atomName = line.readString(11, 15).trim();
        this._atomNumber = line.readInt(16, 20);
        var positionX = line.readFloat(21, 28) * 10;
        var positionY = line.readFloat(29, 36) * 10;
        var positionZ = line.readFloat(37, 45) * 10;

        if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
          this._complex.error = {
            message: "Atom position is invalid in \"".concat(line.readLine(), "\"")
          };
          return;
        }
        /* const velocityX = line.readFloat(46, 53);
        const velocityY = line.readFloat(54, 61);
        const velocityZ = line.readFloat(62, 69); */

        /* Adding residue and atom to complex structure */


        var type = Element$9.getByName(this._atomName[0]);
        /* MAGIC 0. REASONS: This name is something like "CA", where
        C - is an element an A is something else. But what about Calcium? */

        if (type.fullName === 'Unknown') {
          this._complex.error = {
            message: "".concat(this._atomName[0], " hasn't been recognised as an atom name.")
          };
          return;
        }

        var role = Element$9.Role[this._atomName];
        /* Firstly, create a dummy chain */

        var chain = this._chain;

        if (!chain) {
          this._chain = chain = this._complex.addChain('A');
        }
        /* Secondly, add residue to that chain */


        var residue = this._residue;

        if (!residue || residue.getSequence() !== this._residueNumber) {
          this._residue = residue = chain.addResidue(this._residueName, this._residueNumber, ' ');
        }
        /* Lastly, add atom to that residue */


        this._atomPosition = new THREE.Vector3(positionX, positionY, positionZ);
        /* Adding default constants to correct atom addition process */

        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;
        residue.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
      }
      /**
       * Some finalizing procedures. In '.gro' file format there is only 1 chain and 1 molecule.
       */

    }, {
      key: "_finalize",
      value: function _finalize() {
        var molecule = new Molecule$6(this._complex, this._complex.metadata.name, 1); // aggregate residues from chain

        molecule.residues = this._chain._residues;
        molecule._chains = this._chain;
        this._complex._molecules[0] = molecule;

        this._molecules.push(molecule);

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
      /**
       * Main parsing procedure.
       * @returns {Complex} Complex structure for visualizing.
       */

    }, {
      key: "parseSync",
      value: function parseSync() {
        /* Create "Complex" variable */
        var result = this._complex = new Complex$8();
        /* Parse input file line-by-line */

        var reader = new GROReader(this._data);
        var counter = 0;
        /* Simple counter regarding to format of .gro file */

        /* First two lines - technical information, other lines - Atoms */

        this._parseTitle(reader);

        reader.next();

        this._parseNumberOfAtoms(reader);

        reader.next();

        for (counter = 0; counter < this._numAtoms; ++counter) {
          if (!reader.end()) {
            this._parseAtom(reader);

            reader.next();
          } else break;
        }
        /* If number of atoms in second line is less then actual atoms in file */


        if (counter < this._numAtoms) {
          this._complex.error = {
            message: 'File ended unexpectedly.'
          };
        }
        /* Catch errors occurred in parsing process */


        if (result.error) {
          throw new Error(result.error.message);
        }
        /* Finalizing data */


        this._finalize();
        /* Cleaning up */


        this._atomPosition = null;
        this._complex = null;
        this._molecules = null;
        this._molecule = null;
        /* Return resulting Complex variable */

        return result;
      }
    }]);

    return GROParser;
  }(Parser);

  GROParser.formats = ['gro'];
  GROParser.extensions = ['.gro'];

  function _createSuper$1R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1S(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$9 = chem.Complex,
      Element$a = chem.Element,
      Bond$5 = chem.Bond,
      Molecule$7 = chem.Molecule;
  var orderMap$1 = {
    un: 0,
    1: 1,
    2: 2,
    3: 3,
    ar: 1,
    am: 1,
    nc: 0,
    du: 1
  };
  var typeMap$1 = {
    un: Bond$5.BondType.UNKNOWN,
    // unknown (cannot be determined from the parameter tables)
    1: Bond$5.BondType.COVALENT,
    // single
    2: Bond$5.BondType.COVALENT,
    // double
    3: Bond$5.BondType.COVALENT,
    // triple
    ar: Bond$5.BondType.AROMATIC,
    // aromatic
    am: Bond$5.BondType.COVALENT,
    // amide
    nc: Bond$5.BondType.UNKNOWN,
    // not connected
    du: Bond$5.BondType.COVALENT // dummy

  };
  var resNumberRegex = /\d+$/;
  var spacesRegex = /\s+/;

  function splitToFields(str) {
    return str.trim().split(spacesRegex);
  }
  /* There is no jsdoc documentation because of eslint corrections:
   * not all Parser methods are implemented
   */


  var MOL2Parser = /*#__PURE__*/function (_Parser) {
    inherits(MOL2Parser, _Parser);

    var _super = _createSuper$1R(MOL2Parser);

    function MOL2Parser(data, options) {
      var _this;

      classCallCheck(this, MOL2Parser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._compoundIndx = -1;
      _this._molecules = [];
      _this._molecule = null;
      _this._currPosIdx = 0;
      _this._currStartIdx = 0;
      _this._serialAtomMap = {};
      _this._options.fileType = 'mol2';
      return _this;
    }

    createClass(MOL2Parser, [{
      key: "_parseRawStrings",
      value: function _parseRawStrings(data) {
        return data.split(/\r?\n|\r/);
      }
    }, {
      key: "_toStringFromStart",
      value: function _toStringFromStart(numb, MOL2Data) {
        var newPosIdx = this._currStartIdx + numb;
        this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
      }
    }, {
      key: "_toHeaderString",
      value: function _toHeaderString(header, MOL2Data) {
        this._toStringFromStart(0, MOL2Data);

        while (this._currPosIdx < MOL2Data.length) {
          if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header))) {
            return;
          }

          this._currPosIdx++;
        }

        this._toStringFromStart(0, MOL2Data);
      }
    }, {
      key: "_toStringFromHeader",
      value: function _toStringFromHeader(header, numb, MOL2Data) {
        this._toHeaderString(header, MOL2Data);

        var newPosIdx = this._currPosIdx + numb;

        if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header)) && newPosIdx < MOL2Data.length) {
          this._currPosIdx = newPosIdx;
        }
      }
    }, {
      key: "_setStart",
      value: function _setStart(startPos, MOL2Data) {
        if (startPos >= MOL2Data.length) {
          this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
        } else {
          this._currStartIdx = this._currPosIdx = startPos;
        }
      }
    }, {
      key: "_probablyHaveDataToParse",
      value: function _probablyHaveDataToParse(MOL2Data) {
        return this._currPosIdx < MOL2Data.length - 2;
      }
    }, {
      key: "_findNextCompoundStart",
      value: function _findNextCompoundStart(MOL2Data) {
        while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== '@<TRIPOS>MOLECULE>') {
          this._currPosIdx++;
        }

        this._setStart(++this._currPosIdx, MOL2Data);

        return this._probablyHaveDataToParse(MOL2Data);
      }
    }, {
      key: "_parseMolecule",
      value: function _parseMolecule(MOL2Data) {
        this._toHeaderString('MOLECULE', MOL2Data);

        var metadata = this._complex.metadata;
        metadata.name = MOL2Data[++this._currPosIdx];
        metadata.format = 'mol2';
        this._molecule = {
          _index: '',
          _chains: []
        };
        this._molecule._index = this._compoundIndx + 1;

        this._molecules.push(this._molecule);
      }
      /* Atom format description:
       * atomId atomName x y z element [resSeq [resName [charge [statusBit]]]]
       * statusBits is the internal SYBYL status bits associated with the atom.
       * These should never be set by the user.
       * Source: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf
       */

    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(atomsNum, MOL2Data) {
        this._toHeaderString('ATOM', MOL2Data);

        for (var i = 0; i < atomsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 6) {
            throw new Error('MOL2 parsing error: Not enough information to create atom!');
          }

          var atomId = parseInt(parsedStr[0], 10);
          var atomName = parsedStr[1];
          var x = parseFloat(parsedStr[2]);
          var y = parseFloat(parsedStr[3]);
          var z = parseFloat(parsedStr[4]);
          var element = parsedStr[5].split('.')[0].toUpperCase();
          var charge = 0;

          if (parsedStr.length >= 9) {
            charge = parseFloat(parsedStr[8]) || 0.0;
          }

          var chain = this._chain;

          if (!chain) {
            // .mol2 may contain information about multiple molecules, but they can't be visualized
            // at the same time now. There is no need to create different chain IDs then.
            this._chain = chain = this._complex.getChain('A') || this._complex.addChain('A');
            this._residue = null;
          }

          if (!this._setResidue(parsedStr)) {
            continue;
          } // These fields are not listed in mol2 format. Set them default.
          // Atoms and het atoms doesn't differ in .mol2,
          // but het atoms have special residues. It can be used in next updates


          var het = false;
          var altLoc = ' ';
          var occupancy = 1.0;
          var tempFactor = 0.0;
          var type = Element$a.getByName(element);
          var role = Element$a.Role[atomName];
          var xyz = new THREE.Vector3(x, y, z);

          this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
        }
      }
    }, {
      key: "_setResidue",
      value: function _setResidue(parsedStr) {
        var resSeq = 1;
        var resName = 'UNK'; // The same meaning has '<0>' in some mol2 files

        if (parsedStr.length >= 7) {
          resSeq = parseInt(parsedStr[6], 10);
        }

        if (parsedStr.length >= 8 && parsedStr[7] !== '<0>') {
          resName = parsedStr[7].replace(resNumberRegex, '');
        }

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return false;
          }
        }

        var residue = this._residue;
        var chain = this._chain;

        if (!residue || residue.getSequence() !== resSeq) {
          this._residue = chain.addResidue(resName, resSeq, 'A');
        }

        return true;
      }
      /* Bond format description
       * bondId originAtomId targetAtomId bondType [statusBits]
       */

    }, {
      key: "_parseBonds",
      value: function _parseBonds(bondsNum, MOL2Data) {
        this._toHeaderString('BOND', MOL2Data);

        for (var i = 0; i < bondsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 3) {
            throw new Error('MOL2 parsing error: Missing information about bonds!');
          }

          var originAtomId = parseInt(parsedStr[1], 10);
          var targetAtomId = parseInt(parsedStr[2], 10);
          var bondType = parsedStr[3];

          if (originAtomId > targetAtomId) {
            var _ref = [targetAtomId, originAtomId];
            originAtomId = _ref[0];
            targetAtomId = _ref[1];
          }

          this._complex.addBond(originAtomId, targetAtomId, orderMap$1[bondType] || 0, typeMap$1[bondType] || Bond$5.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_fixSerialAtoms",
      value: function _fixSerialAtoms() {
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          this._serialAtomMap[atom.serial] = atom;
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;

        if (Object.keys(serialAtomMap).length === 0) {
          throw new Error('MOL2 parsing error: Missing atom information!');
        }

        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];
          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        // Get chain from complex
        var chain = this._complex._chains[0];
        this._complex._molecules = []; // Aggregate residues from chains
        // (to be precise from the chain 'A')

        for (var i = 0; i < this._molecules.length; i++) {
          var currMolecule = this._molecules[i];
          var molResidues = chain._residues;
          var molecule = new Molecule$7(this._complex, currMolecule._name, i + 1);
          molecule.residues = molResidues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._complex._finalizeBonds();

        this._fixSerialAtoms();

        this._fixBondsArray();

        this._finalizeMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(MOL2Data) {
        this._compoundIndx++;

        this._parseMolecule(MOL2Data); // Ignoring comments and everything before @<TRIPOS>MOLECULE block


        this._toStringFromHeader('MOLECULE', 2, MOL2Data);

        var parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);

        var atomsNum = parsedStr[0];
        var bondsNum = parsedStr[1];

        this._parseAtoms(atomsNum, MOL2Data);

        this._parseBonds(bondsNum, MOL2Data);
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$9();

        var MOL2Data = this._parseRawStrings(this._data);

        do {
          this._parseCompound(MOL2Data);
        } while (this._findNextCompoundStart(MOL2Data));

        this._finalize();

        return result;
      }
    }]);

    return MOL2Parser;
  }(Parser);

  MOL2Parser.formats = ['mol2'];
  MOL2Parser.extensions = ['.mol2', '.ml2', '.sy2'];

  var parsers = new ParserList([// note: order might be important
  PDBParser, CIFParser, MMTFParser, XYZParser, CMLParser, PubChemParser, SDFParser, CCP4Parser, DSN6Parser, GROParser, MOL2Parser]);

  function _createSuper$1S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1T(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * A list of available exporters.
   * @extends EntityList
   */

  var ExporterList = /*#__PURE__*/function (_EntityList) {
    inherits(ExporterList, _EntityList);

    var _super = _createSuper$1S(ExporterList);

    /**
     * Create a list of exporters.
     * The exporters are indexed by supported data formats (`.formats` and
     * `.extensions` properties of a Exporter subclass).
     * The Exporters can be retrieved later by matching against specs (see {@link ExporterList#find}).
     *
     * @param {!Array<function(new:Exporter)>=} someExporters A list of {@link Exporter} subclasses to
     *   automatically register at creation time.
     * @see ExporterList#register
     */
    function ExporterList() {
      var someExporters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      classCallCheck(this, ExporterList);

      return _super.call(this, someExporters, ['formats']);
    }
    /**
     * Find a suitable exporter for data.
     *
     * @param {Object} specs Exporter specifications.
     * @param {string=} specs.format Supported data format.
     * @param {*=} specs.data Data to export.
     */


    createClass(ExporterList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        }

        return toConsumableArray(list);
      }
    }]);

    return ExporterList;
  }(EntityList);

  var Exporter = /*#__PURE__*/function () {
    function Exporter(source, options) {
      classCallCheck(this, Exporter);

      this._source = source;
      this._options = options || {};
      this._abort = false;
    }

    createClass(Exporter, [{
      key: "exportSync",
      value: function exportSync() {
        throw new Error('Exporting to this source is not implemented');
      }
    }, {
      key: "export",
      value: function _export() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Export aborted'));
              }

              return resolve(_this.exportSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Exporter;
  }();
  makeContextDependent(Exporter.prototype);

  var PDBResult = /*#__PURE__*/function () {
    function PDBResult() {
      classCallCheck(this, PDBResult);

      this._resultArray = [];
      this._currentStr = -1;
      this._tag = null;
      this._fixedNumeration = false;
      this._numeration = false;
      this._tagStrNum = 0;
    }

    createClass(PDBResult, [{
      key: "getResult",
      value: function getResult() {
        this.writeString('\n', 81, 81);
        return this._resultArray.join('');
      }
    }, {
      key: "_currentStrLength",
      value: function _currentStrLength() {
        var curStr = this._resultArray[this._currentStr];
        return curStr ? curStr.length : 0;
      } // numeration can be number or boolean
      // if numeration is number then just put this number to 8-10 pos in string
      // if numeration is boolean then increase number for all new strings

    }, {
      key: "newTag",
      value: function newTag(tag, numeration) {
        if (!tag) {
          this._tag = null;
        } else {
          this._tag = tag;
        }

        if (!___default['default'].isUndefined(numeration)) {
          if (___default['default'].isNumber(numeration)) {
            this._tagStrNum = numeration;
            this._numeration = true;
            this._fixedNumeration = true;
          } else if (___default['default'].isBoolean(numeration)) {
            this._tagStrNum = 0;
            this._numeration = numeration;
            this._fixedNumeration = false;
          }
        } else {
          this._numeration = false;
          this._fixedNumeration = false;
          this._tagStrNum = 0;
        }
      }
    }, {
      key: "newString",
      value: function newString(tag) {
        this.writeString('\n', 81, 81);
        this._currentStr++;

        this._resultArray.push('');

        if (tag) {
          this.writeString(tag, 1, 6);
        } else if (this._tag) {
          this.writeString(this._tag, 1, 6);
        }

        if (this._numeration) {
          if (!this._fixedNumeration) {
            this._tagStrNum++;
          }

          if (this._tagStrNum !== 1) {
            this.writeString(this._tagStrNum.toString(), 10, 8);
          }
        }
      }
    }, {
      key: "writeEntireString",
      value: function writeEntireString(string, maxStrPos, concat) {
        if (!maxStrPos) {
          maxStrPos = 81;
        }

        for (var j = 0; j < string.length; j++) {
          if (this._currentStrLength() === maxStrPos && j !== string.length - 1) {
            this.newString();

            if (concat) {
              // pretty hardcoddy
              this.writeString(concat.tag, concat.begin, concat.end);
            }
          }

          if (string[j] === '\n') {
            this.newString();
          } else {
            this.writeString(string[j]);
          }
        }
      }
    }, {
      key: "writeString",
      value: function writeString(string, begin, end) {
        var curStr = this._resultArray[this._currentStr];
        var str;
        var curStrLength = curStr ? curStr.length : 0;

        if (___default['default'].isUndefined(string)) {
          return;
        }

        if (!___default['default'].isNumber(begin)) {
          begin = curStrLength + 1;
        }

        if (!___default['default'].isNumber(end)) {
          end = curStrLength + string.length;
        }

        if (!___default['default'].isString(string)) {
          str = string.toString();
        } else {
          str = string;
        }

        var finish = begin < end ? end : begin;
        var start = begin < end ? begin : end;

        if (str.length > Math.abs(begin - end) + 1) {
          str = str.substr(0, Math.abs(begin - end + 1));
        } // spaces before start of new data


        if (start > curStrLength + 1) {
          this._resultArray[this._currentStr] += ' '.repeat(start - curStrLength - 1);
        } else if (start <= curStrLength) {
          var cStr = this._resultArray[this._currentStr];
          this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
        } // if reverse order
        // reverse order of end and begin means that user wants to align text right


        if (end < begin) {
          var len = begin - end + 1;
          str = ' '.repeat(len - str.length) + str;
        } // some hardcode fix for space between string numeration and data
        // (see pdb file format description)


        if (start === 11 && this._numeration && this._tagStrNum !== 1) {
          str = " ".concat(str);
        } // append new data to string


        this._resultArray[this._currentStr] += str;
        curStr = this._resultArray[this._currentStr];

        if (finish > curStr.length) {
          this._resultArray[this._currentStr] += ' '.repeat(finish - curStr.length);
        }
      }
    }, {
      key: "writeBondsArray",
      value: function writeBondsArray(bonds, atom) {
        var bondsArrays = this._getSubArrays(bonds, 4);

        for (var k = 0; k < bondsArrays.length; k++) {
          this.newString();
          this.writeString(atom.serial, 11, 7);

          for (var j = 0; j < bondsArrays[k].length; j++) {
            var serial = bondsArrays[k][j]._left.serial === atom.serial ? bondsArrays[k][j]._right.serial : bondsArrays[k][j]._left.serial;
            this.writeString(serial, 16 + 5 * j, 12 + 5 * j);
          }
        }
      }
    }, {
      key: "_getSubArrays",
      value: function _getSubArrays(arr, subArraySize) {
        var subArrays = [];

        for (var i = 0; i < arr.length; i += subArraySize) {
          subArrays.push(arr.slice(i, i + subArraySize));
        }

        return subArrays;
      } // function for writing matrix in Remark290 and Remark350 tags
      // (see pdb file description)

    }, {
      key: "writeMatrix",
      value: function writeMatrix(matrix, matrixIndx, tag) {
        for (var j = 0; j < 3; j++) {
          this.newString();
          this.writeString(tag, 14, 18);
          this.writeString((j + 1).toString(), 19, 19);
          this.writeString(matrixIndx.toString(), 23, 20);

          for (var k = 0; k < 3; k++) {
            var _numb = parseFloat(matrix.elements[j * 4 + k]).toFixed(6);

            this.writeString(_numb.toString(), 33 + k * 10, 24 + k * 10);
          }

          var numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5);
          this.writeString(numb.toString(), 68, 55);
        }
      }
    }, {
      key: "writeMatrices",
      value: function writeMatrices(matrices, string) {
        if (!matrices) {
          return;
        }

        var matrix = new THREE.Matrix4();

        for (var j = 0; j < matrices.length; j++) {
          matrix.copy(matrices[j]).transpose();
          this.writeMatrix(matrix, j + 1, string);
        }
      }
    }]);

    return PDBResult;
  }();

  function _createSuper$1T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1U(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var PDBExporter = /*#__PURE__*/function (_Exporter) {
    inherits(PDBExporter, _Exporter);

    var _super = _createSuper$1T(PDBExporter);

    function PDBExporter(source, options) {
      var _this;

      classCallCheck(this, PDBExporter);

      _this = _super.call(this, source, options);
      _this._tags = ['HEADER', 'TITLE', 'COMPND', 'REMARK', 'HELIX', 'SHEET', 'ATOM and HETATM', 'CONECT'];
      _this._result = null;
      _this._tagExtractors = {
        HEADER: _this._extractHEADER,
        TITLE: _this._extractTITLE,
        'ATOM and HETATM': _this._extractATOM,
        CONECT: _this._extractCONECT,
        COMPND: _this._extractCOMPND,
        REMARK: _this._extractREMARK,
        HELIX: _this._extractHELIX,
        SHEET: _this._extractSHEET
      };
      _this._stringForRemark350 = 'COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\n' + 'BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\n' + 'MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\n' + 'GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\n' + 'CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.';
      _this._stringForRemark290 = 'CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\n' + 'THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\n' + 'RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\n' + 'RELATED MOLECULES.';
      return _this;
    }

    createClass(PDBExporter, [{
      key: "exportSync",
      value: function exportSync() {
        var result = new PDBResult();

        if (!this._source) {
          return this._result;
        }

        for (var i = 0; i < this._tags.length; i++) {
          var tag = this._tags[i];
          var func = this._tagExtractors[tag];

          if (___default['default'].isFunction(func)) {
            func.call(this, result);
          }
        }

        this._result = result.getResult();
        return this._result;
      }
    }, {
      key: "_extractHEADER",
      value: function _extractHEADER(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;
        result.newTag('HEADER');
        result.newString();

        if (metadata.classification) {
          result.writeString(metadata.classification, 11, 50);
        }

        if (metadata.date) {
          result.writeString(metadata.date, 51, 59);
        }

        if (metadata.id) {
          result.writeString(metadata.id, 63, 66);
        }
      }
    }, {
      key: "_extractTITLE",
      value: function _extractTITLE(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;

        if (!metadata.title) {
          return;
        }

        result.newTag('TITLE', true);

        for (var i = 0; i < metadata.title.length; i++) {
          result.newString();
          result.writeString(metadata.title[i], 11, 80);
        }
      }
    }, {
      key: "_extractCONECT",
      value: function _extractCONECT(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;
        result.newTag('CONECT');

        for (var i = 0; i < atoms.length; i++) {
          var fixedBonds = atoms[i].bonds.filter(function (bond) {
            return bond._fixed;
          });

          if (fixedBonds.length !== 0) {
            result.writeBondsArray(fixedBonds.reverse(), atoms[i]);
          }
        }
      }
    }, {
      key: "_extractSHEET",
      value: function _extractSHEET(result) {
        if (!this._source._sheets) {
          return;
        }

        result.newTag('SHEET');
        var sheets = this._source._sheets;

        for (var i = 0; i < sheets.length; i++) {
          if (sheets[i]._strands) {
            var strands = sheets[i]._strands;

            for (var j = 0; j < strands.length; j++) {
              result.newString();
              result.writeString(j + 1, 10, 8);
              result.writeString(sheets[i]._name, 14, 12);
              result.writeString(strands.length, 16, 15);
              result.writeString(strands[j].init._type._name, 18, 20);
              result.writeString(strands[j].init._chain._name, 22, 22);
              result.writeString(strands[j].init._sequence, 26, 23);
              result.writeString(strands[j].init._icode, 27, 27);
              result.writeString(strands[j].term._type._name, 29, 31);
              result.writeString(strands[j].init._chain._name, 33, 33);
              result.writeString(strands[j].term._sequence, 37, 34);
              result.writeString(strands[j].term._icode, 38, 38);
              result.writeString(strands[j].sense, 40, 39);
            }
          }
        }
      }
    }, {
      key: "_extractHELIX",
      value: function _extractHELIX(result) {
        if (!this._source._helices) {
          return;
        }

        result.newTag('HELIX');
        var helices = this._source._helices;

        for (var i = 0; i < helices.length; i++) {
          var helix = helices[i];

          var helixClass = ___default['default'].invert(typeByPDBHelixClass);

          result.newString();
          result.writeString(helix.serial, 10, 8);
          result.writeString(helix.name, 14, 12);
          result.writeString(helix.init._type._name, 16, 18);
          result.writeString(helix.init._chain._name, 20, 20);
          result.writeString(helix.init._sequence, 25, 22);
          result.writeString(helix.init._icode, 26, 26);
          result.writeString(helix.term._type._name, 28, 30);
          result.writeString(helix.term._chain._name, 32, 32);
          result.writeString(helix.term._sequence, 37, 34);
          result.writeString(helix.term._icode, 38, 38);
          result.writeString(helixClass[helix.type], 40, 39);
          result.writeString(helix.comment, 41, 70);
          result.writeString(helix.length, 76, 72);
        }
      }
    }, {
      key: "_extractATOM",
      value: function _extractATOM(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var tag = atoms[i].het ? 'HETATM' : 'ATOM';
          result.newString(tag);
          var startIndx = atoms[i].element.name.length > 1 || atoms[i].name.length > 3 ? 13 : 14;
          result.writeString(atoms[i].serial, 11, 7);
          result.writeString(atoms[i].name, startIndx, 16);
          result.writeString(String.fromCharCode(atoms[i].location), 17, 17);
          result.writeString(atoms[i].residue._type._name, 20, 18);
          result.writeString(atoms[i].residue._chain._name, 22, 22);
          result.writeString(atoms[i].residue._sequence, 26, 23);
          result.writeString(atoms[i].residue._icode, 27, 27);
          result.writeString(atoms[i].position.x.toFixed(3), 38, 31);
          result.writeString(atoms[i].position.y.toFixed(3), 46, 39);
          result.writeString(atoms[i].position.z.toFixed(3), 54, 47);
          result.writeString(atoms[i].occupancy.toFixed(2), 60, 55);
          result.writeString(atoms[i].temperature.toFixed(2), 66, 61);
          result.writeString(atoms[i].element.name, 78, 77);

          if (atoms[i].charge) {
            result.writeString(atoms[i].charge, 79, 80);
          }
        }
      }
    }, {
      key: "_extractCOMPND",
      value: function _extractCOMPND(result) {
        if (!this._source._molecules) {
          return;
        }

        var molecules = this._source._molecules;
        result.newTag('COMPND', true);

        for (var i = 0; i < molecules.length; i++) {
          var chains = this._getMoleculeChains(molecules[i]);

          result.newString();
          result.writeString("MOL_ID: ".concat(molecules[i].index, ";"), 11, 80);
          result.newString();
          result.writeString("MOLECULE: ".concat(molecules[i].name, ";"), 11, 80);
          result.newString();
          result.writeString('CHAIN: ', 11, 18);
          var chainsString = "".concat(chains.join(', '), ";");
          result.writeEntireString(chainsString, 81);
        }
      }
    }, {
      key: "_extractREMARK",
      value: function _extractREMARK(result) {
        this._Remark290(result);

        this._Remark350(result);
      }
    }, {
      key: "_Remark290",
      value: function _Remark290(result) {
        if (!this._source.symmetry) {
          return;
        }

        if (this._source.symmetry.length !== 0) {
          var matrices = this._source.symmetry;
          result.newTag('REMARK', 290);
          result.newString();
          result.newString();
          result.writeEntireString(this._stringForRemark290);
          result.writeMatrices(matrices, 'SMTRY');
          result.newString();
          result.newString();
          result.writeString('REMARK: NULL', 11, 80);
        }
      }
    }, {
      key: "_Remark350",
      value: function _Remark350(result) {
        if (!this._source.units) {
          return;
        }

        var units = this._source.units;
        var biomolIndx = 0;
        result.newTag('REMARK', 350);
        result.newString();
        result.newString();
        result.writeEntireString(this._stringForRemark350);
        var assemblies = units.filter(function (unit) {
          return unit instanceof Assembly;
        });

        for (var i = 0; i < assemblies.length; i++) {
          result.newString();
          result.newString();
          biomolIndx++;
          result.writeString("BIOMOLECULE: ".concat(biomolIndx), 11, 80);
          var chains = assemblies[i].chains.join(', ');
          result.newString();
          result.writeString('APPLY THE FOLLOWING TO CHAINS: ');
          result.writeEntireString(chains, 69, {
            tag: 'AND CHAINS: ',
            begin: 31,
            end: 42
          });
          var matrices = assemblies[i].matrices;
          result.writeMatrices(matrices, 'BIOMT');
        }
      }
    }, {
      key: "_getMoleculeChains",
      value: function _getMoleculeChains(molecule) {
        function getChainName(residue) {
          return residue._chain._name;
        }

        var chainNames = molecule.residues.map(getChainName);
        return chainNames.filter(function (item, pos) {
          return chainNames.indexOf(item) === pos;
        });
      }
    }]);

    return PDBExporter;
  }(Exporter);
  PDBExporter.formats = ['pdb'];
  PDBExporter.SourceClass = Complex;

  var FBX_POS_SIZE = 3;
  var FBX_NORM_SIZE = 3;
  var FBX_COL_SIZE = 4;

  function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
  }

  function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
    dst[dstIdx + 3] = value;
  }

  var vector4 = new THREE.Vector4();

  function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
    vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w);
    vector4.applyMatrix4(opts.matrix);
    dst[dstIdx] = vector4.x;
    dst[dstIdx + 1] = vector4.y;
    dst[dstIdx + 2] = vector4.z;
  }

  function setSubArray(src, dst, count, copyFunctor, functorOpts) {
    if ((dst.array.length - dst.start) / dst.stride < count || (src.array.length - src.start) / src.stride < count) {
      return; // we've got no space
    }

    if (src.stride === dst.stride) {
      // stride is the same
      dst.array.set(src.array, dst.start);
    } else {
      var idx = dst.start;
      var arridx = src.start;

      for (var i = 0; i < count; ++i, idx += dst.stride, arridx += src.stride) {
        copyFunctor(src.array, arridx, dst.array, idx, functorOpts);
      }
    }
  }

  var FBXModel = /*#__PURE__*/function () {
    function FBXModel() {
      classCallCheck(this, FBXModel);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.lastPos = 0;
      this.lastNorm = 0;
      this.lastCol = 0;
      this.lastIdx = 0;
    }

    createClass(FBXModel, [{
      key: "init",
      value: function init(vertsCount, indsCount) {
        this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
        this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
        this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
        this.indices = new Int32Array(indsCount);
      }
    }, {
      key: "setPositions",
      value: function setPositions(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.positions,
          start: this.lastPos,
          stride: FBX_POS_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setTransformedPositions",
      value: function setTransformedPositions(array, start, count, stride, matrix) {
        var idx = this.lastPos;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 1
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_POS_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.positions, idx, opts);
        }

        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setNormals",
      value: function setNormals(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.normals,
          start: this.lastNorm,
          stride: FBX_NORM_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setTransformedNormals",
      value: function setTransformedNormals(array, start, count, stride, matrix) {
        var idx = this.lastNorm;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 0
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_NORM_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.normals, idx, opts);
        }

        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setColors",
      value: function setColors(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.colors,
          start: this.lastCol,
          stride: FBX_COL_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint4, 1);
        this.lastCol += count * FBX_COL_SIZE;
      }
    }, {
      key: "setIndices",
      value: function setIndices(array, start, count) {
        this.indices.set(array, this.lastIdx);
        this.lastIdx += count;
      }
    }, {
      key: "setShiftedIndices",
      value: function setShiftedIndices(array, count, shift) {
        var shifted = array.map(function (x) {
          return x + shift;
        });
        this.setIndices(shifted, 0, count);
      }
    }, {
      key: "getVerticesNumber",
      value: function getVerticesNumber() {
        return this.lastPos / FBX_POS_SIZE;
      }
    }, {
      key: "addInstance",
      value: function addInstance(matrix, geo) {
        // add indices at first to take old number of vertices for shift
        var currentCount = this.getVerticesNumber();
        this.setShiftedIndices(geo.indices, geo.indices.length, currentCount); // simply write vertices at empty space

        var size = geo.itemSize;
        this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
        this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
        this.setColors(geo.colors, 0, geo.vertsCount, size.color);
      }
    }]);

    return FBXModel;
  }();

  /** Base class for fbx geometry contains simply organized attributes: positions+normals+colors, indices. */
  var FBXGeometry = /*#__PURE__*/function () {
    /**
     * Create a base geo with necessary members.
     */
    function FBXGeometry() {
      classCallCheck(this, FBXGeometry);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.vertsCount = 0;
      this.itemSize = null;
    }
    /**
     * Initialize base geo storing items info from attributes.
     * @param {Object} geo - THREE.BufferGeometry.
     */


    createClass(FBXGeometry, [{
      key: "init",
      value: function init(geo, _info) {
        var attributes = geo.attributes; // save item size

        this.itemSize = {
          position: attributes.position.itemSize,
          normal: attributes.normal.itemSize,
          color: attributes.color.itemSize
        };
      }
    }]);

    return FBXGeometry;
  }();

  function _createSuper$1U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1V(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Fbx geometry, that copies positions+normals, indexes and creates colors filled with defined value.
   * @extends FBXGeometry
   */

  var FBX1CGeometry = /*#__PURE__*/function (_FBXGeometry) {
    inherits(FBX1CGeometry, _FBXGeometry);

    var _super = _createSuper$1U(FBX1CGeometry);

    function FBX1CGeometry() {
      classCallCheck(this, FBX1CGeometry);

      return _super.apply(this, arguments);
    }

    createClass(FBX1CGeometry, [{
      key: "init",

      /**
       * Initialize geo storing positions, normals, indices and create colors.
       * @param {Object} geo - THREE.BufferGeometry.
       */
      value: function init(geo, _info) {
        get(getPrototypeOf(FBX1CGeometry.prototype), "init", this).call(this, geo, _info);

        var _geo$attributes = geo.attributes,
            position = _geo$attributes.position,
            normal = _geo$attributes.normal,
            index = geo.index; // copy vertices attributes

        this.vertsCount = position.count;
        this.positions = position.array;
        this.normals = normal.array; // create color array

        this.colors = new Float32Array(this.vertsCount * this.itemSize.color); // indices

        this.indices = index.array;
      }
      /**
       * Set defined color for all items in color attribute
       * @param {Object} color - THREE.Color.
       */

    }, {
      key: "setColors",
      value: function setColors(color) {
        var offset = 0;

        for (var i = 0, l = this.colors.length, cl = this.itemSize.color; i < l; i += cl) {
          this.colors[offset++] = color.r;
          this.colors[offset++] = color.g;
          this.colors[offset++] = color.b;
        }
      }
    }]);

    return FBX1CGeometry;
  }(FBXGeometry);

  function _createSuper$1V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1W(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Fbx geometry, that copies positions+normals, indexes from cylinder  geometry and creates colors filled with two
   * defined values.
   * @extends FBXGeometry
   */

  var FBX2CCylinder = /*#__PURE__*/function (_FBXGeometry) {
    inherits(FBX2CCylinder, _FBXGeometry);

    var _super = _createSuper$1V(FBX2CCylinder);

    function FBX2CCylinder() {
      var _this;

      classCallCheck(this, FBX2CCylinder);

      _this = _super.call(this);
      _this._cutRawStart = 0;
      _this._cutRawEnd = 0;
      _this._facesPerSlice = 0;
      return _this;
    }
    /**
     * Initialize geo by creating new attributes, because we extend number of vertices to make cylinder two-colored.
     * Indices remain the same. We process open- end close-ended cylinders and consider cylinders od 2 segments
     * in height ONLY.
     * NOTE: cylinder consists of 2 height segments and stores parts in the order: tube, topCap, bottomCap
     * @param {Object} geo - THREE.BufferGeometry.
     * @param {Object} info - information needed for geo extend
     */


    createClass(FBX2CCylinder, [{
      key: "init",
      value: function init(geo, info) {
        get(getPrototypeOf(FBX2CCylinder.prototype), "init", this).call(this, geo, info);

        var position = geo.attributes.position,
            index = geo.index; // extend vertices arrays

        this.vertsCount = position.count + info.addPerCylinder;
        this._facesPerSlice = info.addPerCylinder;
        this.positions = new Float32Array(this.vertsCount * position.itemSize);
        this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
        this.colors = new Float32Array(this.vertsCount * this.itemSize.color);

        this._extendVertices(geo, info); // number of indices stays the same


        this.indices = new Uint32Array(index.count);

        this._extendIndices(geo, info);
      }
      /** Extend vertex attributes to have one more slice to make sharp middle startColor-endColor line. */

    }, {
      key: "_extendVertices",
      value: function _extendVertices(geo, info) {
        var position = geo.attributes.position;
        var normal = geo.attributes.normal;
        var geoParams = geo.getGeoParams();
        var cutRaw = 1; // we expect cylinders of 2 segments in height => so half segment = 1

        this._cutRawStart = cutRaw * geoParams.radialSegments;
        this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
        {
          // write first half of cylinder
          var temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
          this.positions.set(temp, 0);
          temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
          this.normals.set(temp, 0);
        }
        {
          // write second part of cylinder
          var _temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);

          this.positions.set(_temp, this._cutRawEnd * position.itemSize);
          _temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
          this.normals.set(_temp, this._cutRawEnd * normal.itemSize);
        }
      }
      /** Shift values of second part (+caps) indices by newly added vertices count. Number of faces remains the same. */

    }, {
      key: "_extendIndices",
      value: function _extendIndices(geo, info) {
        var index = geo.index;
        var indicesPerQuad = 6; // quad = 2 triangles => 6 indices

        var startToShift = info.addPerCylinder * indicesPerQuad;
        var shift = info.addPerCylinder;
        var shifted = index.array.slice(startToShift, index.count);
        shifted = shifted.map(function (x) {
          return x + shift;
        }); // shift only the endings

        this.indices.set(index.array, 0);
        this.indices.set(shifted, startToShift);
      }
      /**
       * Set defined colors: (first part + bottom cap), (second part + top cap)
       * @param {number} start - start color index
       * @param {number} end - start color index
       * @param {array} array - array of colors
       * @param {array} color - color value components
       */

    }, {
      key: "_setColorRange",
      value: function _setColorRange(start, end, array, color) {
        var colorSize = color.length;

        for (var i = start; i < end; i += colorSize) {
          array.set(color, i);
        }
      }
      /**
       * Set defined colors: (first part + bottom cap), (second part + top cap)
       * @param {Object} color1 - THREE.Color.
       * @param {Object} color2 - THREE.Color.
       */

    }, {
      key: "setColors",
      value: function setColors(color1, color2) {
        var colorSize = this.itemSize.color;
        var part1End = this._cutRawEnd * colorSize;
        var part2End = part1End * 2;

        this._setColorRange(0, part1End, this.colors, color1.toArray());

        this._setColorRange(part1End, part2End, this.colors, color2.toArray());

        if (part2End < this.colors.length) {
          // cylinder has caps, lets paint them
          var capSize = (this._facesPerSlice + 1) * colorSize;
          var cap1End = part2End + capSize;

          this._setColorRange(part2End, cap1End, this.colors, color2.toArray());

          var cap2End = cap1End + capSize; // should be equal to this.colors.length;

          this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
        }
      }
    }]);

    return FBX2CCylinder;
  }(FBXGeometry);

  var FBXInfoExtractor = /*#__PURE__*/function () {
    function FBXInfoExtractor() {
      classCallCheck(this, FBXInfoExtractor);

      this._materials = [];
      this._models = [];
    }

    createClass(FBXInfoExtractor, [{
      key: "process",
      value: function process(data) {
        this._extractModelsAndMaterials(data);

        var models = this._flattenModels();

        return {
          name: data.name,
          models: models,
          materials: this._materials
        };
      }
      /**
       * Extract fbx object information from ComplexVisual
       * @param {object} data - complexVisual to get geometry info from
       */

    }, {
      key: "_extractModelsAndMaterials",
      value: function _extractModelsAndMaterials(data) {
        var _this = this;

        var layersOfInterest = new THREE.Layers();
        layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
        layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
        data.traverse(function (object) {
          if (object instanceof THREE.Mesh && object.layers.test(layersOfInterest) && _this.checkExportAbility(object)) {
            if (object.geometry.type === 'InstancedBufferGeometry') {
              _this._collectInstancedGeoInfo(object);
            } else {
              _this._collectGeoInfo(object);
            }
          }
        });
      }
      /**
       * Reworking indices buffer, see https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/
       * basically, every triangle in Miew has been represented hat way (e.g.) : 0,1,7, but we must (for FBX) rework that
       * into: 0,1,-8.
       * @param {array} indices - belongs to [0, maxVertIndex]
       */

    }, {
      key: "_reworkIndices",
      value: function _reworkIndices(indices) {
        var faceSize = 3;

        for (var i = faceSize - 1; i < indices.length; i += faceSize) {
          indices[i] *= -1;
          indices[i]--;
        }
      }
      /**
       * Combine geometry from several models having the same material into one Model and finally prepare indices
        * @returns {array} models, combined by material id
       */

    }, {
      key: "_flattenModels",
      value: function _flattenModels() {
        var overallVertsCount = 0;

        function shift(x) {
          return x + overallVertsCount;
        }

        var combined = []; // flatten models geometry

        for (var i = 0, n = this._models.length; i < n; i++) {
          var models = this._models[i];
          var indices = [];
          var positions = [];
          var normals = [];
          var colors = []; // reorganize every attributes as array of arrays

          overallVertsCount = 0;

          for (var j = 0; j < models.length; j++) {
            var m = models[j];
            indices.push(m.indices.map(shift));
            overallVertsCount += m.getVerticesNumber();
            positions.push(m.positions);
            normals.push(m.normals);
            colors.push(m.colors);
          } // join all subarrays into one


          indices = utils.mergeTypedArraysUnsafe(indices);

          this._reworkIndices(indices);

          positions = utils.mergeTypedArraysUnsafe(positions);
          normals = utils.mergeTypedArraysUnsafe(normals);
          colors = utils.mergeTypedArraysUnsafe(colors);
          combined.push({
            indices: indices,
            positions: positions,
            normals: normals,
            colors: colors,
            verticesCount: overallVertsCount
          });
        }

        return combined;
      }
      /**
       * Check ability to export the kind of mesh.
       * @param {object} mesh - given mesh to check
       * @returns {boolean} result of check
       */

    }, {
      key: "checkExportAbility",
      value: function checkExportAbility(mesh) {
        // check mesh on not being empty
        if (mesh.geometry.attributes.position.count === 0) {
          return false;
        } // check type of mesh
        // if (mesh.geometry.isInstancedBufferGeometry && settings.now.zSprites) {


        if (mesh instanceof ZSpriteMesh) {
          logger.warn('Currently we cannot export \'sprites\' modes, like BS, WV, LC. Please turn of settings \'zSprites\' and try again');
          return false;
        }

        if (mesh instanceof ThickLineMesh) {
          logger.warn('Currently we cannot export Lines mode');
          return false;
        }

        return true;
      }
      /**
       * Save geometry info from common mesh, like Surface or Cartoon
       */

    }, {
      key: "_collectGeoInfo",
      value: function _collectGeoInfo(mesh) {
        var _mesh$geometry = mesh.geometry,
            _mesh$geometry$attrib = _mesh$geometry.attributes,
            position = _mesh$geometry$attrib.position,
            color = _mesh$geometry$attrib.color,
            normal = _mesh$geometry$attrib.normal,
            index = _mesh$geometry.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var vertCount = position.count;
        model.init(vertCount, index.count);

        if (matrix.isIdentity()) {
          model.setPositions(position.array, 0, vertCount, position.itemSize);
          model.setNormals(normal.array, 0, vertCount, normal.itemSize);
        } else {
          model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
          model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
        }

        model.setColors(color.array, 0, vertCount, color.itemSize);
        model.setIndices(index.array, 0, index.count);

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Collect instanced spheres geometry and materials.
       * @param {object} mesh - mesh with instanced spheres info
       */

    }, {
      key: "_collectSpheresInfo",
      value: function _collectSpheresInfo(mesh) {
        var _mesh$geometry2 = mesh.geometry,
            _mesh$geometry2$attri = _mesh$geometry2.attributes,
            position = _mesh$geometry2$attri.position,
            color = _mesh$geometry2$attri.color,
            index = _mesh$geometry2.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount, instCount * indsCount);
        var geo = new FBX1CGeometry();
        geo.init(mesh.geometry);
        var instMatrix = new THREE.Matrix4();
        var objMatrix = new THREE.Matrix4();
        var sphereColor = new THREE.Color();

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          // update colors in geometry
          var colorIdx = instanceIndex * color.itemSize;
          sphereColor.fromArray(color.array, colorIdx);
          geo.setColors(sphereColor); // add instance to the model

          this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Getting all instanced cylinders from given mesh.
       * Divide cylinder (add additional vertexes) for prettiness therefore algorithm is a bit complicated
       * @param {object} mesh - given mesh with instanced cylinders
       */

    }, {
      key: "_collectCylindersInfo",
      value: function _collectCylindersInfo(mesh) {
        var _mesh$geometry3 = mesh.geometry,
            _mesh$geometry3$attri = _mesh$geometry3.attributes,
            position = _mesh$geometry3$attri.position,
            color = _mesh$geometry3$attri.color,
            color2 = _mesh$geometry3$attri.color2,
            index = _mesh$geometry3.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var oneCCylinder = new FBX1CGeometry();
        oneCCylinder.init(mesh.geometry);

        var splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);

        var twoCCylinder = null;

        if (splittingInfo.needToSplit > 0) {
          twoCCylinder = new FBX2CCylinder();
          twoCCylinder.init(mesh.geometry, splittingInfo);
        }

        var additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
        var instMatrix = new THREE.Matrix4();
        var objMatrix = new THREE.Matrix4();
        var colorStart = new THREE.Color();
        var colorEnd = new THREE.Color();
        var geo = {};

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          // update colors in geometry
          var colorIdx = instanceIndex * color.itemSize;

          if (splittingInfo.is2Colored[instanceIndex]) {
            // .color2 contains starting color, and .color contains starting color (see uber.frag ATTR_COLOR2)
            colorStart.fromArray(color2.array, colorIdx);
            colorEnd.fromArray(color.array, colorIdx);

            if (twoCCylinder) {
              twoCCylinder.setColors(colorStart, colorEnd);
              geo = twoCCylinder;
            }
          } else {
            // has one color per cylinder
            colorStart.fromArray(color.array, colorIdx);
            oneCCylinder.setColors(colorStart);
            geo = oneCCylinder;
          } // add instance to the model


          this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
      /**
       * Adding model to pool of models or extend existing ones
       * @param {object} model - model to add
       * @param {object} material - material to add
       */

    }, {
      key: "_addToPool",
      value: function _addToPool(model, material) {
        var materialIdx = this._checkExistingMaterial(material);

        if (materialIdx < 0) {
          // new model-material pair
          this._models.push([model]);

          this._materials.push(material);
        } else {
          // add model to existing model-material pair
          var models = this._models[materialIdx];
          models.push(model);
        }
      }
      /**
       * Checking if given material already was registered in materials pool (no need to create new one)
       * @param {object} material - given material
       * @returns {number} number of model-material pair
       */

    }, {
      key: "_checkExistingMaterial",
      value: function _checkExistingMaterial(material) {
        return ___default['default'].findIndex(this._materials, function (m) {
          return ___default['default'].isEqual(m, material);
        });
      }
    }, {
      key: "_gatherCylindersColoringInfo",
      value: function _gatherCylindersColoringInfo(geo) {
        var instCount = geo.instanceCount;
        var color1 = geo.attributes.color.array;
        var color2 = geo.attributes.color2.array;
        var stride = geo.attributes.color.itemSize;
        var is2Colored = new Array(instCount); // analyze color instance attributes

        var needToSplit = 0;
        var colIdx = 0;

        for (var i = 0; i < instCount; i++, colIdx += stride) {
          var differs = Math.abs(color1[colIdx] - color2[colIdx]) > 0.0000001 || // compare ending colors
          Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 0.0000001 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 0.0000001;
          is2Colored[i] = differs;
          needToSplit += differs; // count number of 2-colored cylinders
        } // calc number of vertices to add into 2-colored


        var geoParams = geo.getGeoParams();
        var addPerCylinder = geoParams.radialSegments;
        return {
          is2Colored: is2Colored,
          needToSplit: needToSplit,
          addPerCylinder: addPerCylinder
        };
      }
      /**
       * Collect instanced models and materials.
       * @param {object} mesh - given mesh with instanced something (spheres or cylinders)
       */

    }, {
      key: "_collectInstancedGeoInfo",
      value: function _collectInstancedGeoInfo(mesh) {
        if (mesh.geometry instanceof InstancedSpheresGeometry) {
          this._collectSpheresInfo(mesh);
        } else if (mesh.geometry instanceof Instanced2CCylindersGeometry) {
          this._collectCylindersInfo(mesh);
        }
      }
      /**
       * Collect Material info from given mesh.
       * @param {object} mesh - given mesh with material info
       * @returns {object} material
       */

    }, {
      key: "_collectMaterialInfo",
      value: function _collectMaterialInfo(mesh) {
        var uberOptions = mesh.material.uberOptions;
        return {
          diffuse: uberOptions.diffuse.toArray(),
          opacity: uberOptions.opacity,
          shininess: uberOptions.shininess,
          specular: uberOptions.specular.toArray()
        };
      }
    }, {
      key: "_getCylinderInstanceMatrix",
      value: function _getCylinderInstanceMatrix(geo, instIdx, matrix) {
        var matVector1 = geo.attributes.matVector1.array;
        var matVector2 = geo.attributes.matVector2.array;
        var matVector3 = geo.attributes.matVector3.array;
        var idxOffset = instIdx * 4; // used 4 because offset arrays are stored in quads

        matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
      }
    }, {
      key: "_getSphereInstanceMatrix",
      value: function _getSphereInstanceMatrix(geo, instIdx, matrix) {
        var offset = geo.attributes.offset;
        var idx = instIdx * offset.itemSize;
        var x = offset.array[idx];
        var y = offset.array[idx + 1];
        var z = offset.array[idx + 2];
        var scale = offset.array[idx + 3];
        matrix.set(scale, 0, 0, x, 0, scale, 0, y, 0, 0, scale, z, 0, 0, 0, 1);
      }
    }]);

    return FBXInfoExtractor;
  }();

  // Forming default definitions block
  var defaultDefinitions = "\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: \"Model\" {\n    Count: 1\n  }\n  ObjectType: \"Geometry\" {\n    Count: 1\n  }\n  ObjectType: \"Material\" {\n    Count: 1\n  }\n  ObjectType: \"Pose\" {\n    Count: 1\n  }\n  ObjectType: \"GlobalSettings\" {\n    Count: 1\n  }\n} "; // Default model properties

  var defaultProperties = "Properties60: {\n      Property: \"QuaternionInterpolate\", \"bool\", \"\",0\n      Property: \"Visibility\", \"Visibility\", \"A\",1\n      Property: \"Lcl Translation\", \"Lcl Translation\", \"A\",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: \"Lcl Rotation\", \"Lcl Rotation\", \"A\",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: \"Lcl Scaling\", \"Lcl Scaling\", \"A\",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: \"RotationOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationActive\", \"bool\", \"\",0\n      Property: \"TranslationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMinX\", \"bool\", \"\",0\n      Property: \"TranslationMinY\", \"bool\", \"\",0\n      Property: \"TranslationMinZ\", \"bool\", \"\",0\n      Property: \"TranslationMaxX\", \"bool\", \"\",0\n      Property: \"TranslationMaxY\", \"bool\", \"\",0\n      Property: \"TranslationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationOrder\", \"enum\", \"\",0\n      Property: \"RotationSpaceForLimitOnly\", \"bool\", \"\",0\n      Property: \"AxisLen\", \"double\", \"\",10\n      Property: \"PreRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"PostRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationActive\", \"bool\", \"\",0\n      Property: \"RotationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMinX\", \"bool\", \"\",0\n      Property: \"RotationMinY\", \"bool\", \"\",0\n      Property: \"RotationMinZ\", \"bool\", \"\",0\n      Property: \"RotationMaxX\", \"bool\", \"\",0\n      Property: \"RotationMaxY\", \"bool\", \"\",0\n      Property: \"RotationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationStiffnessX\", \"double\", \"\",0\n      Property: \"RotationStiffnessY\", \"double\", \"\",0\n      Property: \"RotationStiffnessZ\", \"double\", \"\",0\n      Property: \"MinDampRangeX\", \"double\", \"\",0\n      Property: \"MinDampRangeY\", \"double\", \"\",0\n      Property: \"MinDampRangeZ\", \"double\", \"\",0\n      Property: \"MaxDampRangeX\", \"double\", \"\",0\n      Property: \"MaxDampRangeY\", \"double\", \"\",0\n      Property: \"MaxDampRangeZ\", \"double\", \"\",0\n      Property: \"MinDampStrengthX\", \"double\", \"\",0\n      Property: \"MinDampStrengthY\", \"double\", \"\",0\n      Property: \"MinDampStrengthZ\", \"double\", \"\",0\n      Property: \"MaxDampStrengthX\", \"double\", \"\",0\n      Property: \"MaxDampStrengthY\", \"double\", \"\",0\n      Property: \"MaxDampStrengthZ\", \"double\", \"\",0\n      Property: \"PreferedAngleX\", \"double\", \"\",0\n      Property: \"PreferedAngleY\", \"double\", \"\",0\n      Property: \"PreferedAngleZ\", \"double\", \"\",0\n      Property: \"InheritType\", \"enum\", \"\",0\n      Property: \"ScalingActive\", \"bool\", \"\",0\n      Property: \"ScalingMin\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMax\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMinX\", \"bool\", \"\",0\n      Property: \"ScalingMinY\", \"bool\", \"\",0\n      Property: \"ScalingMinZ\", \"bool\", \"\",0\n      Property: \"ScalingMaxX\", \"bool\", \"\",0\n      Property: \"ScalingMaxY\", \"bool\", \"\",0\n      Property: \"ScalingMaxZ\", \"bool\", \"\",0\n      Property: \"GeometricTranslation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricScaling\", \"Vector3D\", \"\",1,1,1\n      Property: \"LookAtProperty\", \"object\", \"\"\n      Property: \"UpVectorProperty\", \"object\", \"\"\n      Property: \"Show\", \"bool\", \"\",1\n      Property: \"NegativePercentShapeSupport\", \"bool\", \"\",1\n      Property: \"DefaultAttributeIndex\", \"int\", \"\",0\n      Property: \"Color\", \"Color\", \"A+\",0,0,0\n      Property: \"Size\", \"double\", \"\",100\n      Property: \"Look\", \"enum\", \"\",1\n    }"; // Default materials layer

  var defaultMaterialLayer = "\n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: \"\"\n      MappingInformationType: \"AllSame\"\n      ReferenceInformationType: \"Direct\"\n      Materials: 0\n    }"; // Default layers block

  var defaultLayerBlock = "\n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: \"LayerElementNormal\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementColor\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementMaterial\"\n        TypedIndex: 0\n      }\n    }";
  /**
   * globalSettings info in output file.
   */

  var globalSettings = "GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: \"UpAxis\", \"int\", \"\",1\n      Property: \"UpAxisSign\", \"int\", \"\",1\n      Property: \"FrontAxis\", \"int\", \"\",2\n      Property: \"FrontAxisSign\", \"int\", \"\",1\n      Property: \"CoordAxis\", \"int\", \"\",0\n      Property: \"CoordAxisSign\", \"int\", \"\",1\n      Property: \"UnitScaleFactor\", \"double\", \"\",1\n    }\n  }";

  var FBXResult = /*#__PURE__*/function () {
    function FBXResult() {
      classCallCheck(this, FBXResult);

      this._resultArray = [];
      this._info = null;
    }

    createClass(FBXResult, [{
      key: "getResult",
      value: function getResult(info) {
        this._info = info;

        this._resultArray.push(this._writeHeader());

        this._resultArray.push(this._writeDefinitions());

        this._resultArray.push(this._writeObjects(info.models, info.materials));

        this._resultArray.push(this._writeRelations());

        this._resultArray.push(this._writeConnections()); // connections between models and materials)


        this._info = null;
        return this._resultArray.join('');
      }
      /**
       * Add FBXHeader info to output file.
       * Some fields are really confusing, but it seems that all listed fields are very informative
       */

    }, {
      key: "_writeHeader",
      value: function _writeHeader() {
        var FBXHeaderVersion = 1003; // 1003 is some number which appears to present in many 6.1 ASCII files

        var FBXVersion = 6100; // Mandatory and only supported version

        var date = new Date();
        var timeStampVersion = 1000;
        var creator = "Miew FBX Exporter v".concat(this._info.version); // Supposed to be an engine

        return "; FBX 6.1.0 project file\n; Created by ".concat(creator, " Copyright (c) 2015-2020 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: ").concat(FBXHeaderVersion, "\n  FBXVersion: ").concat(FBXVersion, "\n  CreationTimeStamp:  {\n    Version: ").concat(timeStampVersion, "\n    Year: ").concat(date.getFullYear(), "\n    Month: ").concat(date.getMonth() + 1, " \n    Day: ").concat(date.getDate(), "\n    Hour: ").concat(date.getHours(), "\n    Minute: ").concat(date.getMinutes(), "\n    Second: ").concat(date.getSeconds(), "\n    Millisecond: ").concat(date.getMilliseconds(), "\n  }\n  Creator: \"").concat(creator, "\"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: \"").concat(date, "\"\nCreator: \"").concat(creator, "\"  \n");
      }
      /**
       * Add Definitions info to output file.
       * Not exactly sure if this section is template section (as it is in 7.4+) or it should every time be like this
       */

    }, {
      key: "_writeDefinitions",
      value: function _writeDefinitions() {
        return "\n; Object definitions\n;------------------------------------------------------------------\n\n".concat(defaultDefinitions, "\n");
      }
      /**
       * Adding gathered information about Models to resulting string.
       * Reminder - there may be more then 1 model in scene, but we must place materials after ALL models.
       * @returns {string} string containing all models (vertices, indices, colors, normals etc)
       */

    }, {
      key: "_models",
      value: function _models() {
        var modelVersion = 232;
        var allModels = '';
        var models = this._info.models;

        for (var i = 0; i < models.length; ++i) {
          var model = models[i];
          var vertCount = model.verticesCount;
          allModels += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n    Version: ").concat(modelVersion, " \n    ").concat(defaultProperties, "\n    ").concat(this._verticesIndices(model.positions, model.indices), "\n    ").concat(this._normalLayer(model.normals), " \n    ").concat(this._colorLayer(model.colors, vertCount), " \n    ").concat(defaultMaterialLayer, "  \n    ").concat(defaultLayerBlock, "\n  }");
        }

        return allModels;
      }
      /**
       * Add Material info to result
       */

    }, {
      key: "_materials",
      value: function _materials() {
        var materialVersion = 102;
        var allMaterials = '';
        var materials = this._info.materials;

        for (var i = 0; i < materials.length; ++i) {
          var material = materials[i];
          allMaterials += "\n  Material: \"Material::".concat(this._info.name, "_").concat(i, "_default\", \"\" {\n    Version: ").concat(materialVersion, "\n    ShadingModel: \"lambert\"\n    MultiLayer: 0\n    ").concat(this._materialProperties(material), "\n  }");
        }

        return allMaterials;
      }
      /**
       * Add Objects info to output file.
       */

    }, {
      key: "_writeObjects",
      value: function _writeObjects() {
        return "\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  ".concat(this._models(), "\n  ").concat(this._materials(), "\n  ").concat(globalSettings, "\n}\n");
      }
      /**
       * Add Relations info to output file.
       */

    }, {
      key: "_writeRelations",
      value: function _writeRelations() {
        var modelsList = '';

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n  }");
        }

        var materialList = '';

        for (var _i = 0; _i < this._info.materials.length; ++_i) {
          materialList += "\n  Material: \"Material::".concat(this._info.name, "_").concat(_i, "_default\", \"\" {\n  }");
        }

        return "\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  ".concat(modelsList, "\n  Model: \"Model::Producer Perspective\", \"Camera\" {\n  }\n  Model: \"Model::Producer Top\", \"Camera\" {\n  }\n  Model: \"Model::Producer Bottom\", \"Camera\" {\n  }\n  Model: \"Model::Producer Front\", \"Camera\" {\n  }\n  Model: \"Model::Producer Back\", \"Camera\" {\n  }\n  Model: \"Model::Producer Right\", \"Camera\" {\n  }\n  Model: \"Model::Producer Left\", \"Camera\" {\n  }\n  Model: \"Model::Camera Switcher\", \"CameraSwitcher\" {\n  }\n  ").concat(materialList, "\n}");
      }
      /**
       * Add Connections info to output file.
       */

    }, {
      key: "_writeConnections",
      value: function _writeConnections() {
        var modelsList = '';
        var name = this._info.name;

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Connect: \"OO\", \"Model::".concat(name, "_").concat(i, "\", \"Model::Scene\"");
        }

        var materialList = '';

        for (var _i2 = 0; _i2 < this._info.materials.length; ++_i2) {
          materialList += "\n  Connect: \"OO\", \"Material::".concat(name, "_").concat(_i2, "_default\", \"Model::").concat(name, "_").concat(_i2, "\"");
        }

        return "\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  ".concat(modelsList, "\n  ").concat(materialList, "\n}");
      }
      /**
       * Write float array to string with limited precision
       * @param {Float32Array} array - array to be fixed
       * @returns {String} String with fixed floats
       */

    }, {
      key: "_floatArrayToString",
      value: function _floatArrayToString(array) {
        var str = [];

        for (var i = 0; i < array.length; ++i) {
          str[i] = array[i].toFixed(6);
        }

        return str.join(',');
      }
      /**
       * Adding color layer to resulting file
       * @param {Float32Array} colorArray attribute
       * @param {number} vertCount - number of vertices in the model
       * @returns {string} color layer info
       */

    }, {
      key: "_colorLayer",
      value: function _colorLayer(colorArray, vertCount) {
        var layerElementColorNumber = 0;
        var layerElementColorVersion = 101;
        var layerElementColorName = '';

        var colorsStr = this._floatArrayToString(colorArray); // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed
        // As said [..Array(...)] - fastest and easiest way to produce [0, 1, .....] array


        var colorIndices = toConsumableArray(Array(vertCount).keys());

        return "\n    LayerElementColor: ".concat(layerElementColorNumber, " {\n      Version: ").concat(layerElementColorVersion, "\n      Name: \"").concat(layerElementColorName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\"\n      Colors: ").concat(colorsStr, "\n      ColorIndex: ").concat(colorIndices, "\n    }");
      }
      /**
       * Adding normal layer to resulting file
       * @param {Float32Array} normalArray attribute
       * @returns {string} normal layer info
       */

    }, {
      key: "_normalLayer",
      value: function _normalLayer(normalArray) {
        var layerElementNormalNumber = 0;
        var layerElementNormalVersion = 101;
        var layerElementNormalName = '';

        var normalsStr = this._floatArrayToString(normalArray); // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed


        return "\n    LayerElementNormal: ".concat(layerElementNormalNumber, " {\n      Version: ").concat(layerElementNormalVersion, "\n      Name: \"").concat(layerElementNormalName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\" \n      Normals: ").concat(normalsStr, "\n    }");
      }
      /**
       * Adding vertices and indices to resulting string
       * @return {string} resulting string in FBX notation
       */

    }, {
      key: "_verticesIndices",
      value: function _verticesIndices(positions, indices) {
        var multiLayer = 0;
        var multiTake = 1;
        var shading = 'Y';
        var culling = 'CullingOff';
        var geometryVersion = 124;

        var vertStr = this._floatArrayToString(positions);
        /* About _correctArrayNotation: Float32Arrays will contains only Float32 numbers, which implies that it will be floating points with 17 numbers after point.
        * We cannot (and it's logically incorrect) save all this information, so we convert this Float32Array into Array-like object with numbers with only 6 numbers after point
        * Reminder - this is big memory loss (as we must save at one moment two arrays with similar information) */


        return "MultiLayer: ".concat(multiLayer, "\n    MultiTake: ").concat(multiTake, "\n    Shading: ").concat(shading, "\n    Culling: \"").concat(culling, "\"\n    Vertices: ").concat(vertStr, "\n    PolygonVertexIndex: ").concat(indices, "\n    GeometryVersion: ").concat(geometryVersion);
      }
      /**
       * Forming material properties block.
       * @param {Object} material - given material of model
       * @returns {String} material properties string
       */

    }, {
      key: "_materialProperties",
      value: function _materialProperties(material) {
        return "Properties60:  {\n      Property: \"ShadingModel\", \"KString\", \"\", \"Lambert\"\n      Property: \"MultiLayer\", \"bool\", \"\",0\n      Property: \"EmissiveColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"EmissiveFactor\", \"double\", \"\",0.0000\n      Property: \"AmbientColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"AmbientFactor\", \"double\", \"\",0.0000\n      Property: \"DiffuseColor\", \"ColorRGB\", \"\",".concat(material.diffuse, "\n      Property: \"DiffuseFactor\", \"double\", \"\",1.0000\n      Property: \"Bump\", \"Vector3D\", \"\",0,0,0\n      Property: \"TransparentColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"TransparencyFactor\", \"double\", \"\",0.0000\n      Property: \"SpecularColor\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"SpecularFactor\", \"double\", \"\",1.0000\n      Property: \"ShininessExponent\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"ReflectionColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"ReflectionFactor\", \"double\", \"\",1\n      Property: \"Ambient\", \"ColorRGB\", \"\",1,1,1\n      Property: \"Diffuse\", \"ColorRGB\", \"\",").concat(material.diffuse, "\n      Property: \"Specular\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"Shininess\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"Opacity\", \"double\", \"\",").concat(material.opacity, "\n      Property: \"Reflectivity\", \"double\", \"\",0\n    }");
      }
    }]);

    return FBXResult;
  }();

  function _createSuper$1W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1X(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FBXExporter = /*#__PURE__*/function (_Exporter) {
    inherits(FBXExporter, _Exporter);

    var _super = _createSuper$1W(FBXExporter);

    function FBXExporter(source, options) {
      var _this;

      classCallCheck(this, FBXExporter);

      _this = _super.call(this, source, options); // Data

      _this._data = source;
      _this._version = options.miewVersion || '0.0-UNSPECIFIED';
      _this._extractor = new FBXInfoExtractor();
      return _this;
    }
    /**
     * Entry point to exporter.
     */


    createClass(FBXExporter, [{
      key: "exportSync",
      value: function exportSync() {
        // Creating mandatory blocks
        var result = new FBXResult();

        if (!this._source) {
          return this._result;
        }

        var info = this._extractor.process(this._data);

        info.version = this._version;
        this._result = result.getResult(info);
        return this._result;
      }
    }]);

    return FBXExporter;
  }(Exporter);
  FBXExporter.formats = ['fbx'];
  FBXExporter.SourceClass = ComplexVisual;

  var exporters = new ExporterList([PDBExporter, FBXExporter]);

  var io = {
    loaders: loaders,
    parsers: parsers,
    exporters: exporters
  };

  var tempColor = new THREE.Color();

  var CSS2DRenderer = /*#__PURE__*/function () {
    function CSS2DRenderer() {
      classCallCheck(this, CSS2DRenderer);

      this._width = 0;
      this._height = 0;
      this._widthHalf = 0;
      this._heightHalf = 0;
      this._vector = new THREE.Vector3();
      this._viewMatrix = new THREE.Matrix4();
      this._projectionMatrix = new THREE.Matrix4();
      this._domElement = document.createElement('div');
      this._domElement.style.overflow = 'hidden';
      this._domElement.style.position = 'absolute';
      this._domElement.style.top = '0';
      this._domElement.style.zIndex = '0'; // start a new Stacking Context to enclose all z-ordered children

      this._domElement.style.pointerEvents = 'none';
    }

    createClass(CSS2DRenderer, [{
      key: "getElement",
      value: function getElement() {
        return this._domElement;
      }
    }, {
      key: "reset",
      value: function reset() {
        var myNode = this.getElement();

        while (myNode.firstChild) {
          myNode.removeChild(myNode.firstChild);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this._width = width;
        this._height = height;
        this._widthHalf = this._width / 2;
        this._heightHalf = this._height / 2;
        this._domElement.style.width = "".concat(width, "px");
        this._domElement.style.height = "".concat(height, "px");
      }
    }, {
      key: "_renderObject",
      value: function _renderObject(object, camera, scene) {
        function lerpColorAsHex(a, b, t) {
          tempColor.setHex(a);
          tempColor.lerp(b, t);
          return "#".concat(tempColor.getHexString());
        }

        function colorAsHex(a) {
          tempColor.setHex(a);
          return "#".concat(tempColor.getHexString());
        }

        if (object instanceof CSS2DObject) {
          this._vector.setFromMatrixPosition(object.matrixWorld);

          if (object.userData !== undefined && object.userData.offset !== undefined) {
            var localOffset = new THREE.Vector3(object.userData.offset.x, object.userData.offset.y, 0);

            this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
          }

          this._vector.applyMatrix4(this._viewMatrix);

          var visibility = this._vector.z > -camera.near ? 'hidden' : 'visible';
          var zIndex = 10000 * (camera.far - -this._vector.z) / (camera.far - camera.near);
          var element = object.getElement();

          if (typeof scene.fog === 'undefined') {
            element.style.color = colorAsHex(object.userData.color);

            if (object.userData.background !== 'transparent') {
              element.style.background = colorAsHex(object.userData.background);
            }
          } else {
            var fogFactor = THREE.MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
            element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);

            if (object.userData.background !== 'transparent') {
              element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
            }
          }

          this._vector.applyMatrix4(this._projectionMatrix);

          var style = "".concat(object.userData !== {} ? object.userData.translation : 'translate(-50%, -50%) ', "translate(").concat(this._vector.x * this._widthHalf + this._widthHalf, "px,").concat(-this._vector.y * this._heightHalf + this._heightHalf, "px)");
          element.style.visibility = visibility;
          element.style.WebkitTransform = style;
          element.style.MozTransform = style;
          element.style.oTransform = style;
          element.style.transform = style;
          element.style.zIndex = Number(zIndex).toFixed(0);

          if (element.parentNode !== this._domElement) {
            this._domElement.appendChild(element);
          }
        }

        for (var i = 0, l = object.children.length; i < l; i++) {
          this._renderObject(object.children[i], camera, scene);
        }
      }
    }, {
      key: "render",
      value: function render(scene, camera) {
        scene.updateMatrixWorld();

        if (camera.parent === null) {
          camera.updateMatrixWorld();
        }

        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

        this._viewMatrix.copy(camera.matrixWorldInverse);

        this._projectionMatrix.copy(camera.projectionMatrix);

        this._renderObject(scene, camera, scene);
      }
    }]);

    return CSS2DRenderer;
  }();

  var VK_LEFT = 37;
  var VK_UP = 38;
  var VK_RIGHT = 39;
  var VK_DOWN = 40;
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    TRANSLATE: 1,
    SCALE: 2,
    TRANSLATE_PIVOT: 3
  }; // pausing for this amount of time before releasing mouse button prevents inertial rotation (seconds)

  var FULL_STOP_THRESHOLD = 0.1;
  var quaternion = new THREE.Quaternion();
  var matrix4 = new THREE.Matrix4(); // pivot -- local offset of the rotation pivot point

  function ObjectHandler(objects, camera, pivot, options) {
    this.objects = objects;

    var _objects = slicedToArray(objects, 1);

    this.object = _objects[0];
    this.camera = camera;
    this.pivot = pivot;
    this.axis = new THREE.Vector3(0, 0, 1);
    this.options = options;
    this.lastRotation = {
      axis: new THREE.Vector3(),
      angle: 0.0
    };
  }

  ObjectHandler.prototype._rotate = function () {
    var p = new THREE.Vector3();
    var q = new THREE.Quaternion();
    var s = new THREE.Vector3();
    var m = new THREE.Matrix4();
    return function (quat) {
      var zeroPivot = this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0;
      m.copy(this.object.matrix);

      if (zeroPivot) {
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
      } else {
        m.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
        m.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
      }

      m.decompose(p, q, s); // update objects

      if (!zeroPivot) {
        for (var i = 0; i < this.objects.length; ++i) {
          this.objects[i].position.copy(p);
        }
      }

      for (var j = 0; j < this.objects.length; ++j) {
        this.objects[j].quaternion.copy(q);
        this.objects[j].updateMatrix();
      }
    };
  }();

  ObjectHandler.prototype.setObjects = function (objects) {
    this.objects = objects;

    var _objects2 = slicedToArray(objects, 1);

    this.object = _objects2[0];
  };

  ObjectHandler.prototype.rotate = function () {
    var rot = {
      axis: new THREE.Vector3(),
      angle: 0.0
    };
    return function (quat, mousePrevPos, mouseCurPos, aboutAxis) {
      this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
      quat.setFromAxisAngle(rot.axis, rot.angle);

      if (rot.angle) {
        this._rotate(quat);
      }

      this.lastRotation = rot;
    };
  }();

  ObjectHandler.prototype.translate = function () {
    var dir = new THREE.Vector3();
    var pivot = new THREE.Vector3();
    return function (delta) {
      // reverse-project viewport movement to view coords (compensate for screen aspect ratio)
      dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
      var dist = dir.length();
      dir.normalize(); // transform movement direction to object local coords

      dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert()); // visible translate distance shouldn't depend on camera-to-object distance

      pivot.copy(this.pivot);
      this.object.localToWorld(pivot);
      dist *= Math.abs(pivot.z - this.camera.position.z); // visible translate distance shouldn't depend on object scale

      dist /= this.object.matrixWorld.getMaxScaleOnAxis(); // all objects are translated similar to principal object
      // (we assume they all have identical pivot and scale)

      for (var i = 0; i < this.objects.length; ++i) {
        this.objects[i].translateOnAxis(dir, dist);
      }
    };
  }();

  ObjectHandler.prototype.update = function () {
    var axis = new THREE.Vector3();
    return function (timeSinceLastUpdate, timeSinceMove) {
      if (settings.now.autoRotation !== 0.0) {
        // auto-rotation with constant speed
        // if rotation axis is fixed or hasn't been defined yet
        if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0.0) {
          // use Y-axis (transformed to local object coords)
          axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
        } else {
          // use axis defined by last user rotation
          axis.copy(this.lastRotation.axis);
        }

        this._rotate(quaternion.setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));

        return true;
      }

      if (this.options.intertia && this.lastRotation.angle) {
        // inertial object rotation
        var angle = this.lastRotation.angle * Math.pow(1.0 - this.options.dynamicDampingFactor, 40.0 * timeSinceMove);

        if (Math.abs(angle) <= this.options.intertiaThreshold) {
          this.lastRotation.angle = 0.0;
        } else {
          this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));

          return true;
        }
      }

      return false;
    };
  }();

  ObjectHandler.prototype.stop = function () {
    this.lastRotation.angle = 0.0;
  }; // calculate (axis, angle) pair from mouse/touch movement


  ObjectHandler.prototype.mouse2rotation = function () {
    var center = new THREE.Vector3();
    var eye = new THREE.Vector3();
    var eyeDirection = new THREE.Vector3();
    var cameraUpDirection = new THREE.Vector3();
    var cameraSidewaysDirection = new THREE.Vector3();
    var moveDirection = new THREE.Vector3();
    var mouseDelta = new THREE.Vector2();
    return function (rot, mousePrev, mouseCur, aboutAxis) {
      if (aboutAxis) {
        rot.axis.copy(this.axis);
        rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);
        /* cool method that allows rotation around Z axis to be "tied" to mouse cursor
           res.axis.copy(this.axis);
           var pivot = this.pivot.clone();
          this.object.localToWorld(pivot);
          pivot.project(this.camera);
           var v1 = new THREE.Vector3(mousePrev.x, mousePrev.y, this.camera.position.z);
          v1.sub(pivot);
          var v2 = new THREE.Vector3(mouseCur.x, mouseCur.y, this.camera.position.z);
          v2.sub(pivot);
           v1.sub(res.axis.clone().multiplyScalar(v1.dot(res.axis)));
          v2.sub(res.axis.clone().multiplyScalar(v2.dot(res.axis)));
           var abs = v1.length() * v2.length();
          if (abs > 0) {
            res.angle = res.axis.dot(v1.cross(v2)) / abs;
          }
        */
      } else {
        mouseDelta.subVectors(mouseCur, mousePrev);
        var angle = mouseDelta.length();

        if (angle === 0.0) {
          return;
        }

        center.copy(this.pivot);
        this.object.localToWorld(center);
        eye.subVectors(this.camera.position, center);
        eyeDirection.copy(eye).normalize();
        cameraUpDirection.copy(this.camera.up).normalize();
        cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
        cameraUpDirection.setLength(mouseDelta.y);
        cameraSidewaysDirection.setLength(mouseDelta.x);
        moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
        rot.axis.crossVectors(moveDirection, eye);
        rot.angle = -angle * this.options.rotateFactor;
      }

      rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert()); // make sure angle is always positive (thus 'axis' defines both axis and direction of rotation)

      if (rot.angle < 0.0) {
        rot.axis.negate();
        rot.angle = -rot.angle;
      }
    };
  }();

  function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
    EventDispatcher.call(this);
    var self = this;
    this.object = object;
    this.objectPivot = objectPivot;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.getAltObj = getAltObj; // API

    this.enabled = true;
    this.hotkeysEnabled = true;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this.options = {
      rotateFactor: Math.PI,
      // full screen slide (along short side) would roughly mean 180 deg. rotation
      axisRotateFactor: 4 * Math.PI,
      // full screen slide (along short side) would roughly mean 720 deg. rotation
      intertia: true,
      dynamicDampingFactor: 0.1,
      intertiaThreshold: 1e-3
    }; // internals

    this._state = STATE.NONE;
    this._mousePrevPos = new THREE.Vector2();
    this._mouseCurPos = new THREE.Vector2();
    this._mainObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._altObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._affectedObj = this._mainObj;
    this._isAltObjFreeRotationAllowed = true;
    this._isTranslationAllowed = true;
    this._isKeysTranslatingObj = false;
    this._pressedKeys = [];
    this._clock = new Timer();

    this._clock.start();

    this._lastUpdateTime = this._clock.getElapsedTime(); // events

    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousewheel',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'DOMMouseScroll',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseout',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchmove',
      handler: function handler(e) {
        self.touchmove(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keydown',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keyup',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }, {
      obj: window,
      type: 'blur',
      handler: function handler() {
        self.resetKeys();
      }
    }, {
      obj: self.domElement,
      type: 'contextmenu',
      handler: function handler(e) {
        self.contextmenu(e);
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
    this.resetKeys(); // force an update at start

    this.update();
  } // methods


  ObjectControls.prototype = Object.create(EventDispatcher.prototype);
  ObjectControls.prototype.constructor = ObjectControls;

  ObjectControls.prototype.resetKeys = function () {
    this._pressedKeys[VK_LEFT] = false;
    this._pressedKeys[VK_UP] = false;
    this._pressedKeys[VK_RIGHT] = false;
    this._pressedKeys[VK_DOWN] = false;
  };

  ObjectControls.prototype.contextmenu = function (e) {
    e.stopPropagation();
    e.preventDefault();
  };

  ObjectControls.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  ObjectControls.prototype.enable = function (enable) {
    this.enabled = enable;
  };

  ObjectControls.prototype.enableHotkeys = function (enable) {
    this.hotkeysEnabled = enable;
  };

  ObjectControls.prototype.allowTranslation = function (allow) {
    this._isTranslationAllowed = allow;
  };

  ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
    this._isAltObjFreeRotationAllowed = allow;
  };

  ObjectControls.prototype.keysTranslateObj = function (on) {
    this._isKeysTranslatingObj = on;
  };

  ObjectControls.prototype.isEditingAltObj = function () {
    return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
  }; // convert page coords of mouse/touch to uniform coords with smaller side being [-0.5, 0.5]
  // (uniform coords keep direct proportion with screen distance travelled by mouse regardless of screen aspect ratio)


  ObjectControls.prototype.convertMouseToOnCircle = function (coords, pageX, pageY) {
    var screenSize = Math.min(this.screen.width, this.screen.height);

    if (screenSize === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
  }; // convert page coords of mouse/touch to viewport coords with both sides being [-1, 1]
  // (those are non-uniform coords affected by screen aspect ratio)


  ObjectControls.prototype.convertMouseToViewport = function (coords, pageX, pageY) {
    if (this.screen.width === 0 || this.screen.height === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set(2.0 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2.0 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
  };

  ObjectControls.prototype.stop = function () {
    this._mainObj.stop();

    this._altObj.stop();
  }; // rotate object based on latest mouse/touch movement


  ObjectControls.prototype.rotateByMouse = function () {
    var quat = new THREE.Quaternion();
    return function (aboutZAxis) {
      this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);

      this.dispatchEvent({
        type: 'change',
        action: 'rotate',
        quaternion: quat
      });
    };
  }(); // rotate object by specified quaternion


  ObjectControls.prototype.rotate = function (quat) {
    this.object.quaternion.multiply(quat);
    this.dispatchEvent({
      type: 'change',
      action: 'rotate',
      quaternion: quat
    });
  }; // get object's orientation


  ObjectControls.prototype.getOrientation = function () {
    return this.object.quaternion;
  }; // set object's orientation


  ObjectControls.prototype.setOrientation = function (quat) {
    this.object.quaternion.copy(quat);
  }; // translate object based on latest mouse/touch movement


  ObjectControls.prototype.translate = function () {
    var delta = new THREE.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);

      this._affectedObj.translate(delta);

      this.dispatchEvent({
        type: 'change',
        action: 'translate'
      });
    };
  }(); // get object scale


  ObjectControls.prototype.getScale = function () {
    return this.object.scale.x;
  }; // set uniform object scale


  ObjectControls.prototype.setScale = function (scale) {
    this.object.scale.set(scale, scale, scale);
  }; // scale object by factor (factor should be greater than zero)


  ObjectControls.prototype.scale = function (factor) {
    if (factor <= 0) {
      return;
    }

    this.setScale(this.object.scale.x * factor);
    this.dispatchEvent({
      type: 'change',
      action: 'zoom',
      factor: factor
    });
  };

  ObjectControls.prototype.update = function () {
    var shift = new THREE.Vector2();
    return function () {
      var curTime = this._clock.getElapsedTime();

      var timeSinceLastUpdate = curTime - this._lastUpdateTime; // update object handler

      if (this._state === STATE.NONE) {
        var timeSinceMove = curTime - this._lastMouseMoveTime;

        if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
          this.dispatchEvent({
            type: 'change',
            action: 'auto'
          });
        }
      } // apply arrow keys


      if (this._isKeysTranslatingObj) {
        var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
        var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);

        if (speedX !== 0.0 || speedY !== 0.0) {
          var delta = timeSinceLastUpdate; // update object translation

          var altObj = this.getAltObj();

          if (altObj.objects.length > 0) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }

            shift.set(delta * speedX, delta * speedY);

            this._altObj.translate(shift);

            this.dispatchEvent({
              type: 'change',
              action: 'translate'
            });
          }
        }
      }

      this._lastUpdateTime = curTime;
    };
  }();

  ObjectControls.prototype.reset = function () {
    this._state = STATE.NONE;
    this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
  }; // listeners


  ObjectControls.prototype.mousedown = function (event) {
    if (this.enabled === false || this._state !== STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (this._state === STATE.NONE) {
      if (event.button === 0) {
        this._affectedObj.stop(); // can edit only one object at a time


        var workWithAltObj = false;

        if (event.altKey) {
          var altObj = this.getAltObj();
          workWithAltObj = altObj.objects.length > 0;

          if (workWithAltObj) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }
          }
        }

        this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
        this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
      } else if (event.button === 2) {
        this._state = STATE.TRANSLATE_PIVOT;
      }
    }

    if (this._state === STATE.ROTATE) {
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }

    if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }
  };

  ObjectControls.prototype.mousemove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
        this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.TRANSLATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translate();
        break;

      case STATE.TRANSLATE_PIVOT:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translatePivotByMouse();
        break;
    }
  };

  ObjectControls.prototype.mousewheel = function (event) {
    if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
      return;
    }

    event.preventDefault();
    var delta = 0;

    if (event.wheelDelta) {
      // WebKit / Opera / Explorer 9
      delta = event.wheelDelta / 40;
    } else if (event.detail) {
      // Firefox
      delta = -event.detail / 3;
    }

    var factor = 1.0 + delta * 0.05;
    factor = Math.max(factor, 0.01);
    this.scale(factor);
  };

  ObjectControls.prototype.mouseup = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    this._state = STATE.NONE;

    if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
      this._affectedObj.stop();
    }
  };

  ObjectControls.prototype.touchstartend = function (event) {
    if (this.enabled === false) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {
      case 1:
        this._state = STATE.ROTATE;
        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);

        this._mousePrevPos.copy(this._mouseCurPos);

        break;

      case 2:
        {
          // prevent inertial rotation
          this._mainObj.stop();

          this._altObj.stop();

          this._state = STATE.SCALE;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
          this._scaleStart = this.object.scale.x;
          break;
        }

      default:
        this._state = STATE.NONE;
    }
  };

  ObjectControls.prototype.touchmove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
        this.rotateByMouse(false);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.SCALE:
        if (settings.now.zooming) {
          // update scale
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
          var newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
          var factor = newScale / this.object.scale.x;
          this.scale(factor);
        }

        break;
    }
  };

  ObjectControls.prototype.keydownup = function (event) {
    if (this.enabled === false || this.hotkeysEnabled === false) {
      return;
    }

    switch (event.keyCode) {
      case VK_LEFT:
      case VK_UP:
      case VK_RIGHT:
      case VK_DOWN:
        this._pressedKeys[event.keyCode] = event.type === 'keydown';
        event.preventDefault();
        event.stopPropagation();
        break;
    }
  };

  ObjectControls.prototype.getKeyBindObject = function () {
    return window.top;
  };

  ObjectControls.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  ObjectControls.prototype.translatePivotByMouse = function () {
    var delta = new THREE.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);
      this.translatePivotInWorld(settings.now.translationSpeed * delta.x, settings.now.translationSpeed * delta.y, 0);
    };
  }(); // Translate in WorldCS, translation is scaled with root scale matrix


  ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.applyMatrix4(this.object.matrixWorld);
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  }; // Translate in ModelCS, x, y, z are Ang


  ObjectControls.prototype.translatePivot = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  }; // Set pivot


  ObjectControls.prototype.setPivot = function (newPivot) {
    this.objectPivot.position.copy(newPivot);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  };

  function Picker(gfxObj, camera, domElement) {
    EventDispatcher.call(this);
    var self = this;
    this.gfxObj = gfxObj;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this._lastMousePos = new THREE.Vector2(0, 0);
    this._mouseTotalDist = 0.0;
    this._lastClickBeginTime = -1000.0;
    this._lastClickPos = new THREE.Vector2(0, 0);
    this._clickBeginTime = 0.0;
    this._clock = new Timer();

    this._clock.start();

    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstart(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchend(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
  }

  Picker.prototype = Object.create(EventDispatcher.prototype);
  Picker.prototype.constructor = Picker;

  Picker.prototype.reset = function () {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
  };

  Picker.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  Picker.prototype.pickObject = function (screenPos) {
    if (!this.gfxObj) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var gfxObj = this.gfxObj;
    var rayCaster = new THREE.Raycaster();
    rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
    rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
    var clipPlane = settings.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
    var fogFarPlane = settings.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
    var point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);

    if (!point) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var picked = {};

    if (point.residue || point.atom) {
      var residue = point.residue || point.atom.residue;

      if (settings.now.pick === 'chain') {
        picked = {
          chain: residue.getChain()
        };
      } else if (settings.now.pick === 'molecule') {
        picked = {
          molecule: residue.getMolecule()
        };
      } else if (point.residue || settings.now.pick === 'residue') {
        picked = {
          residue: residue
        };
      } else if (point.atom) {
        picked = {
          atom: point.atom
        };
      }
    }

    this.picked = picked;
    this.dispatchEvent({
      type: 'newpick',
      obj: picked
    });
  };

  Picker.prototype.getMouseInViewport = function (pageX, pageY) {
    return new THREE.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
  };

  Picker.prototype.mousedown = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
      this._mouseTotalDist = 0.0;
      this._clickBeginTime = this._clock.getElapsedTime();
    }
  };

  Picker.prototype.mousemove = function (event) {
    event.preventDefault();
    event.stopPropagation();
    var pos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist += pos.sub(this._lastMousePos).length();
  };

  Picker.prototype.mouseup = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      if (this._mouseTotalDist < 0.01) {
        var curTime = this._clock.getElapsedTime();

        var curPos = this.getMouseInViewport(event.pageX, event.pageY);
        var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;

        if (timeSinceLastClickBegin < 0.7) {
          var clickDist = new THREE.Vector2().subVectors(curPos, this._lastClickPos);

          if (clickDist.length() < 0.01) {
            // it's a double click
            this.dispatchEvent({
              type: 'dblclick',
              obj: this.picked
            });
            this._lastClickPos = curPos;
            this._lastClickBeginTime = -1000; // this click cannot serve as first click in double-click

            return;
          }
        }

        setTimeout(function () {
          self.pickObject(curPos);
        }, 0);
        this._lastClickPos = curPos;
        this._lastClickBeginTime = this._clickBeginTime;
      }
    }
  };

  Picker.prototype.touchstart = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 1) {
      this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
    }
  };

  Picker.prototype.touchend = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
      var dist = pos.sub(this._lastTouchdownPos).length();

      if (dist < 0.01) {
        setTimeout(function () {
          self.pickObject(self._lastTouchdownPos);
        }, 0);
      }
    }
  };

  Picker.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  var Axes = /*#__PURE__*/function () {
    function Axes(target, targetCamera) {
      classCallCheck(this, Axes);

      this._target = target;
      this._targetCamera = targetCamera;
      this._camera = new THREE.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
      this._object = new THREE.AxesHelper(1);
      this._scene = new THREE.Scene();

      this._scene.add(this._object);

      this._full = new THREE.Vector2();

      this._update();
    }

    createClass(Axes, [{
      key: "_update",
      value: function _update() {
        var fov = this._targetCamera.fov;
        var camera = this._camera;
        camera.aspect = this._targetCamera.aspect;
        camera.setMinimalFov(fov);
        camera.setDistanceToFit(1.0, fov);
        camera.updateProjectionMatrix();

        this._object.quaternion.copy(this._target.quaternion);
      }
    }, {
      key: "render",
      value: function render(renderer) {
        this._update();

        renderer.getSize(this._full);
        var width = this._full.width * 0.25;
        var height = this._full.height * 0.25;
        var autoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setViewport(0.0, 0.0, width, height);
        renderer.clear(false, true, false);
        renderer.render(this._scene, this._camera);
        renderer.setViewport(0, 0, this._full.width, this._full.height);
        renderer.autoClear = autoClear;
      }
    }]);

    return Axes;
  }();

  var cDataOffset = 12;
  var cFirstMask = 0x0FFFFF00;
  var cFirstShift = 8;
  var cSecMask1 = 0x000000FF;
  var cSecShift1 = 12;
  var cSecMask2 = 0xFFF00000;
  var cSecShift2 = 20;
  var cThirdMask = 0x000FFFFF;
  var cStrMask = 0xF0000000;
  var cStrShift = 28;
  var c219 = 1 << 19;
  var c220 = 1 << 20;
  var cHelixIdx = 1;
  var cSheetIdx = 2;
  var secTypes = ['helix', 'strand'];
  var cSecNames = ['fs', 'ps', 'ns', 'us'];

  function _createSecondary(strArray, complex) {
    var residues = complex._residues;
    var nRes = residues.length;
    var resid = new Uint8Array(nRes);
    var atoms = complex._atoms;

    for (var i = 0, n = strArray.length; i < n; ++i) {
      var atom = atoms[i];
      resid[atom.residue._index] = strArray[i];
    }

    var secondary = [];
    var rIdx = 0;

    while (rIdx < nRes) {
      if (resid[rIdx] !== 0) {
        var start = rIdx;
        var val = resid[rIdx];

        while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
          ++rIdx;
        }

        secondary.push({
          start: start,
          end: rIdx,
          type: secTypes[val - 1]
        });
      }

      ++rIdx;
    }

    return secondary;
  }

  function fromUInt20ToInt20(uint20) {
    return uint20 >= c219 ? uint20 - c220 : uint20;
  }

  var FrameInfo = /*#__PURE__*/function () {
    function FrameInfo(complex, payload, callbacks) {
      classCallCheck(this, FrameInfo);

      this._complex = complex;
      this._secondary = null;
      this.isLoading = false;
      this._framesRange = {
        start: 0,
        end: -1
      };
      this.frameIsReady = false;
      this._buffer = null;
      this._frameRequest = null;
      this._callbacks = callbacks;

      if (typeof payload === 'function') {
        this._framesRequestLength = 1;
        this._downloadDataFn = payload;
      } else {
        this.parseBinaryData(payload, true);
      }

      this.reset();
      this.setFrame(0);
    }

    createClass(FrameInfo, [{
      key: "_prepareBuffer",
      value: function _prepareBuffer(framesStart, framesEnd) {
        if (framesStart === undefined || framesStart === null) {
          framesStart = 0;
        }

        if (framesEnd === undefined || framesEnd === null) {
          framesEnd = framesStart + this._framesRequestLength;
        }

        if (this._framesCount !== undefined) {
          framesEnd = Math.min(this._framesCount - 1, framesEnd);
        }

        if (this._downloadDataFn) {
          var self = this;

          var onDone = function onDone(data) {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
              self._callbacks.onLoadStatusChanged();
            }

            self._buffer = {
              data: data,
              state: 'ready',
              start: framesStart,
              end: framesEnd
            };

            if (self._frameRequest !== null) {
              var idx = self._frameRequest;
              self._frameRequest = null;
              self.setFrame(idx);
            }
          };

          var onFail = function onFail() {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onError === 'function') {
              self._callbacks.onError('Streaming failed');
            }
          };

          if (!this._buffer) {
            this._buffer = {};
          }

          this._buffer.state = 'downloading';
          this.isLoading = true;

          if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
            self._callbacks.onLoadStatusChanged();
          }

          this._downloadDataFn({
            start: framesStart,
            end: framesEnd + 1
          }, onDone, onFail);
        }
      }
    }, {
      key: "_parseBuffer",
      value: function _parseBuffer() {
        if (this._buffer && this._buffer.state === 'ready') {
          this._framesRange = {
            start: this._buffer.start,
            end: this._buffer.end
          };
          this.parseBinaryData(this._buffer.data, false);

          var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;

          if (_bufferRequestStart >= this._framesCount) {
            _bufferRequestStart = 0;
          }

          this._buffer = {
            state: 'none'
          };

          this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);

          if (this._frameRequest !== null) {
            var idx = this._frameRequest;
            this._frameRequest = null;
            this.setFrame(idx);
          }
        }
      }
    }, {
      key: "parseBinaryData",
      value: function parseBinaryData(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var offset = 0;
        var atomsCount = dataView.getUint32(offset, true);
        offset += 4;
        var framesCount = dataView.getUint32(offset, true);
        this._framesCount = framesCount;
        this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
        offset += 4;
        this._atomsCount = atomsCount;
        var maxSize = 1024 * 1024; // 1 MB

        this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
        var chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;

        if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
          throw new Error();
        }

        var complex = this._complex;
        var timeStep = dataView.getUint32(offset, true);
        var iName = 0;

        while (timeStep > 1000 && iName < cSecNames.length - 1) {
          timeStep /= 1000;
          ++iName;
        }

        this._timeStep = "".concat(timeStep.toString(), " ").concat(cSecNames[iName]);
        offset += 4;
        var secondary = [];
        var posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
        var coordIdx = 0;
        var secondaryArr = new Int8Array(atomsCount);

        for (var j = 0; j < chunkedFramesCount; ++j) {
          for (var i = 0; i < atomsCount; ++i) {
            var hiWord = dataView.getUint32(offset, true);
            offset += 4;
            var loWord = dataView.getUint32(offset, true);
            offset += 4;
            var str = (loWord & cStrMask) >>> cStrShift;
            var x = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
            var y = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
            var z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
            secondaryArr[i] = 0;

            if (str > 0 && str < 4) {
              secondaryArr[i] = cHelixIdx;
            } else if (str === 4) {
              secondaryArr[i] = cSheetIdx;
            }

            posData[coordIdx++] = x / 100;
            posData[coordIdx++] = y / 100;
            posData[coordIdx++] = z / 100;
          }

          secondary.push(_createSecondary(secondaryArr, complex));
        }

        this._secondaryData = secondary;
        this._data = posData;
      }
    }, {
      key: "nextFrame",
      value: function nextFrame() {
        this.setFrame((this._currFrame + 1) % this._framesCount);
      }
    }, {
      key: "needsColorUpdate",
      value: function needsColorUpdate(colorer) {
        return colorer instanceof SecondaryStructureColorer;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(colorer, atom) {
        return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(colorer, residue) {
        return colorer.getResidueColor(this._residues[residue._index], this._complex);
      }
    }, {
      key: "_updateSecondary",
      value: function _updateSecondary() {
        var i;
        var myResidues = this._residues;
        var n = myResidues.length;

        for (i = 0; i < n; ++i) {
          myResidues[i]._secondary = null;
        }

        var sec = this._secondaryData[this._currFrame - this._framesRange.start];

        for (i = 0, n = sec.length; i < n; ++i) {
          var oldSec = sec[i];
          var start = oldSec.start,
              end = oldSec.end;
          var nSec = {
            _start: myResidues[start],
            _end: myResidues[end],
            type: oldSec.type,
            generic: oldSec.generic
          };

          for (var j = start; j <= end; ++j) {
            myResidues[j]._secondary = nSec;
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var compRes = this._complex._residues;
        var n = compRes.length;
        this._residues = new Array(n);
        var myResidues = this._residues;

        var getSec = function getSec() {
          return this._secondary;
        };

        for (var i = 0; i < n; ++i) {
          myResidues[i] = {
            _type: compRes[i]._type,
            _isValid: compRes[i]._isValid,
            _controlPoint: null,
            _wingVector: null,
            _secondary: null,
            getSecondary: getSec
          };
        }
      }
    }, {
      key: "setFrame",
      value: function setFrame(frameIdx) {
        this.frameIsReady = false;

        if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
          this._currFrame = frameIdx;
          this._cachedResidues = false;

          this._updateSecondary();

          this.frameIsReady = true;
        } else {
          this._frameRequest = frameIdx;

          if (!this._buffer) {
            this._prepareBuffer(frameIdx);
          } else {
            var self = this;

            switch (this._buffer.state) {
              case 'none':
                this._prepareBuffer(frameIdx);

                break;

              case 'ready':
                self._parseBuffer();

                break;
            }
          }
        }
      }
    }, {
      key: "disableEvents",
      value: function disableEvents() {
        this._callbacks = null;
      }
      /**
       * Returns link to atom pos vector, clone it if needed
       */

    }, {
      key: "getAtomPos",
      value: function getAtomPos(atomIdx) {
        var vec = FrameInfo._vec;
        var self = this;
        var data = self._data;
        var idx = (self._atomsCount * (self._currFrame - self._framesRange.start) + atomIdx) * 3;
        vec.set(data[idx], data[idx + 1], data[idx + 2]);
        return vec;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        if (this._cachedResidues) {
          return this._residues;
        }

        this._complex.updateToFrame(this);

        return this._residues;
      }
    }]);

    return FrameInfo;
  }();

  defineProperty(FrameInfo, "_vec", new THREE.Vector3());

  /**
   * Create new scene object.
   *
   * @param {array=} params - Object required params.
   * @param {object=} opts - Options to override defaults with.
   *
   *   These options are copied locally and not kept by reference, so the created instance will not reflect further
   *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
   *
   * @exports SceneObject
   * @this SceneObject
   * @abstract
   * @constructor
   * @classdesc Basic class for all scene objects that are not reps.
   */

  var SceneObject = /*#__PURE__*/function () {
    function SceneObject(params, opts) {
      classCallCheck(this, SceneObject);

      if (this.constructor === SceneObject) {
        throw new Error('Can not instantiate abstract class!');
      }
      /**
       * Object's options inherited (prototyped) from defaults.
       * @type {object}
       */


      this.params = params;
      this.opts = ___default['default'].merge(utils.deriveDeep(settings.now.objects[this.type], true), opts);
      this.needsRebuild = false;
      this._mesh = null;
      this.id = null;
    }
    /**
     * Get object identification, probably with options.
     *  @returns {Object} field type contains type information, params - object's formal parameters,
     * opts - changed options
     * Options are returned if they were changed during or after object creation.
     */


    createClass(SceneObject, [{
      key: "identify",
      value: function identify() {
        var result = {
          type: this.type,
          params: this.params
        };
        var diff = utils.objectsDiff(this.opts, settings.now.modes[this.id]);

        if (!___default['default'].isEmpty(diff)) {
          result.opts = diff;
        }

        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        var paramsStr = "o=".concat(this.type, ",").concat(this.params.join(','));
        var optsStr = utils.compareOptionsWithDefaults(this.opts, settings.defaults.objects[this.type]);
        return paramsStr + optsStr;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this._mesh;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._mesh) {
          gfxutils.destroyObject(this._mesh);
        }
      }
    }]);

    return SceneObject;
  }();
  /**
   * Scene object identifier.
   * @type {string}
   */


  SceneObject.prototype.type = '__';

  function _createSuper$1X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Y(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var LinesObj = /*#__PURE__*/function (_SceneObject) {
    inherits(LinesObj, _SceneObject);

    var _super = _createSuper$1X(LinesObj);

    function LinesObj(params, opts) {
      var _this;

      classCallCheck(this, LinesObj);

      _this = _super.call(this, params, opts);

      if (params.length < 2) {
        throw new Error('Wrong number of argumets on line object creation!');
      }

      var _params = slicedToArray(params, 2);

      _this._id1 = _params[0];
      _this._id2 = _params[1];
      return _this;
    }

    createClass(LinesObj, [{
      key: "_getAtomFromName",
      value: function _getAtomFromName(complex, atomId) {
        var err = ' - Wrong atom format it must be \'#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME\' (e.g. \'A.38.CO1\')';
        var atom1 = complex.getAtomByFullname(atomId);

        if (!atom1) {
          throw new Error(atomId + err);
        }

        return atom1;
      }
    }, {
      key: "build",
      value: function build(complex) {
        var geom = new THREE.BufferGeometry();
        this._atom1 = this._getAtomFromName(complex, this._id1);
        this._atom2 = this._getAtomFromName(complex, this._id2);
        var p1 = this._atom1.position;
        var p2 = this._atom2.position;
        var vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeBoundingBox();
        this._line = new meshes.Line(geom, new UberMaterial({
          lights: false,
          overrideColor: true,
          dashedLine: true,
          fogTransparent: settings.now.bg.transparent
        }));

        this._line.computeLineDistances();

        this._line.material.setUberOptions({
          fixedColor: new THREE.Color(this.opts.color),
          dashedLineSize: this.opts.dashSize,
          dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
        });

        this._line.material.updateUniforms();

        this._line.raycast = function (_raycaster, _intersects) {};

        this._mesh = this._line;
        var transforms = complex.getTransforms();

        if (transforms.length > 0) {
          this._mesh = new THREE.Group();

          this._mesh.add(this._line);

          meshutils.applyTransformsToMeshes(this._mesh, transforms);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        if (!this._atom1 || !this._atom2 || !this._line) {
          return;
        }

        var geo = this._line.geometry;
        geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
        geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));

        this._line.computeLineDistances();

        geo.computeBoundingSphere();
        geo.verticesNeedUpdate = true;
      }
    }]);

    return LinesObj;
  }(SceneObject);

  LinesObj.prototype.constructor = LinesObj;
  LinesObj.prototype.type = 'line';

  var fragmentShader$1 = "precision highp float;\n\nuniform sampler2D srcTex;\nuniform vec2 srcTexSize;\nuniform vec2 thickness;\nvarying vec2 vUv;\n\n#ifdef DEPTH_OUTLINE\n  uniform sampler2D srcDepthTex; //depthTexture\n  uniform vec3 color;\n  uniform float threshold;\n#endif\n\nvoid main() {\n\n  vec2 pixelSize = thickness / srcTexSize;\n\n  #ifdef DEPTH_OUTLINE\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\n\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\n\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\n\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\n\n  #else\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\n\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\n\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\n    gl_FragColor = grad;\n  #endif\n}\n";

  function _createSuper$1Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Z(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var OutlineMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(OutlineMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1Y(OutlineMaterial);

    function OutlineMaterial(params) {
      var _this;

      classCallCheck(this, OutlineMaterial);

      // add depth outline
      _this = _super.call(this, params);
      var settings = {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcDepthTex: {
            type: 't',
            value: null
          },
          srcTexSize: {
            type: 'v2',
            value: new THREE.Vector2(512, 512)
          },
          color: {
            type: 'v3',
            value: null
          },
          threshold: {
            type: 'f',
            value: null
          },
          opacity: {
            type: 'f',
            value: 1.0
          },
          thickness: {
            type: 'v2',
            value: new THREE.Vector2(1, 1)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$1,
        transparent: true,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    createClass(OutlineMaterial, [{
      key: "copy",
      value: function copy(source) {
        get(getPrototypeOf(OutlineMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(OutlineMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.depth) {
          defines.DEPTH_OUTLINE = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return OutlineMaterial;
  }(THREE.RawShaderMaterial);

  OutlineMaterial.prototype.depth = false;

  var fragmentShader$2 = "precision highp float;\n\n// edge end finding algorithm parameters\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n// constants\nfloat fxaaQualityEdgeThreshold = 0.125;\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\nfloat fxaaQualitySubpix = 0.7; //0.65;\n// global params\nuniform sampler2D srcTex;\nuniform vec2 srcTexelSize;\nuniform vec3 bgColor;\n// from vs\nvarying vec2 vUv;\n//=====================================================================//\n// calc luminance from rgb\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\n                                                                           // for non-real scene rendering\n// texture sampling by pixel position(coords) and offset(in pixels)\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\n  #ifdef BG_TRANSPARENT\n    vec4 color = texture2D( tex, pos + off * res );\n    return mix(color.rgb, bgColor, 1.0 - color.a);\n  #else\n    return texture2D( tex, pos + off * res ).xyz;\n  #endif\n}\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\n  #ifdef BG_TRANSPARENT\n    vec4 color = texture2D( tex, pos );\n    return mix(color.rgb, bgColor, 1.0 - color.a);\n  #else\n    return texture2D( tex, pos).xyz;\n  #endif\n}\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\n  return texture2D( tex, pos);\n}\n\n//=====================================================================//\nvoid main() {\n  // renaming\n  vec2 posM = vUv;\n  // get luminance for neighbours\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\n  // find max and min luminance\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\n  // calc maximum non-edge range\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n  float range = rangeMax - rangeMin;\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n  // exit when luma contrast is small (is not edge)\n  if(range < rangeMaxClamped){\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\n    return;\n  }\n  float subpixRcpRange = 1.0/range;\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\n  // visibly, thus we decided to leave calculation here for better readability.\n  // calc other neighbours luminance\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\n/*--------------span calculation and subpix amount calulation-----------------*/\n  float lumaNS = lumaN + lumaS;\n  float lumaWE = lumaW + lumaE;\n  float subpixNSWE = lumaNS + lumaWE;\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n  float lumaNESE = lumaNE + lumaSE;\n  float lumaNWNE = lumaNW + lumaNE;\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n  float lumaNWSW = lumaNW + lumaSW;\n  float lumaSWSE = lumaSW + lumaSE;\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n  float edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------subpix amount calulation------------------------------*/\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\n  float lengthSign = srcTexelSize.x;\n  bool horzSpan = edgeHorz >= edgeVert;\n   // debug  code edge span visualization\n/*'  if (horzSpan)\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n  else\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  return;*/\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n  if(!horzSpan) lumaN = lumaW;\n  if(!horzSpan) lumaS = lumaE;\n  if(horzSpan) lengthSign = srcTexelSize.y;\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n  float gradientN = lumaN - lumaM;\n  float gradientS = lumaS - lumaM;\n  float lumaNN = lumaN + lumaM;\n  float lumaSS = lumaS + lumaM;\n  bool pairN = abs(gradientN) >= abs(gradientS);\n  float gradient = max(abs(gradientN), abs(gradientS));\n  if(pairN) lengthSign = -lengthSign;\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n/*--------------------------------------------------------------------------*/\n  vec2 posB;\n  posB = posM;\n  vec2 offNP;\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\n  if(!horzSpan) posB.x += lengthSign * 0.5;\n  if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n  vec2 posN;\n  posN = posB - offNP * FXAA_QUALITY_P0;\n  vec2 posP;\n  posP = posB + offNP * FXAA_QUALITY_P0;\n  float subpixD = ((-2.0)*subpixC) + 3.0;\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\n  float subpixE = subpixC * subpixC;\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\n/*--------------------------------------------------------------------------*/\n  if(!pairN) lumaNN = lumaSS;\n  float gradientScaled = gradient * 1.0/4.0;\n  float lumaMM = lumaM - lumaNN * 0.5;\n  float subpixF = subpixD * subpixE;\n  bool lumaMLTZero = lumaMM < 0.0;\n/*---------------------looped edge-end search-------------------------------*/\n  lumaEndN -= lumaNN * 0.5;\n  lumaEndP -= lumaNN * 0.5;\n  bool doneN = abs(lumaEndN) >= gradientScaled;\n  bool doneP = abs(lumaEndP) >= gradientScaled;\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\n  bool doneNP = (!doneN) || (!doneP);\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n  if(doneNP) {\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n    doneN = abs(lumaEndN) >= gradientScaled;\n    doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\n    doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 3)\n      if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 4)\n          if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 5)\n               if(doneNP) {\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                 doneN = abs(lumaEndN) >= gradientScaled;\n                 doneP = abs(lumaEndP) >= gradientScaled;\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\n                 doneNP = (!doneN) || (!doneP);\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                 #if (FXAA_QUALITY_PS > 6)\n                   if(doneNP) {\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                     doneN = abs(lumaEndN) >= gradientScaled;\n                     doneP = abs(lumaEndP) >= gradientScaled;\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\n                     doneNP = (!doneN) || (!doneP);\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                     #if (FXAA_QUALITY_PS > 7)\n                       if(doneNP) {\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                         doneN = abs(lumaEndN) >= gradientScaled;\n                         doneP = abs(lumaEndP) >= gradientScaled;\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\n                         doneNP = (!doneN) || (!doneP);\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n                       }\n                     #endif\n                   }\n                 #endif\n               }\n             #endif\n           }\n         #endif\n      }\n    #endif\n  }\n/*----------------calculate subpix offset due to edge ends-------------------*/\n  float dstN = posM.x - posN.x;\n  float dstP = posP.x - posM.x;\n  if(!horzSpan) dstN = posM.y - posN.y;\n  if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n  float spanLength = (dstP + dstN);\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n  float spanLengthRcp = 1.0 / spanLength;\n/*--------------------------------------------------------------------------*/\n  bool directionN = dstN < dstP;\n  float dst = min(dstN, dstP);\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\n  float subpixG = subpixF * subpixF;\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n  float subpixH = subpixG * fxaaQualitySubpix;\n/*-----------------calc texture offest using subpix-------------------------*/\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\n  float offset = pixelOffsetSubpix * lengthSign;\n  #ifdef BG_TRANSPARENT\n    // get original texel\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\n    // calc step to blended texel\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\n    // get neighboring texel\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\n    //  calc blend factor from offset\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\n    f = abs(f);\n    // calc alpha (special formula to emulate blending with bg)\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\n    // calc color (special formula to emulate blending with bg)\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\n  #else\n    if(!horzSpan) {\n       posM.x += offset;\n    } else {\n       posM.y += offset;\n    }\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\n  #endif\n  return;\n}\n";

  function _createSuper$1Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1_(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var FXAAMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(FXAAMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1Z(FXAAMaterial);

    function FXAAMaterial(params) {
      var _this;

      classCallCheck(this, FXAAMaterial);

      _this = _super.call(this, params); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          bgColor: {
            type: 'c',
            value: new THREE.Color(0xffffff)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$2,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    createClass(FXAAMaterial, [{
      key: "copy",
      value: function copy(source) {
        get(getPrototypeOf(FXAAMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(FXAAMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.bgTransparent) {
          defines.BG_TRANSPARENT = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return FXAAMaterial;
  }(THREE.RawShaderMaterial);

  FXAAMaterial.prototype.bgTransparent = false;

  var fragmentShader$3 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 32\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\nuniform sampler2D noiseTexture;\nuniform vec2      noiseTexelSize;\nuniform sampler2D diffuseTexture;\nuniform sampler2D depthTexture;\nuniform sampler2D normalTexture;\nuniform vec2      srcTexelSize;\nuniform vec2      camNearFar;\nuniform mat4      projMatrix;\n\nuniform float aspectRatio;\nuniform float tanHalfFOV;\n\nuniform float kernelRadius;\nuniform float depthThreshold;\nuniform float factor;\n\nvarying vec2 vUv;\n\nfloat CalcViewZ(vec2 screenPos)\n{\n  float depth = texture2D(depthTexture, screenPos).x;\n  // [0, 1]->[-1, 1]\n  float clipedZ = 2.0 * depth - 1.0;\n  // see THREE.js camera.makeFrustum for projection details\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\n}\n\nvec3 ViewPosFromDepth(vec2 screenPos)\n{\n  vec3 viewPos;\n  viewPos.z = CalcViewZ(screenPos);\n  //[0, 1]->[-1, 1]\n  vec2 projPos = 2.0 * screenPos - 1.0;\n  // reconstruct viewposition in right-handed sc with z to viewer\n  viewPos.xy = vec2(\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\n                   );\n  return viewPos;\n}\n\nvoid main() {\n  vec3 viewPos = ViewPosFromDepth(vUv);\n  // remap coordinates to prevent noise exture rescale\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\n  vec4 normalData = texture2D(normalTexture, vUv);\n  // return for background fragments (their normals are zero vectors)\n  if (length(normalData.rgb) < EPSILON) {\n    // 0.0 in alpha component means that it is background fragment\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n  }\n  //[0, 1] -> [-1, 1]\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\n  // normalData.a store 1.0 if normal was build for frontfaced surface\n  // and 0.0 in other case\n  if (normalData.a < EPSILON) {\n    normal *= -1.0;\n  }\n  // get random vector for sampling sphere rotation\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\n  randN = normalize(randN);\n  // build TBN (randomly rotated around normal)\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\n  vec3 bitangent = cross(tangent, normal);\n  mat3 TBN = mat3(tangent, bitangent, normal);\n  // calc AO value\n  float AO = 0.0;\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\n    // rotate sampling kernel around normal\n    vec3 reflectedSample = TBN * samplesKernel[i];\n    // get sample\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\n\n    // project sample to screen to get sample's screen pos\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\n    // eye -> clip\n    SampleScrPos = projMatrix * SampleScrPos;\n    // normalize\n    SampleScrPos.xy /= SampleScrPos.w;\n    //[-1, 1] -> [0, 1]\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\n\n    // get view z for sample projected to the objct surface\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\n    // calc occlusion made by object surface at the sample\n    AO += step(samplePos.z, sampleDepth);\n  }\n  // calc result AO-map color\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\n  // write value to AO-map\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\n}\n";

  function _createSuper$1_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1$(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _samplesKernel$1 = [// hemisphere samples adopted to sphere
  new THREE.Vector3(0.295184, 0.077723, 0.068429), new THREE.Vector3(-0.271976, -0.365221, 0.838363), new THREE.Vector3(0.547713, 0.467576, 0.488515), new THREE.Vector3(0.662808, -0.031733, 0.584758), new THREE.Vector3(-0.025717, 0.218955, 0.657094), new THREE.Vector3(-0.310153, -0.365223, 0.370701), new THREE.Vector3(-0.101407, -0.006313, 0.747665), new THREE.Vector3(-0.769138, 0.360399, 0.086847), new THREE.Vector3(-0.271988, -0.275140, 0.905353), new THREE.Vector3(0.096740, -0.566901, 0.700151), new THREE.Vector3(0.562872, -0.735136, 0.094647), new THREE.Vector3(0.379877, 0.359278, 0.190061), new THREE.Vector3(0.519064, -0.023055, 0.405068), new THREE.Vector3(-0.301036, 0.114696, 0.088885), new THREE.Vector3(-0.282922, 0.598305, 0.487214), new THREE.Vector3(-0.181859, 0.251670, 0.679702), new THREE.Vector3(-0.191463, -0.635818, 0.512919), new THREE.Vector3(-0.293655, 0.427423, 0.078921), new THREE.Vector3(-0.267983, 0.680534, 0.132880), new THREE.Vector3(0.139611, 0.319637, 0.477439), new THREE.Vector3(-0.352086, 0.311040, 0.653913), new THREE.Vector3(0.321032, 0.805279, 0.487345), new THREE.Vector3(0.073516, 0.820734, 0.414183), new THREE.Vector3(-0.155324, 0.589983, 0.411460), new THREE.Vector3(0.335976, 0.170782, 0.527627), new THREE.Vector3(0.463460, -0.355658, 0.167689), new THREE.Vector3(0.222654, 0.596550, 0.769406), new THREE.Vector3(0.922138, -0.042070, 0.147555), new THREE.Vector3(-0.727050, -0.329192, 0.369826), new THREE.Vector3(-0.090731, 0.533820, 0.463767), new THREE.Vector3(-0.323457, -0.876559, 0.238524), new THREE.Vector3(-0.663277, -0.372384, 0.342856)];

  var AOMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1_(AOMaterial);

    function AOMaterial() {
      var _this;

      classCallCheck(this, AOMaterial);

      _this = _super.call(this); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          noiseTexture: {
            type: 't',
            value: noise.noiseTexture
          },
          noiseTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight)
          },
          diffuseTexture: {
            type: 't',
            value: null
          },
          normalTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          camNearFar: {
            type: 'v2',
            value: new THREE.Vector2(1.0, 10.0)
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          samplesKernel: {
            type: 'v3v',
            value: _samplesKernel$1
          },
          kernelRadius: {
            type: 'f',
            value: 1.0
          },
          depthThreshold: {
            type: 'f',
            value: 1.0
          },
          factor: {
            type: 'f',
            value: 1.0
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$3,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOMaterial;
  }(THREE.RawShaderMaterial);

  var fragmentShader$4 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 5\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\nuniform sampler2D aoMap;\nuniform sampler2D depthTexture;\nuniform vec2      srcTexelSize;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float x = vUv.x;\n  float y = vUv.y;\n  vec4 res = vec4(0.0);\n  res.a = texture2D(aoMap, vec2(x, y )).a;\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\n  if (res.a < EPSILON) {\n    gl_FragColor = res;\n    return;\n  }\n\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\n  float weightSum = 0.0;\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\n      continue;\n    }\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\n    float depth = texture2D(depthTexture, samplePos).x;\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\n    weightSum += weight;\n  }\n  res.rgb = res.rgb / weightSum;\n  gl_FragColor = res;\n}\n";

  function _createSuper$1$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$20(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$20() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOHorBlurMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOHorBlurMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1$(AOHorBlurMaterial);

    function AOHorBlurMaterial() {
      var _this;

      classCallCheck(this, AOHorBlurMaterial);

      _this = _super.call(this); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$4,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOHorBlurMaterial;
  }(THREE.RawShaderMaterial);

  var fragmentShader$5 = "precision highp float;\n#define EPSILON 0.0000001\n\n#define MAX_SAMPLES_COUNT 5\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\nuniform sampler2D diffuseTexture;\nuniform sampler2D aoMap;\nuniform sampler2D depthTexture;\nuniform vec2      srcTexelSize;\n\nuniform mat4  projMatrix;\nuniform float aspectRatio;\nuniform float tanHalfFOV;\n\n#ifdef USE_FOG\n  uniform vec2 fogNearFar;\n  uniform vec4 fogColor;\n#endif\nvarying vec2 vUv;\n\nfloat CalcViewZ(vec2 screenPos)\n{\n  float depth = texture2D(depthTexture, screenPos).x;\n  // [0, 1]->[-1, 1]\n  float clipedZ = 2.0 * depth - 1.0;\n  // see THREE.js camera.makeFrustum for projection details\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\n}\n\nvec3 ViewPosFromDepth(vec2 screenPos)\n{\n  vec3 viewPos;\n  viewPos.z = CalcViewZ(screenPos);\n  //[0, 1]->[-1, 1]\n  vec2 projPos = 2.0 * screenPos - 1.0;\n  // reconstruct viewposition in right-handed sc with z to viewer\n  viewPos.xy = vec2(\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\n  projPos.y * tanHalfFOV * abs(viewPos.z)\n  );\n  return viewPos;\n}\n\nvoid main() {\n  vec3 viewPos = ViewPosFromDepth(vUv);\n  float x = vUv.x;\n  float y = vUv.y;\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\n  vec4 res = vec4(0.0);\n  res.a = texture2D(aoMap, vec2(x, y )).a;\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\n  if (res.a < EPSILON) {\n    gl_FragColor = color;\n    return;\n  }\n\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\n  float weightSum = 0.0;\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\n      continue;\n    }\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\n    float depth = texture2D(depthTexture, samplePos).x;\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\n    weightSum += weight;\n  }\n  res.rgb /= weightSum;\n\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\n    // Add fog to the result value\n    // Proper way to get an image with fog and ao requires formula:\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\n    // We have:  AO, fogFactor, fogColor,\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\n    //                                                                where molecule has been already drawn with fog)\n    // Transform:\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\n  #else\n    gl_FragColor.rgb = color.rgb * res.rgb;\n  #endif\n  gl_FragColor.a = color.a;\n}\n";

  function _createSuper$20(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$21(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$21() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets$1 = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOVertBlurWithBlendMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AOVertBlurWithBlendMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$20(AOVertBlurWithBlendMaterial);

    function AOVertBlurWithBlendMaterial(params) {
      var _this;

      classCallCheck(this, AOVertBlurWithBlendMaterial);

      _this = _super.call(this, params); // set default values

      _this.setValues.call(assertThisInitialized(_this), {
        uniforms: {
          diffuseTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets$1
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          fogNearFar: {
            type: 'v2',
            value: new THREE.Vector2(100.0, 100.0)
          },
          fogColor: {
            type: 'v4',
            value: new THREE.Vector4(0.0, 0.5, 0.0, 1.0)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$5,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    createClass(AOVertBlurWithBlendMaterial, [{
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        } // set direct values


        get(getPrototypeOf(AOVertBlurWithBlendMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.useFog) {
          defines.USE_FOG = 1;
        }

        if (this.fogTransparent) {
          defines.FOG_TRANSPARENT = 1;
        } // set dependent values


        this.defines = defines;
      }
    }]);

    return AOVertBlurWithBlendMaterial;
  }(THREE.RawShaderMaterial);

  AOVertBlurWithBlendMaterial.prototype.useFog = true;
  AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;

  var fragmentShader$6 = "precision highp float;\n\nuniform sampler2D srcL;\nuniform sampler2D srcR;\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 l = texture2D(srcL, vUv);\n  vec4 r = texture2D(srcR, vUv);\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\n}\n";

  function _createSuper$21(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$22(); return function _createSuperInternal() { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$22() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AnaglyphMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    inherits(AnaglyphMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$21(AnaglyphMaterial);

    function AnaglyphMaterial() {
      var _this;

      classCallCheck(this, AnaglyphMaterial);

      _this = _super.call(this);
      var settings = {
        uniforms: {
          srcL: {
            type: 't',
            value: null
          },
          srcR: {
            type: 't',
            value: null
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$6,
        transparent: false,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    return AnaglyphMaterial;
  }(THREE.RawShaderMaterial);

  var View = /*#__PURE__*/function () {
    function View() {
      classCallCheck(this, View);

      this.position = new THREE.Vector3(0, 0, 0);
      this.scale = 1;
      this.orientation = new THREE.Quaternion(0, 0, 0, 1);
    }

    createClass(View, [{
      key: "set",
      value: function set(position, scale, orientation) {
        this.position = position;
        this.scale = scale;
        this.orientation = orientation;
      }
    }]);

    return View;
  }();

  var _transitionTime = 1.5; // in seconds

  var ViewInterpolator = /*#__PURE__*/function () {
    function ViewInterpolator() {
      classCallCheck(this, ViewInterpolator);
    }

    createClass(ViewInterpolator, [{
      key: "setup",
      value: function setup(startView, endView) {
        this._startTime = undefined;
        this._endTime = undefined;
        this._isPaused = false;
        this._srcView = startView;
        this._dstView = endView;
        this._isMoving = false;
      }
    }, {
      key: "isMoving",
      value: function isMoving() {
        return this._isMoving;
      }
    }, {
      key: "wasStarted",
      value: function wasStarted() {
        return typeof this._startTime !== 'undefined' && typeof this._endTime !== 'undefined';
      }
    }, {
      key: "start",
      value: function start() {
        this._startTime = Date.now();
        var transTime = settings.now.interpolateViews ? _transitionTime * 1000 : 0;
        this._endTime = this._startTime + transTime;
        this._isMoving = true;
      }
    }, {
      key: "getCurrentView",
      value: function getCurrentView() {
        if (typeof this._srcView === 'undefined' || typeof this._dstView === 'undefined' || !this._isMoving || !this.wasStarted()) {
          return {
            success: false
          };
        }

        var view = this.createView();
        var time = Date.now();

        if (time > this._endTime) {
          view = this._dstView;
          this.reset();
          return {
            success: true,
            view: view
          };
        }

        var factor = (time - this._startTime) / (this._endTime - this._startTime);
        view.position.copy(this._srcView.position);
        view.position.lerp(this._dstView.position, factor);
        view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
        view.orientation.copy(this._srcView.orientation);
        view.orientation.slerp(this._dstView.orientation, factor);
        return {
          success: true,
          view: view
        };
      }
    }, {
      key: "reset",
      value: function reset() {
        this._startTime = this._endTime = 0;
        this._isMoving = false;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (!this._isPaused) {
          this.setup(this.getCurrentView().view, this._dstView);
          this._isPaused = true;
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this._isPaused = false;
      }
    }, {
      key: "createView",
      value: function createView() {
        return new View();
      }
    }]);

    return ViewInterpolator;
  }();

  var MAX_COOKIE_LEN = 4000;
  var COUNT_SUFFIX = 'Cnt';

  function _chunkString(string, chunkLen) {
    var l = string.length;
    var chunks = [];

    for (var c = 0, lc = 0; lc < l; c++, lc += chunkLen) {
      chunks[c] = string.slice(lc, lc + chunkLen);
    }

    return chunks;
  }
  /**
   * Create new context dependent Cookie holder object.
   * @param context
   * @param {Object} opts - options
   * @param {string} opts.path - cookie path
   * @constructor
   */


  function Cookies(context, opts) {
    this.context = context;
    this._opts = ___default['default'].merge({
      path: '/'
    }, opts);
  }

  makeContextDependent(Cookies.prototype);
  /**
   * Remove cookie by the name.
   * @param key
   */

  Cookies.prototype.removeCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      this._removeSimpleCookie(key);

      return;
    }

    this._removeSimpleCookie(cntKey);

    cntVal = parseInt(cntVal, 10);

    for (var i = 0; i < cntVal; ++i) {
      this._removeSimpleCookie(key + i);
    }
  };
  /**
   * Set new cookie value. Automatically splits
   * values that are too large into multiple cookies.
   * @param key
   * @param value
   */


  Cookies.prototype.setCookie = function (key, value) {
    this.removeCookie(key);
    value = encodeURIComponent(value);

    var values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);

    var cntVal = values.length;

    if (cntVal === 1) {
      this._setSimpleCookie(key, value);

      return;
    }

    var cntKey = this._toCount(key);

    this._setSimpleCookie(cntKey, cntVal.toString());

    for (var i = 0; i < cntVal; ++i) {
      this._setSimpleCookie(key + i, values[i]);
    }
  };
  /**
   * Obtain the value of a compound cookie.
   * @param key
   */


  Cookies.prototype.getCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      return this._getSimpleCookie(key);
    }

    cntVal = parseInt(cntVal, 10);
    var value = [];

    for (var i = 0; i < cntVal; ++i) {
      value[i] = this._getSimpleCookie(key + i);
    }

    return value.join('');
  };

  Cookies.prototype._toCount = function (key) {
    return key + COUNT_SUFFIX;
  };

  Cookies.prototype._removeSimpleCookie = function (key) {
    document.cookie = "".concat(key, "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;");
  };

  Cookies.prototype._getExpirationDate = function () {
    var today = new Date();
    var EXP_PERIOD_YEARS = 10;
    today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
    return today;
  };

  Cookies.prototype._setSimpleCookie = function (key, value) {
    document.cookie = "".concat(key, "=").concat(value, ";expires=").concat(this._getExpirationDate().toUTCString(), ";path=").concat(this._opts.path);
  };

  Cookies.prototype._getSimpleCookie = function (key) {
    var matches = document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
    return matches ? decodeURIComponent(matches[1]) : '';
  };

  Cookies.prototype._exists = function (key) {
    return document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
  };

  /*
   * Toggling WebVR is done through button.click because of limitations on calling requestPresent in webVR:
   * VRDisplay::requestPresent should be called from user gesture:
   * https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestPresent
   */
  function createWebVRButton (webVRPoC) {
    function showEnterVR(button) {
      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'ENTER VR';
      var currentSession = null;

      function onSessionEnded()
      /* event */
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'ENTER VR';
        currentSession = null;
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        webVRPoC._gfx.renderer.xr.setReferenceSpaceType('local');

        webVRPoC._gfx.renderer.xr.setSession(session);

        button.textContent = 'EXIT VR';
        currentSession = session;
      }

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          // WebXR's requestReferenceSpace only works if the corresponding feature
          // was requested at session creation time. For simplicity, just ask for
          // the interesting ones as optional features, but be aware that the
          // requestReferenceSpace call will fail if it turns out to be unavailable.
          // ('local' is always available for immersive sessions and doesn't need to
          // be requested separately.)
          var sessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor']
          };
          navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
          webVRPoC.moveSceneBehindHeadset();
        } else {
          currentSession.end();
        }
      };
    }

    function showWebXRNotFound(button) {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.textContent = 'VR NOT FOUND';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'transparent';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      var button = document.createElement('button');
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
        return supported ? showEnterVR(button) : showWebXRNotFound(button);
      });
      return button;
    }

    var message = document.createElement('a');
    message.href = 'https://webvr.info';
    message.innerHTML = 'WEBXR NOT SUPPORTED';
    message.style.left = 'calc(50% - 90px)';
    message.style.width = '180px';
    message.style.textDecoration = 'none';
    stylizeElement(message);
    return message;
  }

  var WebVRPoC = /*#__PURE__*/function () {
    function WebVRPoC(onToggle) {
      classCallCheck(this, WebVRPoC);

      this._mainCamera = new THREE.PerspectiveCamera();
      this._button = null;
      this._onToggle = onToggle;
      this._molContainer = new gfxutils.RCGroup();
      this._user = new gfxutils.RCGroup();
      this._scalingPivot = new THREE.Object3D();

      this._user.add(this._scalingPivot);

      this._controller1 = null;
      this._controller2 = null;
      this._pressedGripsCounter = 0;
      this._distance = 0;
      this._gfx = null;
    }

    createClass(WebVRPoC, [{
      key: "startScalingByControllers",
      value: function startScalingByControllers() {
        // reset scale
        this._distance = this._controller1.position.distanceTo(this._controller2.position);
        gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);

        this._scalingPivot.scale.set(1, 1, 1);

        this._scalingPivot.updateMatrix();

        this._scalingPivot.updateMatrixWorld(); // link molecule to pivot


        this._scalingPivot.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "stopScalingByControllers",
      value: function stopScalingByControllers() {
        this._gfx.scene.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "handleGripsDown",
      value: function handleGripsDown(event) {
        this._pressedGripsCounter++;

        if (this._pressedGripsCounter === 2) {
          this.startScalingByControllers();
        } else if (this._pressedGripsCounter === 1) {
          event.target.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "handleGripsUp",
      value: function handleGripsUp(event) {
        this._pressedGripsCounter--;

        if (this._pressedGripsCounter === 1) {
          this.stopScalingByControllers(); // reattach molecule to other controller

          var anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
          anotherController.addSavingWorldTransform(this._molContainer);
        } else if (this._pressedGripsCounter === 0) {
          this._gfx.scene.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "enable",
      value: function enable(gfx) {
        if (!gfx) {
          logger.warn('WebVR couldn\'t be enabled, because gfx is not defined');
          return;
        }

        this._gfx = gfx;
        var renderer = gfx.renderer,
            camera = gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        }

        if (!camera) {
          throw new Error('No camera is available to toggle WebVR');
        } // enable xr in renderer


        renderer.xr.enabled = true; // add button for turning vr mode

        if (!this._button) {
          this._button = createWebVRButton(this);
          document.body.appendChild(this._button);
        } else {
          this._button.style.display = 'block';
        } // store fog setting


        this._mainFog = settings.now.fog;
        settings.set('fog', false);

        this._plugVRNodesIntoScene(gfx, renderer);

        this._setControllersListeners(); // make some Miew job


        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "_plugVRNodesIntoScene",
      value: function _plugVRNodesIntoScene(gfx, renderer) {
        // store common scene camera
        this._mainCamera.copy(gfx.camera); // add hierarchical structure for webVR into scene


        gfx.scene.add(this._user); // turn on webvr transformation

        gfx.scene.add(this._molContainer);

        this._molContainer.add(gfx.root);

        this._controller1 = renderer.xr.getController(0);
        this._controller2 = renderer.xr.getController(1);

        var mesh = this._createControllerMesh();

        this._controller1.add(mesh);

        this._controller2.add(mesh.clone());

        this._user.add(this._controller1);

        this._user.add(this._controller2);
      }
    }, {
      key: "_setControllersListeners",
      value: function _setControllersListeners() {
        var _this = this;

        this._controller1.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller1.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });
      }
    }, {
      key: "disable",
      value: function disable() {
        if (!this._gfx) {
          return;
        }

        var _this$_gfx = this._gfx,
            renderer = _this$_gfx.renderer,
            camera = _this$_gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        } // nullify webxr callback for animation frame


        renderer.setAnimationLoop(null);
        var session = renderer.xr.getSession();

        if (session) {
          session.end();
        }

        renderer.xr.enabled = false; // remove button of VR entering

        if (this._button) {
          this._button.style.display = 'none';
        } // restore fog param


        settings.set('fog', this._mainFog);

        this._unplugVRNodesFromScene(camera); // make some Miew job


        if (this._onToggle) {
          this._onToggle(false);
        }
      }
    }, {
      key: "_unplugVRNodesFromScene",
      value: function _unplugVRNodesFromScene(camera) {
        // restore common camera
        if (this._mainCamera && camera) {
          camera.copy(this._mainCamera);
        } // turn off webvr transformation


        var root = this._molContainer.children[0];

        if (root) {
          this._gfx.scene.add(root);
        }

        this._molContainer.parent.remove(this._molContainer);

        if (this._user) {
          this._gfx.scene.remove(this._user);
        } // free scene nodes


        this._molContainer = null;
        this._user = null;
        this._scalingPivot = null;
        this._user = null;
        this._controller1 = null;
        this._controller2 = null;
      }
    }, {
      key: "_createControllerMesh",
      value: function _createControllerMesh() {
        // visualize controllers with cylinders
        var geometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3);
        var material = new UberMaterial({
          lights: false,
          overrideColor: true
        });
        material.setUberOptions({
          fixedColor: new THREE.Color(0x4444ff)
        });
        material.updateUniforms();
        var cylinder = new THREE.Mesh(geometry, material);
        cylinder.rotateX(-Math.PI / 2);
        return cylinder;
      }
    }, {
      key: "updateMoleculeScale",
      value: function updateMoleculeScale() {
        if (!this._controller1 || !this._controller2) {
          return;
        }

        var self = this; // update molecule scaling by controllers

        if (self._pressedGripsCounter === 2) {
          // recalc scaling pivot
          gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position); // recalc scaler

          var dist = self._controller1.position.distanceTo(self._controller2.position);

          var scaler = dist / self._distance;

          self._scalingPivot.scale.multiplyScalar(scaler); // save cur distance for next frame


          self._distance = dist;
        }
      }
      /**
       * Reposition molecule right before the camera.
       * @note The proper way is to initiate headset in the place of common Miew's camera.
       * But threejs limitations on setting new XRReferenceSpace enforce the molecule repositioning
       * Hope, something will change.
       */

    }, {
      key: "moveSceneBehindHeadset",
      value: function moveSceneBehindHeadset() {
        var gfx = this._gfx;
        var camera = gfx.camera; // set container position in camera space

        var container = this._molContainer;
        container.matrix.identity();
        container.position.set(0, 0, -4.0);
        container.updateMatrix(); // update container world matrix

        container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix); // readd to scene

        gfx.scene.addSavingWorldTransform(container);

        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        var gfx = this._gfx;
        return gfx && gfx.renderer ? gfx.renderer.domElement : null;
      }
    }]);

    return WebVRPoC;
  }();

  var fragmentScreenQuadFromDistTex = "precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D srcTex;\nuniform vec3 aberration;\n\nvoid main() {\n  vec2 uv = vUv * 2.0 - 1.0;\n  \n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\n  gl_FragColor.a = 1.0;\n}";

  var selectors$4 = chem.selectors,
      Atom$2 = chem.Atom,
      Residue$1 = chem.Residue,
      Chain$2 = chem.Chain,
      Molecule$8 = chem.Molecule;
  var EDIT_MODE = {
    COMPLEX: 0,
    COMPONENT: 1,
    FRAGMENT: 2
  };
  var LOADER_NOT_FOUND = 'Could not find suitable loader for this source';
  var PARSER_NOT_FOUND = 'Could not find suitable parser for this source';
  var createElement$2 = utils.createElement;

  function updateFogRange(fog, center, radius) {
    fog.near = center - radius * settings.now.fogNearFactor;
    fog.far = center + radius * settings.now.fogFarFactor;
  }

  function removeExtension(fileName) {
    var dot = fileName.lastIndexOf('.');

    if (dot >= 0) {
      fileName = fileName.substr(0, dot);
    }

    return fileName;
  }

  function hasValidResidues(complex) {
    var hasValidRes = false;
    complex.forEachComponent(function (component) {
      component.forEachResidue(function (residue) {
        if (residue._isValid) {
          hasValidRes = true;
        }
      });
    });
    return hasValidRes;
  }

  function reportProgress(log, action, percent) {
    var TOTAL_PERCENT = 100;

    if (percent !== undefined) {
      log.debug("".concat(action, "... ").concat(Math.floor(percent * TOTAL_PERCENT), "%"));
    } else {
      log.debug("".concat(action, "..."));
    }
  }

  function chooseFogColor() {
    return settings.now.fogColorEnable ? settings.now.fogColor : settings.now.bg.color;
  } // ////////////////////////////////////////////////////////////////////////////

  /**
   * Main 3D Molecular Viewer class.
   *
   * @param {object} opts - Viewer options.
   * @param {HTMLElement=} opts.container - DOM element that serves as a viewer container.
   * @param {object=} opts.settings - An object with properties to override default settings.
   * @param {string=} opts.settingsCookie='settings' - The name of the cookie to save current settings to.
   * @param {string=} opts.cookiePath='/' - The path option for cookies. Defaults to root.
   *
   * @exports Miew
   * @constructor
   */


  function Miew(opts) {
    EventDispatcher.call(this);
    this._opts = ___default['default'].merge({
      settingsCookie: 'settings',
      cookiePath: '/'
    }, opts);
    /** @type {?object} */

    this._gfx = null;
    /** @type {ViewInterpolator} */

    this._interpolator = new ViewInterpolator();
    /** @type {HTMLElement} */

    this._container = opts && opts.container || document.getElementById('miew-container') || ___default['default'].head(document.getElementsByClassName('miew-container')) || document.body;
    /** @type {HTMLElement} */

    this._containerRoot = this._container;
    /** @type {boolean} */

    this._running = false;
    /** @type {boolean} */

    this._halting = false;
    /** @type {boolean} */

    this._building = false;
    /** @type {boolean} */

    this._needRender = true;
    /** @type {boolean} */

    this._hotKeysEnabled = true;
    /** @type {Settings} */

    this.settings = settings;
    var log = logger;
    log.console = false;
    log.level =  'info';
    /**
     * @type {Logger}
     * @example
     * miew.logger.addEventListener('message', function _onLogMessage(evt) {
     *   console.log(evt.message);
     * });
     */

    this.logger = log;
    this._cookies = new Cookies(this);
    this.restoreSettings();

    if (opts && opts.settings) {
      this.settings.set(opts.settings);
    }
    /** @type {?Spinner} */


    this._spinner = null;
    /** @type {JobHandle[]} */

    this._loading = [];
    /** @type {?number}
     * @deprecated until Animation system refactoring
     */

    this._animInterval = null;
    /** @type {object} */

    this._visuals = {};
    /** @type {?string} */

    this._curVisualName = null;
    /** @type {array} */

    this._objects = [];
    /** @type {object} */

    this._sourceWindow = null;
    this.reset();

    if (this._repr) {
      log.debug("Selected ".concat(this._repr.mode.name, " mode with ").concat(this._repr.colorer.name, " colorer."));
    }

    var self = this;
    Miew.registeredPlugins.forEach(function (plugin) {
      plugin.call(self);
    });

    this._initOnSettingsChanged();
  }

  Miew.prototype = Object.create(EventDispatcher.prototype);
  Miew.prototype.constructor = Miew;

  Miew.prototype.getMaxRepresentationCount = function () {
    return ComplexVisual.NUM_REPRESENTATION_BITS;
  };
  /**
   * Replace viewer container contents with a DOM element.
   * @param {HTMLElement} container - parent container.
   * @param {HTMLElement} element - DOM element to show.
   * @private
   */


  function _setContainerContents(container, element) {
    var parent = container;

    while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
    }

    parent.appendChild(element);
  }
  /**
   * Update Shadow Camera target position and frustum.
   * @private
   */


  Miew.prototype._updateShadowCamera = function () {
    var shadowMatrix = new THREE.Matrix4();
    var direction = new THREE.Vector3();
    var OBB = {
      center: new THREE.Vector3(),
      halfSize: new THREE.Vector3()
    };
    return function () {
      this._gfx.scene.updateMatrixWorld();

      for (var i = 0; i < this._gfx.scene.children.length; i++) {
        if (this._gfx.scene.children[i].type === 'DirectionalLight') {
          var light = this._gfx.scene.children[i];
          shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
          this.getOBB(shadowMatrix, OBB);
          direction.subVectors(light.target.position, light.position);
          light.position.subVectors(OBB.center, direction);
          light.target.position.copy(OBB.center);
          light.shadow.bias = 0.09;
          light.shadow.camera.bottom = -OBB.halfSize.y;
          light.shadow.camera.top = OBB.halfSize.y;
          light.shadow.camera.right = OBB.halfSize.x;
          light.shadow.camera.left = -OBB.halfSize.x;
          light.shadow.camera.near = direction.length() - OBB.halfSize.z;
          light.shadow.camera.far = direction.length() + OBB.halfSize.z;
          light.shadow.camera.updateProjectionMatrix();
        }
      }
    };
  }();
  /**
   * Initialize the viewer.
   * @returns {boolean} true on success.
   * @throws Forwards exception raised during initialization.
   * @see Miew#term
   */


  Miew.prototype.init = function () {
    var container = this._container;
    var elem = utils.createElement('div', {
      "class": 'miew-canvas'
    });

    _setContainerContents(container, elem);

    this._container = elem;
    var frag = document.createDocumentFragment();
    frag.appendChild(this._msgMode = createElement$2('div', {
      "class": 'mode-message overlay'
    }, createElement$2('p', {}, 'COMPONENT EDIT MODE')));
    frag.appendChild(this._msgAtomInfo = createElement$2('div', {
      "class": 'atom-info overlay'
    }, createElement$2('p', {}, '')));
    container.appendChild(frag);

    if (this._gfx !== null) {
      // block double init
      return true;
    }

    var self = this;

    this._showMessage('Viewer is being initialized...');

    try {
      this._initGfx();

      this._initListeners();

      this._spinner = new Spinner({
        lines: 13,
        length: 28,
        width: 14,
        radius: 42,
        color: '#fff',
        zIndex: 700
      });
      window.top.addEventListener('keydown', function (event) {
        self._onKeyDown(event);
      });
      window.top.addEventListener('keyup', function (event) {
        self._onKeyUp(event);
      });
      this._objectControls = new ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, function () {
        return self._getAltObj();
      });

      this._objectControls.addEventListener('change', function (e) {
        if (settings.now.shadow.on) {
          self._updateShadowCamera();
        } // route rotate, zoom, translate and translatePivot events to the external API


        switch (e.action) {
          case 'rotate':
            self.dispatchEvent({
              type: 'rotate',
              quaternion: e.quaternion
            });
            break;

          case 'zoom':
            self.dispatchEvent({
              type: 'zoom',
              factor: e.factor
            });
            break;

          default:
            self.dispatchEvent({
              type: e.action
            });
        }

        self.dispatchEvent({
          type: 'transform'
        });
        self._needRender = true;
      });

      var gfx = this._gfx;
      this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);

      this._picker.addEventListener('newpick', function (event) {
        self._onPick(event);
      });

      this._picker.addEventListener('dblclick', function (event) {
        self.center(event);
      });
    } catch (error) {
      if (error.name === 'TypeError' && error.message === 'Cannot read property \'getExtension\' of null') {
        this._showMessage('Could not create WebGL context.');
      } else if (error.message.search(/webgl/i) > 1) {
        this._showMessage(error.message);
      } else {
        this._showMessage('Viewer initialization failed.');

        throw error;
      }

      return false;
    } // automatically load default file


    var file = this._opts && this._opts.load;

    if (file) {
      var type = this._opts && this._opts.type;
      this.load(file, {
        fileType: type,
        keepRepsInfo: true
      });
    }

    return true;
  };
  /**
   * Terminate the viewer completely.
   * @see Miew#init
   */


  Miew.prototype.term = function () {
    this._showMessage('Viewer has been terminated.');

    this._loading.forEach(function (job) {
      job.cancel();
    });

    this._loading.length = 0;
    this.halt();
    this._gfx = null;
  };
  /**
   * Display message inside the viewer container, hiding WebGL canvas.
   * @param {string} msg - Message to show.
   * @private
   */


  Miew.prototype._showMessage = function (msg) {
    var element = document.createElement('div');
    element.setAttribute('class', 'miew-message');
    element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));

    _setContainerContents(this._container, element);
  };
  /**
   * Display WebGL canvas inside the viewer container, hiding any message shown.
   * @private
   */


  Miew.prototype._showCanvas = function () {
    _setContainerContents(this._container, this._gfx.renderer.domElement);
  };

  Miew.prototype._requestAnimationFrame = function (callback) {
    var xr = this._gfx.renderer.xr;

    if (xr && xr.enabled) {
      this._gfx.renderer.setAnimationLoop(callback);

      return;
    }

    requestAnimationFrame(callback);
  };

  function arezSpritesSupported(context) {
    return context.getExtension('EXT_frag_depth');
  }

  function isAOSupported(context) {
    return context.getExtension('WEBGL_depth_texture') && context.getExtension('WEBGL_draw_buffers');
  }
  /**
   * Initialize WebGL and set 3D scene up.
   * @private
   */


  Miew.prototype._initGfx = function () {
    var gfx = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
    var webGLOptions = {
      preserveDrawingBuffer: true,
      alpha: true,
      premultipliedAlpha: false
    };

    if (settings.now.antialias) {
      webGLOptions.antialias = true;
    }

    gfx.renderer2d = new CSS2DRenderer();
    gfx.renderer = new THREE.WebGL1Renderer(webGLOptions);
    gfx.renderer.shadowMap.enabled = settings.now.shadow.on;
    gfx.renderer.shadowMap.autoUpdate = false;
    gfx.renderer.shadowMap.type = THREE.PCFShadowMap;
    capabilities.init(gfx.renderer); // z-sprites and ambient occlusion possibility

    if (!arezSpritesSupported(gfx.renderer.getContext())) {
      settings.set('zSprites', false);
    }

    if (!isAOSupported(gfx.renderer.getContext())) {
      settings.set('ao', false);
    }

    gfx.renderer.autoClear = false;
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.clearColor();
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    gfx.camera = new THREE.PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.position.z = settings.now.camDistance;
    gfx.camera.updateProjectionMatrix();
    gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
    gfx.stereoCam = new THREE.StereoCamera();
    gfx.scene = new THREE.Scene();
    var color = chooseFogColor();
    gfx.scene.fog = new THREE.Fog(color, settings.now.camNear, settings.now.camFar);
    gfx.root = new gfxutils.RCGroup();
    gfx.scene.add(gfx.root);
    gfx.pivot = new gfxutils.RCGroup();
    gfx.root.add(gfx.pivot);
    gfx.selectionScene = new THREE.Scene();
    gfx.selectionRoot = new THREE.Group();
    gfx.selectionRoot.matrixAutoUpdate = false;
    gfx.selectionScene.add(gfx.selectionRoot);
    gfx.selectionPivot = new THREE.Group();
    gfx.selectionPivot.matrixAutoUpdate = false;
    gfx.selectionRoot.add(gfx.selectionPivot);
    var light12 = new THREE.DirectionalLight(0xffffff, 0.45);
    light12.position.set(0, 0.414, 1);
    light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    light12.castShadow = true;
    light12.shadow.bias = 0.09;
    light12.shadow.radius = settings.now.shadow.radius;
    light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
    var pixelRatio = gfx.renderer.getPixelRatio();
    var shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
    light12.shadow.mapSize.width = shadowMapSize;
    light12.shadow.mapSize.height = shadowMapSize;
    light12.target.position.set(0.0, 0.0, 0.0);
    gfx.scene.add(light12);
    gfx.scene.add(light12.target);
    var light3 = new THREE.AmbientLight(0x666666);
    light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    gfx.scene.add(light3); // add axes

    gfx.axes = new Axes(gfx.root, gfx.camera);
    var deviceWidth = gfx.width * pixelRatio;
    var deviceHeight = gfx.height * pixelRatio;
    gfx.offscreenBuf = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      depthBuffer: true
    });

    if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
      gfx.offscreenBuf.depthTexture = new THREE.DepthTexture();
      gfx.offscreenBuf.depthTexture.type = THREE.UnsignedShortType;
    }

    gfx.offscreenBuf2 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf3 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf4 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.volBFTex = gfx.offscreenBuf3;
    gfx.volFFTex = gfx.offscreenBuf4;
    gfx.volWFFTex = gfx.offscreenBuf; // use float textures for volume rendering if possible

    if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
      gfx.offscreenBuf5 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf6 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf7 = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
        depthBuffer: true
      });
      gfx.volBFTex = gfx.offscreenBuf5;
      gfx.volFFTex = gfx.offscreenBuf6;
      gfx.volWFFTex = gfx.offscreenBuf7;
    } else {
      this.logger.warn('Device doesn\'t support OES_texture_float extension');
    }

    gfx.stereoBufL = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    gfx.stereoBufR = new THREE.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      depthBuffer: false
    });
    this._gfx = gfx;

    this._showCanvas();

    this._embedWebXR(settings.now.stereo === 'WEBVR');

    this._container.appendChild(gfx.renderer2d.getElement()); // add FPS counter


    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0';
    stats.domElement.style.bottom = '0';

    this._container.appendChild(stats.domElement);

    this._fps = stats;

    this._fps.show(settings.now.fps);
  };
  /**
   * Setup event listeners.
   * @private
   */


  Miew.prototype._initListeners = function () {
    var self = this;
    window.addEventListener('resize', function () {
      self._onResize();
    });
  };
  /**
   * Try to add numbers to the base name to make it unique among visuals
   * @private
   */


  Miew.prototype._makeUniqueVisualName = function (baseName) {
    if (!baseName) {
      return Math.random().toString();
    }

    var name = baseName;
    var suffix = 1;

    while (this._visuals.hasOwnProperty(name)) {
      name = "".concat(baseName, " (").concat(suffix.toString(), ")");
      suffix++;
    }

    return name;
  };
  /**
   * Add visual to the viewer
   * @private
   */


  Miew.prototype._addVisual = function (visual) {
    if (!visual) {
      return null;
    } // change visual name in order to make it unique


    var name = this._makeUniqueVisualName(visual.name);

    visual.name = name;
    this._visuals[name] = visual;

    this._gfx.pivot.add(visual);

    if (visual.getSelectionGeo) {
      this._gfx.selectionPivot.add(visual.getSelectionGeo());
    }

    return name;
  };
  /**
   * Remove visual from the viewer
   * @private
   */


  Miew.prototype._removeVisual = function (visual) {
    var name = '';
    var obj = null;

    if (visual instanceof Visual) {
      name = visual.name;
      obj = visual;
    } else if (typeof visual === 'string') {
      name = visual;
      obj = this._visuals[name];
    }

    if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
      return;
    }

    if (name === this._curVisualName) {
      this._curVisualName = undefined;
    }

    delete this._visuals[name];
    obj.release(); // removes nodes from scene

    this._needRender = true;
  };
  /**
   * Call specified function for each Visual
   * @private
   */


  Miew.prototype._forEachVisual = function (callback) {
    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        callback(this._visuals[name]);
      }
    }
  };
  /**
   * Release (destroy) all visuals in the scene
   * @private
   */


  Miew.prototype._releaseAllVisuals = function () {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        this._visuals[name].release();
      }
    }

    this._visuals = {};
  };
  /**
   * Call specified function for each ComplexVisual
   * @private
   */


  Miew.prototype._forEachComplexVisual = function (callback) {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof ComplexVisual) {
        callback(this._visuals[name]);
      }
    }
  };
  /**
   * Returns ComplexVisual with specified name, or current (if not found), or any, or null
   * @private
   */


  Miew.prototype._getComplexVisual = function (name) {
    name = name || this._curVisualName;
    var any = null;
    var named = null;

    this._forEachComplexVisual(function (visual) {
      any = visual;

      if (visual.name === name) {
        named = visual;
      }
    });

    return named || any;
  };
  /**
   * Returns first found VolumeVisual (no more than one should be present actually)
   * @private
   */


  Miew.prototype._getVolumeVisual = function () {
    var any = null;

    this._forEachVisual(function (visual) {
      if (visual instanceof VolumeVisual) {
        any = visual;
      }
    });

    return any;
  };
  /**
   * Returns ComplexVisual corresponding to specified complex
   * @private
   */


  Miew.prototype._getVisualForComplex = function (complex) {
    if (!complex) {
      return null;
    }

    var found = null;

    this._forEachComplexVisual(function (visual) {
      if (visual.getComplex() === complex) {
        found = visual;
      }
    });

    return found;
  };
  /*
     * Get a list of names of visuals currently shown by the viewer
     */


  Miew.prototype.getVisuals = function () {
    return Object.keys(this._visuals);
  };
  /*
     * Get complex visuals count
     */


  Miew.prototype.getComplexVisualsCount = function () {
    var count = 0;

    this._forEachComplexVisual(function () {
      return count++;
    });

    return count;
  };
  /*
     * Get current visual
     */


  Miew.prototype.getCurrentVisual = function () {
    return this._curVisualName;
  };
  /*
     * Set current visual.
     * All further operations will be performed on this visual (complex) if not stated otherwise.
     */


  Miew.prototype.setCurrentVisual = function (name) {
    if (!this._visuals[name]) {
      return;
    }

    this._curVisualName = name;
  };
  /**
   * Run the viewer, start processing update/render frames periodically.
   * Has no effect if already running.
   * @see Miew#halt
   */


  Miew.prototype.run = function () {
    var _this = this;

    if (!this._running) {
      this._running = true;

      if (this._halting) {
        this._halting = false;
        return;
      }

      this._objectControls.enable(true);

      this._interpolator.resume();

      this._requestAnimationFrame(function () {
        return _this._onTick();
      });
    }
  };
  /**
   * Request the viewer to stop.
   * Will be processed during the next frame.
   * @see Miew#run
   */


  Miew.prototype.halt = function () {
    if (this._running) {
      this._discardComponentEdit();

      this._discardFragmentEdit();

      this._objectControls.enable(false);

      this._interpolator.pause();

      this._halting = true;
    }
  };
  /**
   * Request the viewer to start / stop responsing
   * on hot keys.
   * @param enabled - start (true) or stop (false) response on hot keys.
   */


  Miew.prototype.enableHotKeys = function (enabled) {
    this._hotKeysEnabled = enabled;

    this._objectControls.enableHotkeys(enabled);
  };
  /**
   * Callback which processes window resize.
   * @private
   */


  Miew.prototype._onResize = function () {
    this._needRender = true;
    var gfx = this._gfx;
    gfx.width = this._container.clientWidth;
    gfx.height = this._container.clientHeight;
    gfx.camera.aspect = gfx.width / gfx.height;
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    this.dispatchEvent({
      type: 'resize'
    });
  };

  Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
    var gfx = this._gfx;
    stereo = stereo || 'NONE';
    var isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH';
    var multi = isAnaglyph ? 1 : 0.5;
    gfx.offscreenBuf.setSize(multi * width, height);
    gfx.offscreenBuf2.setSize(multi * width, height);
    gfx.offscreenBuf3.setSize(multi * width, height);
    gfx.offscreenBuf4.setSize(multi * width, height);

    if (gfx.offscreenBuf5) {
      gfx.offscreenBuf5.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf6) {
      gfx.offscreenBuf6.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf7) {
      gfx.offscreenBuf7.setSize(multi * width, height);
    }

    if (isAnaglyph) {
      gfx.stereoBufL.setSize(width, height);
      gfx.stereoBufR.setSize(width, height);
    }
  };
  /**
   * Callback which processes update/render frames.
   * @private
   */


  Miew.prototype._onTick = function () {
    var _this2 = this;

    if (this._halting) {
      this._running = false;
      this._halting = false;
      return;
    }

    this._fps.update();

    this._requestAnimationFrame(function () {
      return _this2._onTick();
    });

    this._onUpdate();

    if (this._needRender) {
      this._onRender();

      this._needRender = !settings.now.suspendRender || settings.now.stereo === 'WEBVR';
    }
  };

  Miew.prototype._getBSphereRadius = function () {
    // calculate radius that would include all visuals
    var radius = 0;

    this._forEachVisual(function (visual) {
      radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
    });

    return radius * this._objectControls.getScale();
  };
  /**
   * Calculate bounding box that would include all visuals and being axis aligned in world defined by
   * transformation matrix: matrix
   * @param {Matrix4} matrix - transformation matrix.
   * @param {object}  OBB           - calculating bounding box.
   * @param {Vector3} OBB.center    - OBB center.
   * @param {Vector3} OBB.halfSize  - half magnitude of OBB sizes.
   */


  Miew.prototype.getOBB = function () {
    var _bSphereForOneVisual = new THREE.Sphere();

    var _bBoxForOneVisual = new THREE.Box3();

    var _bBox = new THREE.Box3();

    var _invMatrix = new THREE.Matrix4();

    var _points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
    return function (matrix, OBB) {
      _bBox.makeEmpty();

      this._forEachVisual(function (visual) {
        _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);

        _bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);

        _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual);

        _bBox.union(_bBoxForOneVisual);
      });

      _bBox.getCenter(OBB.center);

      _invMatrix.copy(matrix).invert();

      OBB.center.applyMatrix4(_invMatrix);
      var min = _bBox.min;
      var max = _bBox.max;

      _points[0].set(min.x, min.y, min.z); // 000


      _points[1].set(max.x, min.y, min.z); // 100


      _points[2].set(min.x, max.y, min.z); // 010


      _points[3].set(min.x, min.y, max.z); // 001


      for (var i = 0, l = _points.length; i < l; i++) {
        _points[i].applyMatrix4(_invMatrix);
      }

      OBB.halfSize.set(Math.abs(_points[0].x - _points[1].x), Math.abs(_points[0].y - _points[2].y), Math.abs(_points[0].z - _points[3].z)).multiplyScalar(0.5);
    };
  }();

  Miew.prototype._updateFog = function () {
    var gfx = this._gfx;

    if (settings.now.fog) {
      if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
        var color = chooseFogColor();
        gfx.scene.fog = new THREE.Fog(color);

        this._setUberMaterialValues({
          fog: settings.now.fog
        });
      }

      updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
    } else if (gfx.scene.fog) {
      gfx.scene.fog = undefined;

      this._setUberMaterialValues({
        fog: settings.now.fog
      });
    }
  };

  Miew.prototype._onUpdate = function () {
    if (this.isScriptingCommandAvailable !== undefined && this.isScriptingCommandAvailable() && !this._building) {
      this.callNextCmd();
    }

    this._objectControls.update();

    this._forEachComplexVisual(function (visual) {
      visual.getComplex().update();
    });

    if (settings.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
      this.rebuild();
    }

    if (!this._loading.length && !this._building && !this._needRebuild()) {
      this._updateView();
    }

    this._updateFog();

    if (this._gfx.renderer.xr.enabled) {
      this.webVR.updateMoleculeScale();
    }
  };

  Miew.prototype._onRender = function () {
    var gfx = this._gfx; // update all matrices

    gfx.scene.updateMatrixWorld();
    gfx.camera.updateMatrixWorld();

    this._clipPlaneUpdateValue(this._getBSphereRadius());

    this._fogFarUpdateValue();

    gfx.renderer.setRenderTarget(null);
    gfx.renderer.clear();

    this._renderFrame(settings.now.stereo);
  };

  Miew.prototype._renderFrame = function () {
    var _anaglyphMat = new AnaglyphMaterial();

    var _size = new THREE.Vector2();

    return function (stereo) {
      var gfx = this._gfx;
      var renderer = gfx.renderer;
      renderer.getSize(_size);

      if (stereo !== 'NONE') {
        gfx.camera.focus = gfx.camera.position.z; // set focus to the center of the object

        gfx.stereoCam.aspect = 1.0; // in anaglyph mode we render full-size image for each eye
        // while in other stereo modes only half-size (two images on the screen)

        if (stereo === 'ANAGLYPH') {
          gfx.stereoCam.update(gfx.camera);
        } else {
          gfx.stereoCam.updateHalfSized(gfx.camera, settings.now.camFov);
        }
      } // resize offscreen buffers to match the target


      var pixelRatio = gfx.renderer.getPixelRatio();

      this._resizeOffscreenBuffers(_size.width * pixelRatio, _size.height * pixelRatio, stereo);

      this._renderShadowMap();

      switch (stereo) {
        case 'WEBVR':
        case 'NONE':
          this._renderScene(gfx.camera, false);

          break;

        case 'SIMPLE':
        case 'DISTORTED':
          renderer.setScissorTest(true);
          renderer.setScissor(0, 0, _size.width / 2, _size.height);
          renderer.setViewport(0, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED');

          renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height);
          renderer.setViewport(_size.width / 2, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED');

          renderer.setScissorTest(false);
          break;

        case 'ANAGLYPH':
          this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);

          this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);

          renderer.setRenderTarget(null);
          _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
          _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
          gfx.renderer.renderScreenQuad(_anaglyphMat);
          break;
      }

      gfx.renderer2d.render(gfx.scene, gfx.camera);

      if (settings.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
        gfx.axes.render(renderer);
      }
    };
  }();

  Miew.prototype._onBgColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx) {
      if (gfx.scene.fog) {
        gfx.scene.fog.color.set(color);
      }

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    }

    this._needRender = true;
  };

  Miew.prototype._onFogColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx && gfx.scene.fog) {
      gfx.scene.fog.color.set(color);
    }

    this._needRender = true;
  };

  Miew.prototype._setUberMaterialValues = function (values) {
    this._gfx.root.traverse(function (obj) {
      if ((obj instanceof THREE.Mesh || obj instanceof THREE.LineSegments || obj instanceof THREE.Line) && obj.material instanceof UberMaterial) {
        obj.material.setValues(values);
        obj.material.needsUpdate = true;
      }
    });
  };

  Miew.prototype._enableMRT = function (on, renderBuffer, textureBuffer) {
    var gfx = this._gfx;
    var gl = gfx.renderer.getContext();
    var ext = gl.getExtension('WEBGL_draw_buffers');
    var properties = gfx.renderer.properties;

    if (!on) {
      ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
      return;
    } // take extra texture from Texture Buffer


    gfx.renderer.setRenderTarget(textureBuffer);

    var tx8 = properties.get(textureBuffer.texture).__webglTexture;

    gl.bindTexture(gl.TEXTURE_2D, tx8); // take texture and framebuffer from renderbuffer

    gfx.renderer.setRenderTarget(renderBuffer);

    var fb = properties.get(renderBuffer).__webglFramebuffer;

    var tx = properties.get(renderBuffer.texture).__webglTexture; // set framebuffer


    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    fb.width = renderBuffer.width;
    fb.height = renderBuffer.height;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0); // mapping textures

    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
  };

  Miew.prototype._renderScene = function () {
    return function (camera, distortion, target) {
      distortion = distortion || false;
      target = target || null;
      var gfx = this._gfx; // render to offscreen buffer

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(target);
      gfx.renderer.clear();

      if (gfx.renderer.xr.enabled) {
        gfx.renderer.render(gfx.scene, camera);
        return;
      } // clean buffer for normals texture


      gfx.renderer.setClearColor(0x000000, 0.0);
      gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
      gfx.renderer.clearColor();
      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.clear();
      var bHaveComplexes = this._getComplexVisual() !== null;

      var volumeVisual = this._getVolumeVisual();

      var ssao = bHaveComplexes && settings.now.ao;

      if (ssao) {
        this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
      }

      if (settings.now.transparency === 'prepass') {
        this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
      } else if (settings.now.transparency === 'standard') {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.render(gfx.scene, camera);
      }

      if (ssao) {
        this._enableMRT(false, null, null);
      } // when fxaa we should get resulting image in temp off-screen buff2 for further postprocessing with fxaa filter
      // otherwise we render to canvas


      var outline = bHaveComplexes && settings.now.outline.on;
      var fxaa = bHaveComplexes && settings.now.fxaa;
      var volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
      var dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
      var srcBuffer = gfx.offscreenBuf;

      if (ssao) {
        this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);

        if (!fxaa && !distortion && !volume && !outline) {
          srcBuffer = dstBuffer;
          dstBuffer = target;
          gfx.renderer.setRenderTarget(dstBuffer);
          gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
        }
      } else {
        // just copy color buffer to dst buffer
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
      } // outline


      if (outline) {
        srcBuffer = dstBuffer;
        dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;

        if (srcBuffer != null) {
          this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
        }
      } // render selected part with outline material


      this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);

      if (volume) {
        // copy current picture to the buffer that retains depth-data of the original molecule render
        // so that volume renderer could use depth-test
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        dstBuffer = gfx.offscreenBuf;

        this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex); // if this is the last stage -- copy image to target


        if (!fxaa && !distortion) {
          gfx.renderer.setRenderTarget(target);
          gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        }
      }

      srcBuffer = dstBuffer;

      if (fxaa) {
        dstBuffer = distortion ? gfx.offscreenBuf4 : target;

        this._performFXAA(srcBuffer, dstBuffer);

        srcBuffer = dstBuffer;
      }

      if (distortion) {
        dstBuffer = target;

        this._performDistortion(srcBuffer, dstBuffer, true);
      }
    };
  }();

  Miew.prototype._performDistortion = function () {
    var _scene = new THREE.Scene();

    var _camera = new THREE.OrthographicCamera(-1.0, 1.0, 1.0, -1.0, -500, 1000);

    var _material = new THREE.RawShaderMaterial({
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        aberration: {
          type: 'fv3',
          value: new THREE.Vector3(1.0)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentScreenQuadFromDistTex,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });

    var _geo = gfxutils.buildDistorionMesh(10, 10, settings.now.debug.stereoBarrel);

    _scene.add(new meshes.Mesh(_geo, _material));

    return function (srcBuffer, targetBuffer, mesh) {
      this._gfx.renderer.setRenderTarget(targetBuffer);

      this._gfx.renderer.clear();

      if (mesh) {
        _material.uniforms.srcTex.value = srcBuffer.texture;

        _material.uniforms.aberration.value.set(0.995, 1.0, 1.01);

        this._gfx.renderer.render(_scene, _camera);
      } else {
        this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings.now.debug.stereoBarrel);
      }
    };
  }();

  Miew.prototype._renderOutline = function () {
    var _outlineMaterial = new OutlineMaterial({
      depth: true
    });

    return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx; // apply Sobel filter -- draw outline

      _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
      _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);

      _outlineMaterial.uniforms.color.value = new THREE.Color(settings.now.outline.color);
      _outlineMaterial.uniforms.threshold.value = settings.now.outline.threshold;
      _outlineMaterial.uniforms.thickness.value = new THREE.Vector2(settings.now.outline.thickness, settings.now.outline.thickness);
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._renderShadowMap = function () {
    var pars = {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    };
    return function () {
      if (!settings.now.shadow.on) {
        return;
      }

      var gfx = this._gfx;
      var currentRenderTarget = gfx.renderer.getRenderTarget();
      var activeCubeFace = gfx.renderer.getActiveCubeFace();
      var activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
      var _state = gfx.renderer.state; // Set GL state for depth map.

      _state.setBlending(THREE.NoBlending);

      _state.buffers.color.setClear(1, 1, 1, 1);

      _state.buffers.depth.setTest(true);

      _state.setScissorTest(false);

      for (var i = 0; i < gfx.scene.children.length; i++) {
        if (gfx.scene.children[i].type === 'DirectionalLight') {
          var light = gfx.scene.children[i];

          if (light.shadow.map == null) {
            light.shadow.map = new THREE.WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, pars);
            light.shadow.camera.updateProjectionMatrix();
          }

          light.shadow.updateMatrices(light);
          gfx.renderer.setRenderTarget(light.shadow.map);
          gfx.renderer.clear();
          gfx.renderer.render(gfx.scene, light.shadow.camera);
        }
      }

      gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
  }();
  /**
   * Check if there is selection which must be rendered or not.
   * @private
   * @returns {boolean} true on existing selection to render
   */


  Miew.prototype._hasSelectionToRender = function () {
    var selPivot = this._gfx.selectionPivot;

    for (var i = 0; i < selPivot.children.length; i++) {
      var selPivotChild = selPivot.children[i];

      if (selPivotChild.children.length > 0) {
        return true;
      }
    }

    return false;
  };

  Miew.prototype._renderSelection = function () {
    var _outlineMaterial = new OutlineMaterial();

    return function (camera, srcBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx; // clear offscreen buffer (leave z-buffer intact)

      gfx.renderer.setClearColor('black', 0); // render selection to offscreen buffer

      gfx.renderer.setRenderTarget(srcBuffer);
      gfx.renderer.clear(true, false, false);

      if (self._hasSelectionToRender()) {
        gfx.selectionRoot.matrix = gfx.root.matrix;
        gfx.selectionPivot.matrix = gfx.pivot.matrix;
        gfx.renderer.render(gfx.selectionScene, camera);
      } else {
        // just render something to force "target clear" operation to finish
        gfx.renderer.renderDummyQuad();
      } // overlay to screen


      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6); // apply Sobel filter -- draw outline

      _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);

      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
    if (!renderTarget) {
      return false;
    }

    var gfx = this._gfx;
    var oldRT = gfx.renderer.getRenderTarget();
    gfx.renderer.setRenderTarget(renderTarget);
    var context = gfx.renderer.getContext();
    var result = context.checkFramebufferStatus(context.FRAMEBUFFER);
    gfx.renderer.setRenderTarget(oldRT);

    if (result !== context.FRAMEBUFFER_COMPLETE) {
      // floatFrameBufferWarning = ;
      this.logger.warn('Device doesn\'t support electron density rendering');
      return false;
    }

    return true;
  };

  Miew.prototype._renderVolume = function () {
    var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial();
    var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial();
    var cubeOffsetMat = new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5);
    var world2colorMat = new THREE.Matrix4();
    var volumeRenderingSupported;
    return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
      var gfx = this._gfx;

      if (typeof volumeRenderingSupported === 'undefined') {
        volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
      }

      if (!volumeRenderingSupported) {
        return;
      }

      var mesh = volumeVisual.getMesh();
      mesh.rebuild(gfx.camera); // use main camera to prepare special textures to be used by volumetric rendering
      // these textures have the size of the window and are stored in offscreen buffers

      gfx.renderer.setClearColor('black', 0);
      gfx.renderer.setRenderTarget(tmpBuf1);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf2);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf1); // draw plane with its own material, because it differs slightly from volumeBFMat

      camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeBFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.setRenderTarget(tmpBuf2);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeFFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.scene.overrideMaterial = null;
      camera.layers.set(gfxutils.LAYERS.DEFAULT); // prepare texture that contains molecule positions

      world2colorMat.copy(mesh.matrixWorld).invert();
      UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
      camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.render(gfx.scene, camera); // render volume

      var vm = mesh.material;
      vm.uniforms._BFRight.value = tmpBuf1.texture;
      vm.uniforms._FFRight.value = tmpBuf2.texture;
      vm.uniforms._WFFRight.value = tmpBuf3.texture;
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.renderer.setRenderTarget(dstBuf);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();
  /*  Render scene with 'ZPrepass transparency Effect'
     * Idea: transparent objects are rendered in two passes. The first one writes result only into depth buffer.
     * The second pass reads depth buffer and writes only to color buffer. The method results in
     * correct image of front part of the semi-transparent objects, but we can see only front transparent objects
     * and opaque objects inside, there is no transparent objects inside.
     * Notes: 1. Opaque objects should be rendered strictly before semi-transparent ones.
     * 2. Realization doesn't use camera layers because scene traversing is used for material changes and
     * we can use it to select needed meshes and don't complicate meshes builders with layers
    */


  Miew.prototype._renderWithPrepassTransparency = function () {
    return function (camera, targetBuffer) {
      var gfx = this._gfx;
      gfx.renderer.setRenderTarget(targetBuffer); // opaque objects

      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      gfx.renderer.render(gfx.scene, camera); // transparent objects z prepass

      camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
      gfx.renderer.getContext().colorMask(false, false, false, false); // don't update color buffer

      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.getContext().colorMask(true, true, true, true); // update color buffer
      // transparent objects color pass

      camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
      gfx.renderer.render(gfx.scene, camera); // restore default layer

      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();

  Miew.prototype._performFXAA = function () {
    var _fxaaMaterial = new FXAAMaterial();

    return function (srcBuffer, targetBuffer) {
      if (typeof srcBuffer === 'undefined' || typeof targetBuffer === 'undefined') {
        return;
      }

      var gfx = this._gfx; // clear canvas

      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.clear(); // do fxaa processing of offscreen buff2

      _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _fxaaMaterial.uniforms.srcTexelSize.value.set(1.0 / srcBuffer.width, 1.0 / srcBuffer.height);

      _fxaaMaterial.uniforms.bgColor.value.set(settings.now.bg.color);

      if (_fxaaMaterial.bgTransparent !== settings.now.bg.transparent) {
        _fxaaMaterial.setValues({
          bgTransparent: settings.now.bg.transparent
        });

        _fxaaMaterial.needsUpdate = true;
      }

      gfx.renderer.renderScreenQuad(_fxaaMaterial);
    };
  }();

  Miew.prototype._performAO = function () {
    var _aoMaterial = new AOMaterial();

    var _horBlurMaterial = new AOHorBlurMaterial();

    var _vertBlurMaterial = new AOVertBlurWithBlendMaterial();

    var _scale = new THREE.Vector3();

    return function (srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
      if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
        return;
      }

      var gfx = this._gfx;
      var tanHalfFOV = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
      _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
      _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;

      _aoMaterial.uniforms.srcTexelSize.value.set(1.0 / srcColorBuffer.width, 1.0 / srcColorBuffer.height);

      _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);

      _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      gfx.root.matrix.extractScale(_scale);
      _aoMaterial.uniforms.kernelRadius.value = settings.now.debug.ssaoKernelRadius * _scale.x;
      _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius(); // diameter

      _aoMaterial.uniforms.factor.value = settings.now.debug.ssaoFactor; // N: should be tempBuffer1 for proper use of buffers (see buffers using outside the function)

      gfx.renderer.setRenderTarget(tempBuffer1);
      gfx.renderer.renderScreenQuad(_aoMaterial);
      _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;

      _horBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer1.width, 1.0 / tempBuffer1.height);

      _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      gfx.renderer.setRenderTarget(tempBuffer);
      gfx.renderer.renderScreenQuad(_horBlurMaterial);
      _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
      _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;

      _vertBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer.width, 1.0 / tempBuffer.height);

      _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      var fog = gfx.scene.fog;

      if (fog) {
        _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);

        _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings.now.fogAlpha);
      }

      if (_vertBlurMaterial.useFog !== settings.now.fog || _vertBlurMaterial.fogTransparent !== settings.now.bg.transparent) {
        _vertBlurMaterial.setValues({
          useFog: settings.now.fog,
          fogTransparent: settings.now.bg.transparent
        });

        _vertBlurMaterial.needsUpdate = true;
      }

      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_vertBlurMaterial);
    };
  }();
  /**
   * Reset the viewer, unload molecules.
   * @param {boolean=} keepReps - Keep representations while resetting viewer state.
   */


  Miew.prototype.reset = function ()
  /* keepReps */
  {
    if (this._picker) {
      this._picker.reset();
    }

    this._lastPick = null;

    this._releaseAllVisuals();

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetObjects();

    if (this._gfx) {
      gfxutils.clearTree(this._gfx.pivot);

      this._gfx.renderer2d.reset();
    }

    this.setNeedRender();
  };

  Miew.prototype._resetScene = function () {
    this._objectControls.reset();

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.resetReps();
    this.resetPivot();
    this.rebuildAll();
  };

  Miew.prototype.resetView = function () {
    // reset controls
    if (this._picker) {
      this._picker.reset();
    }

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetScene(); // reset selection


    this._forEachComplexVisual(function (visual) {
      visual.updateSelectionMask({});
      visual.rebuildSelectionGeometry();
    });
  };

  Miew.prototype._export = function (format) {
    var TheExporter = ___default['default'].head(io.exporters.find({
      format: format
    }));

    if (!TheExporter) {
      this.logger.error('Could not find suitable exporter for this source');
      return Promise.reject(new Error('Could not find suitable exporter for this source'));
    }

    this.dispatchEvent({
      type: 'exporting'
    });

    if (this._visuals[this._curVisualName] instanceof ComplexVisual) {
      var dataSource = null;

      if (TheExporter.SourceClass === ComplexVisual) {
        dataSource = this._visuals[this._curVisualName];
      } else if (TheExporter.SourceClass === Complex) {
        dataSource = this._visuals[this._curVisualName]._complex;
      }

      var exporter = new TheExporter(dataSource, {
        miewVersion: Miew.VERSION
      });
      return exporter["export"]().then(function (data) {
        return data;
      });
    }

    if (this._visuals[this._curVisualName] instanceof VolumeVisual) {
      return Promise.reject(new Error('Sorry, exporter for volume data not implemented yet'));
    }

    return Promise.reject(new Error('Unexpected format of data'));
  };

  var rePdbId = /^(?:(pdb|cif|mmtf|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
  var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
  var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;

  function resolveSourceShortcut(source, opts) {
    if (!___default['default'].isString(source)) {
      return source;
    } // e.g. "mmtf:1CRN"


    var matchesPdbId = rePdbId.exec(source);

    if (matchesPdbId) {
      var _matchesPdbId = slicedToArray(matchesPdbId, 3),
          _matchesPdbId$ = _matchesPdbId[1],
          format = _matchesPdbId$ === void 0 ? 'pdb' : _matchesPdbId$,
          id = _matchesPdbId[2];

      format = format.toLowerCase();
      id = id.toUpperCase();

      switch (format) {
        case 'pdb':
          source = "https://files.rcsb.org/download/".concat(id, ".pdb");
          break;

        case 'cif':
          source = "https://files.rcsb.org/download/".concat(id, ".cif");
          break;

        case 'mmtf':
          source = "https://mmtf.rcsb.org/v1.0/full/".concat(id);
          break;

        case 'ccp4':
          source = "https://www.ebi.ac.uk/pdbe/coordinates/files/".concat(id.toLowerCase(), ".ccp4");
          break;

        case 'dsn6':
          source = "https://edmaps.rcsb.org/maps/".concat(id.toLowerCase(), "_2fofc.dsn6");
          break;

        default:
          throw new Error('Unexpected data format shortcut');
      }

      opts.fileType = format;
      opts.fileName = "".concat(id, ".").concat(format);
      opts.sourceType = 'url';
      return source;
    } // e.g. "pc:aspirin"


    var matchesPubchem = rePubchem.exec(source);

    if (matchesPubchem) {
      var compound = matchesPubchem[1].toLowerCase();
      source = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/".concat(compound, "/JSON?record_type=3d");
      opts.fileType = 'pubchem';
      opts.fileName = "".concat(compound, ".json");
      opts.sourceType = 'url';
      return source;
    } // otherwise is should be an URL


    if (opts.sourceType === 'url' || opts.sourceType === undefined) {
      opts.sourceType = 'url'; // e.g. "./data/1CRN.pdb"

      if (!reUrlScheme.test(source)) {
        source = utils.resolveURL(source);
      }
    }

    return source;
  }

  function updateBinaryMode(opts) {
    var binary = opts.binary; // detect by format

    if (opts.fileType !== undefined) {
      var TheParser = ___default['default'].head(io.parsers.find({
        format: opts.fileType
      }));

      if (TheParser) {
        binary = TheParser.binary || false;
      } else {
        throw new Error('Could not find suitable parser for this format');
      }
    } // detect by file extension


    if (binary === undefined && opts.fileExt !== undefined) {
      var _TheParser = ___default['default'].head(io.parsers.find({
        ext: opts.fileExt
      }));

      if (_TheParser) {
        binary = _TheParser.binary || false;
      }
    } // temporary workaround for animation


    if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
      opts.binary = true;
      opts.animation = true; // who cares?
    } // update if detected


    if (binary !== undefined) {
      if (opts.binary !== undefined && opts.binary !== binary) {
        opts.context.logger.warn('Overriding incorrect binary mode');
      }
    }

    opts.binary = binary || false;
  }

  function _fetchData(source, opts, job) {
    return new Promise(function (resolve) {
      if (job.shouldCancel()) {
        throw new Error('Operation cancelled');
      }

      job.notify({
        type: 'fetching'
      }); // allow for source shortcuts

      source = resolveSourceShortcut(source, opts); // detect a proper loader

      var TheLoader = ___default['default'].head(io.loaders.find({
        type: opts.sourceType,
        source: source
      }));

      if (!TheLoader) {
        throw new Error(LOADER_NOT_FOUND);
      } // split file name


      var fileName = opts.fileName || TheLoader.extractName(source);

      if (fileName) {
        var _utils$splitFileName = utils.splitFileName(fileName),
            _utils$splitFileName2 = slicedToArray(_utils$splitFileName, 2),
            name = _utils$splitFileName2[0],
            fileExt = _utils$splitFileName2[1];

        ___default['default'].defaults(opts, {
          name: name,
          fileExt: fileExt,
          fileName: fileName
        });
      } // should it be text or binary?


      updateBinaryMode(opts); // FIXME: All new settings retrieved from server are applied after the loading is complete. However, we need some
      // flags to alter the loading process itself. Here we apply them in advance. Dirty hack. Kill the server, remove
      // all hacks and everybody's happy.

      var newOptions = ___default['default'].get(opts, 'preset.expression');

      if (!___default['default'].isUndefined(newOptions)) {
        newOptions = JSON.parse(newOptions);

        if (newOptions && newOptions.settings) {
          var keys = ['singleUnit'];

          for (var keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
            var key = keys[keyIndex];

            var value = ___default['default'].get(newOptions.settings, key);

            if (!___default['default'].isUndefined(value)) {
              settings.set(key, value);
            }
          }
        }
      } // create a loader


      var loader = new TheLoader(source, opts);
      loader.context = opts.context;
      job.addEventListener('cancel', function () {
        return loader.abort();
      });
      loader.addEventListener('progress', function (event) {
        if (event.lengthComputable && event.total > 0) {
          reportProgress(loader.logger, 'Fetching', event.loaded / event.total);
        } else {
          reportProgress(loader.logger, 'Fetching');
        }
      });
      console.time('fetch');
      var promise = loader.load().then(function (data) {
        console.timeEnd('fetch');
        opts.context.logger.info('Fetching finished');
        job.notify({
          type: 'fetchingDone',
          data: data
        });
        return data;
      })["catch"](function (error) {
        console.timeEnd('fetch');
        opts.context.logger.debug(error.message);

        if (error.stack) {
          opts.context.logger.debug(error.stack);
        }

        opts.context.logger.error('Fetching failed');
        job.notify({
          type: 'fetchingDone',
          error: error
        });
        throw error;
      });
      resolve(promise);
    });
  }

  function _parseData(data, opts, job) {
    if (job.shouldCancel()) {
      return Promise.reject(new Error('Operation cancelled'));
    }

    job.notify({
      type: 'parsing'
    });

    var TheParser = ___default['default'].head(io.parsers.find({
      format: opts.fileType,
      ext: opts.fileExt,
      data: data
    }));

    if (!TheParser) {
      return Promise.reject(new Error('Could not find suitable parser'));
    }

    var parser = new TheParser(data, opts);
    parser.context = opts.context;
    job.addEventListener('cancel', function () {
      return parser.abort();
    });
    console.time('parse');
    return parser.parse().then(function (dataSet) {
      console.timeEnd('parse');
      job.notify({
        type: 'parsingDone',
        data: dataSet
      });
      return dataSet;
    })["catch"](function (error) {
      console.timeEnd('parse');
      opts.error = error;
      opts.context.logger.debug(error.message);

      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }

      opts.context.logger.error('Parsing failed');
      job.notify({
        type: 'parsingDone',
        error: error
      });
      throw error;
    });
  }
  /**
   * Load molecule asynchronously.
   * @param {string|File} source - Molecule source to load (e.g. PDB ID, URL or File object).
   * @param {object=} opts - Options.
   * @param {string=} opts.sourceType - Data source type (e.g. 'url', 'file').
   * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
   * @param {string=} opts.mdFile - .nc file path.
   * @param {boolean=} opts.keepRepsInfo - prevent reset of object and reps information.
   * @returns {Promise} name of the visual that was added to the viewer
   */


  Miew.prototype.load = function (source, opts) {
    var _this3 = this;

    opts = ___default['default'].merge({}, opts, {
      context: this
    }); // for a single-file scenario

    if (!this.settings.now.use.multiFile) {
      // abort all loaders in progress
      if (this._loading.length) {
        this._loading.forEach(function (job) {
          job.cancel();
        });

        this._loading.length = 0;
      } // reset


      if (!opts.animation) {
        // FIXME: sometimes it is set AFTERWARDS!
        this.reset(true);
      }
    }

    this._interpolator.reset();

    this.dispatchEvent({
      type: 'loading',
      options: opts,
      source: source
    });
    var job = new JobHandle();

    this._loading.push(job);

    job.addEventListener('notification', function (e) {
      _this3.dispatchEvent(e.slaveEvent);
    });

    this._spinner.spin(this._container);

    var onLoadEnd = function onLoadEnd(anything) {
      var jobIndex = _this3._loading.indexOf(job);

      if (jobIndex !== -1) {
        _this3._loading.splice(jobIndex, 1);
      }

      _this3._spinner.stop();

      _this3._refreshTitle();

      job.notify({
        type: 'loadingDone',
        anything: anything
      });
      return anything;
    };

    return _fetchData(source, opts, job).then(function (data) {
      return _parseData(data, opts, job);
    }).then(function (object) {
      var name = _this3._onLoad(object, opts);

      return onLoadEnd(name);
    })["catch"](function (err) {
      _this3.logger.error('Could not load data');

      _this3.logger.debug(err);

      throw onLoadEnd(err);
    });
  };
  /**
   * Unload molecule (delete corresponding visual).
   * @param {string=} name - name of the visual
   */


  Miew.prototype.unload = function (name) {
    this._removeVisual(name || this.getCurrentVisual());

    this.resetPivot();

    if (settings.now.shadow.on) {
      this._updateShadowCamera();
    }
  };
  /**
   * Start new animation. Now is broken.
   * @param fileData - new data to animate
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._startAnimation = function (fileData) {
    this._stopAnimation();

    var self = this;

    var visual = this._getComplexVisual();

    if (visual === null) {
      this.logger.error('Unable to start animation - no molecule is loaded.');
      return;
    }

    try {
      this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
        onLoadStatusChanged: function onLoadStatusChanged() {
          self.dispatchEvent({
            type: 'mdPlayerStateChanged',
            state: {
              isPlaying: self._isAnimating,
              isLoading: self._frameInfo ? self._frameInfo.isLoading : true
            }
          });
        },
        onError: function onError(message) {
          self._stopAnimation();

          self.logger.error(message);
        }
      });
    } catch (e) {
      this.logger.error('Animation file does not fit to current complex!');
      return;
    }

    this._continueAnimation();
  };
  /**
   * Pause current animation. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._pauseAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    this._isAnimating = false;
    clearInterval(this._animInterval);
    this._animInterval = null;

    if (this._frameInfo) {
      this.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: this._isAnimating,
          isLoading: this._frameInfo.isLoading
        }
      });
    }
  };
  /**
   * Continue current animation after pausing. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._continueAnimation = function () {
    this._isAnimating = true;
    var minFrameTime = 1000 / settings.now.maxfps;
    minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
    var self = this;
    var pivot = self._gfx.pivot;

    var visual = this._getComplexVisual();

    if (visual) {
      visual.resetSelectionMask();
      visual.rebuildSelectionGeometry();
      this._msgAtomInfo.style.opacity = 0.0;
    }

    this._animInterval = setInterval(function () {
      self.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: self._isAnimating,
          isLoading: self._frameInfo.isLoading
        }
      });

      if (self._frameInfo.frameIsReady) {
        pivot.updateToFrame(self._frameInfo);

        self._updateObjsToFrame(self._frameInfo);

        self._refreshTitle(" Frame ".concat(self._frameInfo._currFrame, " of ").concat(self._frameInfo._framesCount, " time interval - ").concat(self._frameInfo._timeStep));

        try {
          self._frameInfo.nextFrame();
        } catch (e) {
          self.logger.error('Error during animation');

          self._stopAnimation();

          return;
        }

        self._needRender = true;
      }
    }, minFrameTime);
  };
  /**
   * Stop current animation. Now is broken.
   * @private
   * @deprecated until animation system refactoring.
   */


  Miew.prototype._stopAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    clearInterval(this._animInterval);

    this._frameInfo.disableEvents();

    this._frameInfo = null;
    this._animInterval = null;
    this.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: null
    });
  };
  /**
   * Invoked upon successful loading of some data source
   * @param {DataSource} dataSource - Data source for visualization (molecular complex or other)
   * @param {object} opts - Options.
   * @private
   */


  Miew.prototype._onLoad = function (dataSource, opts) {
    var gfx = this._gfx;
    var visualName = null;

    if (opts.animation) {
      this._refreshTitle();

      this._startAnimation(dataSource);

      return null;
    }

    this._stopAnimation();

    if (!opts || !opts.keepRepsInfo) {
      this._opts.reps = null;
      this._opts._objects = null;
    }

    if (dataSource.id === 'Complex') {
      var complex = dataSource; // update title

      if (opts.fileName) {
        complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
      } else if (opts.amberFileName) {
        complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
      } else {
        complex.name = "Dynamic ".concat(opts.fileType, " molecule");
      }

      visualName = this._addVisual(new ComplexVisual(complex.name, complex));
      this._curVisualName = visualName;
      var desc = this.info();
      this.logger.info("Parsed ".concat(opts.fileName, " (").concat(desc.atoms, " atoms, ").concat(desc.bonds, " bonds, ").concat(desc.residues, " residues, ").concat(desc.chains, " chains)."));

      if (___default['default'].isNumber(this._opts.unit)) {
        complex.setCurrentUnit(this._opts.unit);
      }

      if (opts.preset) ; else if (settings.now.autoPreset) {
        switch (opts.fileType) {
          case 'cml':
            this.resetReps('small');
            break;

          case 'pdb':
          case 'mmtf':
          case 'cif':
            if (hasValidResidues(complex)) {
              this.resetReps('macro');
            } else {
              this.resetReps('small');
            }

            break;

          default:
            this.resetReps('default');
            break;
        }
      } else {
        this.resetReps('default');
      }
    } else if (dataSource.id === 'Volume') {
      this.resetEd();
      visualName = this._onLoadEd(dataSource);
    }

    gfx.camera.updateProjectionMatrix();

    this._updateFog(); // reset global transform


    gfx.root.resetTransform();
    this.resetPivot(); // set scale to fit everything on the screen

    this._objectControls.setScale(settings.now.radiusToFit / this._getBSphereRadius());

    this._resetObjects();

    if (settings.now.autoResolution) {
      this._tweakResolution();
    }

    if (settings.now.shadow.on) {
      this._updateShadowCamera();
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    this._refreshTitle();

    return visualName;
  };

  Miew.prototype.resetEd = function () {
    if (this._edLoader) {
      this._edLoader.abort();

      this._edLoader = null;
    } // free all resources


    this._removeVisual(this._getVolumeVisual());

    this._needRender = true;
  };

  Miew.prototype.loadEd = function (source) {
    var _this4 = this;

    this.resetEd();

    var TheLoader = ___default['default'].head(io.loaders.find({
      source: source
    }));

    if (!TheLoader) {
      this.logger.error(LOADER_NOT_FOUND);
      return Promise.reject(new Error(LOADER_NOT_FOUND));
    }

    var loader = this._edLoader = new TheLoader(source, {
      binary: true
    });
    loader.context = this;
    return loader.load().then(function (data) {
      var TheParser = ___default['default'].head(io.parsers.find({
        format: 'ccp4'
      }));

      if (!TheParser) {
        throw new Error(PARSER_NOT_FOUND);
      }

      var parser = new TheParser(data);
      parser.context = _this4;
      return parser.parse().then(function (dataSource) {
        _this4._onLoadEd(dataSource);
      });
    })["catch"](function (error) {
      _this4.logger.error('Could not load ED data');

      _this4.logger.debug(error);
    });
  };

  Miew.prototype._onLoadEd = function (dataSource) {
    dataSource.normalize();
    var volumeVisual = new VolumeVisual('volume', dataSource);
    volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME); // volume mesh is not visible to common render

    var visualName = this._addVisual(volumeVisual);

    this._needRender = true;
    return visualName;
  };

  Miew.prototype._needRebuild = function () {
    var needsRebuild = false;

    this._forEachComplexVisual(function (visual) {
      needsRebuild = needsRebuild || visual.needsRebuild();
    });

    return needsRebuild;
  };

  Miew.prototype._rebuildObjects = function () {
    var self = this;
    var gfx = this._gfx;
    var i;
    var n; // remove old object geometry

    var toRemove = [];

    for (i = 0; i < gfx.pivot.children.length; ++i) {
      var child = gfx.pivot.children[i];

      if (!(child instanceof Visual)) {
        toRemove.push(child);
      }
    }

    for (i = 0; i < toRemove.length; ++i) {
      toRemove[i].parent.remove(toRemove[i]);
    }

    setTimeout(function () {
      var objList = self._objects;

      for (i = 0, n = objList.length; i < n; ++i) {
        var obj = objList[i];

        if (obj.needsRebuild) {
          obj.build();
        }

        if (obj.getGeometry()) {
          gfx.pivot.add(obj.getGeometry());
        }
      }
    }, 10);
  };

  Miew.prototype.changeUnit = function (unitIdx, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      throw new Error('There is no complex to change!');
    }

    function currentUnitInfo() {
      var unit = visual ? visual.getComplex().getCurrentUnit() : 0;
      var type = unit > 0 ? "Bio molecule ".concat(unit) : 'Asymmetric unit';
      return "Current unit: ".concat(unit, " (").concat(type, ")");
    }

    if (unitIdx === undefined) {
      return currentUnitInfo();
    }

    if (___default['default'].isString(unitIdx)) {
      unitIdx = Math.max(parseInt(unitIdx, 10), 0);
    }

    if (visual.getComplex().setCurrentUnit(unitIdx)) {
      this._resetScene();

      this._updateInfoPanel();
    }

    return currentUnitInfo();
  };
  /**
   * Start to rebuild geometry asynchronously.
   */


  Miew.prototype.rebuild = function () {
    var _this5 = this;

    if (this._building) {
      this.logger.warn('Miew.rebuild(): already building!');
      return;
    }

    this._building = true;
    this.dispatchEvent({
      type: 'rebuilding'
    });

    this._rebuildObjects();

    this._gfx.renderer2d.reset();

    var rebuildActions = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.needsRebuild()) {
        rebuildActions.push(visual.rebuild().then(function () {
          return new Promise(function (resolve) {
            visual.rebuildSelectionGeometry();
            resolve();
          });
        }));
      }
    }); // Start asynchronous rebuild


    var self = this;

    this._spinner.spin(this._container);

    Promise.all(rebuildActions).then(function () {
      self._spinner.stop();

      self._needRender = true;

      self._refreshTitle();

      _this5.dispatchEvent({
        type: 'buildingDone'
      });

      self._building = false;
    });
  };
  /** Mark all representations for rebuilding */


  Miew.prototype.rebuildAll = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setNeedsRebuild();
    });
  };

  Miew.prototype._refreshTitle = function (appendix) {
    var title;
    appendix = appendix === undefined ? '' : appendix;

    var visual = this._getComplexVisual();

    if (visual) {
      title = visual.getComplex().name;
      var rep = visual.repGet(visual.repCurrent());
      title += rep ? " \u2013 ".concat(rep.mode.name, " Mode") : '';
    } else {
      title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data';
    }

    title += appendix;
    this.dispatchEvent({
      type: 'titleChanged',
      data: title
    });
  };

  Miew.prototype.setNeedRender = function () {
    this._needRender = true;
  };

  Miew.prototype._extractRepresentation = function () {
    var _this6 = this;

    var changed = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.getSelectionCount() === 0) {
        return;
      }

      var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
      var defPreset = settings.now.presets["default"];
      var res = visual.repAdd({
        selector: selector,
        mode: defPreset[0].mode.id,
        colorer: defPreset[0].colorer.id,
        material: defPreset[0].material.id
      });

      if (!res) {
        if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
          _this6.logger.warn("Number of representations is limited to ".concat(ComplexVisual.NUM_REPRESENTATION_BITS));
        }

        return;
      }

      _this6.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });

      visual.repCurrent(res.index);
      changed.push(visual.name);
    });

    if (changed.length > 0) {
      this.logger.report("New representation from selection for complexes: ".concat(changed.join(', ')));
    }
  };
  /**
   * Change current representation list.
   * @param {array} reps - Representation list.
   */


  Miew.prototype._setReps = function (reps) {
    reps = reps || this._opts && this._opts.reps || [];

    this._forEachComplexVisual(function (visual) {
      return visual.resetReps(reps);
    });
  };
  /**
   * Apply existing preset to current scene.
   * @param preset
   */


  Miew.prototype.applyPreset = function (preset) {
    var presets = settings.now.presets;
    var presList = [preset || settings.defaults.preset, settings.defaults.preset, Object.keys(presets)[0]];
    var reps = null;

    for (var i = 0; !reps && i < presList.length; ++i) {
      settings.set('preset', presList[i]);
      reps = presets[settings.now.preset];

      if (!reps) {
        this.logger.warn("Unknown preset \"".concat(settings.now.preset, "\""));
      }
    }

    this._setReps(reps);
  };
  /**
   * Reset current representation list to initial values.
   * @param {string} [preset] - The source preset in case of uninitialized representation list.
   */


  Miew.prototype.resetReps = function (preset) {
    var reps = this._opts && this._opts.reps;

    if (reps) {
      this._setReps(reps);
    } else {
      this.applyPreset(preset);
    }
  };
  /**
   * Get number of representations created so far.
   * @returns {number} Number of reps.
   */


  Miew.prototype.repCount = function (name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repCount() : 0;
  };
  /**
   * Get or set the current representation index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @param {string=} [name] - Complex name. Defaults to the current one.
   * @returns {number} The current index.
   */


  Miew.prototype.repCurrent = function (index, name) {
    var visual = this._getComplexVisual(name);

    var newIdx = visual ? visual.repCurrent(index) : -1;

    if (index && newIdx !== index) {
      this.logger.warn("Representation ".concat(index, " was not found. Current rep remains unchanged."));
    }

    return newIdx;
  };
  /**
   * Get or set representation by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
   * @param {object=} rep - Optional representation description.
   * @param {string=} rep.selector - Selector string.
   * @param {string=} rep.mode - Mode id.
   * @param {string=} rep.colorer - Colorer id.
   * @param {string=} rep.material - Material id.
   * @returns {?object} Representation description.
   */


  Miew.prototype.rep = function (index, rep) {
    var visual = this._getComplexVisual('');

    if (!visual) {
      return null;
    }

    var res = visual.rep(index, rep);

    if (res.status === 'created') {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });
    } else if (res.status === 'changed') {
      this.dispatchEvent({
        type: 'repChanged',
        index: res.index,
        name: visual.name
      });
    }

    return res.desc;
  };
  /**
   * Get representation (not just description) by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
   * @returns {?object} Representation.
   */


  Miew.prototype.repGet = function (index, name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repGet(index) : null;
  };
  /**
   * Add new representation.
   * @param {object=} rep - Representation description.
   * @returns {number} Index of the new representation.
   */


  Miew.prototype.repAdd = function (rep, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return -1;
    }

    var res = visual.repAdd(rep);

    if (res) {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: name
      });
      return res.index;
    }

    return -1;
  };
  /**
   * Remove representation.
   * @param {number=} index - Zero-based representation index.
   */


  Miew.prototype.repRemove = function (index, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return;
    }

    visual.repRemove(index);
    this.dispatchEvent({
      type: 'repRemoved',
      index: index,
      name: name
    });
  };
  /**
   * Hide representation.
   * @param {number} index - Zero-based representation index.
   * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
   */


  Miew.prototype.repHide = function (index, hide, name) {
    this._needRender = true;

    var visual = this._getComplexVisual(name);

    return visual ? visual.repHide(index, hide) : null;
  };

  Miew.prototype._setEditMode = function (mode) {
    this._editMode = mode;
    var elem = this._msgMode;

    if (elem) {
      elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0;

      if (mode !== EDIT_MODE.COMPLEX) {
        var t = elem.getElementsByTagName('p')[0];
        t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
      }
    }

    this.dispatchEvent({
      type: 'editModeChanged',
      data: mode === EDIT_MODE.COMPLEX
    });
  };

  Miew.prototype._enterComponentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var editors = [];

    this._forEachComplexVisual(function (visual) {
      var editor = visual.beginComponentEdit();

      if (editor) {
        editors.push(editor);
      }
    });

    if (editors === []) {
      return;
    }

    this._editors = editors;
    this.logger.info('COMPONENT EDIT MODE -- ON');

    this._setEditMode(EDIT_MODE.COMPONENT);

    this._objectControls.keysTranslateObj(true);
  };

  Miew.prototype._applyComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this.rebuildAll();
  };

  Miew.prototype._discardComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._needRender = true;
    this.rebuildAll();
  };

  Miew.prototype._enterFragmentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var selectedVisuals = [];

    this._forEachComplexVisual(function (visual) {
      if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
        selectedVisuals.push(visual);
      }
    });

    if (selectedVisuals.length !== 1) {
      // either we have no selection or
      // we have selected atoms in two or more visuals -- not supported
      return;
    }

    var editor = selectedVisuals[0].beginFragmentEdit();

    if (!editor) {
      return;
    }

    this._editors = [editor];
    this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)');

    this._setEditMode(EDIT_MODE.FRAGMENT);

    this._objectControls.allowTranslation(false);

    this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());

    this._needRender = true;
  };

  Miew.prototype._applyFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.rebuildAll();
  };

  Miew.prototype._discardFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this._needRender = true;
  };

  Miew.prototype._onPick = function (event) {
    if (!settings.now.picking) {
      // picking is disabled
      return;
    }

    if (this._animInterval !== null) {
      // animation playback is on
      return;
    }

    if (this._editMode === EDIT_MODE.FRAGMENT) {
      // prevent picking in fragment edit mode
      return;
    }

    if (this._objectControls.isEditingAltObj()) {
      // prevent picking during component rotation
      return;
    } // update last pick & find complex


    var complex = null;

    if (event.obj.atom) {
      complex = event.obj.atom.residue.getChain().getComplex();
      this._lastPick = event.obj.atom;
    } else if (event.obj.residue) {
      complex = event.obj.residue.getChain().getComplex();
      this._lastPick = event.obj.residue;
    } else if (event.obj.chain) {
      complex = event.obj.chain.getComplex();
      this._lastPick = event.obj.chain;
    } else if (event.obj.molecule) {
      complex = event.obj.molecule.complex;
      this._lastPick = event.obj.molecule;
    } else {
      this._lastPick = null;
    }

    function _updateSelection(visual) {
      visual.updateSelectionMask(event.obj);
      visual.rebuildSelectionGeometry();
    } // update visual


    if (complex) {
      var visual = this._getVisualForComplex(complex);

      if (visual) {
        _updateSelection(visual);

        this._needRender = true;
      }
    } else {
      this._forEachComplexVisual(_updateSelection);

      this._needRender = true;
    }

    this._updateInfoPanel();

    this.dispatchEvent(event);
  };

  Miew.prototype._onKeyDown = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    switch (event.keyCode) {
      case 'C'.charCodeAt(0):
        if (settings.now.editing) {
          this._enterComponentEditMode();
        }

        break;

      case 'F'.charCodeAt(0):
        if (settings.now.editing) {
          this._enterFragmentEditMode();
        }

        break;

      case 'A'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit();

            break;
        }

        break;

      case 'D'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit();

            break;
        }

        break;

      case 'S'.charCodeAt(0):
        event.preventDefault();
        event.stopPropagation();
        settings.set('ao', !settings.now.ao);
        this._needRender = true;
        break;

      case 107:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.expandSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;

      case 109:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.shrinkSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;
    }
  };

  Miew.prototype._onKeyUp = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    if (event.keyCode === 'X'.charCodeAt(0)) {
      this._extractRepresentation();
    }
  };

  Miew.prototype._updateInfoPanel = function () {
    var info = this._msgAtomInfo.getElementsByTagName('p')[0];

    var atom;
    var residue;
    var count = 0;

    this._forEachComplexVisual(function (visual) {
      count += visual.getSelectionCount();
    });

    while (info.firstChild) {
      info.removeChild(info.firstChild);
    }

    if (count === 0) {
      this._msgAtomInfo.style.opacity = 0.0;
      return;
    }

    var firstLine = "".concat(String(count), " atom").concat(count !== 1 ? 's' : '', " selected");

    if (this._lastPick !== null) {
      firstLine += ', the last pick:';
    }

    var secondLine = '';
    var aName = '';
    var coordLine = '';

    if (this._lastPick instanceof Atom$2) {
      atom = this._lastPick;
      residue = atom.residue;
      aName = atom.name;
      var location = atom.location !== 32 ? String.fromCharCode(atom.location) : ''; // 32 is code of white-space

      secondLine = "".concat(atom.element.fullName, " #").concat(atom.serial).concat(location, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim(), ".");
      secondLine += aName;
      coordLine = "Coord: (".concat(atom.position.x.toFixed(2).toString(), ",     ").concat(atom.position.y.toFixed(2).toString(), ",     ").concat(atom.position.z.toFixed(2).toString(), ")");
    } else if (this._lastPick instanceof Residue$1) {
      residue = this._lastPick;
      secondLine = "".concat(residue._type._fullName, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim());
    } else if (this._lastPick instanceof Chain$2) {
      secondLine = "chain ".concat(this._lastPick._name);
    } else if (this._lastPick instanceof Molecule$8) {
      secondLine = "molecule ".concat(this._lastPick._name);
    }

    info.appendChild(document.createTextNode(firstLine));

    if (secondLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(secondLine));
    }

    if (coordLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(coordLine));
    }

    this._msgAtomInfo.style.opacity = 1.0;
  };

  Miew.prototype._getAltObj = function () {
    if (this._editors) {
      var altObj = null;

      for (var i = 0; i < this._editors.length; ++i) {
        var nextAltObj = this._editors[i].getAltObj();

        if (nextAltObj.objects.length > 0) {
          if (altObj) {
            // we have selected atoms in two or more visuals -- not supported
            altObj = null;
            break;
          }

          altObj = nextAltObj;
        }
      }

      if (altObj) {
        return altObj;
      }
    }

    return {
      objects: [],
      pivot: new THREE.Vector3(0, 0, 0)
    };
  };

  Miew.prototype.resetPivot = function () {
    var boundingBox = new THREE.Box3();
    var center = new THREE.Vector3();
    return function () {
      boundingBox.makeEmpty();

      this._forEachVisual(function (visual) {
        boundingBox.union(visual.getBoundaries().boundingBox);
      });

      boundingBox.getCenter(center);

      this._objectControls.setPivot(center.negate());

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotResidue = function () {
    var center = new THREE.Vector3();
    return function (residue) {
      var visual = this._getVisualForComplex(residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      if (residue._controlPoint) {
        center.copy(residue._controlPoint);
      } else {
        var x = 0;
        var y = 0;
        var z = 0;
        var amount = residue._atoms.length;

        for (var i = 0; i < amount; ++i) {
          var p = residue._atoms[i].position;
          x += p.x / amount;
          y += p.y / amount;
          z += p.z / amount;
        }

        center.set(x, y, z);
      }

      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotAtom = function () {
    var center = new THREE.Vector3();
    return function (atom) {
      var visual = this._getVisualForComplex(atom.residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      center.copy(atom.position);
      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.getSelectionCenter = function () {
    var _centerInVisual = new THREE.Vector3(0.0, 0.0, 0.0);

    return function (center, includesAtom, selector) {
      center.set(0.0, 0.0, 0.0);
      var count = 0;

      this._forEachComplexVisual(function (visual) {
        if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
          center.add(_centerInVisual);
          count++;
        }
      });

      if (count === 0) {
        return false;
      }

      center.divideScalar(count);
      center.negate();
      return true;
    };
  }();

  Miew.prototype.setPivotSubset = function () {
    var _center = new THREE.Vector3(0.0, 0.0, 0.0);

    function _includesInCurSelection(atom, selectionBit) {
      return atom.mask & 1 << selectionBit;
    }

    function _includesInSelector(atom, selector) {
      return selector.selector.includesAtom(atom);
    }

    return function (selector) {
      var includesAtom = selector ? _includesInSelector : _includesInCurSelection;

      if (this.getSelectionCenter(_center, includesAtom, selector)) {
        this._objectControls.setPivot(_center);

        this.dispatchEvent({
          type: 'transform'
        });
      } else {
        this.logger.warn('selection is empty. Center operation not performed');
      }
    };
  }();
  /**
   * Makes a screenshot.
   * @param {number} [width] - Width of an image. Defaults to the canvas width.
   * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
   *        if width is omitted too.
   * @returns {string} Data URL representing the image contents.
   */


  Miew.prototype.screenshot = function (width, height) {
    var gfx = this._gfx;
    var deviceWidth = gfx.renderer.domElement.width;
    var deviceHeight = gfx.renderer.domElement.height;

    function fov2Tan(fov) {
      return Math.tan(THREE.MathUtils.degToRad(0.5 * fov));
    }

    function tan2Fov(tan) {
      return THREE.MathUtils.radToDeg(Math.atan(tan)) * 2.0;
    }

    function getDataURL() {
      var dataURL;
      var currBrowser = utils.getBrowser();

      if (currBrowser === utils.browserType.SAFARI) {
        var canvas = document.createElement('canvas');
        var canvasContext = canvas.getContext('2d');
        canvas.width = width === undefined ? deviceWidth : width;
        canvas.height = height === undefined ? deviceHeight : height;
        canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
        dataURL = canvas.toDataURL('image/png');
      } else {
        // Copy current canvas to screenshot
        dataURL = gfx.renderer.domElement.toDataURL('image/png');
      }

      return dataURL;
    }

    height = height || width;
    var screenshotURI;

    if (width === undefined && height === undefined || width === deviceWidth && height === deviceHeight) {
      // renderer.domElement.toDataURL('image/png') returns flipped image in Safari
      // It hasn't been resolved yet, but getScreenshotSafari()
      // fixes it using an extra canvas.
      screenshotURI = getDataURL();
    } else {
      var originalAspect = gfx.camera.aspect;
      var originalFov = gfx.camera.fov;
      var originalTanFov2 = fov2Tan(gfx.camera.fov); // screenshot should contain the principal area of interest (a centered square touching screen sides)

      var areaOfInterestSize = Math.min(gfx.width, gfx.height);
      var areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height; // set appropriate camera aspect & FOV

      var shotAspect = width / height;
      gfx.renderer.setPixelRatio(1);
      gfx.camera.aspect = shotAspect;
      gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1.0));
      gfx.camera.updateProjectionMatrix(); // resize canvas to the required size of screenshot

      gfx.renderer.setDrawingBufferSize(width, height, 1); // make screenshot

      this._renderFrame(settings.now.stereo);

      screenshotURI = getDataURL(); // restore original camera & canvas proportions

      gfx.renderer.setPixelRatio(window.devicePixelRatio);
      gfx.camera.aspect = originalAspect;
      gfx.camera.fov = originalFov;
      gfx.camera.updateProjectionMatrix();
      gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
      this._needRender = true;
    }

    return screenshotURI;
  };
  /**
   * Makes screenshot and initiates a download.
   * @param {string} [filename] - Name of a file. Default to a 'screenshot-XXXXX.png', where XXXXX is a current
   *        date/time in seconds.
   * @param {number} [width] - Width of an image. Defaults to the canvas width.
   * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
   *        if width is omitted too.
   */


  Miew.prototype.screenshotSave = function (filename, width, height) {
    var uri = this.screenshot(width, height);
    utils.shotDownload(uri, filename);
  };

  Miew.prototype.save = function (opts) {
    var _this7 = this;

    this._export(opts.fileType).then(function (dataString) {
      var filename = _this7._visuals[_this7._curVisualName]._complex.name;
      utils.download(dataString, filename, opts.fileType);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone'
      });
    })["catch"](function (error) {
      _this7.logger.error('Could not export data');

      _this7.logger.debug(error);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone',
        error: error
      });
    });
  };

  Miew.prototype._tweakResolution = function () {
    var maxPerf = [['poor', 100], ['low', 500], ['medium', 1000], ['high', 5000], ['ultra', Number.MAX_VALUE]];
    var atomCount = 0;

    this._forEachComplexVisual(function (visual) {
      atomCount += visual.getComplex().getAtomCount();
    });

    if (atomCount > 0) {
      var performance = this._gfxScore * 10e5 / atomCount; // set resolution based on estimated performance

      for (var i = 0; i < maxPerf.length; ++i) {
        if (performance < maxPerf[i][1]) {
          this._autoChangeResolution(maxPerf[i][0]);

          break;
        }
      }
    }
  };

  Miew.prototype._autoChangeResolution = function (resolution) {
    if (resolution !== settings.now.resolution) {
      this.logger.report("Your rendering resolution was changed to \"".concat(resolution, "\" for best performance."));
    }

    settings.now.resolution = resolution;
  };
  /**
   * Save current settings to cookies.
   */


  Miew.prototype.saveSettings = function () {
    this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
  };
  /**
   * Load settings from cookies.
   */


  Miew.prototype.restoreSettings = function () {
    try {
      var cookie = this._cookies.getCookie(this._opts.settingsCookie);

      var diffs = cookie ? JSON.parse(cookie) : {};
      this.settings.applyDiffs(diffs, true);
    } catch (e) {
      this.logger.error("Cookies parse error: ".concat(e.message));
    }
  };
  /**
   * Reset current settings to the defaults.
   */


  Miew.prototype.resetSettings = function () {
    this.settings.reset();
  };
  /*
     * DANGEROUS and TEMPORARY. The method should change or disappear in future versions.
     * @param {string|object} opts - See {@link Miew} constructor.
     * @see {@link Miew#set}, {@link Miew#repAdd}, {@link Miew#rep}.
     */


  Miew.prototype.setOptions = function (opts) {
    if (typeof opts === 'string') {
      opts = Miew.options.fromAttr(opts);
    }

    if (opts.reps) {
      this._opts.reps = null;
    }

    ___default['default'].merge(this._opts, opts);

    if (opts.settings) {
      this.set(opts.settings);
    }

    this._opts._objects = opts._objects;

    this._resetObjects();

    if (opts.load) {
      this.load(opts.load, {
        fileType: opts.type
      });
    }

    if (opts.preset) {
      settings.now.preset = opts.preset;
    }

    if (opts.reps) {
      this.resetReps(opts.preset);
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    var visual = this._getComplexVisual();

    if (visual) {
      visual.getComplex().resetCurrentUnit();

      if (___default['default'].isNumber(opts.unit)) {
        visual.getComplex().setCurrentUnit(opts.unit);
      }

      this.resetView();
      this.rebuildAll();
    }
  };

  Miew.prototype.info = function (name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return {};
    }

    var complex = visual.getComplex();
    var metadata = complex.metadata;
    return {
      id: metadata.id || complex.name || 'UNKNOWN',
      title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
      atoms: complex.getAtomCount(),
      bonds: complex.getBondCount(),
      residues: complex.getResidueCount(),
      chains: complex.getChainCount()
    };
  };
  /*
     * OBJECTS SEGMENT
     */


  Miew.prototype.addObject = function (objData, bThrow) {
    var Ctor = null;

    if (objData.type === LinesObj.prototype.type) {
      Ctor = LinesObj;
    }

    if (Ctor === null) {
      throw new Error("Unknown scene object type - ".concat(objData.type));
    }

    try {
      var newObj = new Ctor(objData.params, objData.opts);

      this._addSceneObject(newObj);
    } catch (error) {
      if (!bThrow) {
        this.logger.debug("Error during scene object creation: ".concat(error.message));
      } else {
        throw error;
      }
    }

    this._needRender = true;
  };

  Miew.prototype._addSceneObject = function (sceneObject) {
    var visual = this._getComplexVisual();

    if (sceneObject.build && visual) {
      sceneObject.build(visual.getComplex());

      this._gfx.pivot.add(sceneObject.getGeometry());
    }

    var objects = this._objects;
    objects[objects.length] = sceneObject;
  };

  Miew.prototype._updateObjsToFrame = function (frameData) {
    var objs = this._objects;

    for (var i = 0, n = objs.length; i < n; ++i) {
      if (objs[i].updateToFrame) {
        objs[i].updateToFrame(frameData);
      }
    }
  };

  Miew.prototype._resetObjects = function () {
    var objs = this._opts._objects;
    this._objects = [];

    if (objs) {
      for (var i = 0, n = objs.length; i < n; ++i) {
        this.addObject(objs[i], false);
      }
    }
  };

  Miew.prototype.removeObject = function (index) {
    var obj = this._objects[index];

    if (!obj) {
      throw new Error("Scene object with index ".concat(index, " does not exist"));
    }

    obj.destroy();

    this._objects.splice(index, 1);

    this._needRender = true;
  };
  /**
   * Get a string with a URL to reproduce the current scene.
   *
   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
   * preset information regardless of the differences with settings
   * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
   * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
   * @returns {string} URL
   */


  Miew.prototype.getURL = function (opts) {
    return options.toURL(this.getState(___default['default'].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    })));
  };
  /**
   * Get a string with a script to reproduce the current scene.
   *
   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
   * preset information regardless of the differences with settings
   * @param {boolean} [opts.settings=true] - when this flag is true, changes in settings are included
   * @param {boolean} [opts.view=true] - when this flag is true, a view information is included
   * @returns {string} script
   */


  Miew.prototype.getScript = function (opts) {
    return options.toScript(this.getState(___default['default'].defaults(opts, {
      compact: true,
      settings: true,
      view: true
    })));
  };
  /*
     * Generates object that represents the current state of representations list
     * @param {boolean} compareWithDefaults - when this flag is true, reps list is compared (if possible)
     * to preset's defaults and only diffs are generated
     */


  Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
    var ans = {};
    var repCount = 0;

    if (complexVisual) {
      repCount = complexVisual.repCount();
    }

    var currPreset = settings.defaults.presets[settings.now.preset];
    var compare = compareWithDefaults;

    if (currPreset === undefined || currPreset.length > repCount) {
      compare = false;
      ans.preset = 'empty';
    } else if (settings.now.preset !== settings.defaults.preset) {
      ans.preset = settings.now.preset;
    }

    var repsDiff = [];
    var emptyReps = true;

    for (var i = 0, n = repCount; i < n; ++i) {
      repsDiff[i] = complexVisual.repGet(i).compare(compare ? currPreset[i] : null);

      if (!___default['default'].isEmpty(repsDiff[i])) {
        emptyReps = false;
      }
    }

    if (!emptyReps) {
      ans.reps = repsDiff;
    }

    return ans;
  };
  /*
     * Obtain object that represents current state of miew (might be used as options in constructor).
     * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
     * preset information regardless of the differences with settings
     * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
     * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
     * @returns {Object} State object.
     */


  Miew.prototype.getState = function (opts) {
    var state = {};
    opts = ___default['default'].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    }); // load

    var visual = this._getComplexVisual();

    if (visual !== null) {
      var complex = visual.getComplex();
      var metadata = complex.metadata;

      if (metadata.id) {
        var format = metadata.format ? "".concat(metadata.format, ":") : '';
        state.load = format + metadata.id;
      }

      var unit = complex.getCurrentUnit();

      if (unit !== 1) {
        state.unit = unit;
      }
    } // representations


    var repsInfo = this._compareReps(visual, opts.compact);

    if (repsInfo.preset) {
      state.preset = repsInfo.preset;
    }

    if (repsInfo.reps) {
      state.reps = repsInfo.reps;
    } // objects


    var objects = this._objects;
    var objectsState = [];

    for (var i = 0, n = objects.length; i < n; ++i) {
      objectsState[i] = objects[i].identify();
    }

    if (objects.length > 0) {
      state._objects = objectsState;
    } // view


    if (opts.view) {
      state.view = this.view();
    } // settings


    if (opts.settings) {
      var diff = this.settings.getDiffs(false);

      if (!___default['default'].isEmpty(diff)) {
        state.settings = diff;
      }
    }

    return state;
  };
  /**
   * Get parameter value.
   * @param {string} param - Parameter name or path (e.g. 'modes.BS.atom').
   * @param {*=} value - Default value.
   * @returns {*} Parameter value.
   */


  Miew.prototype.get = function (param, value) {
    return settings.get(param, value);
  };

  Miew.prototype._clipPlaneUpdateValue = function (radius) {
    var clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings.now.draft.clipPlaneFactor, settings.now.camNear);
    var opts = {
      clipPlaneValue: clipPlaneValue
    };

    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions(opts);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setUberOptions(opts);
      }
    }

    if (this._picker !== null) {
      this._picker.clipPlaneValue = clipPlaneValue;
    }
  };

  Miew.prototype._fogFarUpdateValue = function () {
    if (this._picker !== null) {
      if (this._gfx.scene.fog) {
        this._picker.fogFarValue = this._gfx.scene.fog.far;
      } else {
        this._picker.fogFarValue = undefined;
      }
    }
  };

  Miew.prototype._updateShadowmapMeshes = function (process) {
    this._forEachComplexVisual(function (visual) {
      var reprList = visual._reprList;

      for (var i = 0, n = reprList.length; i < n; ++i) {
        var repr = reprList[i];
        process(repr.geo, repr.material);
      }
    });
  };

  Miew.prototype._updateMaterials = function (values) {
    var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    this._forEachComplexVisual(function (visual) {
      return visual.setMaterialValues(values, needTraverse, process);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setValues(values);

        obj._line.material.needsUpdate = true;
      }
    }
  };

  Miew.prototype._fogAlphaChanged = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions({
        fogAlpha: settings.now.fogAlpha
      });
    });
  };

  Miew.prototype._embedWebXR = function () {
    var _this8 = this;

    // switch off
    if (settings.now.stereo !== 'WEBVR') {
      if (this.webVR) {
        this.webVR.disable();
      }

      this.webVR = null;
      return;
    } // switch on


    if (!this.webVR) {
      this.webVR = new WebVRPoC(function () {
        _this8._requestAnimationFrame(function () {
          return _this8._onTick();
        });

        _this8._needRender = true;

        _this8._onResize();
      });
    }

    this.webVR.enable(this._gfx);
  };

  Miew.prototype._initOnSettingsChanged = function () {
    var _this9 = this;

    var on = function on(props, func) {
      props = ___default['default'].isArray(props) ? props : [props];
      props.forEach(function (prop) {
        _this9.settings.addEventListener("change:".concat(prop), func);
      });
    };

    on('modes.VD.frame', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.showFrame(settings.now.modes.VD.frame);
      _this9._needRender = true;
    });
    on('modes.VD.isoMode', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.getMesh().material.updateDefines();
      _this9._needRender = true;
    });
    on('bg.color', function () {
      _this9._onBgColorChanged();
    });
    on('ao', function () {
      if (settings.now.ao && !isAOSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support ao');

        settings.set('ao', false);
      } else {
        var values = {
          normalsToGBuffer: settings.now.ao
        };

        _this9._setUberMaterialValues(values);
      }
    });
    on('zSprites', function () {
      if (settings.now.zSprites && !arezSpritesSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support zSprites');

        settings.set('zSprites', false);
      }

      _this9.rebuildAll();
    });
    on('fogColor', function () {
      _this9._onFogColorChanged();
    });
    on('fogColorEnable', function () {
      _this9._onFogColorChanged();
    });
    on('bg.transparent', function (evt) {
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
      } // update materials


      _this9._updateMaterials({
        fogTransparent: evt.value
      });

      _this9.rebuildAll();
    });
    on('draft.clipPlane', function (evt) {
      // update materials
      _this9._updateMaterials({
        clipPlane: evt.value
      });

      _this9.rebuildAll();
    });
    on('shadow.on', function (evt) {
      // update materials
      var values = {
        shadowmap: evt.value,
        shadowmapType: settings.now.shadow.type
      };
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
      }

      _this9._updateMaterials(values, true);

      if (values.shadowmap) {
        _this9._updateShadowCamera();

        _this9._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
      } else {
        _this9._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
      }

      _this9._needRender = true;
    });
    on('shadow.type', function (evt) {
      // update materials if shadowmap is enable
      if (settings.now.shadow.on) {
        _this9._updateMaterials({
          shadowmapType: evt.value
        }, true);

        _this9._needRender = true;
      }
    });
    on('shadow.radius', function (evt) {
      for (var i = 0; i < _this9._gfx.scene.children.length; i++) {
        if (_this9._gfx.scene.children[i].shadow !== undefined) {
          var light = _this9._gfx.scene.children[i];
          light.shadow.radius = evt.value;
          _this9._needRender = true;
        }
      }
    });
    on('fps', function () {
      _this9._fps.show(settings.now.fps);
    });
    on(['fog', 'fogNearFactor', 'fogFarFactor'], function () {
      _this9._updateFog();

      _this9._needRender = true;
    });
    on('fogAlpha', function () {
      var fogAlpha = settings.now.fogAlpha;

      if (fogAlpha < 0 || fogAlpha > 1) {
        _this9.logger.warn('fogAlpha must belong range [0,1]');
      }

      _this9._fogAlphaChanged();

      _this9._needRender = true;
    });
    on('autoResolution', function (evt) {
      if (evt.value && !_this9._gfxScore) {
        _this9.logger.warn('Benchmarks are missed, autoresolution will not work! ' + 'Autoresolution should be set during miew startup.');
      }
    });
    on('stereo', function () {
      _this9._embedWebXR(settings.now.stereo === 'WEBVR');

      _this9._needRender = true;
    });
    on(['transparency', 'palette'], function () {
      _this9.rebuildAll();
    });
    on('resolution', function () {
      // update complex visuals
      _this9.rebuildAll(); // update volume visual


      var volume = _this9._getVolumeVisual();

      if (volume) {
        volume.getMesh().material.updateDefines();
        _this9._needRender = true;
      }
    });
    on(['axes', 'fxaa', 'ao', 'outline.on', 'outline.color', 'outline.threshold', 'outline.thickness'], function () {
      _this9._needRender = true;
    });
  };
  /**
   * Set parameter value.
   * @param {string|object} params - Parameter name or path (e.g. 'modes.BS.atom') or even settings object.
   * @param {*=} value - Value.
   */


  Miew.prototype.set = function (params, value) {
    settings.set(params, value);
  };
  /**
   * Select atoms with selection string.
   * @param {string} expression - string expression of selection
   * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
   */


  Miew.prototype.select = function (expression, append) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return;
    }

    var sel = expression;

    if (___default['default'].isString(expression)) {
      sel = selectors$4.parse(expression).selector;
    }

    visual.select(sel, append);
    this._lastPick = null;

    this._updateInfoPanel();

    this._needRender = true;
  };

  var VIEW_VERSION = '1';
  /**
   * Get or set view info packed into string.
   *
   * **Note:** view is stored for *left-handed* cs, euler angles are stored in radians and *ZXY-order*,
   *
   * @param {string=} expression - Optional string encoded the view
   */

  Miew.prototype.view = function (expression) {
    var self = this;
    var pivot = this._gfx.pivot;
    var transform = [];
    var eulerOrder = 'ZXY';

    function encode() {
      var pos = pivot.position;
      var scale = self._objectControls.getScale() / settings.now.radiusToFit;
      var euler = new THREE.Euler();
      euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder);
      transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
      return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
    }

    function decode() {
      // backwards compatible: old non-versioned view is the 0th version
      if (expression.length === 40) {
        expression = "0".concat(expression);
      }

      var version = expression[0];
      transform = utils.arrayFromBase64(expression.substr(1), Float32Array); // apply adapter for old versions

      if (version !== VIEW_VERSION) {
        if (version === '0') {
          // cancel radiusToFit included in old views
          transform[3] /= 8.0;
        } else {
          // do nothing
          self.logger.warn("Encoded view version mismatch, stored as ".concat(version, " vs ").concat(VIEW_VERSION, " expected"));
          return;
        }
      }

      var interpolator = self._interpolator;
      var srcView = interpolator.createView();
      srcView.position.copy(pivot.position);
      srcView.scale = self._objectControls.getScale();
      srcView.orientation.copy(self._objectControls.getOrientation());
      var dstView = interpolator.createView();
      dstView.position.set(transform[0], transform[1], transform[2]); // hack to make preset views work after we moved centering offset to visual nodes
      // FIXME should only store main pivot offset in preset

      if (self._getComplexVisual()) {
        dstView.position.sub(self._getComplexVisual().position);
      }

      dstView.scale = transform[3]; // eslint-disable-line prefer-destructuring

      dstView.orientation.setFromEuler(new THREE.Euler(transform[4], transform[5], transform[6], eulerOrder));
      interpolator.setup(srcView, dstView);
    }

    if (typeof expression === 'undefined') {
      return encode();
    }

    decode();
    return expression;
  };
  /*
     * Update current view due to viewinterpolator state
     */


  Miew.prototype._updateView = function () {
    var self = this;
    var pivot = this._gfx.pivot;
    var interpolator = this._interpolator;

    if (!interpolator.wasStarted()) {
      interpolator.start();
    }

    if (!interpolator.isMoving()) {
      return;
    }

    var res = interpolator.getCurrentView();

    if (res.success) {
      var curr = res.view;
      pivot.position.copy(curr.position);

      self._objectControls.setScale(curr.scale * settings.now.radiusToFit);

      self._objectControls.setOrientation(curr.orientation);

      this.dispatchEvent({
        type: 'transform'
      });
      self._needRender = true;
    }
  };
  /**
   * Translate object by vector
   * @param {number} x - translation value (Ang) along model's X axis
   * @param {number} y - translation value (Ang) along model's Y axis
   * @param {number} z - translation value (Ang) along model's Z axis
   */


  Miew.prototype.translate = function (x, y, z) {
    this._objectControls.translatePivot(x, y, z);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Rotate object by Euler angles
   * @param {number} x - rotation angle around X axis in radians
   * @param {number} y - rotation angle around Y axis in radians
   * @param {number} z - rotation angle around Z axis in radians
   */


  Miew.prototype.rotate = function (x, y, z) {
    this._objectControls.rotate(new THREE.Quaternion().setFromEuler(new THREE.Euler(x, y, z, 'XYZ')));

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Scale object by factor
   * @param {number} factor - scale multiplier, should greater than zero
   */


  Miew.prototype.scale = function (factor) {
    if (factor <= 0) {
      throw new RangeError('Scale should be greater than zero');
    }

    this._objectControls.scale(factor);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };
  /**
   * Center view on selection
   * @param {empty | subset | string} selector - defines part of molecule which must be centered (
   * empty - center on current selection;
   * subset - center on picked atom/residue/molecule;
   * string - center on atoms correspond to selection string)
   */


  Miew.prototype.center = function (selector) {
    // no arguments - center on current selection;
    if (selector === undefined) {
      this.setPivotSubset();
      this._needRender = true;
      return;
    } // subset with atom or residue - center on picked atom/residue;


    if (selector.obj !== undefined && ('atom' in selector.obj || 'residue' in selector.obj)) {
      // from event with selection
      if ('atom' in selector.obj) {
        this.setPivotAtom(selector.obj.atom);
      } else {
        this.setPivotResidue(selector.obj.residue);
      }

      this._needRender = true;
      return;
    } // string - center on atoms correspond to selection string


    if (selector.obj === undefined && selector !== '') {
      var sel = selectors$4.parse(selector);

      if (sel.error === undefined) {
        this.setPivotSubset(sel);
        this._needRender = true;
        return;
      }
    } // empty subset or incorrect/empty string - center on all molecule;


    this.resetPivot();
    this._needRender = true;
  };
  /**
   * Build selector that contains all atoms within given distance from group of atoms
   * @param {Selector} selector - selector describing source group of atoms
   * @param {number} radius - distance
   * @returns {Selector} selector describing result group of atoms
   */


  Miew.prototype.within = function (selector, radius) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return selectors$4.None();
    }

    if (selector instanceof String) {
      selector = selectors$4.parse(selector);
    }

    var res = visual.within(selector, radius);

    if (res) {
      visual.rebuildSelectionGeometry();
      this._needRender = true;
    }

    return res;
  };
  /**
   * Get atom position in 2D canvas coords
   * @param {string} fullAtomName - full atom name, like A.38.CG
   * @returns {Object} {x, y} or false if atom not found
   */


  Miew.prototype.projected = function (fullAtomName, complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return false;
    }

    var atom = visual.getComplex().getAtomByFullname(fullAtomName);

    if (atom === null) {
      return false;
    }

    var pos = atom.position.clone(); // we consider atom position to be affected only by common complex transform
    // ignoring any transformations that may add during editing

    this._gfx.pivot.updateMatrixWorldRecursive();

    this._gfx.camera.updateMatrixWorldRecursive();

    this._gfx.pivot.localToWorld(pos);

    pos.project(this._gfx.camera);
    return {
      x: (pos.x + 1.0) * 0.5 * this._gfx.width,
      y: (1.0 - pos.y) * 0.5 * this._gfx.height
    };
  };
  /**
   * Replace secondary structure with calculated one.
   *
   * DSSP algorithm implementation is used.
   *
   * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
   * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
   *
   * @param {string=} complexName - complex name
   */


  Miew.prototype.dssp = function (complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return;
    }

    visual.getComplex().dssp(); // rebuild dependent representations (cartoon or ss-colored)

    visual._reprList.forEach(function (rep) {
      if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
        rep.needsRebuild = true;
      }
    });
  };

  Miew.prototype.exportCML = function () {
    var self = this;

    function extractRotation(m) {
      var xAxis = new THREE.Vector3();
      var yAxis = new THREE.Vector3();
      var zAxis = new THREE.Vector3();
      m.extractBasis(xAxis, yAxis, zAxis);
      xAxis.normalize();
      yAxis.normalize();
      zAxis.normalize();
      var retMat = new THREE.Matrix4();
      retMat.identity();
      retMat.makeBasis(xAxis, yAxis, zAxis);
      return retMat;
    }

    function updateCMLData(complex) {
      var root = self._gfx.root;
      var mat = extractRotation(root.matrixWorld);
      var v4 = new THREE.Vector4(0, 0, 0, 0);
      var vCenter = new THREE.Vector4(0, 0, 0, 0);
      var xml = null;
      var ap = null; // update atoms in cml

      complex.forEachAtom(function (atom) {
        if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
          xml = atom.xmlNodeRef.xmlNode;
          ap = atom.position;
          v4.set(ap.x, ap.y, ap.z, 1.0);
          v4.applyMatrix4(mat);
          xml.setAttribute('x3', v4.x.toString());
          xml.setAttribute('y3', v4.y.toString());
          xml.setAttribute('z3', v4.z.toString());
          xml.removeAttribute('x2');
          xml.removeAttribute('y2');
        }
      }); // update stereo groups in cml

      complex.forEachSGroup(function (sGroup) {
        if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
          xml = sGroup.xmlNodeRef.xmlNode;
          ap = sGroup.getPosition();
          v4.set(ap.x, ap.y, ap.z, 1.0);
          var cp = sGroup.getCentralPoint();

          if (cp === null) {
            v4.applyMatrix4(mat);
          } else {
            vCenter.set(cp.x, cp.y, cp.z, 0.0);
            v4.add(vCenter);
            v4.applyMatrix4(mat); // pos in global space

            vCenter.set(cp.x, cp.y, cp.z, 1.0);
            vCenter.applyMatrix4(mat);
            v4.sub(vCenter);
          }

          xml.setAttribute('x', v4.x.toString());
          xml.setAttribute('y', v4.y.toString());
          xml.setAttribute('z', v4.z.toString());
        }
      });
    }

    var visual = self._getComplexVisual();

    var complex = visual ? visual.getComplex() : null;

    if (complex && complex.originalCML) {
      updateCMLData(complex); // serialize xml structure to string

      var oSerializer = new XMLSerializer();
      return oSerializer.serializeToString(complex.originalCML);
    }

    return null;
  };
  /**
   * Reproduce the RCSB PDB Molecule of the Month style by David S. Goodsell
   *
   * @see http://pdb101.rcsb.org/motm/motm-about
   */


  Miew.prototype.motm = function () {
    settings.set({
      fogColorEnable: true,
      fogColor: 0x000000,
      outline: {
        on: true,
        threshold: 0.01
      },
      bg: {
        color: 0xffffff
      }
    });

    this._forEachComplexVisual(function (visual) {
      var rep = [];
      var complex = visual.getComplex();
      var palette = palettes.get(settings.now.palette);

      for (var i = 0; i < complex.getChainCount(); i++) {
        var curChainName = complex._chains[i]._name;
        var curChainColor = palette.getChainColor(curChainName);
        rep[i] = {
          selector: "chain ".concat(curChainName),
          mode: 'VW',
          colorer: ['CB', {
            color: curChainColor,
            factor: 0.9
          }],
          material: 'FL'
        };
      }

      visual.resetReps(rep);
    });
  };

  Miew.prototype.VERSION =  "0.9.0+20230822.103925.6b542ed" ; // Uncomment this to get debug trace:
  // Miew.prototype.debugTracer = new utils.DebugTracer(Miew.prototype);

  ___default['default'].assign(Miew,
  /** @lends Miew */
  {
    VERSION: Miew.prototype.VERSION,
    registeredPlugins: [],
    // export namespaces // TODO: WIP: refactoring external interface
    chem: chem,
    io: io,
    modes: modes,
    colorers: colorers,
    materials: materials,
    palettes: palettes,
    options: options,
    settings: settings,
    utils: utils,
    gfx: {
      Representation: Representation
    },

    /**
     * Third-party libraries packaged together with Miew.
     *
     * @property {object} lodash - [Lodash](https://lodash.com/), a modern JavaScript utility library delivering
     *   modularity, performance & extras.
     * @property {object} three - [three.js](https://threejs.org/), JavaScript 3D library.
     *
     * @example
     * var _ = Miew.thirdParty.lodash;
     * var opts = _.merge({ ... }, Miew.options.fromURL(window.location.search));
     * var miew = new Miew(opts);
     */
    thirdParty: {
      lodash: ___default['default'],
      three: THREE__namespace
    }
  });

  /* eslint-disable */
  // DO NOT EDIT! Automatically generated from .jison
  /* parser generated by jison 0.4.18 */
  /*
    Returns a Parser object of the following structure:

    Parser: {
      yy: {}
    }

    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),

          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },

          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }


    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }


    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser$1 = (function(){
  var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,60],$V1=[1,62],$V2=[1,63],$V3=[1,65],$V4=[1,66],$V5=[1,67],$V6=[1,68],$V7=[1,69],$V8=[1,80],$V9=[1,72],$Va=[1,73],$Vb=[1,74],$Vc=[1,75],$Vd=[1,99],$Ve=[1,76],$Vf=[1,100],$Vg=[1,79],$Vh=[1,51],$Vi=[1,81],$Vj=[1,82],$Vk=[1,84],$Vl=[1,83],$Vm=[1,85],$Vn=[1,96],$Vo=[1,97],$Vp=[1,98],$Vq=[1,86],$Vr=[1,87],$Vs=[1,64],$Vt=[1,70],$Vu=[1,71],$Vv=[1,77],$Vw=[1,78],$Vx=[1,53],$Vy=[1,54],$Vz=[1,55],$VA=[1,61],$VB=[1,88],$VC=[1,89],$VD=[1,90],$VE=[1,91],$VF=[1,92],$VG=[1,93],$VH=[1,94],$VI=[1,95],$VJ=[1,101],$VK=[1,102],$VL=[1,103],$VM=[1,104],$VN=[1,105],$VO=[1,56],$VP=[1,57],$VQ=[1,58],$VR=[1,59],$VS=[1,115],$VT=[1,111],$VU=[1,114],$VV=[1,112],$VW=[1,113],$VX=[1,118],$VY=[1,117],$VZ=[1,134],$V_=[1,149],$V$=[1,150],$V01=[1,157],$V11=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],$V21=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,71,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],$V31=[5,6,7,9,13,15,17,18,19,20,23,25,26,27,30,33,34,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,82,83,84,85,86,87,88,89,90,91,92,93,94,95],$V41=[5,70,72],$V51=[5,74],$V61=[71,101];
  var parser = {trace: function trace () { },
  yy: {},
  symbols_: {"error":2,"Program":3,"Command":4,"EOF":5,"RESET":6,"BUILD":7,"ALL":8,"HELP":9,"Path":10,"MOTM":11,"OneArgCommand":12,"GET":13,"STRING":14,"SET":15,"Value":16,"SET_SAVE":17,"SET_RESTORE":18,"SET_RESET":19,"PRESET":20,"AddRepresentation":21,"EditRepresentation":22,"REMOVE":23,"RepresentationReference":24,"HIDE":25,"SHOW":26,"LIST":27,"EXPAND_KEY":28,"SELECTOR_KEY":29,"SELECT":30,"AS":31,"WordAll":32,"SELECTOR":33,"WITHIN":34,"NUMBER":35,"OF":36,"MATERIAL":37,"IDENTIFIER":38,"ModeCMD":39,"ColorCMD":40,"VIEW":41,"BASE_64":42,"UNIT":43,"DSSP":44,"SCALE":45,"ROTATE":46,"AxesList":47,"TRANSLATE":48,"CENTER":49,"GetURLBranch":50,"Screenshot":51,"LINE":52,"ArgList":53,"LISTOBJ":54,"REMOVEOBJ":55,"URL":56,"VIEW_KEY":57,"SCREENSHOT":58,"LOAD":59,"Url":60,"FILE_KEY":61,"ADD":62,"Description":63,"REP":64,"MODE":65,"COLOR":66,"Descriptor":67,"RepresentationOwnProperty":68,"RepresentationOwnPropertyOpts":69,"DESC_KEY":70,"=":71,"DESC_KEY_OPTS":72,"AxesArg":73,"DESC_KEY_AXES":74,"Arg":75,"PathWoDescKey":76,"HEX":77,"BOOL":78,"Word":79,"CommandSetWoDESC_KEY":80,"DescKeys":81,"CLEAR":82,"FILE_LIST":83,"FILE_REGISTER":84,"FILE_DELETE":85,"PRESET_ADD":86,"PRESET_DELETE":87,"PRESET_UPDATE":88,"PRESET_RENAME":89,"PRESET_OPEN":90,"CREATE_SCENARIO":91,"RESET_SCENARIO":92,"DELETE_SCENARIO":93,"ADD_SCENARIO_ITEM":94,"LIST_SCENARIO":95,"PDB_KEY":96,"DELAY_KEY":97,"PRST_KEY":98,"DESCRIPTION_KEY":99,"CommandSet":100,".":101,"PresetPath":102,"/":103,"HexOrNumber":104,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",6:"RESET",7:"BUILD",8:"ALL",9:"HELP",11:"MOTM",13:"GET",14:"STRING",15:"SET",17:"SET_SAVE",18:"SET_RESTORE",19:"SET_RESET",20:"PRESET",23:"REMOVE",25:"HIDE",26:"SHOW",27:"LIST",28:"EXPAND_KEY",29:"SELECTOR_KEY",30:"SELECT",31:"AS",33:"SELECTOR",34:"WITHIN",35:"NUMBER",36:"OF",37:"MATERIAL",38:"IDENTIFIER",41:"VIEW",42:"BASE_64",43:"UNIT",44:"DSSP",45:"SCALE",46:"ROTATE",48:"TRANSLATE",49:"CENTER",52:"LINE",54:"LISTOBJ",55:"REMOVEOBJ",56:"URL",57:"VIEW_KEY",58:"SCREENSHOT",59:"LOAD",61:"FILE_KEY",62:"ADD",64:"REP",65:"MODE",66:"COLOR",70:"DESC_KEY",71:"=",72:"DESC_KEY_OPTS",74:"DESC_KEY_AXES",77:"HEX",78:"BOOL",82:"CLEAR",83:"FILE_LIST",84:"FILE_REGISTER",85:"FILE_DELETE",86:"PRESET_ADD",87:"PRESET_DELETE",88:"PRESET_UPDATE",89:"PRESET_RENAME",90:"PRESET_OPEN",91:"CREATE_SCENARIO",92:"RESET_SCENARIO",93:"DELETE_SCENARIO",94:"ADD_SCENARIO_ITEM",95:"LIST_SCENARIO",96:"PDB_KEY",97:"DELAY_KEY",98:"PRST_KEY",99:"DESCRIPTION_KEY",101:".",103:"/"},
  productions_: [0,[3,2],[3,1],[4,1],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,3],[4,3],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,2],[4,4],[4,2],[4,6],[4,2],[4,1],[4,1],[4,1],[4,2],[4,2],[4,1],[4,2],[4,1],[4,2],[4,2],[4,2],[4,1],[4,2],[4,1],[4,1],[4,3],[4,3],[4,4],[4,4],[4,1],[4,2],[50,1],[50,2],[50,2],[50,3],[50,3],[51,1],[51,2],[51,3],[12,2],[12,2],[12,2],[21,1],[21,2],[21,2],[21,3],[22,2],[22,3],[39,2],[39,3],[40,2],[40,3],[24,1],[24,1],[63,1],[63,2],[63,3],[63,4],[67,1],[67,1],[67,2],[68,3],[69,3],[47,1],[47,2],[73,2],[53,1],[53,2],[75,3],[16,1],[16,1],[16,1],[16,1],[16,1],[79,1],[79,1],[32,1],[32,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[100,1],[100,1],[76,1],[76,3],[76,3],[10,1],[10,1],[10,3],[10,3],[10,3],[60,1],[102,1],[102,3],[104,1],[104,1]],
  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
  /* this == yyval */

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1:
   return $$[$0-1]; 
  case 3:
  this.$ = yy.miew.reset(false); yy.ClearContext(); yy.miew.resetReps("empty");
  break;
  case 4:
  this.$ = yy.miew.rebuild();
  break;
  case 5:
  this.$ = yy.miew.rebuildAll(); yy.miew.rebuild();
  break;
  case 6:
  this.$ = yy.echo(yy.utils.help().toString());
  break;
  case 7:
  this.$ = yy.echo(yy.utils.help($$[$0]).toString());
  break;
  case 8:
  this.$ = yy.miew.motm();
  break;
  case 10: case 11:
  this.$ = yy.utils.propagateProp($$[$0]); yy.echo(yy.miew.get($$[$0]).toString());
  break;
  case 12: case 13:
  this.$ = yy.miew.set($$[$0-1], yy.utils.propagateProp($$[$0-1], $$[$0]));break;
  case 14:
  this.$ = yy.miew.saveSettings();break;
  case 15:
  this.$ = yy.miew.restoreSettings();break;
  case 16:
  this.$ = yy.miew.resetSettings();break;
  case 17:
  this.$ = yy.miew.resetReps();
  break;
  case 18:
  this.$ = yy.miew.applyPreset($$[$0]);
  break;
  case 21:
  this.$ = yy.miew.repRemove($$[$0]); yy.representations.remove($$[$0]);
  break;
  case 22:
  this.$ = yy.miew.repHide($$[$0]);
  break;
  case 23:
  this.$ = yy.miew.repHide($$[$0], false);
  break;
  case 24:
  this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e'));
  break;
  case 25:
  this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
  break;
  case 26:
  this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
  break;
  case 27:
  this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
  break;
  case 28:
  this.$ = yy.miew.select(yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0], true));
  break;
  case 29:
  this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0-3].toLowerCase(), $$[$0-2], true); yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
  break;
  case 30:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {selector : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0])});
  break;
  case 31:
  this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0-2], true), Number($$[$0-4]));
  break;
  case 32:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {material : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 35:
  this.$ = yy.echo(yy.miew.view());
  break;
  case 36: case 37:
  this.$ = yy.miew.view($$[$0]);
  break;
  case 38:
  this.$ = yy.echo(yy.miew.changeUnit());
  break;
  case 39:
  this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
  break;
  case 40:
  this.$ = yy.miew.dssp();
  break;
  case 41:
  this.$ = yy.miew.scale($$[$0]);
  break;
  case 42:
   for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.rotate($$[$0][i]['x'] * Math.PI / 180.0, $$[$0][i]['y'] * Math.PI / 180.0, $$[$0][i]['z'] * Math.PI / 180.0);} 
  break;
  case 43:
   for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.translate($$[$0][i]['x'] || 0, $$[$0][i]['y'] || 0, $$[$0][i]['z'] || 0);} 
  break;
  case 44:
  this.$ = yy.miew.center();
  break;
  case 45:
  this.$ = yy.miew.center($$[$0]);
  break;
  case 48: case 49:
  this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-1], $$[$0]]}, true);
  break;
  case 50: case 51:
  this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-2], $$[$0-1]], opts:$$[$0].toJSO(yy.utils, 'objects', 'line')}, true);
  break;
  case 52:
  this.$ = yy.echo(yy.utils.listObjs(yy.miew));
  break;
  case 53:
  this.$ = yy.miew.removeObject($$[$0]);
  break;
  case 54:
  this.$ = yy.echo(yy.miew.getURL({view: false, settings: false}));
  break;
  case 55:
  this.$ = yy.echo(yy.miew.getURL({view: false, settings: true}));
  break;
  case 56:
  this.$ = yy.echo(yy.miew.getURL({view: true,  settings: false}));
  break;
  case 57: case 58:
  this.$ = yy.echo(yy.miew.getURL({view: true,  settings: true}));
  break;
  case 59:
  this.$ = yy.miew.screenshotSave();
  break;
  case 60:
  this.$ = yy.miew.screenshotSave('', Number($$[$0]));
  break;
  case 61:
  this.$ = yy.miew.screenshotSave('', Number($$[$0-1]), Number($$[$0]));
  break;
  case 62: case 63: case 64:
  this.$ = yy.utils.load(yy.miew, $$[$0]); yy.representations.clear();
  break;
  case 65:
  this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
  break;
  case 66:
  this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
  break;
  case 67:
  this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
  break;
  case 68:
  this.$ = yy.echo(yy.representations.add($$[$0-1], yy.miew.repAdd($$[$0])));
  break;
  case 69:
  this.$ = yy.miew.rep($$[$0]); yy.miew.repCurrent($$[$0]);
  break;
  case 70:
  this.$ = yy.miew.rep($$[$0-1], $$[$0]); yy.miew.repCurrent($$[$0-1]);
  break;
  case 71:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 72:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
  break;
  case 73:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
  break;
  case 74:
  this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
  break;
  case 75:
  this.$ = Number(yy.representations.get($$[$0]));
  break;
  case 76: case 92:
  this.$ = Number($$[$0]);
  break;
  case 77:
  this.$ = $$[$0];
  break;
  case 78:
  this.$ = yy._.assign($$[$0-1], $$[$0]);
  break;
  case 79:
  this.$ = yy._.assign($$[$0-2], $$[$0-1], $$[$0]);
  break;
  case 80:
  this.$ = yy._.assign($$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);
  break;
  case 81: case 82:
  this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
  break;
  case 83:
  this.$ = yy.CreateObjectPair($$[$0-1].key, new Array($$[$0-1].val, $$[$0].toJSO(yy.utils, $$[$0-1].key, $$[$0-1].val)));
  break;
  case 84: case 85:
  this.$ = Object.create({'key': yy.keyRemap($$[$0-2]), 'val': yy.utils.checkArg($$[$0-2], $$[$0])});
  break;
  case 86:
  this.$ = [$$[$0]];
  break;
  case 87:
  this.$ = $$[$0-1].concat($$[$0]);
  break;
  case 88:
  this.$ = yy.CreateObjectPair($$[$0-1].toLowerCase(), Number($$[$0]));
  break;
  case 89:
  this.$ = new yy.ArgList($$[$0]);
  break;
  case 90:
  this.$ = $$[$0-1].append($$[$0]);
  break;
  case 91:
  this.$ = new yy.Arg($$[$0-2], $$[$0]);
  break;
  case 93:
  this.$ = parseInt($$[$0]);
  break;
  case 94:
  this.$ = JSON.parse($$[$0]);
  break;
  case 95: case 96:
  this.$ = String($$[$0]);
  break;
  case 157: case 158: case 161: case 162: case 163:
  this.$ = $$[$0-2] + $$[$0-1] + $$[$0]; //cause of could be color word in path;
  break;
  case 166:
  this.$ = $$[$0-2] = $$[$0-2] + $$[$0-1] + $$[$0];
  break;
  }
  },
  table: [{3:1,4:2,5:[1,3],6:[1,4],7:[1,5],9:[1,6],11:[1,7],12:8,13:[1,9],15:[1,10],17:[1,11],18:[1,12],19:[1,13],20:[1,14],21:15,22:16,23:[1,17],25:[1,18],26:[1,19],27:[1,20],30:[1,21],33:[1,22],34:[1,23],37:[1,24],39:25,40:26,41:[1,27],43:[1,28],44:[1,29],45:[1,30],46:[1,31],48:[1,32],49:[1,33],50:34,51:35,52:[1,36],54:[1,37],55:[1,38],56:[1,44],58:[1,45],59:[1,39],62:[1,40],64:[1,41],65:[1,42],66:[1,43]},{1:[3]},{5:[1,46]},{1:[2,2]},{5:[2,3]},{5:[2,4],8:[1,47]},{5:[2,6],6:$V0,7:$V1,9:$V2,10:48,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,8]},{5:[2,9]},{6:$V0,7:$V1,9:$V2,10:106,13:$V3,14:[1,107],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{6:$V0,7:$V1,9:$V2,10:108,13:$V3,14:[1,109],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,14]},{5:[2,15]},{5:[2,16]},{5:[2,17],14:$VS,16:110,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,19]},{5:[2,20]},{24:116,35:$VX,38:$VY},{24:119,35:$VX,38:$VY},{24:120,35:$VX,38:$VY},{5:[2,25],24:121,28:[1,122],29:[1,123],35:$VX,38:$VY},{14:[1,124]},{14:[1,125]},{35:[1,126]},{38:[1,127]},{5:[2,33]},{5:[2,34]},{5:[2,35],14:[1,128],42:[1,129]},{5:[2,38],35:[1,130]},{5:[2,40]},{35:[1,131]},{47:132,73:133,74:$VZ},{47:135,73:133,74:$VZ},{5:[2,44],14:[1,136]},{5:[2,46]},{5:[2,47]},{6:$V0,7:$V1,9:$V2,10:138,13:$V3,14:[1,137],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,52]},{35:[1,139]},{14:[1,143],38:[1,141],60:140,61:[1,142]},{5:[2,65],38:[1,144],63:145,67:146,68:147,69:148,70:$V_,72:$V$},{24:151,35:$VX,38:$VY},{38:[1,152]},{38:[1,153]},{5:[2,54],29:[1,154],57:[1,155]},{5:[2,59],35:[1,156]},{1:[2,1]},{5:[2,5]},{5:[2,7],101:$V01},o($V11,[2,159]),o($V11,[2,160]),o($V21,[2,97]),o($V21,[2,98]),o($V11,[2,147]),o($V11,[2,148]),o($V11,[2,149]),o($V11,[2,150]),o($V11,[2,151]),o($V11,[2,152]),o($V11,[2,153]),o($V21,[2,101]),o($V21,[2,102]),o($V21,[2,103]),o($V21,[2,104]),o($V21,[2,105]),o($V21,[2,106]),o($V21,[2,107]),o($V21,[2,108]),o($V21,[2,109]),o($V21,[2,110]),o($V21,[2,111]),o($V21,[2,112]),o($V21,[2,113]),o($V21,[2,114]),o($V21,[2,115]),o($V21,[2,116]),o($V21,[2,117]),o($V21,[2,118]),o($V21,[2,119]),o($V21,[2,120]),o($V21,[2,121]),o($V21,[2,122]),o($V21,[2,123]),o($V21,[2,124]),o($V21,[2,125]),o($V21,[2,126]),o($V21,[2,127]),o($V21,[2,128]),o($V21,[2,129]),o($V21,[2,130]),o($V21,[2,131]),o($V21,[2,132]),o($V21,[2,133]),o($V21,[2,134]),o($V21,[2,135]),o($V21,[2,136]),o($V21,[2,137]),o($V21,[2,138]),o($V21,[2,139]),o($V21,[2,140]),o($V21,[2,141]),o($V21,[2,142]),o($V21,[2,143]),o($V21,[2,144]),o($V21,[2,145]),o($V21,[2,146]),{5:[2,10],101:$V01},{5:[2,11]},{14:$VS,16:158,35:$VT,38:$VU,77:$VV,78:$VW,101:$V01},{14:$VS,16:159,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,18]},o($V31,[2,92]),o($V31,[2,93]),o($V31,[2,94]),o($V31,[2,95]),o($V31,[2,96]),{5:[2,21]},o($V41,[2,75]),o($V41,[2,76]),{5:[2,22]},{5:[2,23]},{5:[2,24]},{5:[2,26]},{5:[2,27]},{5:[2,28],31:[1,160]},{5:[2,30]},{36:[1,161]},{5:[2,32]},{5:[2,36]},{5:[2,37]},{5:[2,39]},{5:[2,41]},{5:[2,42],73:162,74:$VZ},o($V51,[2,86]),{35:[1,163]},{5:[2,43],73:162,74:$VZ},{5:[2,45]},{14:[1,164]},{6:$V0,7:$V1,9:$V2,10:165,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:49,80:52,81:50,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR,101:$V01},{5:[2,53]},{5:[2,62]},{5:[2,63]},{5:[2,64]},{5:[2,164]},{5:[2,66],63:166,67:146,68:147,69:148,70:$V_,72:$V$},{5:[2,67]},{5:[2,77],67:167,68:147,69:148,70:$V_,72:$V$},o($V41,[2,81]),o($V41,[2,82],{80:52,53:168,75:169,76:170,79:171,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN}),{71:[1,172]},{71:[1,173]},{5:[2,69],63:174,67:146,68:147,69:148,70:$V_,72:$V$},{5:[2,71],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:175,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,73],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:176,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,55],57:[1,177]},{5:[2,56],29:[1,178]},{5:[2,60],35:[1,179]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,181],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:180,80:52,81:182,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,12]},{5:[2,13]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:183,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:184,80:52,81:185,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{14:[1,186]},o($V51,[2,87]),o($V51,[2,88]),{5:[2,48],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:187,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,49],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,53:188,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:169,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,101:$V01},{5:[2,68]},{5:[2,78],67:189,68:147,69:148,70:$V_,72:$V$},o($V41,[2,83],{80:52,76:170,79:171,75:190,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN}),o($V31,[2,89]),{71:[1,191],101:[1,192]},o($V61,[2,156]),{14:$VS,16:193,35:$VT,38:$VU,77:$VV,78:$VW},{14:$VS,16:194,35:$VT,38:$VU,77:$VV,78:$VW},{5:[2,70]},{5:[2,72],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,74],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,57]},{5:[2,58]},{5:[2,61]},o($V11,[2,161]),o($V11,[2,162]),o($V11,[2,163]),{5:[2,29]},{5:[2,99]},{5:[2,100]},{31:[1,195]},{5:[2,50],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,51],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,75:190,76:170,79:171,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},{5:[2,79],67:196,68:147,69:148,70:$V_,72:$V$},o($V31,[2,90]),{14:$VS,16:197,35:$VT,38:$VU,77:$VV,78:$VW},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,199],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,79:198,80:52,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN},o($V41,[2,84]),o($V31,[2,85]),{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:200,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,49:$Vm,52:$Vn,54:$Vo,55:$Vp,56:$Vq,58:$Vr,59:$Vs,62:$Vt,64:$Vu,65:$Vv,66:$Vw,70:$Vx,72:$Vy,74:$Vz,79:184,80:52,81:185,82:$VA,83:$VB,84:$VC,85:$VD,86:$VE,87:$VF,88:$VG,89:$VH,90:$VI,91:$VJ,92:$VK,93:$VL,94:$VM,95:$VN,96:$VO,97:$VP,98:$VQ,99:$VR},{5:[2,80]},o($V31,[2,91]),o($V61,[2,157]),o($V61,[2,158]),{5:[2,31]}],
  defaultActions: {3:[2,2],4:[2,3],7:[2,8],8:[2,9],11:[2,14],12:[2,15],13:[2,16],15:[2,19],16:[2,20],25:[2,33],26:[2,34],29:[2,40],34:[2,46],35:[2,47],37:[2,52],46:[2,1],47:[2,5],107:[2,11],110:[2,18],116:[2,21],119:[2,22],120:[2,23],121:[2,24],122:[2,26],123:[2,27],125:[2,30],127:[2,32],128:[2,36],129:[2,37],130:[2,39],131:[2,41],136:[2,45],139:[2,53],140:[2,62],141:[2,63],142:[2,64],143:[2,164],145:[2,67],158:[2,12],159:[2,13],166:[2,68],174:[2,70],177:[2,57],178:[2,58],179:[2,61],183:[2,29],184:[2,99],185:[2,100],196:[2,80],200:[2,31]},
  parseError: function parseError (str, hash) {
      if (hash.recoverable) {
          this.trace(str);
      } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
      }
  },
  parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
              sharedState.yy[k] = this.yy[k];
          }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
      } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
      }
              function lex() {
              var token;
              token = tstack.pop() || lexer.lex() || EOF;
              if (typeof token !== 'number') {
                  if (token instanceof Array) {
                      tstack = token;
                      token = tstack.pop();
                  }
                  token = self.symbols_[token] || token;
              }
              return token;
          }
      var symbol, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == 'undefined') {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === 'undefined' || !action.length || !action[0]) {
              var errStr = '';
              expected = [];
              for (p in table[state]) {
                  if (this.terminals_[p] && p > TERROR) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                  }
              }
              if (lexer.showPosition) {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
              } else {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
              }
              this.parseError(errStr, {
                  text: lexer.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer.yylineno,
                  loc: yyloc,
                  expected: expected
              });
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                  yyleng = lexer.yyleng;
                  yytext = lexer.yytext;
                  yylineno = lexer.yylineno;
                  yyloc = lexer.yylloc;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                  yyval._$.range = [
                      lstack[lstack.length - (len || 1)].range[0],
                      lstack[lstack.length - 1].range[1]
                  ];
              }
              r = this.performAction.apply(yyval, [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
              ].concat(args));
              if (typeof r !== 'undefined') {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }};


  /* generated by jison-lex 0.3.4 */
  var lexer = (function(){
  var lexer = ({

  EOF:1,

  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },

  // resets the lexer, sets new input
  setInput:function (input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
          };
          if (this.options.ranges) {
              this.yylloc.range = [0,0];
          }
          this.offset = 0;
          return this;
      },

  // consumes and returns one char from the input
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) {
              this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
      },

  // unshifts one char (or a string) into the input
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
              this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;

          this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ?
                  (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                   + oldLines[oldLines.length - lines.length].length - lines[0].length :
                this.yylloc.first_column - len
          };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
      },

  // When called from action, caches matched text and appends it on next action
  more:function () {
          this._more = true;
          return this;
      },

  // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
  reject:function () {
          if (this.options.backtrack_lexer) {
              this._backtrack = true;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });

          }
          return this;
      },

  // retain first n characters of the match
  less:function (n) {
          this.unput(this.match.slice(n));
      },

  // displays already matched input, i.e. for error messages
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },

  // displays upcoming input, i.e. for error messages
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },

  // displays the character position where the lexing error occurred, i.e. for error messages
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
      },

  // test the lexed token: return FALSE when not a match, otherwise return token
  test_match:function(match, indexed_rule) {
          var token,
              lines,
              backup;

          if (this.options.backtrack_lexer) {
              // save context
              backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
              };
              if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
              }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno += lines.length;
          }
          this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ?
                           lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                           this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
              this.done = false;
          }
          if (token) {
              return token;
          } else if (this._backtrack) {
              // recover context
              for (var k in backup) {
                  this[k] = backup[k];
              }
              return false; // rule action called reject() implying the next rule should be tested instead.
          }
          return false;
      },

  // return next match in input
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) {
              this.done = true;
          }

          var token,
              match,
              tempMatch,
              index;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (this.options.backtrack_lexer) {
                      token = this.test_match(tempMatch, rules[i]);
                      if (token !== false) {
                          return token;
                      } else if (this._backtrack) {
                          match = false;
                          continue; // rule action called reject() implying a rule MISmatch.
                      } else {
                          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                          return false;
                      }
                  } else if (!this.options.flex) {
                      break;
                  }
              }
          }
          if (match) {
              token = this.test_match(match, rules[index]);
              if (token !== false) {
                  return token;
              }
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });
          }
      },

  // return next match that has a token
  lex:function lex () {
          var r = this.next();
          if (r) {
              return r;
          } else {
              return this.lex();
          }
      },

  // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
  begin:function begin (condition) {
          this.conditionStack.push(condition);
      },

  // pop the previously active lexer condition state off the condition stack
  popState:function popState () {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
              return this.conditionStack.pop();
          } else {
              return this.conditionStack[0];
          }
      },

  // produce the lexer rule set which is active for the currently active lexer condition state
  _currentRules:function _currentRules () {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
              return this.conditions["INITIAL"].rules;
          }
      },

  // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
  topState:function topState (n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
              return this.conditionStack[n];
          } else {
              return "INITIAL";
          }
      },

  // alias for begin(condition)
  pushState:function pushState (condition) {
          this.begin(condition);
      },

  // return the number of states currently on the stack
  stateStackSize:function stateStackSize() {
          return this.conditionStack.length;
      },
  options: {"case-insensitive":true},
  performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
  switch($avoiding_name_collisions) {
  case 0:/* ignore whitespace */
  break;
  case 1:return '';
  case 2:return '';
  case 3:return 42;
  case 4:return 35;
  case 5:return 77;
  case 6:return 78;
  case 7:return 78;
  case 8:return 8;
  case 9:return 6;
  case 10:return 82;
  case 11:return 7;
  case 12:return 9;
  case 13:return 59;
  case 14:return 13
  case 15:return 15
  case 16:return 17
  case 17:return 18
  case 18:return 19
  case 19:return 20
  case 20:return 11
  case 21:return 62
  case 22:return 64
  case 23:return 23
  case 24:return 25
  case 25:return 26
  case 26:return 27
  case 27:return 30
  case 28:return 34
  case 29:return 33
  case 30:return 65
  case 31:return 66
  case 32:return 37
  case 33:return 41
  case 34:return 43
  case 35:return 52
  case 36:return 54
  case 37:return 55
  case 38:return 46
  case 39:return 48
  case 40:return 45
  case 41:return 49
  case 42:return 56
  case 43:return 58;
  case 44:return 44
  case 45:return 83
  case 46:return 84
  case 47:return 85
  case 48:return 86
  case 49:return 87
  case 50:return 88
  case 51:return 89
  case 52:return 90
  case 53:return 91
  case 54:return 92
  case 55:return 93
  case 56:return 94
  case 57:return 95
  case 58:return 70
  case 59:return 70
  case 60:return 72
  case 61:return 72
  case 62:return 74
  case 63:return 74
  case 64:return 74
  case 65:return 31
  case 66:return 36
  case 67:return 96
  case 68:return 97
  case 69:return 98
  case 70:return 99
  case 71:yy_.yytext = yy.utils.unquoteString(yy_.yytext); return 14;
  case 72:return 38;
  case 73:return 5;
  case 74:return 101;
  case 75:return 103;
  case 76:return '\\';
  case 77:return 28
  case 78:return 61
  case 79:return 29
  case 80:return 57
  case 81:return 71
  }
  },
  rules: [/^(?:\s+)/i,/^(?:[#].*)/i,/^(?:\/\/.*)/i,/^(?:([_A-Z0-9\/\+]+==))/i,/^(?:-?[0-9]+(\.[0-9]+)?\b)/i,/^(?:0[xX][0-9A-F]+\b)/i,/^(?:false\b)/i,/^(?:true\b)/i,/^(?:all\b)/i,/^(?:reset\b)/i,/^(?:clear\b)/i,/^(?:build\b)/i,/^(?:help\b)/i,/^(?:load\b)/i,/^(?:get\b)/i,/^(?:set\b)/i,/^(?:set_save\b)/i,/^(?:set_restore\b)/i,/^(?:set_reset\b)/i,/^(?:preset\b)/i,/^(?:motm\b)/i,/^(?:add\b)/i,/^(?:rep\b)/i,/^(?:remove\b)/i,/^(?:hide\b)/i,/^(?:show\b)/i,/^(?:list\b)/i,/^(?:select\b)/i,/^(?:within\b)/i,/^(?:selector\b)/i,/^(?:mode\b)/i,/^(?:color\b)/i,/^(?:material\b)/i,/^(?:view\b)/i,/^(?:unit\b)/i,/^(?:line\b)/i,/^(?:listobj\b)/i,/^(?:removeobj\b)/i,/^(?:rotate\b)/i,/^(?:translate\b)/i,/^(?:scale\b)/i,/^(?:center\b)/i,/^(?:url\b)/i,/^(?:screenshot\b)/i,/^(?:dssp\b)/i,/^(?:file_list\b)/i,/^(?:file_register\b)/i,/^(?:file_delete\b)/i,/^(?:preset_add\b)/i,/^(?:preset_delete\b)/i,/^(?:preset_update\b)/i,/^(?:preset_rename\b)/i,/^(?:preset_open\b)/i,/^(?:create_scenario\b)/i,/^(?:reset_scenario\b)/i,/^(?:delete_scenario\b)/i,/^(?:add_scenario_item\b)/i,/^(?:list_scenario\b)/i,/^(?:s\b)/i,/^(?:mt\b)/i,/^(?:m\b)/i,/^(?:c\b)/i,/^(?:x\b)/i,/^(?:y\b)/i,/^(?:z\b)/i,/^(?:as\b)/i,/^(?:of\b)/i,/^(?:pdb\b)/i,/^(?:delay\b)/i,/^(?:prst\b)/i,/^(?:desc\b)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:\.)/i,/^(?:\/)/i,/^(?:\\)/i,/^(?:-e\b)/i,/^(?:-f\b)/i,/^(?:-s\b)/i,/^(?:-v\b)/i,/^(?:=)/i],
  conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],"inclusive":true}}
  });
  return lexer;
  })();
  parser.lexer = lexer;
  function Parser () {
    this.yy = {};
  }
  Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();

  var MiewCLIParser = {parser: parser$1};
  var MiewCLIParser_1 = MiewCLIParser.parser;

  var modeIdDesc = {
    $help: ['Rendering mode shortcut', '    BS - balls and sticks mode', '    LN - lines mode', '    LC - licorice mode', '    VW - van der waals mode', '    TR - trace mode', '    TU - tube mode', '    CA - cartoon mode', '    SA - isosurface mode', '    QS - quick surface mode', '    SE - solvent excluded mode', '    TX - text mode'],
    BS: {
      $help: ['   Balls and sticks', '      aromrad = <number> #aromatic radius', '      atom = <number>    #atom radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    CA: {
      $help: ['   Cartoon', '      arrow = <number>   #arrow size', '      depth = <number>   #depth of surface', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> #', '      width = <number>  #secondary width\n']
    },
    LN: {
      $help: ['   Lines', '      atom = <number>    #atom radius', '      chunkarom = <number>', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      offsarom = <number>\n']
    },
    LC: {
      $help: ['   Licorice', '      aromrad = <number> #aromatic radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    VW: {
      $help: ['   Van der Waals', '      nothing\n']
    },
    TR: {
      $help: ['   Trace', '      radius = <number>  #tube radius\n']
    },
    TU: {
      $help: ['   Tube', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> \n']
    },
    SA: {
      $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
    },
    QS: {
      $help: ['   Quick surface', '      isoValue = <number>', '      scale = <number>', '      wireframe = <bool>', '      zClip = <bool> #clip z plane\n']
    },
    SE: {
      $help: ['   Solvent excluded surface', '      zClip = <bool> #clip z plane\n']
    },
    TX: {
      $help: ['   Text mode', '      template = <format string> string that can include "{{ id }}"', '          it will be replaced by value, id can be one of next:', '          serial, name, type, sequence, residue, chain, hetatm, water\n', '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', '      dx = <number> #offset along x', '      dy = <number> #offset along y', '      dz = <number> #offset along z', '      fg = <string> #text color modificator', '           could be keyword, named color or hex', '      fg = <string> #back color modificator', '           could be keyword, named color or hex', '      showBg = <bool> #if set show background', '           plate under text']
    }
  };
  var colorDesc = {
    $help: ['Coloring mode shortcut', '    EL - color by element', '    CH - color by chain', '    SQ - color by sequence', '    RT - color by residue type', '    SS - color by secondary structure', '    UN - uniform'],
    UN: {
      $help: ['Parameters of coloring modes customization', '   Uniform', '      color = <number|color> #RGB->HEX->dec\n'],
      color: {
        $help: Object.keys(palettes.get(settings.now.palette).namedColors).sort().join('\n')
      }
    }
  };
  var materialDesc = {
    $help: ['Material shortcut', '    DF - diffuse', '    TR - transparent', '    SF - soft plastic', '    PL - glossy plastic', '    ME - metal', '    GL - glass']
  };
  var addRepDesc = {
    $help: ['Short (packed) representation description as a set of variables', '    s=<EXPRESSION>', '        selector property', '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]', '        render mode property', '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]', '        color mode property', '    mt=<MATERIAL_ID>', '        material property'],
    s: {
      $help: 'Selection expression string as it is in menu->representations->selection'
    },
    m: modeIdDesc,
    c: colorDesc,
    mt: materialDesc
  };
  var setGetParameterDesc = {
    $help: ['Parameters of rendering modes customization: modes', 'Parameters of colorer customization: colorers', 'Autobuild: autobuild = (<number>|<bool>)'],
    modes: modeIdDesc,
    colorers: colorDesc
  };
  var help = {
    $help: ['help (<cmd name>| <path to property>)', 'You can get detailed information about command options', '   using "help cmd.opt.opt.[...]"\n', '   you can use one line comments', '   everything started from (#|//) will be skipped', '   Example: >build //some comment\n', 'List of available commands:'],
    reset: {
      $help: ['Reload current object, delete all representations', '    Nothing will work until load new object']
    },
    load: {
      $help: ['load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])', '    Load new pdb object from selected source'],
      PDBID: {
        $help: 'pdb id in remote molecule database'
      },
      URL: {
        $help: 'url to source file'
      },
      f: {
        $help: ['open file system dialog to fetch local file', 'optionally you can determine trajectory file', 'via URL for *.top model']
      }
    },
    clear: {
      $help: 'No args. Clear terminal'
    },
    add: {
      $help: ['add [<REP_NAME>] [<DESCRIPTION>]', '    Add new item to representation set with', '    default or <DESCRIPTION> params'],
      REP_NAME: {
        $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
      },
      DESCRIPTION: addRepDesc
    },
    rep: {
      $help: ['rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]', '    set current representation by name or index', '    edit current representation by <DESCRIPTION>'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      },
      DESCRIPTION: addRepDesc
    },
    remove: {
      $help: ['remove (<REP_NAME>|<REP_INDEX>)', 'Remove representation by name or index'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      }
    },
    selector: {
      $help: ['selector <EXPRESSION>', '   set selector from EXPRESSION to current representation'],
      EXPRESSION: {
        $help: 'Selection expression string as it is in menu->representations->selection'
      }
    },
    mode: {
      $help: ['mode <MODE_ID> [<PARAMETER>=<VALUE>...]', '   set rendering mode and apply parameters to current representation'],
      MODE_ID: modeIdDesc
    },
    color: {
      $help: ['color <COLORER_ID> [<PARAMETER>=<VALUE>...]', '   set colorer and apply parameters to current representation'],
      COLORER_ID: colorDesc
    },
    material: {
      $help: ['material <MATERIAL_ID>', '   set material to current representation'],
      MATERIAL_ID: materialDesc
    },
    build: {
      $help: 'build help str',
      add: {
        $help: 'build.add',
        "new": {
          $help: ['add.new', 'add.new new line 1', 'add.new new line 2', 'add.new new line 3']
        }
      },
      del: {
        $help: 'build.del'
      }
    },
    list: {
      $help: ['list [-e|-s|<REP_NAME>|<REP_INDEX>]', 'Print representations if no args print list of representations', '    -e expand list and show all representations', '    -s show all user-registered selectors', '    <REP_NAME>|<REP_INDEX> show only current representation']
    },
    hide: {
      $help: ['hide (<REP_NAME>|<REP_INDEX>)', 'Hide representation referenced in args']
    },
    show: {
      $help: ['show (<REP_NAME>|<REP_INDEX>)', 'Show representation referenced in args']
    },
    get: {
      $help: ['get <PARAMETER>', 'Print <PARAMETER> value', '    <PARAMETER> - path to option use get.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set: {
      $help: ['set <PARAMETER> <VALUE>', 'Set <PARAMETER> with <VALUE>', '    <PARAMETER> - path to option use set.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set_save: {
      $help: ['set_save', 'Save current settings to cookie']
    },
    set_restore: {
      $help: ['set_restore', 'Load and apply settings from cookie']
    },
    set_reset: {
      $help: ['set_reset', 'Reset current settings to the defaults']
    },
    preset: {
      $help: ['preset [<PRESET>]', 'Reset current representation or set preset to <PRESET>'],
      PRESET: {
        $help: ['default', 'wire', 'small', 'macro']
      }
    },
    unit: {
      $help: ['unit [<unit_id>]', 'Change current biological structure view. Zero <unit_id> value means asymmetric unit,', 'positive values set an assembly with corresponding number.', 'Being called with no parameters command prints current unit information.']
    },
    view: {
      $help: ['view [<ENCODED_VIEW>]', 'Get current encoded view or set if ENCODED_VIEW placed as argument'],
      ENCODED_VIEW: {
        $help: ['encoded view matrix string (binary code)']
      }
    },
    rotate: {
      $help: ['rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...', 'Rotate scene']
    },
    scale: {
      $help: ['scale <SCALE>', 'Scale scene']
    },
    select: {
      $help: ['select <SELECTOR_STRING> [as <SELECTOR_NAME>]', 'Select atoms using selector defined in SELECTOR_STRING', '    and if SELECTOR_NAME is defined register it in viewer', '    you can use it later as a complex selector']
    },
    within: {
      $help: ['within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>', 'Build within named selector', '    DISTANCE        <number>', '    SELECTOR_STRING <string(selection language)>', '    SELECTOR_NAME   <identifier>']
    },
    url: {
      $help: ['url [-s] [-v]', 'Report URL encoded scene', '    if -s set that include settings in the URL', '    if -v set that include view in the URL']
    },
    screenshot: {
      $help: ['screenshot [<WIDTH> [<HEIGHT>]]', 'Make a screenshot of the scene', '    WIDTH  <number> in pixels', '    HEIGHT <number> in pixels, equal to WIDTH by default']
    },
    line: {
      $help: ['line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]', 'Draw dashed line between two specified atoms']
    },
    removeobj: {
      $help: ['removeobj <id>', 'Remove scene object by its index. Indices could be obtained by <listobj> command']
    },
    listobj: {
      $help: ['listobj', 'Display the list of all existing scene objects']
    }
  };

  var selectors$5 = Miew.chem.selectors,
      modes$1 = Miew.modes,
      colorers$1 = Miew.colorers,
      materials$1 = Miew.materials,
      palettes$1 = Miew.palettes,
      options$1 = Miew.options,
      settings$1 = Miew.settings;

  function None() {}

  var NULL = function () {
    var obj = new None();
    return function () {
      return obj;
    };
  }();

  var RepresentationMap = /*#__PURE__*/function () {
    function RepresentationMap() {
      classCallCheck(this, RepresentationMap);

      this.representationMap = {};
      this.representationID = {};
    }

    createClass(RepresentationMap, [{
      key: "get",
      value: function get(strId) {
        return this.representationMap[strId] || this.representationID[strId] || '<no name>';
      }
    }, {
      key: "add",
      value: function add(strId, index) {
        if (strId === -1) {
          return 'Can not create representation: there is no data';
        }

        if (index !== undefined) {
          if (!this.representationMap.hasOwnProperty(strId)) {
            this.representationMap[strId.toString()] = index;
            this.representationID[index] = strId.toString();
          } else {
            return 'This name has already existed, registered without name';
          }
        }

        return "Representation ".concat(strId, " successfully added");
      }
    }, {
      key: "remove",
      value: function remove(index) {
        if (index && this.representationID.hasOwnProperty(index)) {
          delete this.representationMap[this.representationID[index]];
          delete this.representationID[index];
        }

        var sortedKeys = Object.keys(this.representationID).sort();

        for (var i in sortedKeys) {
          if (sortedKeys.hasOwnProperty(i)) {
            var id = sortedKeys[i];

            if (id > index) {
              this.representationID[id - 1] = this.representationID[id];
              this.representationMap[this.representationID[id]] -= 1;
              delete this.representationID[id];
            }
          }
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        this.representationMap = {};
        this.representationID = {};
      }
    }]);

    return RepresentationMap;
  }();

  var representationsStorage = new RepresentationMap();

  function keyRemap(key) {
    var keys = {
      s: 'selector',
      m: 'mode',
      c: 'colorer',
      mt: 'material',
      mode: 'modes',
      color: 'colorers',
      colorer: 'colorers',
      select: 'selector',
      material: 'materials',
      selector: 'selector'
    };
    var ans = keys[key];
    return ans === undefined ? key : ans;
  }

  var CLIUtils = /*#__PURE__*/function () {
    function CLIUtils() {
      classCallCheck(this, CLIUtils);
    }

    createClass(CLIUtils, [{
      key: "list",
      value: function list(miew, repMap, key) {
        var ret = '';

        if (miew && repMap !== undefined) {
          if (key === undefined || key === '-e') {
            var count = miew.repCount();

            for (var i = 0; i < count; i++) {
              ret += this.listRep(miew, repMap, i, key);
            }
          }
        }

        return ret;
      }
    }, {
      key: "listRep",
      value: function listRep(miew, repMap, repIndex, key) {
        var ret = '';
        var rep = miew.repGet(repIndex);

        if (!rep) {
          logger.warn("Rep ".concat(repIndex, " does not exist!"));
          return ret;
        }

        var index = repIndex;
        var repName = repMap.get(index);
        var mode = rep.mode,
            colorer = rep.colorer;
        var selectionStr = rep.selectorString;
        var material = rep.materialPreset;
        ret += "#".concat(index, " : ").concat(mode.name).concat(repName === '<no name>' ? '' : ", ".concat(repName), "\n");

        if (key !== undefined) {
          ret += "    selection : \"".concat(selectionStr, "\"\n");
          ret += "    mode      : (".concat(mode.id, "), ").concat(mode.name, "\n");
          ret += "    colorer   : (".concat(colorer.id, "), ").concat(colorer.name, "\n");
          ret += "    material  : (".concat(material.id, "), ").concat(material.name, "\n");
        }

        return ret;
      }
    }, {
      key: "listSelector",
      value: function listSelector(miew, context) {
        var ret = '';

        for (var k in context) {
          if (context.hasOwnProperty(k)) {
            ret += "".concat(k, " : \"").concat(context[k], "\"\n");
          }
        }

        return ret;
      }
    }, {
      key: "listObjs",
      value: function listObjs(miew) {
        var objs = miew._objects;

        if (!objs || !Array.isArray(objs) || objs.length === 0) {
          return 'There are no objects on the scene';
        }

        var strList = [];

        for (var i = 0, n = objs.length; i < n; ++i) {
          strList[i] = "".concat(i, ": ").concat(objs[i].toString());
        }

        return strList.join('\n');
      }
    }, {
      key: "joinHelpStr",
      value: function joinHelpStr(helpData) {
        if (helpData instanceof Array) {
          return helpData.join('\n');
        }

        return helpData;
      }
    }, {
      key: "help",
      value: function help$1(path) {
        if (___default['default'].isUndefined(path)) {
          return "".concat(this.joinHelpStr(help.$help), "\n").concat(___default['default'].slice(___default['default'].sortBy(___default['default'].keys(help)), 1).join(', '), "\n");
        }

        var helpItem = ___default['default'].get(help, path);

        return ___default['default'].isUndefined(helpItem) ? this.help() : "".concat(this.joinHelpStr(helpItem.$help), "\n");
      }
    }, {
      key: "load",
      value: function load(miew, arg) {
        if (miew === undefined || arg === undefined || arg === '-f') {
          return;
        }

        miew.awaitWhileCMDisInProcess();

        var finish = function finish() {
          return miew.finishAwaitingCMDInProcess();
        };

        miew.load(arg).then(finish, finish);
      }
    }, {
      key: "checkArg",
      value: function checkArg(key, arg, modificate) {
        if (key !== undefined && arg !== undefined) {
          if (keyRemap(key) === 'selector') {
            var res = selectors$5.parse(arg);

            if (res.error !== undefined) {
              var selExc = {
                message: res.error
              };
              throw selExc;
            }

            if (modificate !== undefined && modificate) {
              return res.selector;
            }

            return arg;
          }

          var modificators = {
            colorers: colorers$1,
            modes: modes$1,
            materials: materials$1
          };
          var modificator = key;
          var temp;

          while (modificator !== temp) {
            temp = modificator;
            modificator = keyRemap(temp);
          }

          if (modificators[modificator].get(arg) === undefined) {
            var exc = {
              message: "".concat(arg, " is not existed in ").concat(modificator)
            };
            throw exc;
          }

          return arg;
        }

        return NULL;
      }
    }, {
      key: "propagateProp",
      value: function propagateProp(path, arg) {
        if (path !== undefined) {
          var argExc = {};

          var adapter = options$1.adapters[_typeof_1(___default['default'].get(settings$1.defaults, path))];

          if (adapter === undefined) {
            var pathExc = {
              message: "".concat(path, " is not existed")
            };
            throw pathExc;
          }

          if ((path.endsWith('.color') || path.endsWith('.baseColor') || path.endsWith('.EL.carbon')) && typeof arg !== 'number') {
            arg = palettes$1.get(settings$1.now.palette).getNamedColor(arg);
          }

          if (path.endsWith('.fg') || path.endsWith('.bg')) {
            if (typeof arg !== 'number') {
              var val = palettes$1.get(settings$1.now.palette).getNamedColor(arg, true);

              if (val !== undefined) {
                arg = "0x".concat(val.toString(16));
              }
            } else {
              arg = "0x".concat(arg.toString(16));
            }
          }

          if (path.endsWith('.template')) {
            arg = arg.replace(/\\n/g, '\n'); // NOSONAR
          }

          if (arg !== undefined && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
            argExc = {
              message: "".concat(path, " must be a \"").concat(_typeof_1(___default['default'].get(settings$1.defaults, path)), "\"")
            };
            throw argExc;
          }
        }

        return arg;
      }
    }, {
      key: "unquoteString",
      value: function unquoteString(value) {
        return utils.unquoteString(value);
      }
    }]);

    return CLIUtils;
  }(); // repIndexOrRepMap could be RepresentationMap or index


  var utilFunctions = new CLIUtils();

  function CreateObjectPair(a, b) {
    var obj = {};
    obj[a] = b;
    return obj;
  }

  function ArgList(arg) {
    if (arg instanceof this.constructor) {
      return arg;
    }

    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }

  ArgList.prototype.append = function (value) {
    var values = this._values;
    values[values.length] = value;
    return this;
  };

  ArgList.prototype.remove = function (value) {
    var values = this._values;
    var index = values.indexOf(value);

    if (index >= 0) {
      values.splice(index, 1);
    }

    return this;
  };

  ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
    var res = {};
    var list = this._values;

    for (var i = 0, n = list.length; i < n; ++i) {
      ___default['default'].set(res, list[i].id, cliUtils.propagateProp("".concat(keyRemap(cmd), ".").concat(arg, ".").concat(list[i].id), list[i].val));
    }

    return res;
  };

  function Arg(_id, _val) {
    this.id = _id;
    this.val = _val;
  }

  var cliutils = Object.create({});
  cliutils.Arg = Arg;
  cliutils.ArgList = ArgList;
  cliutils.miew = null;
  cliutils.echo = null;
  cliutils.representations = representationsStorage;
  cliutils.utils = utilFunctions;
  cliutils._ = ___default['default'];
  cliutils.CreateObjectPair = CreateObjectPair;
  cliutils.keyRemap = keyRemap;
  cliutils.Context = selectors$5.Context;
  cliutils.ClearContext = selectors$5.ClearContext;
  cliutils.NULL = NULL;

  cliutils.notimplemented = function () {
    return this.NULL;
  };

  Miew.prototype.script = function (script, _printCallback, _errorCallback) {
    MiewCLIParser_1.yy.miew = this;
    MiewCLIParser_1.yy.echo = _printCallback;
    MiewCLIParser_1.yy.error = _errorCallback;

    if (this.cmdQueue === undefined) {
      this.cmdQueue = [];
    }

    if (this.commandInAction === undefined) {
      this.commandInAction = false;
    }

    this.cmdQueue = this.cmdQueue.concat(script.split('\n'));
  };

  Miew.prototype.awaitWhileCMDisInProcess = function () {
    this.commandInAction = true;
  };

  Miew.prototype.finishAwaitingCMDInProcess = function () {
    this.commandInAction = false;
  };

  Miew.prototype.isScriptingCommandAvailable = function () {
    return this.commandInAction !== undefined && !this.commandInAction && this.cmdQueue !== undefined && this.cmdQueue.length > 0;
  };

  Miew.prototype.callNextCmd = function () {
    if (this.isScriptingCommandAvailable()) {
      var cmd = this.cmdQueue.shift();
      var res = {};
      res.success = false;

      try {
        MiewCLIParser_1.parse(cmd);
        res.success = true;
      } catch (e) {
        res.error = e.message;
        MiewCLIParser_1.yy.error(res.error);
        this.finishAwaitingCMDInProcess();
      }

      return res;
    }

    return '';
  };

  MiewCLIParser_1.yy = cliutils; // workaround for incorrect JISON parser generator for AMD module

  MiewCLIParser_1.yy.parseError = MiewCLIParser_1.parseError;

  return Miew;

})));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash":1,"three":2}],4:[function(require,module,exports){
var Miew = require('../dist/Miew');

window.onload = function () {
  var viewer = new Miew({
    container: document.getElementsByClassName('miew-container')[0],
    load: '1CRN',
  });

  if (viewer.init()) {
    viewer.run();
  }
};

},{"../dist/Miew":3}]},{},[4]);
